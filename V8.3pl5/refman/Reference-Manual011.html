<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">

<LINK rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<STYLE type="text/css" media="all">@import "/modules/node/node.css";</STYLE>

<STYLE type="text/css" media="all">@import "/modules/system/defaults.css";</STYLE>
<STYLE type="text/css" media="all">@import "/modules/system/system.css";</STYLE>
<STYLE type="text/css" media="all">@import "/modules/user/user.css";</STYLE>

<STYLE type="text/css" media="all">@import "/sites/all/themes/coq/style.css";</STYLE>
<STYLE type="text/css" media="all">@import "/sites/all/themes/coq/coqdoc.css";</STYLE>
<STYLE type="text/css" media="all">@import "/sites/all/themes/coq/hevea.css";</STYLE>
<TITLE>Chapter 8  Tactics

</TITLE>
</HEAD>
<BODY >

<div id="container">
<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="http://coq.inria.fr/" class="active">Home</a></li>

    <li><a href="http://coq.inria.fr/about-coq" title="More about coq">About Coq</a></li>    
    <li><a href="http://coq.inria.fr/download">Get Coq</a></li>
    <li><a href="http://coq.inria.fr/documentation">Documentation</a></li>
    <li><a href="http://coq.inria.fr/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">

<div id="logoWrapper">

<div id="logo"><a href="http://coq.inria.fr/" title="Home"><img src="/files/barron_logo.png" alt="Home"></a>
</div>
<div id="siteName"><a href="http://coq.inria.fr/" title="Home">The Coq Proof Assistant</a>
</div>

</div>
</div>

<div id="content">

<H1 CLASS="chapter"><A NAME="htoc205">Chapter 8</A>  Tactics
<A NAME="@default481"></A>
<A NAME="Tactics"></A></H1><UL>
<LI><A HREF="Reference-Manual011.html#toc51">8.1  Invocation of tactics

</A>
</LI><LI><A HREF="Reference-Manual011.html#toc52">8.2  Explicit proof as a term</A>
</LI><LI><A HREF="Reference-Manual011.html#toc53">8.3  Basics
</A>
</LI><LI><A HREF="Reference-Manual011.html#toc54">8.4  Negation and contradiction</A>
</LI><LI><A HREF="Reference-Manual011.html#toc55">8.5  Conversion tactics

</A>
</LI><LI><A HREF="Reference-Manual011.html#toc56">8.6  Introductions</A>
</LI><LI><A HREF="Reference-Manual011.html#toc57">8.7  Induction and Case Analysis</A>
</LI><LI><A HREF="Reference-Manual011.html#toc58">8.8  Equality</A>
</LI><LI><A HREF="Reference-Manual011.html#toc59">8.9  Equality and inductive sets</A>
</LI><LI><A HREF="Reference-Manual011.html#toc60">8.10  Inversion
</A>
</LI><LI><A HREF="Reference-Manual011.html#toc61">8.11  Classical tactics</A>
</LI><LI><A HREF="Reference-Manual011.html#toc62">8.12  Automatizing
</A>
</LI><LI><A HREF="Reference-Manual011.html#toc63">8.13  Controlling automation</A>
</LI><LI><A HREF="Reference-Manual011.html#toc64">8.14  Generation of induction principles with <TT>Scheme</TT>


</A>
</LI><LI><A HREF="Reference-Manual011.html#toc65">8.15  Generation of induction principles with <TT>Functional Scheme</TT>

</A>
</LI><LI><A HREF="Reference-Manual011.html#toc66">8.16  Simple tactic macros


</A>
</LI></UL>
<P>A deduction rule is a link between some (unique) formula, that we call
the <EM>conclusion</EM> and (several) formulas that we call the <EM>premises</EM>. Indeed, a deduction rule can be read in two ways. The first
one has the shape: <I>&#X201C;if I know this and this then I can deduce
this&#X201D;</I>. For instance, if I have a proof of <I>A</I> and a proof of <I>B</I>
then I have a proof of <I>A</I> &#X2227; <I>B</I>. This is forward reasoning from
premises to conclusion. The other way says: <I>&#X201C;to prove this I
have to prove this and this&#X201D;</I>. For instance, to prove <I>A</I> &#X2227; <I>B</I>, I
have to prove <I>A</I> and I have to prove <I>B</I>. This is backward reasoning
which proceeds from conclusion to premises. We say that the conclusion
is <EM>the goal</EM><A NAME="@default482"></A> to prove and premises are <EM>the
subgoals</EM><A NAME="@default483"></A>. The tactics implement <EM>backward
reasoning</EM>. When applied to a goal, a tactic replaces this goal with
the subgoals it generates. We say that a tactic reduces a goal to its
subgoal(s).</P><P>Each (sub)goal is denoted with a number. The current goal is numbered
1. By default, a tactic is applied to the current goal, but one can
address a particular goal in the list by writing <I><FONT COLOR=maroon>n:</FONT></I><FONT COLOR=maroon><I>tactic</I></FONT> which
means <I>&#X201C;apply tactic </I><I><FONT COLOR=maroon>tactic</FONT></I><I> to goal number </I><I><FONT COLOR=maroon>n</FONT></I><I>&#X201D;</I>.
We can show the list of subgoals by typing <TT>Show</TT> (see
Section <A HREF="Reference-Manual010.html#Show">7.3.1</A>). </P><P>Since not every rule applies to a given statement, every tactic cannot be
used to reduce any goal. In other words, before applying a tactic to a
given goal, the system checks that some <EM>preconditions</EM> are
satisfied. If it is not the case, the tactic raises an error message.</P><P>Tactics are build from atomic tactics and tactic expressions (which
extends the folklore notion of tactical) to combine those atomic
tactics. This chapter is devoted to atomic tactics. The tactic
language will be described in Chapter <A HREF="Reference-Manual012.html#TacticLanguage">9</A>.</P><P>There are, at least, three levels of atomic tactics. The simplest one
implements basic rules of the logical framework. The second level is
the one of <EM>derived rules</EM> which are built by combination of other
tactics. The third one implements heuristics or decision procedures to
build a complete proof of a goal.</P><H2 CLASS="section"><A NAME="toc51"></A><A NAME="htoc206">8.1</A>  Invocation of tactics
<A NAME="tactic-syntax"></A>
<A NAME="@default484"></A></H2><P>A tactic is applied as an ordinary command. If the tactic does not
address the first subgoal, the command may be preceded by the wished
subgoal number as shown below:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>tactic_invocation</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>num</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>tactic</FONT></I> <TT>.</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>tactic</FONT></I> <TT>.</TT></TD></TR>
</TABLE><H2 CLASS="section"><A NAME="toc52"></A><A NAME="htoc207">8.2</A>  Explicit proof as a term</H2><H3 CLASS="subsection"><A NAME="htoc208">8.2.1</A>  <TT>exact </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default485"></A><A NAME="@tactic3"></A><TT>
</TT><A NAME="exact"></A></H3><P>This tactic applies to any goal. It gives directly the exact proof
term of the goal. Let <TT>T</TT> be our goal, let <TT>p</TT> be a term of type
<TT>U</TT> then <TT>exact p</TT> succeeds iff <TT>T</TT> and <TT>U</TT> are
convertible (see Section <A HREF="Reference-Manual006.html#conv-rules">4.3</A>).</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not an exact proof</TT><A NAME="@error51"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>eexact </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default486"></A><A NAME="@tactic4"></A> <P>This tactic behaves like <TT>exact</TT> but is able to handle terms with meta-variables. </P></LI></OL><H3 CLASS="subsection"><A NAME="htoc209">8.2.2</A>  <TT>refine </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default487"></A><A NAME="@tactic5"></A><TT>
</TT><A NAME="refine"></A><TT>
</TT><A NAME="@default488"></A></H3><P>This tactic allows to give an exact proof but still with some
holes. The holes are noted &#X201C;<TT>_</TT>&#X201D;.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>invalid argument</TT><A NAME="@error52"></A>: 
the tactic <TT>refine</TT> doesn&#X2019;t know what to do
with the term you gave.
</LI><LI CLASS="li-enumerate"><TT>Refine passed ill-formed term</TT>: the term you gave is not
a valid proof (not easy to debug in general).
This message may also occur in higher-level tactics, which call 
<TT>refine</TT> internally.
</LI><LI CLASS="li-enumerate"><TT>Cannot infer a term for this placeholder</TT><A NAME="@error53"></A>
there is a hole in the term you gave
which type cannot be inferred. Put a cast around it.
</LI></OL><P>An example of use is given in Section <A HREF="Reference-Manual013.html#refine-example">10.1</A>.</P><H2 CLASS="section"><A NAME="toc53"></A><A NAME="htoc210">8.3</A>  Basics
<A NAME="@default489"></A></H2><P>Tactics presented in this section implement the basic typing rules of
p<SPAN STYLE="font-variant:small-caps">Cic</SPAN> given in Chapter <A HREF="Reference-Manual006.html#Cic">4</A>.</P><H3 CLASS="subsection"><A NAME="htoc211">8.3.1</A>  <TT>assumption</TT>
<A NAME="@default490"></A><A NAME="@tactic6"></A></H3><P>This tactic applies to any goal. It implements the
&#X201C;Var&#X201D;<A NAME="@default491"></A> rule given in
Section <A HREF="Reference-Manual006.html#Typed-terms">4.2</A>. It looks in the local context for an
hypothesis which type is equal to the goal. If it is the case, the
subgoal is proved. Otherwise, it fails.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>No such assumption</TT><A NAME="@error54"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<A NAME="@default492"></A><A NAME="@tactic7"></A>
<TT>eassumption</TT><P>This tactic behaves like <TT>assumption</TT> but is able to handle
goals with meta-variables.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc212">8.3.2</A>  <TT>clear </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default493"></A><A NAME="@tactic8"></A><TT>
</TT><A NAME="clear"></A></H3><P>This tactic erases the hypothesis named <I><FONT COLOR=maroon>ident</FONT></I> in the local context
of the current goal. Then <I><FONT COLOR=maroon>ident</FONT></I> is no more displayed and no more
usable in the proof development.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>clear </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><P>This is equivalent to <TT>clear </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>. </TT><TT>&#X2026;</TT><TT> clear
</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>.</TT></P></LI><LI CLASS="li-enumerate"><TT>clearbody </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default494"></A><A NAME="@tactic9"></A><P>This tactic expects <I><FONT COLOR=maroon>ident</FONT></I> to be a local definition then clears
its body. Otherwise said, this tactic turns a definition into an
assumption.</P></LI><LI CLASS="li-enumerate"><TT>clear - </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><P>This tactic clears all hypotheses except the ones depending in 
the hypotheses named <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> and in the
goal.</P></LI><LI CLASS="li-enumerate"><TT>clear</TT><P>This tactic clears all hypotheses except the ones depending in 
goal.</P></LI><LI CLASS="li-enumerate"><TT>clear dependent </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default495"></A><A NAME="@tactic10"></A><P>This clears the hypothesis <I><FONT COLOR=maroon>ident</FONT></I> and all hypotheses
which depend on it.</P></LI></OL><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<I><FONT COLOR=maroon>ident</FONT></I><TT> not found</TT><A NAME="@error55"></A>
</LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><TT> is used in the conclusion</TT><A NAME="@error56"></A> 
</LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><TT> is used in the hypothesis </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2019;</TT><A NAME="@error57"></A> 
</LI></OL><H3 CLASS="subsection"><A NAME="htoc213">8.3.3</A>  <TT>move </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> after </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="@default496"></A><A NAME="@tactic11"></A><TT>
</TT><A NAME="move"></A></H3><P>This moves the hypothesis named <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> in the local context
after the hypothesis named <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB>.</P><P>If <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> comes before <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> in the order of dependences,
then all hypotheses between <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> which
(possibly indirectly) depend on <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> are moved also.</P><P>If <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> comes after <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> in the order of dependences,
then all hypotheses between <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> which 
(possibly indirectly) occur in <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> are moved also.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>move </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> before </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><P>This moves <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> towards and just before the hypothesis named <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB>.</P></LI><LI CLASS="li-enumerate"><TT>move </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> at top</TT><P>This moves <I><FONT COLOR=maroon>ident</FONT></I> at the top of the local context (at the beginning of the context).</P></LI><LI CLASS="li-enumerate"><TT>move </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> at bottom</TT><P>This moves <I><FONT COLOR=maroon>ident</FONT></I> at the bottom of the local context (at the end of the context).</P></LI></OL><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>i</I></TT></SUB><TT> not found</TT><A NAME="@error58"></A></LI><LI CLASS="li-enumerate"><TT>Cannot move </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> after </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>:
it occurs in </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><A NAME="@error59"></A></LI><LI CLASS="li-enumerate"><TT>Cannot move </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> after </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>:
it depends on </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><A NAME="@error60"></A></LI></OL><H3 CLASS="subsection"><A NAME="htoc214">8.3.4</A>  <TT>rename </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> into </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="@default497"></A><A NAME="@tactic12"></A></H3><P>This renames hypothesis <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> into <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> in the current
context<SUP><A NAME="text15" HREF="#note15">1</A></SUP></P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>rename </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> into </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>, &#X2026;,
</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2<I>k</I>-1</TT></SUB><TT> into </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2<I>k</I></TT></SUB><P>Is equivalent to the sequence of the corresponding atomic <TT>rename</TT>. </P></LI></OL><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> not found</TT><A NAME="@error61"></A></LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT> is already used</TT><A NAME="@error62"></A></LI></OL><H3 CLASS="subsection"><A NAME="htoc215">8.3.5</A>  <TT>intro
</TT><A NAME="@default498"></A><A NAME="@tactic13"></A><TT>
</TT><A NAME="intro"></A></H3><P>This tactic applies to a goal which is either a product or starts with
a let binder. If the goal is a product, the tactic implements the
&#X201C;Lam&#X201D;<A NAME="@default499"></A> rule given in
Section <A HREF="Reference-Manual006.html#Typed-terms">4.2</A><SUP><A NAME="text16" HREF="#note16">2</A></SUP>. If the
goal starts with a let binder then the tactic implements a mix of the
&#X201C;Let&#X201D;<A NAME="@default500"></A> and &#X201C;Conv&#X201D;<A NAME="@default501"></A>.</P><P>If the current goal is a dependent product <TT>forall </TT><TT><I>x</I></TT><TT>:</TT><TT><I>T</I></TT><TT>, </TT><TT><I>U</I></TT> (resp <TT>let </TT><TT><I>x</I></TT><TT>:=</TT><TT><I>t</I></TT><TT> in </TT><TT><I>U</I></TT>) then <TT>intro</TT> puts <TT><I>x</I></TT><TT>:</TT><TT><I>T</I></TT> (resp <TT><I>x</I></TT><TT>:=</TT><TT><I>t</I></TT>)
in the local context.
The new subgoal is <I>U</I>.
</P><P>If the goal is a non dependent product <TT><I>T</I></TT><TT> -&gt; </TT><TT><I>U</I></TT>, then it puts
in the local context either <TT>H</TT><I>n</I><TT>:</TT><TT><I>T</I></TT> (if <I>T</I> is of
type <TT>Set</TT> or <TT>Prop</TT>) or <TT>X</TT><I>n</I><TT>:</TT><TT><I>T</I></TT> (if the type
of <I>T</I> is <TT>Type</TT>). The optional index <I>n</I> is such that <TT>H</TT><I>n</I> or <TT>X</TT><I>n</I> is a fresh identifier.
In both cases the new subgoal is <I>U</I>.</P><P>If the goal is neither a product nor starting with a let definition,
the tactic <TT>intro</TT> applies the tactic <TT>red</TT> until the tactic
<TT>intro</TT> can be applied or the goal is not reducible.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>No product even after head-reduction</TT><A NAME="@error63"></A>
</LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><TT> is already used</TT><A NAME="@error64"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>intros</TT><A NAME="@default502"></A><A NAME="@tactic14"></A><P>Repeats <TT>intro</TT> until it meets the head-constant. It never reduces
head-constants and it never fails.</P></LI><LI CLASS="li-enumerate"><TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><P>Applies <TT>intro</TT> but forces <I><FONT COLOR=maroon>ident</FONT></I> to be the name of the
introduced hypothesis.</P><P><BR>
<B>Error message: </B><TT>name </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> is already used</TT><A NAME="@error65"></A></P><P><BR>
<B>Remark: </B>If a name used by <TT>intro</TT> hides the base name of a global
constant then the latter can still be referred to by a qualified name
(see <A HREF="Reference-Manual004.html#LongNames">2.6.2</A>).</P></LI><LI CLASS="li-enumerate"><TT>intros </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB> <P>Is equivalent to the composed tactic <TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>; &#X2026; ;
intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB>.</P><P>More generally, the <TT>intros</TT> tactic takes a pattern as
argument in order to introduce names for components of an inductive
definition or to clear introduced hypotheses; This is explained
in <A HREF="#intros-pattern">8.7.3</A>.</P></LI><LI CLASS="li-enumerate"><TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I> <A NAME="@default503"></A><A NAME="@tactic15"></A><P>Repeats <TT>intro</TT> until it meets a premise of the goal having form
<TT>(</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT> and discharges the variable
named <I><FONT COLOR=maroon>ident</FONT></I> of the current goal.</P><P><BR>
<B>Error message: </B><TT>No such hypothesis in current goal</TT><A NAME="@error66"></A></P></LI><LI CLASS="li-enumerate"><TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> <A NAME="@default504"></A><A NAME="@tactic16"></A><P>Repeats <TT>intro</TT> until the <I><FONT COLOR=maroon>num</FONT></I>-th non-dependent product. For
instance, on the subgoal <CODE>forall x y:nat, x=y -&gt; y=x</CODE> the tactic <TT>intros until 1</TT>
is equivalent to <TT>intros x y H</TT>, as <CODE>x=y -&gt; y=x</CODE> is the
first non-dependent product. And on the subgoal <CODE>forall x y z:nat, x=y -&gt; y=x</CODE> the tactic <TT>intros until 1</TT>
is equivalent to <TT>intros x y z</TT> as the product on <TT>z</TT>
can be rewritten as a non-dependent product: <CODE>forall x y:nat, nat -&gt; x=y -&gt; y=x</CODE></P><P><BR>
<B>Error message: </B><TT>No such hypothesis in current goal</TT><A NAME="@error67"></A></P><P>Happens when <I><FONT COLOR=maroon>num</FONT></I> is 0 or is greater than the number of non-dependent
products of the goal.</P></LI><LI CLASS="li-enumerate"><TT>intro after </TT><I><FONT COLOR=maroon>ident</FONT></I> <A NAME="@default505"></A><A NAME="@tactic17"></A><BR>
 <TT>intro before </TT><I><FONT COLOR=maroon>ident</FONT></I> <A NAME="@default506"></A><A NAME="@tactic18"></A><BR>
 <TT>intro at top</TT> <A NAME="@default507"></A><A NAME="@tactic19"></A><BR>
 <TT>intro at bottom</TT> <A NAME="@default508"></A><A NAME="@tactic20"></A><P>Applies <TT>intro</TT> and moves the freshly introduced hypothesis
respectively after the hypothesis <I><FONT COLOR=maroon>ident</FONT></I>, before the hypothesis
<I><FONT COLOR=maroon>ident</FONT></I>, at the top of the local context, or at the bottom of the
local context. All hypotheses on which the new hypothesis depends
are moved too so as to respect the order of dependencies between
hypotheses. Note that <TT>intro at bottom</TT> is a synonym for <TT>intro</TT> with no argument.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<TT>No product even after head-reduction</TT><A NAME="@error68"></A>
</LI><LI CLASS="li-enumerate"><TT>No such hypothesis</TT><A NAME="@error69"></A> : <I><FONT COLOR=maroon>ident</FONT></I>
</LI></OL></LI><LI CLASS="li-enumerate"><TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> after </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><BR>
 <TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> before </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><BR>
 <TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> at top</TT><BR>
 <TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> at bottom</TT><P>Behaves as previously but naming the introduced hypothesis
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>. It is equivalent to <TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB> followed by
the appropriate call to <TT>move</TT> (see Section <A HREF="#move">8.3.3</A>).</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<TT>No product even after head-reduction</TT><A NAME="@error70"></A>
</LI><LI CLASS="li-enumerate"><TT>No such hypothesis</TT><A NAME="@error71"></A> : <I><FONT COLOR=maroon>ident</FONT></I>
</LI></OL></LI></OL><H3 CLASS="subsection"><A NAME="htoc216">8.3.6</A>  <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default509"></A><A NAME="@tactic21"></A><TT>
</TT><A NAME="apply"></A></H3><P>This tactic applies to any goal. The argument <I><FONT COLOR=maroon>term</FONT></I> is a term
well-formed in the local context. The tactic <TT>apply</TT> tries to
match the current goal against the conclusion of the type of <I><FONT COLOR=maroon>term</FONT></I>.
If it succeeds, then the tactic returns as many subgoals as the number
of non dependent premises of the type of <I><FONT COLOR=maroon>term</FONT></I>. If the conclusion of
the type of <I><FONT COLOR=maroon>term</FONT></I> does not match the goal <EM>and</EM> the conclusion
is an inductive type isomorphic to a tuple type, then each component
of the tuple is recursively matched to the goal in the left-to-right
order.</P><P>The tactic <TT>apply</TT> relies on first-order unification with
dependent types unless the conclusion of the type of <I><FONT COLOR=maroon>term</FONT></I> is of the
form <TT>(</TT><TT><I>P</I></TT><TT>  </TT><TT><I>t</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><TT><I>t</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT> with <I>P</I> to be instantiated. In
the latter case, the behavior depends on the form of the goal. If the
goal is of the form <TT>(fun </TT><TT><I>x</I></TT><TT> =&gt; </TT><TT><I>Q</I></TT><TT>) </TT><TT><I>u</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><TT><I>u</I></TT><SUB><TT><I>n</I></TT></SUB> and the
<I>t</I><SUB><I>i</I></SUB> and <I>u</I><SUB><I>i</I></SUB> unifies, then <I>P</I> is taken to be (fun <I>x</I> =&gt; <I>Q</I>).
Otherwise, <TT>apply</TT> tries to define <I>P</I> by abstracting over
<I>t</I><SUB>1</SUB> &#X2026; <I>t</I><SUB><I>n</I></SUB> in the goal. See <TT>pattern</TT> in
Section <A HREF="#pattern">8.5.7</A> to transform the goal so that it gets the form
<TT>(fun </TT><TT><I>x</I></TT><TT> =&gt; </TT><TT><I>Q</I></TT><TT>) </TT><TT><I>u</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><TT><I>u</I></TT><SUB><TT><I>n</I></TT></SUB>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Impossible to unify &#X2026; with &#X2026;</TT><A NAME="@error72"></A> <P>The <TT>apply</TT>
tactic failed to match the conclusion of <I><FONT COLOR=maroon>term</FONT></I> and the current goal.
You can help the <TT>apply</TT> tactic by transforming your
goal with the <TT>change</TT> or <TT>pattern</TT> tactics (see 
sections <A HREF="#pattern">8.5.7</A>, <A HREF="#change">8.3.12</A>).</P></LI><LI CLASS="li-enumerate"><TT>Unable to find an instance for the variables
</TT><I><FONT COLOR=maroon>ident</FONT></I><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@error73"></A><P>This occurs when some instantiations of the premises of <I><FONT COLOR=maroon>term</FONT></I> are not
deducible from the unification. This is the case, for instance, when
you want to apply a transitivity property. In this case, you have to
use one of the variants below:</P></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> 
<A NAME="@default510"></A><A NAME="@tactic22"></A><P>Provides <TT>apply</TT> with explicit instantiations for all dependent
premises of the type of <I><FONT COLOR=maroon>term</FONT></I> which do not occur in the conclusion
and consequently cannot be found by unification. Notice that
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> must be given according to the order
of these dependent premises of the type of <I><FONT COLOR=maroon>term</FONT></I>.</P><P><BR>
<B>Error message: </B><TT>Not the right number of missing arguments</TT><A NAME="@error74"></A></P></LI><LI CLASS="li-enumerate"><TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with (</TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT>1</TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>) &#X2026; (</TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>
:= </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)</TT> <P>This also provides <TT>apply</TT> with values for instantiating
premises. Here, variables are referred by names and non-dependent
products by increasing numbers (see syntax in Section <A HREF="#Binding-list">8.3.22</A>).</P></LI><LI CLASS="li-enumerate"><TT>apply</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <TT>,</TT> &#X2026;<TT>,</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> <P>This is a shortcut for <TT>apply</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <TT>; [ .. |</TT>
&#X2026; <TT>; [ .. | </TT><TT>apply</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> ]</TT> &#X2026; <TT>]</TT>, i.e. for the
successive applications of <I><FONT COLOR=maroon>term</FONT></I><SUB><I>i</I>+1</SUB> on the last subgoal
generated by <TT>apply</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>i</I></SUB>, starting from the application
of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>.</P></LI><LI CLASS="li-enumerate"><TT>eapply </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default511"></A><A NAME="@tactic23"></A><A NAME="eapply"></A><P>The tactic <TT>eapply</TT> behaves as <TT>apply</TT> but does not fail
when no instantiation are deducible for some variables in the
premises. Rather, it turns these variables into so-called
existential variables which are variables still to instantiate. An
existential variable is identified by a name of the form <TT>?</TT><TT><I>n</I></TT>
where <I>n</I> is a number. The instantiation is intended to be found
later in the proof.</P><P>An example of use of <TT>eapply</TT> is given in
Section <A HREF="Reference-Manual013.html#eapply-example">10.2</A>. </P></LI><LI CLASS="li-enumerate"><TT>simple apply </TT><I><FONT COLOR=maroon>term</FONT></I> <A NAME="@default512"></A><A NAME="@tactic24"></A> <P>This behaves like <TT>apply</TT> but it reasons modulo conversion only
on subterms that contain no variables to instantiate. For instance,
if <TT>id := fun x:nat =&gt; x</TT> and <TT>H : forall y, id y = y</TT> then
<TT>simple apply H</TT> on goal <TT>O = O</TT> does not succeed because it
would require the conversion of <TT>f ?y</TT> and <TT>O</TT> where <TT>?y</TT> is a variable to instantiate. Tactic <TT>simple apply</TT> does not
either traverse tuples as <TT>apply</TT> does.</P><P>Because it reasons modulo a limited amount of conversion, <TT>simple apply</TT> fails quicker than <TT>apply</TT> and it is then
well-suited for uses in used-defined tactics that backtrack often.</P></LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>[</FONT></I><TT>simple</TT><I><FONT COLOR=maroon>]</FONT></I> <TT>apply</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>[</FONT></I><TT>with</TT>
<I><FONT COLOR=maroon>bindings_list</FONT></I><SUB>1</SUB><I><FONT COLOR=maroon>]</FONT></I> <TT>,</TT> &#X2026;<TT>,</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> <I><FONT COLOR=maroon>[</FONT></I><TT>with</TT>
<I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><I>n</I></SUB><I><FONT COLOR=maroon>]</FONT></I><BR>
 <I><FONT COLOR=maroon>[</FONT></I><TT>simple</TT><I><FONT COLOR=maroon>]</FONT></I> <TT>eapply</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>[</FONT></I><TT>with</TT>
<I><FONT COLOR=maroon>bindings_list</FONT></I><SUB>1</SUB><I><FONT COLOR=maroon>]</FONT></I> <TT>,</TT> &#X2026;<TT>,</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> <I><FONT COLOR=maroon>[</FONT></I><TT>with</TT>
<I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><I>n</I></SUB><I><FONT COLOR=maroon>]</FONT></I><P>This summarizes the different syntaxes for <TT>apply</TT> and <TT>eapply</TT>.</P></LI><LI CLASS="li-enumerate"><TT>lapply </TT><I><FONT COLOR=maroon>term</FONT></I> <A NAME="@default513"></A><A NAME="@tactic25"></A> <P>This tactic applies to any goal, say <TT>G</TT>. The argument <I><FONT COLOR=maroon>term</FONT></I>
has to be well-formed in the current context, its type being
reducible to a non-dependent product <TT>A -&gt; B</TT> with <TT>B</TT>
possibly containing products. Then it generates two subgoals <TT>B-&gt;G</TT> and <TT>A</TT>. Applying <TT>lapply H</TT> (where <TT>H</TT> has type
<TT>A-&gt;B</TT> and <TT>B</TT> does not start with a product) does the same
as giving the sequence <TT>cut B. 2:apply H.</TT> where <TT>cut</TT> is
described below.</P><P><BR>
<B>Warning: </B>When <I><FONT COLOR=maroon>term</FONT></I> contains more than one non
dependent product the tactic <TT>lapply</TT> only takes into account the
first product.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc217">8.3.7</A>  <TT>set ( </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><TT>:=</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> )</TT>
<A NAME="tactic:set"></A>
<A NAME="@default514"></A><A NAME="@tactic26"></A>
<A NAME="@default515"></A><A NAME="@tactic27"></A>
<A NAME="@default516"></A><A NAME="@tactic28"></A></H3><P>This replaces <I><FONT COLOR=maroon>term</FONT></I> by <I><FONT COLOR=maroon>ident</FONT></I> in the conclusion or in the
hypotheses of the current goal and adds the new definition <I><FONT COLOR=maroon>ident</FONT></I><TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> to the local context. The default is to make this
replacement only in the conclusion.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>set (</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>) in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I><P>This notation allows to specify which occurrences of <I><FONT COLOR=maroon>term</FONT></I> have to
be substituted in the context. The <TT>in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I> clause is an
occurrence clause whose syntax and behavior is described in
Section <A HREF="#Occurrences clauses">8.3.23</A>.</P></LI><LI CLASS="li-enumerate"><TT>set (</TT> <I><FONT COLOR=maroon>ident</FONT></I> <I><FONT COLOR=maroon>binder</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT><P>This is equivalent to <TT>set (</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:=</TT> <TT>fun</TT>
<I><FONT COLOR=maroon>binder</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I> <TT>=&gt;</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT>.</P></LI><LI CLASS="li-enumerate"><TT>set </TT> <I><FONT COLOR=maroon>term</FONT></I><P>This behaves as <TT>set (</TT> <I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT> but <I><FONT COLOR=maroon>ident</FONT></I>
is generated by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. This variant also supports an occurrence clause.</P></LI><LI CLASS="li-enumerate"><TT>set (</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> <I><FONT COLOR=maroon>binder</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I>
<TT>) in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I><BR>
 <TT>set </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I><P>These are the general forms which combine the previous possibilities.</P></LI><LI CLASS="li-enumerate"><TT>remember </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT>as</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><P>This behaves as <TT>set (</TT> <I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I> <TT>) in *</TT> and using a
logical (Leibniz&#X2019;s) equality instead of a local definition.</P></LI><LI CLASS="li-enumerate"><TT>remember </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT>as</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I><P>This is a more general form of <TT>remember</TT> that remembers the
occurrences of <I><FONT COLOR=maroon>term</FONT></I> specified by an occurrences set.</P></LI><LI CLASS="li-enumerate"><TT>pose ( </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><TT>:=</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT>)</TT><P>This adds the local definition <I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I> to the current
context without performing any replacement in the goal or in the
hypotheses. It is equivalent to <TT>set ( </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><TT>:=</TT><TT>
</TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT>) in |-</TT>.</P></LI><LI CLASS="li-enumerate"><TT>pose (</TT> <I><FONT COLOR=maroon>ident</FONT></I> <I><FONT COLOR=maroon>binder</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT><P>This is equivalent to <TT>pose (</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:=</TT> <TT>fun</TT>
<I><FONT COLOR=maroon>binder</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I> <TT>=&gt;</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT>.</P></LI><LI CLASS="li-enumerate"><TT>pose </TT><I><FONT COLOR=maroon>term</FONT></I><P>This behaves as <TT>pose (</TT> <I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT> but
<I><FONT COLOR=maroon>ident</FONT></I> is generated by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc218">8.3.8</A>  <TT>assert ( </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>form</FONT></I><TT> )</TT>
<A NAME="@default517"></A><A NAME="@tactic29"></A></H3><P>This tactic applies to any goal. <TT>assert (H : U)</TT> adds a new
hypothesis of name <TT>H</TT> asserting <TT>U</TT> to the current goal
and opens a new subgoal <TT>U</TT><SUP><A NAME="text17" HREF="#note17">3</A></SUP>. The subgoal <TT>U</TT> comes first
in the list of subgoals remaining to prove.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not a proposition or a type</TT><A NAME="@error75"></A><P>Arises when the argument <I><FONT COLOR=maroon>form</FONT></I> is neither of type <TT>Prop</TT>, <TT>Set</TT> nor <TT>Type</TT>.</P></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>assert </TT><I><FONT COLOR=maroon>form</FONT></I><P>This behaves as <TT>assert (</TT> <I><FONT COLOR=maroon>ident</FONT></I> : <I><FONT COLOR=maroon>form</FONT></I> <TT>)</TT> but
<I><FONT COLOR=maroon>ident</FONT></I> is generated by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P></LI><LI CLASS="li-enumerate"><TT>assert (</TT> <I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT><P>This behaves as <TT>assert (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><TT>);[exact
</TT><I><FONT COLOR=maroon>term</FONT></I><TT>|idtac]</TT> where <I><FONT COLOR=maroon>type</FONT></I> is the type of <I><FONT COLOR=maroon>term</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>cut </TT><I><FONT COLOR=maroon>form</FONT></I><A NAME="@default518"></A><A NAME="@tactic30"></A> <P>This tactic applies to any goal. It implements the non dependent
case of the &#X201C;App&#X201D;<A NAME="@default519"></A> rule given in
Section <A HREF="Reference-Manual006.html#Typed-terms">4.2</A>. (This is Modus Ponens inference rule.)
<TT>cut U</TT> transforms the current goal <TT>T</TT> into the two
following subgoals: <TT>U -&gt; T</TT> and <TT>U</TT>. The subgoal <TT>U
-&gt; T</TT> comes first in the list of remaining subgoal to prove.</P></LI><LI CLASS="li-enumerate"><TT>assert </TT><I><FONT COLOR=maroon>form</FONT></I><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><A NAME="@default520"></A><A NAME="@tactic31"></A><P>This tactic behaves like <TT>assert</TT> but applies <I><FONT COLOR=maroon>tactic</FONT></I>
to solve the subgoals generated by <TT>assert</TT>.</P></LI><LI CLASS="li-enumerate"><TT>assert </TT><I><FONT COLOR=maroon>form</FONT></I><TT> as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><A NAME="@default521"></A><A NAME="@tactic32"></A><P>If <I><FONT COLOR=maroon>intro_pattern</FONT></I> is a naming introduction pattern (see
Section <A HREF="#intros-pattern">8.7.3</A>), the hypothesis is named after this
introduction pattern (in particular, if <I><FONT COLOR=maroon>intro_pattern</FONT></I> is <I><FONT COLOR=maroon>ident</FONT></I>,
the tactic behaves like <TT>assert (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>form</FONT></I><TT>)</TT>).</P><P>If <I><FONT COLOR=maroon>intro_pattern</FONT></I> is a disjunctive/conjunctive introduction
pattern, the tactic behaves like <TT>assert </TT><I><FONT COLOR=maroon>form</FONT></I> then destructing the
resulting hypothesis using the given introduction pattern.</P></LI><LI CLASS="li-enumerate"><TT>assert </TT><I><FONT COLOR=maroon>form</FONT></I><TT> as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><P>This combines the two previous variants of <TT>assert</TT>.</P></LI><LI CLASS="li-enumerate"><TT>pose proof </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><A NAME="@default522"></A><A NAME="@tactic33"></A><P>This tactic behaves like <TT>assert T as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><TT> by
exact </TT><I><FONT COLOR=maroon>term</FONT></I> where <TT>T</TT> is the type of <I><FONT COLOR=maroon>term</FONT></I>.</P><P>In particular, <TT>pose proof </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>ident</FONT></I> behaves as
<TT>assert (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>:T) by exact </TT><I><FONT COLOR=maroon>term</FONT></I> (where <TT>T</TT> is
the type of <I><FONT COLOR=maroon>term</FONT></I>) and <TT>pose proof </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as
</TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><A NAME="@default523"></A><A NAME="@tactic34"></A> behaves
like <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>specialize (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)</TT><A NAME="@default524"></A><A NAME="@tactic35"></A><BR>
 <TT>specialize </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>The tactic <TT>specialize</TT> works on local hypothesis <I><FONT COLOR=maroon>ident</FONT></I>.
The premises of this hypothesis (either universal
quantifications or non-dependent implications) are instantiated
by concrete terms coming either from arguments <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>
&#X2026; <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> or from a bindings list (see
Section <A HREF="#Binding-list">8.3.22</A> for more about bindings lists). In the
second form, all instantiation elements must be given, whereas
in the first form the application to <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X2026;
<I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> can be partial. The first form is equivalent to 
<TT>assert (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2019;:=</TT><I><FONT COLOR=maroon>ident</FONT></I><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>);
clear </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; rename </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2019; into </TT><I><FONT COLOR=maroon>ident</FONT></I>. </P><P>The name <I><FONT COLOR=maroon>ident</FONT></I> can also refer to a global lemma or
hypothesis. In this case, for compatibility reasons, the
behavior of <TT>specialize</TT> is close to that of <TT>generalize</TT>: the instantiated statement becomes an additional 
premise of the goal. </P></LI></OL><H3 CLASS="subsection"><A NAME="htoc219">8.3.9</A>  <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I>
<A NAME="@default525"></A><A NAME="@tactic36"></A></H3><P>This tactic applies to any goal. The argument <I><FONT COLOR=maroon>term</FONT></I> is a term
well-formed in the local context and the argument <I><FONT COLOR=maroon>ident</FONT></I> is an
hypothesis of the context. The tactic <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I>
tries to match the conclusion of the type of <I><FONT COLOR=maroon>ident</FONT></I> against a non
dependent premise of the type of <I><FONT COLOR=maroon>term</FONT></I>, trying them from right to
left. If it succeeds, the statement of hypothesis <I><FONT COLOR=maroon>ident</FONT></I> is
replaced by the conclusion of the type of <I><FONT COLOR=maroon>term</FONT></I>. The tactic also
returns as many subgoals as the number of other non dependent premises
in the type of <I><FONT COLOR=maroon>term</FONT></I> and of the non dependent premises of the type
of <I><FONT COLOR=maroon>ident</FONT></I>. If the conclusion of the type of <I><FONT COLOR=maroon>term</FONT></I> does not match
the goal <EM>and</EM> the conclusion is an inductive type isomorphic to a
tuple type, then the tuple is (recursively) decomposed and the first
component of the tuple of which a non dependent premise matches the
conclusion of the type of <I><FONT COLOR=maroon>ident</FONT></I>. Tuples are decomposed in a
width-first left-to-right order (for instance if the type of <TT>H1</TT>
is a <CODE>A &lt;-&gt; B</CODE> statement, and the type of <TT>H2</TT> is <CODE>A</CODE>
then <TT>apply H1 in H2</TT> transforms the type of <TT>H2</TT> into <TT>B</TT>). The tactic <TT>apply</TT> relies on first-order pattern-matching
with dependent types.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Statement without assumptions</TT><A NAME="@error76"></A><P>This happens if the type of <I><FONT COLOR=maroon>term</FONT></I> has no non dependent premise.</P></LI><LI CLASS="li-enumerate"><TT>Unable to apply</TT><A NAME="@error77"></A><P>This happens if the conclusion of <I><FONT COLOR=maroon>ident</FONT></I> does not match any of the
non dependent premises of the type of <I><FONT COLOR=maroon>term</FONT></I>.
</P></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I><P>This applies each of <I><FONT COLOR=maroon>term</FONT></I> in sequence in <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I><P>This does the same but uses the bindings in each <I><FONT COLOR=maroon>bindings_list</FONT></I> to 
instantiate the parameters of the corresponding type of <I><FONT COLOR=maroon>term</FONT></I>
(see syntax of bindings in Section <A HREF="#Binding-list">8.3.22</A>).</P></LI><LI CLASS="li-enumerate"><TT>eapply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I>
<A NAME="@default526"></A><A NAME="@tactic37"></A><P>This works as <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> in
</TT><I><FONT COLOR=maroon>ident</FONT></I> but turns unresolved bindings into existential variables, if
any, instead of failing.</P></LI><LI CLASS="li-enumerate"><TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT>,</TT><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT>,</TT><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><P>This works as <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT>,</TT><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT>,</TT><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> in
</TT><I><FONT COLOR=maroon>ident</FONT></I> then destructs the hypothesis <I><FONT COLOR=maroon>ident</FONT></I> along
<I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I> as <TT>destruct </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> as
</TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I> would.</P></LI><LI CLASS="li-enumerate"><TT>eapply </TT><I><FONT COLOR=maroon>term</FONT></I><TT>,</TT><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT>,</TT><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><P>This works as <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT>,</TT><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT>,</TT><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I> but using <TT>eapply</TT>.</P></LI><LI CLASS="li-enumerate"><TT>simple apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I>
<A NAME="@default527"></A><A NAME="@tactic38"></A> 
<A NAME="@default528"></A><A NAME="@tactic39"></A> <P>This behaves like <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I> but it reasons
modulo conversion only on subterms that contain no variables to
instantiate. For instance, if <TT>id := fun x:nat =&gt; x</TT> and <TT>H :
forall y, id y = y -&gt; True</TT> and <TT>H0 : O = O</TT> then <TT>simple
apply H in H0</TT> does not succeed because it would require the
conversion of <TT>f ?y</TT> and <TT>O</TT> where <TT>?y</TT> is a variable to
instantiate. Tactic <TT>simple apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I> does not
either traverse tuples as <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I> does.</P></LI><LI CLASS="li-enumerate"><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>simple</TT><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><BR>
<TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>simple</TT><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> eapply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><P>This summarizes the different syntactic variants of <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT>
in </TT><I><FONT COLOR=maroon>ident</FONT></I> and <TT>eapply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I>.
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc220">8.3.10</A>  <TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default529"></A><A NAME="@tactic40"></A><TT>
</TT><A NAME="generalize"></A></H3><P>This tactic applies to any goal. It generalizes the conclusion w.r.t.
one subterm of it. For example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Show.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 </I></TT><TT><I>&lt;</I></TT><TT><I>= x + y + y</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> generalize (x + y + y).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, 0 </I></TT><TT><I>&lt;</I></TT><TT><I>= n</I></TT><BR>
</DIV><P>If the goal is <I>G</I> and <I>t</I> is a subterm of type <I>T</I> in the goal, then
<TT>generalize</TT> <I>t</I> replaces the goal by <TT>forall (x:</TT><TT><I>T</I></TT><TT>), </TT><TT><I>G</I>&#X2032;</TT>
where <I>G</I>&#X2032; is obtained from <I>G</I> by replacing all occurrences of <I>t</I> by
<TT>x</TT>. The name of the variable (here <TT>n</TT>) is chosen based on <I>T</I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> , &#X2026; , </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><P>Is equivalent to <TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>; &#X2026; ; generalize
</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB>. Note that the sequence of <I><FONT COLOR=maroon>term</FONT></I><SUB><I>i</I></SUB>&#X2019;s are processed
from <I>n</I> to 1.</P></LI><LI CLASS="li-enumerate"><TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><P>Is equivalent to <TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I> but generalizing only over
the specified occurrences of <I><FONT COLOR=maroon>term</FONT></I> (counting from left to right on the
expression printed using option <TT>Set Printing All</TT>).</P></LI><LI CLASS="li-enumerate"><TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>ident</FONT></I><P>Is equivalent to <TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I> but use <I><FONT COLOR=maroon>ident</FONT></I> to name the
generalized hypothesis.</P></LI><LI CLASS="li-enumerate"><TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>11</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1<I>i</I></TT><SUB><TT>1</TT></SUB></SUB><TT> 
as </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>
, </TT><TT>&#X2026;</TT><TT> ,
</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>n</I>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>ni</I></TT><SUB><TT><I>n</I></TT></SUB></SUB><TT>
as </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><P>This is the most general form of <TT>generalize</TT> that combines the
previous behaviors.</P></LI><LI CLASS="li-enumerate"><TT>generalize dependent </TT><I><FONT COLOR=maroon>term</FONT></I> <A NAME="@default530"></A><A NAME="@tactic41"></A><P>This generalizes <I><FONT COLOR=maroon>term</FONT></I> but also <EM>all</EM> hypotheses which depend
on <I><FONT COLOR=maroon>term</FONT></I>. It clears the generalized hypotheses.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc221">8.3.11</A>  <TT>revert </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>
</TT><A NAME="@default531"></A><A NAME="@tactic42"></A><TT>
</TT><A NAME="revert"></A></H3><P>This applies to any goal with variables <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>.
It moves the hypotheses (possibly defined) to the goal, if this respects
dependencies. This tactic is the inverse of <TT>intro</TT>. </P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<I><FONT COLOR=maroon>ident</FONT></I><TT> is used in the hypothesis </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2019;</TT><A NAME="@error78"></A> 
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>revert dependent </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default532"></A><A NAME="@tactic43"></A><P>This moves to the goal the hypothesis <I><FONT COLOR=maroon>ident</FONT></I> and all hypotheses
which depend on it.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc222">8.3.12</A>  <TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default533"></A><A NAME="@tactic44"></A><TT>
</TT><A NAME="change"></A></H3><P>This tactic applies to any goal. It implements the rule
&#X201C;Conv&#X201D;<A NAME="@default534"></A> given in Section <A HREF="Reference-Manual006.html#Conv">4.3</A>. <TT>change U</TT> replaces the current goal <TT>T</TT> with <TT>U</TT> providing that
<TT>U</TT> is well-formed and that <TT>T</TT> and <TT>U</TT> are convertible.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not convertible</TT><A NAME="@error79"></A>
</LI></OL><P><A NAME="@default535"></A><A NAME="@tactic45"></A>
<BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> <P>This replaces the occurrences of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> by <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> in the
current goal. The terms <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> must be
convertible.</P></LI><LI CLASS="li-enumerate"><TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> <P>This replaces the occurrences numbered <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB> of
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> by <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> in the current goal.
The terms <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> must be convertible.</P><P><BR>
<B>Error message: </B><TT>Too few occurrences</TT></P></LI><LI CLASS="li-enumerate"><TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I></LI><LI CLASS="li-enumerate"><TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I></LI><LI CLASS="li-enumerate"><TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> in
</TT><I><FONT COLOR=maroon>ident</FONT></I><P>This applies the <TT>change</TT> tactic not to the goal but to the
hypothesis <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI></OL><P><BR>
<B>See also: </B><A HREF="#Conversion-tactics">8.5</A></P><H3 CLASS="subsection"><A NAME="htoc223">8.3.13</A>  <TT>fix </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>num</FONT></I><TT>
</TT><A NAME="@default536"></A><A NAME="@tactic46"></A><TT>
</TT><A NAME="tactic:fix"></A></H3><P>This tactic is a primitive tactic to start a proof by induction. In
general, it is easier to rely on higher-level induction tactics such
as the ones described in Section <A HREF="#Tac-induction">8.7</A>.</P><P>In the syntax of the tactic, the identifier <I><FONT COLOR=maroon>ident</FONT></I> is the name given
to the induction hypothesis. The natural number <I><FONT COLOR=maroon>num</FONT></I> tells on which
premise of the current goal the induction acts, starting
from 1 and counting both dependent and non dependent
products. Especially, the current lemma must be composed of at least
<I><FONT COLOR=maroon>num</FONT></I> products.</P><P>Like in a <TT>fix</TT> expression, the induction
hypotheses have to be used on structurally smaller arguments.
The verification that inductive proof arguments are correct is done
only at the time of registering the lemma in the environment. To know
if the use of induction hypotheses is correct at some
time of the interactive development of a proof, use the command <TT>Guarded</TT> (see Section <A HREF="Reference-Manual010.html#Guarded">7.3.2</A>).</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>fix</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>num</FONT></I> <TT>with (</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB>
<I><FONT COLOR=maroon>binder</FONT></I><SUB>2</SUB>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I><SUB>2</SUB> <I><FONT COLOR=maroon>[</FONT></I><TT>{ struct </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2032;</TT><SUB><TT>2</TT></SUB><TT>
}</TT><I><FONT COLOR=maroon>]</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB>2</SUB> <TT>)</TT> &#X2026; <TT>(</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>
<I><FONT COLOR=maroon>binder</FONT></I><SUB><I>n</I></SUB>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I><SUB><I>n</I></SUB> <I><FONT COLOR=maroon>[</FONT></I><TT>{ struct </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2032;</TT><SUB><TT><I>n</I></TT></SUB><TT> }</TT><I><FONT COLOR=maroon>]</FONT></I>
<TT>:</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB><I>n</I></SUB> <TT>)</TT><P>This starts a proof by mutual induction. The statements to be
simultaneously proved are respectively <TT>forall</TT>
<I><FONT COLOR=maroon>binder</FONT></I><SUB>2</SUB>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I><SUB>2</SUB><TT>,</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB>2</SUB>, &#X2026;, <TT>forall</TT>
<I><FONT COLOR=maroon>binder</FONT></I><SUB><I>n</I></SUB>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I><SUB><I>n</I></SUB><TT>,</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB><I>n</I></SUB>. The identifiers
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> are the names of the induction
hypotheses. The identifiers <I><FONT COLOR=maroon>ident</FONT></I>&#X2032;<SUB>2</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I>&#X2032;<SUB><I>n</I></SUB> are the
respective names of the premises on which the induction is performed
in the statements to be simultaneously proved (if not given, the
system tries to guess itself what they are).</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc224">8.3.14</A>  <TT>cofix </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default537"></A><A NAME="@tactic47"></A><TT>
</TT><A NAME="tactic:cofix"></A></H3><P>This tactic starts a proof by coinduction. The identifier <I><FONT COLOR=maroon>ident</FONT></I> is
the name given to the coinduction hypothesis. Like in a <TT>cofix</TT>
expression, the use of induction hypotheses have to guarded by a
constructor. The verification that the use of coinductive hypotheses
is correct is done only at the time of registering the lemma in the
environment. To know if the use of coinduction hypotheses is correct
at some time of the interactive development of a proof, use the
command <TT>Guarded</TT> (see Section <A HREF="Reference-Manual010.html#Guarded">7.3.2</A>).</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>cofix</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> <TT>with (</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB>
<I><FONT COLOR=maroon>binder</FONT></I><SUB>2</SUB>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I><SUB>2</SUB> <TT>:</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB>2</SUB> <TT>)</TT> &#X2026; <TT>(</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>binder</FONT></I><SUB>1</SUB>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I><SUB>1</SUB> <TT>:</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB><I>n</I></SUB>
<TT>)</TT><P>This starts a proof by mutual coinduction. The statements to be
simultaneously proved are respectively <TT>forall</TT>
<I><FONT COLOR=maroon>binder</FONT></I><SUB>2</SUB>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I><SUB>2</SUB><TT>,</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB>2</SUB>, &#X2026;, <TT>forall</TT>
<I><FONT COLOR=maroon>binder</FONT></I><SUB><I>n</I></SUB>  &#X2026;  <I><FONT COLOR=maroon>binder</FONT></I><SUB><I>n</I></SUB><TT>,</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB><I>n</I></SUB>. The identifiers
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> are the names of the
coinduction hypotheses.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc225">8.3.15</A>  <TT>evar (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>:</TT><I><FONT COLOR=maroon>term</FONT></I><TT>)
</TT><A NAME="@default538"></A><A NAME="@tactic48"></A><TT>
</TT><A NAME="evar"></A></H3><P>The <TT>evar</TT> tactic creates a new local definition named <I><FONT COLOR=maroon>ident</FONT></I> with
type <I><FONT COLOR=maroon>term</FONT></I> in the context. The body of this binding is a fresh
existential variable.</P><H3 CLASS="subsection"><A NAME="htoc226">8.3.16</A>  <TT>instantiate (</TT><I><FONT COLOR=maroon>num</FONT></I><TT>:= </TT><I><FONT COLOR=maroon>term</FONT></I><TT>)
</TT><A NAME="@default539"></A><A NAME="@tactic49"></A><TT>
</TT><A NAME="instantiate"></A></H3><P>The <TT>instantiate</TT> tactic allows to solve an existential variable
with the term <I><FONT COLOR=maroon>term</FONT></I>. The <I><FONT COLOR=maroon>num</FONT></I>  argument is the position of the
existential variable from right to left in the conclusion. This cannot be
the number of the existential variable since this number is different
in every session.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>instantiate (</TT><I><FONT COLOR=maroon>num</FONT></I><TT>:=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>) in </TT><I><FONT COLOR=maroon>ident</FONT></I></LI><LI CLASS="li-enumerate"><TT>instantiate (</TT><I><FONT COLOR=maroon>num</FONT></I><TT>:=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>) in (Value of </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>)</TT></LI><LI CLASS="li-enumerate"><TT>instantiate (</TT><I><FONT COLOR=maroon>num</FONT></I><TT>:=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>) in (Type of </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>)</TT><P>These allow to refer respectively to existential variables occurring in 
a hypothesis or in the body or the type of a local definition. </P></LI><LI CLASS="li-enumerate"><TT>instantiate</TT><P>Without argument, the <TT>instantiate</TT> tactic tries to solve as
many existential variables as possible, using information gathered
from other tactics in the same tactical. This is automatically
done after each complete tactic (i.e. after a dot in proof mode),
but not, for example, between each tactic when they are sequenced
by semicolons.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc227">8.3.17</A>  <TT>admit
</TT><A NAME="@default540"></A><A NAME="@tactic50"></A><TT>
</TT><A NAME="admit"></A></H3><P>The <TT>admit</TT> tactic &#X201C;solves&#X201D; the current subgoal by an
axiom. This typically allows to temporarily skip a subgoal so as to
progress further in the rest of the proof. To know if some proof still
relies on unproved subgoals, one can use the command <TT>Print
Assumptions</TT> (see Section <A HREF="Reference-Manual009.html#PrintAssumptions">6.3.5</A>). Admitted subgoals
have names of the form <I><FONT COLOR=maroon>ident</FONT></I><TT>_admitted</TT> possibly followed
by a number.</P><H3 CLASS="subsection"><A NAME="htoc228">8.3.18</A>  <TT>constr_eq </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="@default541"></A><A NAME="@tactic51"></A><TT>
</TT><A NAME="constreq"></A></H3><P>This tactic applies to any goal. It checks whether its arguments are
equal modulo alpha conversion and casts.</P><P><BR>
<B>Error message: </B><TT>Not equal</TT><A NAME="@error80"></A></P><H3 CLASS="subsection"><A NAME="htoc229">8.3.19</A>  <TT>is_evar </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default542"></A><A NAME="@tactic52"></A><TT>
</TT><A NAME="isevar"></A></H3><P>This tactic applies to any goal. It checks whether its argument is an
existential variable. Existential variables are uninstantiated
variables generated by e.g. <TT>eapply</TT> (see Section <A HREF="#apply">8.3.6</A>).</P><P><BR>
<B>Error message: </B><TT>Not an evar</TT><A NAME="@error81"></A></P><H3 CLASS="subsection"><A NAME="htoc230">8.3.20</A>  <TT>has_evar </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default543"></A><A NAME="@tactic53"></A><TT>
</TT><A NAME="hasevar"></A></H3><P>This tactic applies to any goal. It checks whether its argument has an
existential variable as a subterm. Unlike <TT>context</TT> patterns
combined with <TT>is_evar</TT>, this tactic scans all subterms,
including those under binders.</P><P><BR>
<B>Error message: </B><TT>No evars</TT><A NAME="@error82"></A></P><H3 CLASS="subsection"><A NAME="htoc231">8.3.21</A>  <TT>is_var </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default544"></A><A NAME="@tactic54"></A><TT>
</TT><A NAME="isvar"></A></H3><P>This tactic applies to any goal. It checks whether its argument is a
variable or hypothesis in the current goal context or in the opened sections.</P><P><BR>
<B>Error message: </B><TT>Not a variable or hypothesis</TT><A NAME="@error83"></A></P><H3 CLASS="subsection"><A NAME="htoc232">8.3.22</A>  Bindings list
<A NAME="@default545"></A>
<A NAME="Binding-list"></A></H3><P>Tactics that take a term as argument may also support a bindings list, so
as to instantiate some parameters of the term by name or position.
The general form of a term equipped with a bindings list is <I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I> where <I><FONT COLOR=maroon>bindings_list</FONT></I> may be of two
different forms:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
In a bindings list of the form <TT>(</TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT>1</TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>)
&#X2026; (</TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)</TT>, <I><FONT COLOR=maroon>ref</FONT></I> is either an <I><FONT COLOR=maroon>ident</FONT></I> or a
<I><FONT COLOR=maroon>num</FONT></I>. The references are determined according to the type of
<I><FONT COLOR=maroon>term</FONT></I>. If <I><FONT COLOR=maroon>ref</FONT></I><SUB><I>i</I></SUB> is an identifier, this identifier has to be
bound in the type of <I><FONT COLOR=maroon>term</FONT></I> and the binding provides the tactic
with an instance for the parameter of this name. If <I><FONT COLOR=maroon>ref</FONT></I><SUB><I>i</I></SUB> is
some number <I>n</I>, this number denotes the <I>n</I>-th non dependent
premise of the <I><FONT COLOR=maroon>term</FONT></I>, as determined by the type of <I><FONT COLOR=maroon>term</FONT></I>.<P><BR>
<B>Error message: </B><TT>No such binder</TT><A NAME="@error84"></A></P></LI><LI CLASS="li-itemize">A bindings list can also be a simple list of terms <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>. In that case the references to
which these terms correspond are determined by the tactic. In case
of <TT>induction</TT>, <TT>destruct</TT>, <TT>elim</TT> and <TT>case</TT> (see
Section <A HREF="#elim">11</A>) the terms have to provide instances for all the
dependent products in the type of <I><FONT COLOR=maroon>term</FONT></I> while in the case of <TT>apply</TT>, or of <TT>constructor</TT> and its variants, only instances for
the dependent products which are not bound in the conclusion of the
type are required.<P><BR>
<B>Error message: </B><TT>Not the right number of missing arguments</TT><A NAME="@error85"></A>
</P></LI></UL><H3 CLASS="subsection"><A NAME="htoc233">8.3.23</A>  Occurrences sets and occurrences clauses</H3><P>
<A NAME="Occurrences clauses"></A>
<A NAME="@default546"></A></P><P>An occurrences clause is a modifier to some tactics that obeys the
following syntax:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>occurrence_clause</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><TT>in</TT> <I><FONT COLOR=maroon>goal_occurrences</FONT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>goal_occurrences</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>at_occurrences</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>,</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&#X2026; <TT>,</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>at_occurrences</FONT></I><I><FONT COLOR=maroon>]</FONT></I><I><FONT COLOR=maroon>]</FONT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>[</FONT></I><TT>|-</TT> <I><FONT COLOR=maroon>[</FONT></I><TT>*</TT> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>at_occurrences</FONT></I><I><FONT COLOR=maroon>]</FONT></I><I><FONT COLOR=maroon>]</FONT></I><I><FONT COLOR=maroon>]</FONT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP> <TT>*</TT> <TT>|-</TT> <I><FONT COLOR=maroon>[</FONT></I><TT>*</TT> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>at_occurrences</FONT></I><I><FONT COLOR=maroon>]</FONT></I><I><FONT COLOR=maroon>]</FONT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP> <TT>*</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>at_occurrences</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><TT>at</TT> <I><FONT COLOR=maroon>occurrences</FONT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>occurrences</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>[</FONT></I><TT>-</TT><I><FONT COLOR=maroon>]</FONT></I> <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I></SUB></TD></TR>
</TABLE><P>The role of an occurrence clause is to select a set of occurrences of
a <I><FONT COLOR=maroon>term</FONT></I> in a goal. In the first case, the <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB>
<I><FONT COLOR=maroon>[</FONT></I><TT>at</TT> <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP><I>i</I></SUP> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I><SUB><I>i</I></SUB></SUB><SUP><I>i</I></SUP><I><FONT COLOR=maroon>]</FONT></I> parts
indicate that occurrences have to be selected in the hypotheses named
<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB>. If no numbers are given for hypothesis <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB>,
then all occurrences of <I><FONT COLOR=maroon>term</FONT></I> in the hypothesis are selected. If
numbers are given, they refer to occurrences of <I><FONT COLOR=maroon>term</FONT></I> when the term
is printed using option <TT>Set Printing All</TT> (see
Section <A HREF="Reference-Manual004.html#SetPrintingAll">2.9</A>), counting from left to right. In
particular, occurrences of <I><FONT COLOR=maroon>term</FONT></I> in implicit arguments (see
Section <A HREF="Reference-Manual004.html#Implicit Arguments">2.7</A>) or coercions (see
Section <A HREF="Reference-Manual004.html#Coercions">2.8</A>) are counted.</P><P>If a minus sign is given between <TT>at</TT> and the list of occurrences,
it negates the condition so that the clause denotes all the occurrences except
the ones explicitly mentioned after the minus sign.</P><P>As an exception to the left-to-right order, the occurrences in the
<TT>return</TT> subexpression of a <TT>match</TT> are considered <EM>before</EM> the occurrences in the matched term.</P><P>In the second case, the <TT>*</TT> on the left of <TT>|-</TT> means that
all occurrences of <I><FONT COLOR=maroon>term</FONT></I> are selected in every hypothesis.</P><P>In the first and second case, if <TT>*</TT> is mentioned on the right of
<TT>|-</TT>, the occurrences of the conclusion of the goal have to be
selected. If some numbers are given, then only the occurrences denoted
by these numbers are selected. In no numbers are given, all
occurrences of <I><FONT COLOR=maroon>term</FONT></I> in the goal are selected.</P><P>Finally, the last notation is an abbreviation for <TT>* |- *</TT>. Note
also that <TT>|-</TT> is optional in the first case when no <TT>*</TT> is
given.</P><P>Here are some tactics that understand occurrences clauses:
<TT>set</TT>, <TT>remember</TT>, <TT>induction</TT>, <TT>destruct</TT>.</P><P><BR>
<B>See also: </B> Sections <A HREF="#tactic:set">8.3.7</A>, <A HREF="#Tac-induction">8.7</A>, <A HREF="Reference-Manual004.html#SetPrintingAll">2.9</A>.</P><H2 CLASS="section"><A NAME="toc54"></A><A NAME="htoc234">8.4</A>  Negation and contradiction</H2><H3 CLASS="subsection"><A NAME="htoc235">8.4.1</A>  <TT>absurd </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default547"></A><A NAME="@tactic55"></A><TT>
</TT><A NAME="absurd"></A></H3><P>This tactic applies to any goal. The argument <I><FONT COLOR=maroon>term</FONT></I> is any
proposition <TT>P</TT> of type <TT>Prop</TT>. This tactic applies <TT>False</TT> elimination, that is it deduces the current goal from <TT>False</TT>, and generates as subgoals <TT>&#X223C;</TT><TT>P</TT> and <TT>P</TT>. It is
very useful in proofs by cases, where some cases are impossible. In
most cases, <TT>P</TT> or &#X223C;<TT>P</TT> is one of the hypotheses of
the local context.</P><H3 CLASS="subsection"><A NAME="htoc236">8.4.2</A>  <TT>contradiction
</TT><A NAME="contradiction"></A><TT>
</TT><A NAME="@default548"></A><A NAME="@tactic56"></A></H3><P>This tactic applies to any goal. The <TT>contradiction</TT> tactic
attempts to find in the current context (after all <TT>intros</TT>) one
hypothesis which is equivalent to <TT>False</TT>. It permits to prune 
irrelevant cases. This tactic is a macro for the tactics sequence 
<TT>intros; elimtype False; assumption</TT>. </P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>No such assumption</TT><A NAME="@error86"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>contradiction </TT><I><FONT COLOR=maroon>ident</FONT></I><P>The proof of <TT>False</TT> is searched in the hypothesis named <I><FONT COLOR=maroon>ident</FONT></I>.
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc237">8.4.3</A>  <TT>contradict </TT><I><FONT COLOR=maroon>ident</FONT></I></H3><P>
<A NAME="contradict"></A>
<A NAME="@default549"></A><A NAME="@tactic57"></A></P><P>This tactic allows to manipulate negated hypothesis and goals. The
name <I><FONT COLOR=maroon>ident</FONT></I> should correspond to a hypothesis. With 
<TT>contradict H</TT>, the current goal and context is transformed in
the following way: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>H:</TT><TT>¬</TT><TT>A </TT><TT>&#X22A2;</TT><TT> B</TT>  becomes  <TT>&#X22A2;</TT><TT> A</TT>
</LI><LI CLASS="li-itemize"><TT>H:</TT><TT>¬</TT><TT>A </TT><TT>&#X22A2;</TT><TT> </TT><TT>¬</TT><TT>B</TT>   becomes  <TT>H: B </TT><TT>&#X22A2;</TT><TT> A </TT>
</LI><LI CLASS="li-itemize"><TT>H: A </TT><TT>&#X22A2;</TT><TT> B</TT>  becomes  <TT>&#X22A2;</TT><TT> </TT><TT>¬</TT><TT>A</TT>
</LI><LI CLASS="li-itemize"><TT>H: A </TT><TT>&#X22A2;</TT><TT> </TT><TT>¬</TT><TT>B</TT>  becomes  <TT>H: B </TT><TT>&#X22A2;</TT><TT> </TT><TT>¬</TT><TT>A</TT>
</LI></UL><H3 CLASS="subsection"><A NAME="htoc238">8.4.4</A>  <TT>exfalso</TT></H3><P>
<A NAME="exfalso"></A>
<A NAME="@default550"></A><A NAME="@tactic58"></A></P><P>This tactic implements the &#X201C;ex falso quodlibet&#X201D; logical principle:
an elimination of <TT>False</TT> is performed on the current goal, and the
user is then required to prove that <TT>False</TT> is indeed provable in
the current context. This tactic is a macro for <TT>elimtype False</TT>.</P><H2 CLASS="section"><A NAME="toc55"></A><A NAME="htoc239">8.5</A>  Conversion tactics
<A NAME="@default551"></A>
<A NAME="Conversion-tactics"></A></H2><P>This set of tactics implements different specialized usages of the
tactic <TT>change</TT>.</P><P>All conversion tactics (including <TT>change</TT>) can be
parameterized by the parts of the goal where the conversion can
occur. This is done using <EM>goal clauses</EM> which consists in a list
of hypotheses and, optionally, of a reference to the conclusion of the
goal. For defined hypothesis it is possible to specify if the
conversion should occur on the type part, the body part or both
(default).</P><P><A NAME="@default552"></A>
<A NAME="@default553"></A>
Goal clauses are written after a conversion tactic (tactics
<TT>set</TT> <A HREF="#tactic:set">8.3.7</A>, <TT>rewrite</TT> <A HREF="#rewrite">8.8.1</A>,
<TT>replace</TT> <A HREF="#tactic:replace">8.8.3</A> and
<TT>autorewrite</TT> <A HREF="#tactic:autorewrite">8.12.13</A> also use goal clauses) and
are introduced by the keyword <TT>in</TT>. If no goal clause is provided,
the default is to perform the conversion only in the conclusion.</P><P>The syntax and description of the various goal clauses is the following:
</P><DL CLASS="description"><DT CLASS="dt-description">
</DT><DD CLASS="dd-description"><TT>in </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> |- </TT> only in hypotheses <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>
&#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>
</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><TT>in </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> |- *</TT> in hypotheses <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> and in the conclusion
</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><TT>in * |-</TT> in every hypothesis
</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><TT>in *</TT> (equivalent to <TT>in * |- *</TT>) everywhere
</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><TT>in (type of </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>) (value of </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>) </TT><TT>&#X2026;</TT><TT> |-</TT> in
type part of <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>, in the value part of <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB>, etc. 
</DD></DL><P>For backward compatibility, the notation <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>
performs the conversion in hypotheses <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>.</P><H3 CLASS="subsection"><A NAME="htoc240">8.5.1</A>  <TT>cbv </TT><I><FONT COLOR=maroon>flag</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>flag</FONT></I><SUB><TT><I>n</I></TT></SUB>, <TT>lazy </TT><I><FONT COLOR=maroon>flag</FONT></I><SUB><TT>1</TT></SUB><TT>
&#X2026; </TT><I><FONT COLOR=maroon>flag</FONT></I><SUB><TT><I>n</I></TT></SUB> and <TT>compute</TT>
<A NAME="@default554"></A><A NAME="@tactic59"></A>
<A NAME="@default555"></A><A NAME="@tactic60"></A>
<A NAME="@default556"></A><A NAME="@tactic61"></A>
<A NAME="@default557"></A><A NAME="@tactic62"></A><A NAME="vmcompute"></A></H3><P>These parameterized reduction tactics apply to any goal and perform
the normalization of the goal according to the specified flags. In
correspondence with the kinds of reduction considered in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  namely
&#X3B2; (reduction of functional application), &#X3B4; (unfolding of
transparent constants, see <A HREF="Reference-Manual009.html#Transparent">6.10.2</A>), &#X3B9; (reduction of
pattern-matching over a constructed term, and unfolding of <TT>fix</TT>
and <TT>cofix</TT> expressions) and &#X3B6; (contraction of local
definitions), the flag are either <TT>beta</TT>, <TT>delta</TT>, <TT>iota</TT>
or <TT>zeta</TT>. The <TT>delta</TT> flag itself can be refined into <TT>delta [</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT> or <TT>delta
-[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT>, restricting in the first case the
constants to unfold to the constants listed, and restricting in the
second case the constant to unfold to all but the ones explicitly
mentioned. Notice that the <TT>delta</TT> flag does not apply to
variables bound by a let-in construction inside the term itself (use
here the <TT>zeta</TT> flag). In any cases, opaque constants are not
unfolded (see Section <A HREF="Reference-Manual009.html#Opaque">6.10.1</A>).</P><P>The goal may be normalized with two strategies: <EM>lazy</EM> (<TT>lazy</TT>
tactic), or <EM>call-by-value</EM> (<TT>cbv</TT> tactic). The lazy strategy
is a call-by-need strategy, with sharing of reductions: the arguments of a
function call are partially evaluated only when necessary, and if an
argument is used several times then it is computed only once. This
reduction is efficient for reducing expressions with dead code. For
instance, the proofs of a proposition <TT>exists </TT><TT><I>x</I></TT><TT>. </TT><TT><I>P</I>(<I>x</I>)</TT> reduce to a
pair of a witness <I>t</I>, and a proof that <I>t</I> satisfies the predicate
<I>P</I>. Most of the time, <I>t</I> may be computed without computing the proof
of <I>P</I>(<I>t</I>), thanks to the lazy strategy.</P><P>The call-by-value strategy is the one used in ML languages: the
arguments of a function call are evaluated first, using a weak
reduction (no reduction under the &#X3BB;-abstractions). Despite the
lazy strategy always performs fewer reductions than the call-by-value
strategy, the latter is generally more efficient for evaluating purely
computational expressions (i.e. with few dead code).</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>compute</TT> <A NAME="@default558"></A><A NAME="@tactic63"></A><BR>
 <TT>cbv</TT><P>These are synonyms for <TT>cbv beta delta iota zeta</TT>.</P></LI><LI CLASS="li-enumerate"><TT>lazy</TT><P>This is a synonym for <TT>lazy beta delta iota zeta</TT>.</P></LI><LI CLASS="li-enumerate"><TT>compute [</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT><BR>
 <TT>cbv [</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT><P>These are synonyms of <TT>cbv beta delta
[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>] iota zeta</TT>.</P></LI><LI CLASS="li-enumerate"><TT>compute -[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT><BR>
 <TT>cbv -[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT><P>These are synonyms of <TT>cbv beta delta
-[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>] iota zeta</TT>.</P></LI><LI CLASS="li-enumerate"><TT>lazy [</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT><BR>
 <TT>lazy -[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT><P>These are respectively synonyms of <TT>cbv beta delta
[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>] iota zeta</TT> and <TT>cbv beta delta
-[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>] iota zeta</TT>.</P></LI><LI CLASS="li-enumerate"><TT>vm_compute</TT> <A NAME="@default559"></A><A NAME="@tactic64"></A><P>This tactic evaluates the goal using the optimized call-by-value
evaluation bytecode-based virtual machine. This algorithm is
dramatically more efficient than the algorithm used for the <TT>cbv</TT> tactic, but it cannot be fine-tuned. It is specially
interesting for full evaluation of algebraic objects. This includes
the case of reflexion-based tactics.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc241">8.5.2</A>  <TT>red</TT>
<A NAME="@default560"></A><A NAME="@tactic65"></A></H3><P>This tactic applies to a goal which has the form <TT>forall (x:T1)&#X2026;(xk:Tk), c t1 &#X2026; tn</TT> where <TT>c</TT> is a constant. If
<TT>c</TT> is transparent then it replaces <TT>c</TT> with its definition
(say <TT>t</TT>) and then reduces <TT>(t t1 &#X2026; tn)</TT> according to
&#X3B2;&#X3B9;&#X3B6;-reduction rules.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not reducible</TT><A NAME="@error87"></A>
</LI></OL><H3 CLASS="subsection"><A NAME="htoc242">8.5.3</A>  <TT>hnf</TT>
<A NAME="@default561"></A><A NAME="@tactic66"></A></H3><P>This tactic applies to any goal. It replaces the current goal with its
head normal form according to the &#X3B2;&#X3B4;&#X3B9;&#X3B6;-reduction
rules, i.e. it reduces the head of the goal until it becomes a
product or an irreducible term.</P><P><BR>
<B>Example: </B>The term <CODE>forall n:nat, (plus (S n) (S n))</CODE> is not reduced by <TT>hnf</TT>.</P><P><BR>
<B>Remark: </B>The &#X3B4; rule only applies to transparent constants
(see Section <A HREF="Reference-Manual009.html#Opaque">6.10.1</A> on transparency and opacity).</P><H3 CLASS="subsection"><A NAME="htoc243">8.5.4</A>  <TT>simpl
</TT><A NAME="@default562"></A><A NAME="@tactic67"></A></H3><P>This tactic applies to any goal. The tactic <TT>simpl</TT> first applies
&#X3B2;&#X3B9;-reduction rule. Then it expands transparent constants
and tries to reduce <TT>T&#X2019;</TT> according, once more, to &#X3B2;&#X3B9;
rules. But when the &#X3B9; rule is not applicable then possible
&#X3B4;-reductions are not applied. For instance trying to use <TT>simpl</TT> on <TT>(plus n O)=n</TT> changes nothing. Notice that only
transparent constants whose name can be reused as such in the
recursive calls are possibly unfolded. For instance a constant defined
by <TT>plus&#X2019; := plus</TT> is possibly unfolded and reused in the
recursive calls, but a constant such as <TT>succ := plus (S O)</TT> is
never unfolded.</P><P><A NAME="@default563"></A><A NAME="@tactic68"></A>
<BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>simpl </TT><I><FONT COLOR=maroon>term</FONT></I><P>This applies <TT>simpl</TT> only to the occurrences of <I><FONT COLOR=maroon>term</FONT></I> in the
current goal.</P></LI><LI CLASS="li-enumerate"><TT>simpl </TT><I><FONT COLOR=maroon>term</FONT></I><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><P>This applies <TT>simpl</TT> only to the <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB>
occurrences of <I><FONT COLOR=maroon>term</FONT></I> in the current goal.</P><P><BR>
<B>Error message: </B><TT>Too few occurrences</TT></P></LI><LI CLASS="li-enumerate"><TT>simpl </TT><I><FONT COLOR=maroon>ident</FONT></I><P>This applies <TT>simpl</TT> only to the applicative subterms whose head
occurrence is <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>simpl </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><P>This applies <TT>simpl</TT> only to the <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB>
applicative subterms whose head occurrence is <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc244">8.5.5</A>  <TT>unfold </TT><I><FONT COLOR=maroon>qualid</FONT></I><A NAME="@default564"></A><A NAME="@tactic69"></A><TT>
</TT><A NAME="unfold"></A></H3><P>This tactic applies to any goal. The argument <I><FONT COLOR=maroon>qualid</FONT></I> must denote a
defined transparent constant or local definition (see Sections <A HREF="Reference-Manual003.html#Basic-definitions">1.3.2</A> and <A HREF="Reference-Manual009.html#Transparent">6.10.2</A>). The tactic <TT>unfold</TT> applies the &#X3B4; rule to each occurrence of the constant
to which <I><FONT COLOR=maroon>qualid</FONT></I> refers in the current goal and then replaces it
with its &#X3B2;&#X3B9;-normal form.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<I><FONT COLOR=maroon>qualid</FONT></I> <TT>does not denote an evaluable constant</TT><A NAME="@error88"></A></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>unfold </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>, &#X2026;, </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>n</I></TT></SUB>
<A NAME="@default565"></A><A NAME="@tactic70"></A><P>Replaces <EM>simultaneously</EM> <I><FONT COLOR=maroon>qualid</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>qualid</FONT></I><SUB><I>n</I></SUB>
with their definitions and replaces the current goal with its
&#X3B2;&#X3B9; normal form.</P></LI><LI CLASS="li-enumerate"><TT>unfold </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><SUP><TT>1</TT></SUP><TT>, &#X2026;, </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><SUP><TT>1</TT></SUP><TT>,
&#X2026;, </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><SUP><TT><I>n</I></TT></SUP><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>j</I></TT></SUB><SUP><TT><I>n</I></TT></SUP><P>The lists <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP>1</SUP>, &#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB><SUP>1</SUP> and <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP><I>n</I></SUP>, &#X2026;,
<I><FONT COLOR=maroon>num</FONT></I><SUB><I>j</I></SUB><SUP><I>n</I></SUP> specify the occurrences of <I><FONT COLOR=maroon>qualid</FONT></I><SUB>1</SUB>, &#X2026;,
<I><FONT COLOR=maroon>qualid</FONT></I><SUB><I>n</I></SUB> to be unfolded. Occurrences are located from left to
right.</P><P><BR>
<B>Error message: </B><TT>bad occurrence number of </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>i</I></TT></SUB></P><P><BR>
<B>Error message: </B><I><FONT COLOR=maroon>qualid</FONT></I><SUB><I>i</I></SUB> <TT>does not occur</TT></P></LI><LI CLASS="li-enumerate"><TT>unfold </TT><I><FONT COLOR=maroon>string</FONT></I><P>If <I><FONT COLOR=maroon>string</FONT></I> denotes the discriminating symbol of a notation (e.g. <TT>"+"</TT>) or an expression defining a notation (e.g. <CODE>"_ + _"</CODE>), and
this notation refers to an unfoldable constant, then the tactic
unfolds it.</P></LI><LI CLASS="li-enumerate"><TT>unfold </TT><I><FONT COLOR=maroon>string</FONT></I><TT>%</TT><I><FONT COLOR=maroon>key</FONT></I><P>This is variant of <TT>unfold </TT><I><FONT COLOR=maroon>string</FONT></I> where <I><FONT COLOR=maroon>string</FONT></I> gets its
interpretation from the scope bound to the delimiting key
<I><FONT COLOR=maroon>key</FONT></I> instead of its default interpretation (see
Section <A HREF="Reference-Manual015.html#scopechange">12.2.2</A>).</P></LI><LI CLASS="li-enumerate"><TT>unfold </TT><I><FONT COLOR=maroon>qualid_or_string</FONT></I><SUB><TT>1</TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><SUP><TT>1</TT></SUP><TT>, &#X2026;, </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><SUP><TT>1</TT></SUP><TT>,
&#X2026;, </TT><I><FONT COLOR=maroon>qualid_or_string</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><SUP><TT><I>n</I></TT></SUP><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>j</I></TT></SUB><SUP><TT><I>n</I></TT></SUP><P>This is the most general form, where <I><FONT COLOR=maroon>qualid_or_string</FONT></I> is either a
<I><FONT COLOR=maroon>qualid</FONT></I> or a <I><FONT COLOR=maroon>string</FONT></I> referring to a notation.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc245">8.5.6</A>  <TT>fold</TT> <I><FONT COLOR=maroon>term</FONT></I><A NAME="@default566"></A><A NAME="@tactic71"></A></H3><P>This tactic applies to any goal. The term <I><FONT COLOR=maroon>term</FONT></I> is reduced using the <TT>red</TT>
tactic. Every occurrence of the resulting term in the goal is then
replaced by <I><FONT COLOR=maroon>term</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>fold</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> <P>Equivalent to <TT>fold</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>;</TT>&#X2026;<TT>; fold</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB>.
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc246">8.5.7</A>  <TT>pattern </TT><I><FONT COLOR=maroon>term</FONT></I>
<A NAME="@default567"></A><A NAME="@tactic72"></A>
<A NAME="pattern"></A></H3><P>This command applies to any goal. The argument <I><FONT COLOR=maroon>term</FONT></I> must be a free
subterm of the current goal. The command <TT>pattern</TT> performs
&#X3B2;-expansion (the inverse of &#X3B2;-reduction) of the current goal
(say <TT>T</TT>) by
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
replacing all occurrences of <I><FONT COLOR=maroon>term</FONT></I> in <TT>T</TT> with a fresh variable
</LI><LI CLASS="li-enumerate">abstracting this variable
</LI><LI CLASS="li-enumerate">applying the abstracted goal to <I><FONT COLOR=maroon>term</FONT></I>
</LI></OL><P>For instance, if the current goal <I>T</I> is expressible has &#X3C6;(<I>t</I>)
where the notation captures all the instances of <I>t</I> in &#X3C6;(<I>t</I>),
then <TT>pattern </TT><TT><I>t</I></TT> transforms it into <TT>(fun x:</TT><TT><I>A</I></TT><TT> =&gt; </TT><TT>&#X3C6;(</TT><TT>x</TT><TT>)</TT><TT>) </TT><TT><I>t</I></TT>. This command can be used, for instance, when the tactic
<TT>apply</TT> fails on matching.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>pattern </TT><I><FONT COLOR=maroon>term</FONT></I><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>n</I></TT></SUB><P>Only the occurrences <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I></SUB> of <I><FONT COLOR=maroon>term</FONT></I> are
considered for &#X3B2;-expansion. Occurrences are located from left
to right.</P></LI><LI CLASS="li-enumerate"><TT>pattern </TT><I><FONT COLOR=maroon>term</FONT></I><TT> at - </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>n</I></TT></SUB><P>All occurrences except the occurrences of indexes <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB> &#X2026;
 <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I></SUB> of <I><FONT COLOR=maroon>term</FONT></I> are considered for
&#X3B2;-expansion. Occurrences are located from left to right.</P></LI><LI CLASS="li-enumerate"><TT>pattern </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>, &#X2026;, </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>m</I></TT></SUB><P>Starting from a goal &#X3C6;(<I>t</I><SUB>1</SUB> &#X2026; <I>t</I><SUB><I>m</I></SUB>), the tactic
<TT>pattern </TT><TT><I>t</I></TT><SUB><TT>1</TT></SUB><TT>, &#X2026;, </TT><TT><I>t</I></TT><SUB><TT><I>m</I></TT></SUB> generates the equivalent goal <TT>(fun (x</TT><SUB><TT>1</TT></SUB><TT>:</TT><TT><I>A</I></TT><SUB><TT>1</TT></SUB><TT>) &#X2026; (x</TT><SUB><TT><I>m</I></TT></SUB><TT>:</TT><TT><I>A</I></TT><SUB><TT><I>m</I></TT></SUB><TT>) =&gt; </TT><TT>&#X3C6;(</TT><TT>x</TT><SUB><TT>1</TT></SUB><TT>&#X2026;
 x</TT><SUB><TT><I>m</I></TT></SUB><TT>)</TT><TT>) </TT><TT><I>t</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><TT><I>t</I></TT><SUB><TT><I>m</I></TT></SUB>.<BR>
If <I>t</I><SUB><I>i</I></SUB> occurs in one of the
generated types <I>A</I><SUB><I>j</I></SUB> these occurrences will also be considered and
possibly abstracted.</P></LI><LI CLASS="li-enumerate"><TT>pattern </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><SUP><TT>1</TT></SUP><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>n</I></TT><SUB><TT>1</TT></SUB></SUB><SUP><TT>1</TT></SUP><TT>, &#X2026;,
</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><SUP><TT><I>m</I></TT></SUP><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>n</I></TT><SUB><TT><I>m</I></TT></SUB></SUB><SUP><TT><I>m</I></TT></SUP><P>This behaves as above but processing only the occurrences <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP>1</SUP>,
&#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB><SUP>1</SUP> of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP><I>m</I></SUP>, &#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB><I>j</I></SUB><SUP><I>m</I></SUP>
of <I><FONT COLOR=maroon>term</FONT></I><SUB><I>m</I></SUB> starting from <I><FONT COLOR=maroon>term</FONT></I><SUB><I>m</I></SUB>.</P></LI><LI CLASS="li-enumerate"><TT>pattern</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>[</FONT></I><TT>at </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>-</TT><TT><I><FONT COLOR=maroon>]</FONT></I></TT> <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP>1</SUP> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I><SUB>1</SUB></SUB><SUP>1</SUP><I><FONT COLOR=maroon>]</FONT></I> <TT>,</TT> &#X2026;<TT>,</TT>
<I><FONT COLOR=maroon>term</FONT></I><SUB><I>m</I></SUB> <I><FONT COLOR=maroon>[</FONT></I><TT>at </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>-</TT><TT><I><FONT COLOR=maroon>]</FONT></I></TT> <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP><I>m</I></SUP> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I><SUB><I>m</I></SUB></SUB><SUP><I>m</I></SUP><I><FONT COLOR=maroon>]</FONT></I><P>This is the most general syntax that combines the different variants.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc247">8.5.8</A>  Conversion tactics applied to hypotheses</H3><P><I><FONT COLOR=maroon>conv_tactic</FONT></I> <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> </P><P>Applies the conversion tactic <I><FONT COLOR=maroon>conv_tactic</FONT></I> to the
hypotheses <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>. The tactic <I><FONT COLOR=maroon>conv_tactic</FONT></I> is
any of the conversion tactics listed in this section. </P><P>If <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> is a local definition, then <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> can be replaced
by (Type of <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB>) to address not the body but the type of the
local definition. Example: <TT>unfold not in (Type of H1) (Type of H3).</TT></P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>No such hypothesis</TT><A NAME="@error89"></A> : <I><FONT COLOR=maroon>ident</FONT></I>.
</LI></OL><H2 CLASS="section"><A NAME="toc56"></A><A NAME="htoc248">8.6</A>  Introductions</H2><P>Introduction tactics address goals which are inductive constants.
They are used when one guesses that the goal can be obtained with one
of its constructors&#X2019; type.</P><H3 CLASS="subsection"><A NAME="htoc249">8.6.1</A>  <TT>constructor </TT><I><FONT COLOR=maroon>num</FONT></I><A NAME="constructor"></A><TT>
</TT><A NAME="@default568"></A><A NAME="@tactic73"></A></H3><P>This tactic applies to a goal such that the head of its conclusion is
an inductive constant (say <TT>I</TT>). The argument <I><FONT COLOR=maroon>num</FONT></I> must be less
or equal to the numbers of constructor(s) of <TT>I</TT>. Let <TT>ci</TT> be
the <TT>i</TT>-th constructor of <TT>I</TT>, then <TT>constructor i</TT> is
equivalent to <TT>intros; apply ci</TT>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not an inductive product</TT><A NAME="@error90"></A>
</LI><LI CLASS="li-enumerate"><TT>Not enough constructors</TT><A NAME="@error91"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>constructor</TT> <P>This tries <TT>constructor 1</TT> then <TT>constructor 2</TT>,
&#X2026; , then <TT>constructor</TT> <I>n</I> where <I>n</I> if
the number of constructors of the head of the goal.</P></LI><LI CLASS="li-enumerate"><TT>constructor </TT><I><FONT COLOR=maroon>num</FONT></I><TT> with</TT> <I><FONT COLOR=maroon>bindings_list</FONT></I><P>Let <TT>ci</TT> be the <TT>i</TT>-th constructor of <TT>I</TT>, then <TT>constructor i with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I> is equivalent to <TT>intros;
apply ci with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I>.</P><P><BR>
<B>Warning: </B>the terms in the <I><FONT COLOR=maroon>bindings_list</FONT></I> are checked
in the context where <TT>constructor</TT> is executed and not in the
context where <TT>apply</TT> is executed (the introductions are not
taken into account).</P></LI><LI CLASS="li-enumerate"><TT>split</TT><A NAME="@default569"></A><A NAME="@tactic74"></A><P>Applies if <TT>I</TT> has only one constructor, typically in the case
of conjunction <I>A</I>&#X2227; <I>B</I>. Then, it is equivalent to <TT>constructor 1</TT>.</P></LI><LI CLASS="li-enumerate"><TT>exists </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><A NAME="@default570"></A><A NAME="@tactic75"></A> <P>Applies if <TT>I</TT> has only one constructor, for instance in the
case of existential quantification &#X2203; <I>x</I>· <I>P</I>(<I>x</I>). 
Then, it is equivalent to <TT>intros; constructor 1 with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>exists </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>This iteratively applies <TT>exists </TT><I><FONT COLOR=maroon>bindings_list</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>left</TT><A NAME="@default571"></A><A NAME="@tactic76"></A><BR>
 <TT>right</TT><A NAME="@default572"></A><A NAME="@tactic77"></A><P>Apply if <TT>I</TT> has two constructors, for instance in the case of
disjunction <I>A</I>&#X2228; <I>B</I>. Then, they are respectively equivalent to <TT>constructor 1</TT> and <TT>constructor 2</TT>.</P></LI><LI CLASS="li-enumerate"><TT>left with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><BR>
 <TT>right with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><BR>
 <TT>split with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>As soon as the inductive type has the right number of constructors,
these expressions are equivalent to calling <TT>constructor </TT><TT><I>i</I></TT><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I> for the appropriate <I>i</I>.</P></LI><LI CLASS="li-enumerate"><TT>econstructor</TT><A NAME="@default573"></A><A NAME="@tactic78"></A><BR>
 <TT>eexists</TT><A NAME="@default574"></A><A NAME="@tactic79"></A><BR>
 <TT>esplit</TT><A NAME="@default575"></A><A NAME="@tactic80"></A><BR>
 <TT>eleft</TT><A NAME="@default576"></A><A NAME="@tactic81"></A><BR>
 <TT>eright</TT><A NAME="@default577"></A><A NAME="@tactic82"></A><BR>

These tactics and their variants behave like <TT>constructor</TT>,
<TT>exists</TT>, <TT>split</TT>, <TT>left</TT>, <TT>right</TT> and
their variants but they introduce existential variables instead of
failing when the instantiation of a variable cannot be found (cf
<TT>eapply</TT> and Section <A HREF="Reference-Manual013.html#eapply-example">10.2</A>).</LI></OL><H2 CLASS="section"><A NAME="toc57"></A><A NAME="htoc250">8.7</A>  Induction and Case Analysis
<A NAME="Tac-induction"></A></H2><P>The tactics presented in this section implement induction or case
analysis on inductive or coinductive objects (see
Section <A HREF="Reference-Manual006.html#Cic-inductive-definitions">4.5</A>).</P><H3 CLASS="subsection"><A NAME="htoc251">8.7.1</A>  <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default578"></A><A NAME="@tactic83"></A></H3><P>This tactic applies to any goal. The type of the argument <I><FONT COLOR=maroon>term</FONT></I> must
be an inductive constant. Then, the tactic <TT>induction</TT>
generates subgoals, one for each possible form of <I><FONT COLOR=maroon>term</FONT></I>, i.e. one
for each constructor of the inductive type.</P><P>The tactic <TT>induction</TT> automatically replaces every occurrences
of <I><FONT COLOR=maroon>term</FONT></I> in the conclusion and the hypotheses of the goal. It
automatically adds induction hypotheses (using names of the form <TT>IHn1</TT>) to the local context. If some hypothesis must not be taken
into account in the induction hypothesis, then it needs to be removed
first (you can also use the tactics <TT>elim</TT> or <TT>simple induction</TT>,
see below).</P><P>There are particular cases:</P><UL CLASS="itemize"><LI CLASS="li-itemize">If <I><FONT COLOR=maroon>term</FONT></I> is an identifier <I><FONT COLOR=maroon>ident</FONT></I> denoting a quantified
variable of the conclusion of the goal, then <TT>induction </TT><I><FONT COLOR=maroon>ident</FONT></I>
behaves as <TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; induction </TT><I><FONT COLOR=maroon>ident</FONT></I>.</LI><LI CLASS="li-itemize">If <I><FONT COLOR=maroon>term</FONT></I> is a <I><FONT COLOR=maroon>num</FONT></I>, then <TT>induction </TT><I><FONT COLOR=maroon>num</FONT></I> behaves as
<TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> followed by <TT>induction</TT> applied to the
last introduced hypothesis.<P><BR>
<B>Remark: </B>For simple induction on a numeral, use syntax <TT>induction
(</TT><I><FONT COLOR=maroon>num</FONT></I><TT>)</TT> (not very interesting anyway).</P></LI></UL><P><BR>
<B>Example: </B></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma induction_test : forall n:nat, n = n -</TT><TT>&gt;</TT><TT> n </TT><TT>&lt;</TT><TT>= n.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, n = n -</I></TT><TT><I>&gt;</I></TT><TT><I> n </I></TT><TT><I>&lt;</I></TT><TT><I>= n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros n H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : n = n</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   n </I></TT><TT><I>&lt;</I></TT><TT><I>= n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> induction n.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : 0 = 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 </I></TT><TT><I>&lt;</I></TT><TT><I>= 0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> S n </I></TT><TT><I>&lt;</I></TT><TT><I>= S n</I></TT><BR>
</DIV><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not an inductive product</TT><A NAME="@error92"></A>
</LI><LI CLASS="li-enumerate"><TT>Unable to find an instance for the variables
</TT><I><FONT COLOR=maroon>ident</FONT></I><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@error93"></A><P>Use in this case 
the variant <TT>elim &#X2026; with &#X2026;</TT> below.
</P></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><P>This behaves as <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I> but uses the names in
<I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I> to name the variables introduced in the context.
The <I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I> must typically be of the form
<TT>[</TT> <I>p</I><SUB>11</SUB> &#X2026;<I>p</I><SUB>1<I>n</I><SUB>1</SUB></SUB> <TT>|</TT> &#X2026; <TT>|</TT> <I>p</I><SUB><I>m</I>1</SUB> &#X2026;<I>p</I><SUB><I>mn</I><SUB><I>m</I></SUB></SUB> <TT>]</TT> with <I>m</I> being the number of constructors of the type of
<I><FONT COLOR=maroon>term</FONT></I>. Each variable introduced by <TT>induction</TT> in the context
of the <I>i</I><SUP><I>th</I></SUP> goal gets its name from the list <I>p</I><SUB><I>i</I>1</SUB> &#X2026;<I>p</I><SUB><I>in</I><SUB><I>i</I></SUB></SUB> in order. If there are not enough names, <TT>induction</TT>
invents names for the remaining variables to introduce. More
generally, the <I>p</I><SUB><I>ij</I></SUB> can be any disjunctive/conjunctive
introduction pattern (see Section <A HREF="#intros-pattern">8.7.3</A>). For instance,
for an inductive type with one constructor, the pattern notation
<TT>(</TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT>,&#X2026;,</TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT> can be used instead of
<TT>[</TT> <I>p</I><SUB>1</SUB> &#X2026;<I>p</I><SUB><I>n</I></SUB> <TT>]</TT>.</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>naming_intro_pattern</FONT></I><P>This behaves as <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I> but adds an equation between
<I><FONT COLOR=maroon>term</FONT></I> and the value that <I><FONT COLOR=maroon>term</FONT></I> takes in each of the induction
case. The name of the equation is built according to
<I><FONT COLOR=maroon>naming_intro_pattern</FONT></I> which can be an identifier, a &#X201C;?&#X201D;, etc, as
indicated in Section <A HREF="#intros-pattern">8.7.3</A>.</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>naming_intro_pattern</FONT></I><TT> </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><P>This combines the two previous forms.</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>This behaves like <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I> providing explicit
instances for the premises of the type of <I><FONT COLOR=maroon>term</FONT></I> (see the syntax of
bindings in Section <A HREF="#Binding-list">8.3.22</A>).</P></LI><LI CLASS="li-enumerate"><TT>einduction </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default579"></A><A NAME="@tactic84"></A><P>This tactic behaves like <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I> excepts that it
does not fail if some dependent premise of the type of <I><FONT COLOR=maroon>term</FONT></I> is
not inferable. Instead, the unresolved premises are posed as
existential variables to be inferred later, in the same way as <TT>eapply</TT> does (see Section <A HREF="Reference-Manual013.html#eapply-example">10.2</A>).</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><P>This behaves as <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB> but using <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> as
induction scheme. It does not expect the conclusion of the type of
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> to be inductive.</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>This behaves as <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> but
also providing instances for the premises of the type of <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>.</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> using </TT><I><FONT COLOR=maroon>qualid</FONT></I><P>This syntax is used for the case <I><FONT COLOR=maroon>qualid</FONT></I> denotes an induction principle
with complex predicates as the induction principles generated by
<TT>Function</TT> or <TT>Functional Scheme</TT> may be.</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I><P>This syntax is used for selecting which occurrences of <I><FONT COLOR=maroon>term</FONT></I> the
induction has to be carried on. The <TT>in </TT><I><FONT COLOR=maroon>at_occurrences</FONT></I> clause is an
occurrence clause whose syntax and behavior is described in
Section <A HREF="#Occurrences clauses">8.3.23</A>.</P><P>When an occurrence clause is given, an equation between <I><FONT COLOR=maroon>term</FONT></I> and
the value it gets in each case of the induction is added to the
context of the subgoals corresponding to the induction cases (even
if no clause <TT>as </TT><I><FONT COLOR=maroon>naming_intro_pattern</FONT></I> is given).</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>1</TT></SUB><TT> as </TT><I><FONT COLOR=maroon>naming_intro_pattern</FONT></I><TT> </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>2</TT></SUB><TT> in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I><BR>
 <TT>einduction </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>1</TT></SUB><TT> as </TT><I><FONT COLOR=maroon>naming_intro_pattern</FONT></I><TT> </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>2</TT></SUB><TT> in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I><P>These are the most general forms of <TT>induction</TT> and <TT>einduction</TT>. It combines the effects of the <TT>with</TT>, <TT>as</TT>,
<TT>using</TT>, and <TT>in</TT> clauses.</P></LI><LI CLASS="li-enumerate"><TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="elim"></A><P>This is a more basic induction tactic. Again, the type of the
argument <I><FONT COLOR=maroon>term</FONT></I> must be an inductive type. Then, according to
the type of the goal, the tactic <TT>elim</TT> chooses the appropriate
destructor and applies it as the tactic <TT>apply</TT>
would do. For instance, if the proof context contains <TT>n:nat</TT> and the current goal is <TT>T</TT> of type <TT>Prop</TT>, then <TT>elim n</TT> is equivalent to <TT>apply nat_ind with
(n:=n)</TT>. The tactic <TT>elim</TT> does not modify the context of
the goal, neither introduces the induction loading into the context
of hypotheses.</P><P>More generally, <TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I> also works when the type of <I><FONT COLOR=maroon>term</FONT></I>
is a statement with premises and whose conclusion is inductive. In
that case the tactic performs induction on the conclusion of the
type of <I><FONT COLOR=maroon>term</FONT></I> and leaves the non-dependent premises of the type as
subgoals. In the case of dependent products, the tactic tries to
find an instance for which the elimination lemma applies and fails
otherwise.</P></LI><LI CLASS="li-enumerate"><TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>Allows to give explicit instances to the premises of the type
of <I><FONT COLOR=maroon>term</FONT></I> (see Section <A HREF="#Binding-list">8.3.22</A>).</P></LI><LI CLASS="li-enumerate"><TT>eelim </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default580"></A><A NAME="@tactic85"></A><P>In case the type of <I><FONT COLOR=maroon>term</FONT></I> has dependent premises, this turns them into
existential variables to be resolved later on.</P></LI><LI CLASS="li-enumerate"><TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><BR>
 <TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><A NAME="@default581"></A><A NAME="@tactic86"></A><P>Allows the user to give explicitly an elimination predicate
<I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> which is not the standard one for the underlying inductive
type of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>. The <I><FONT COLOR=maroon>bindings_list</FONT></I> clause allows to
instantiate premises of the type of <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>.</P></LI><LI CLASS="li-enumerate"><TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>2</TT></SUB><BR>
 <TT>eelim </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>2</TT></SUB><P>These are the most general forms of <TT>elim</TT> and <TT>eelim</TT>. It
combines the effects of the <TT>using</TT> clause and of the two uses
of the <TT>with</TT> clause.</P></LI><LI CLASS="li-enumerate"><TT>elimtype </TT><I><FONT COLOR=maroon>form</FONT></I><A NAME="@default582"></A><A NAME="@tactic87"></A><P>The argument <I><FONT COLOR=maroon>form</FONT></I> must be inductively defined. <TT>elimtype I</TT>
is equivalent to <TT>cut I. intro H</TT><I><FONT COLOR=maroon>n</FONT></I><TT>; elim H</TT><I><FONT COLOR=maroon>n</FONT></I><TT>;
clear H</TT><I><FONT COLOR=maroon>n</FONT></I>. Therefore the hypothesis <TT>H</TT><I><FONT COLOR=maroon>n</FONT></I> will
not appear in the context(s) of the subgoal(s). Conversely, if <TT>t</TT> is a term of (inductive) type <TT>I</TT> and which does not occur
in the goal then <TT>elim t</TT> is equivalent to <TT>elimtype I; 2:
exact t.</TT></P></LI><LI CLASS="li-enumerate"><TT>simple induction </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default583"></A><A NAME="@tactic88"></A><P>This tactic behaves as <TT>intros until
</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; elim </TT><I><FONT COLOR=maroon>ident</FONT></I> when <I><FONT COLOR=maroon>ident</FONT></I> is a quantified
variable of the goal.</P></LI><LI CLASS="li-enumerate"><TT>simple induction </TT><I><FONT COLOR=maroon>num</FONT></I><P>This tactic behaves as <TT>intros until
</TT><I><FONT COLOR=maroon>num</FONT></I><TT>; elim </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the name given by
<TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> to the <I><FONT COLOR=maroon>num</FONT></I>-th non-dependent premise of
the goal.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc252">8.7.2</A>  <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default584"></A><A NAME="@tactic89"></A></H3><P>
<A NAME="destruct"></A></P><P>The tactic <TT>destruct</TT> is used to perform case analysis without
recursion. Its behavior is similar to <TT>induction</TT> except
that no induction hypothesis is generated. It applies to any goal and
the type of <I><FONT COLOR=maroon>term</FONT></I> must be inductively defined. There are particular cases:</P><UL CLASS="itemize"><LI CLASS="li-itemize">If <I><FONT COLOR=maroon>term</FONT></I> is an identifier <I><FONT COLOR=maroon>ident</FONT></I> denoting a quantified
variable of the conclusion of the goal, then <TT>destruct </TT><I><FONT COLOR=maroon>ident</FONT></I>
behaves as <TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; destruct </TT><I><FONT COLOR=maroon>ident</FONT></I>.</LI><LI CLASS="li-itemize">If <I><FONT COLOR=maroon>term</FONT></I> is a <I><FONT COLOR=maroon>num</FONT></I>, then <TT>destruct </TT><I><FONT COLOR=maroon>num</FONT></I> behaves as
<TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> followed by <TT>destruct</TT> applied to the
last introduced hypothesis.<P><BR>
<B>Remark: </B>For destruction of a numeral, use syntax <TT>destruct
(</TT><I><FONT COLOR=maroon>num</FONT></I><TT>)</TT> (not very interesting anyway).</P></LI></UL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><P>This behaves as <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I> but uses the names in
<I><FONT COLOR=maroon>intro_pattern</FONT></I> to name the variables introduced in the context.
The <I><FONT COLOR=maroon>intro_pattern</FONT></I> must have the form <TT>[</TT> <I>p</I><SUB>11</SUB> &#X2026;<I>p</I><SUB>1<I>n</I><SUB>1</SUB></SUB> <TT>|</TT> &#X2026; <TT>|</TT> <I>p</I><SUB><I>m</I>1</SUB> &#X2026;<I>p</I><SUB><I>mn</I><SUB><I>m</I></SUB></SUB> <TT>]</TT> with <I>m</I> being the number of constructors of the type of
<I><FONT COLOR=maroon>term</FONT></I>. Each variable introduced by <TT>destruct</TT> in the context
of the <I>i</I><SUP><I>th</I></SUP> goal gets its name from the list <I>p</I><SUB><I>i</I>1</SUB> &#X2026;<I>p</I><SUB><I>in</I><SUB><I>i</I></SUB></SUB> in order. If there are not enough names, <TT>destruct</TT>
invents names for the remaining variables to introduce. More
generally, the <I>p</I><SUB><I>ij</I></SUB> can be any disjunctive/conjunctive
introduction pattern (see Section <A HREF="#intros-pattern">8.7.3</A>). This
provides a concise notation for nested destruction.</P></LI><LI CLASS="li-enumerate"><TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><TT> _eqn</TT><P>This behaves as <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I> but adds an equation between
<I><FONT COLOR=maroon>term</FONT></I> and the value that <I><FONT COLOR=maroon>term</FONT></I> takes in each of the possible
cases. The name of the equation is chosen by Coq. If 
<I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I> is simply <TT>[]</TT>, it is automatically considered
as a disjunctive pattern of the appropriate size.</P></LI><LI CLASS="li-enumerate"><TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><TT> _eqn: </TT><I><FONT COLOR=maroon>naming_intro_pattern</FONT></I><P>This behaves as <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as
</TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><TT> _eqn</TT> but use <I><FONT COLOR=maroon>naming_intro_pattern</FONT></I> to
name the equation (see Section <A HREF="#intros-pattern">8.7.3</A>). Note that spaces 
can generally be removed around <TT>_eqn</TT>.</P></LI><LI CLASS="li-enumerate"><TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>This behaves like <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I> providing explicit
instances for the dependent premises of the type of <I><FONT COLOR=maroon>term</FONT></I> (see
syntax of bindings in Section <A HREF="#Binding-list">8.3.22</A>).</P></LI><LI CLASS="li-enumerate"><TT>edestruct </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default585"></A><A NAME="@tactic90"></A><P>This tactic behaves like <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I> excepts that it
does not fail if the instance of a dependent premises of the type of
<I><FONT COLOR=maroon>term</FONT></I> is not inferable. Instead, the unresolved instances are left
as existential variables to be inferred later, in the same way as
<TT>eapply</TT> does (see Section <A HREF="Reference-Manual013.html#eapply-example">10.2</A>).</P></LI><LI CLASS="li-enumerate"><TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><BR>
 <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>These are synonyms of <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> and
<TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I><P>This syntax is used for selecting which occurrences of <I><FONT COLOR=maroon>term</FONT></I> the
case analysis has to be done on. The <TT>in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I> clause is an
occurrence clause whose syntax and behavior is described in
Section <A HREF="#Occurrences clauses">8.3.23</A>.</P><P>When an occurrence clause is given, an equation between <I><FONT COLOR=maroon>term</FONT></I> and
the value it gets in each case of the analysis is added to the
context of the subgoals corresponding to the cases (even
if no clause <TT>as </TT><I><FONT COLOR=maroon>naming_intro_pattern</FONT></I> is given).</P></LI><LI CLASS="li-enumerate"><TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>1</TT></SUB><TT> as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><TT> _eqn: </TT><I><FONT COLOR=maroon>naming_intro_pattern</FONT></I><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>2</TT></SUB><TT> in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I><BR>
 <TT>edestruct </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>1</TT></SUB><TT> as </TT><I><FONT COLOR=maroon>disj_conj_intro_pattern</FONT></I><TT> _eqn: </TT><I><FONT COLOR=maroon>naming_intro_pattern</FONT></I><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><SUB><TT>2</TT></SUB><TT> in </TT><I><FONT COLOR=maroon>goal_occurrences</FONT></I><P>These are the general forms of <TT>destruct</TT> and <TT>edestruct</TT>.
They combine the effects of the <TT>with</TT>, <TT>as</TT>, <TT>using</TT>,
and <TT>in</TT> clauses.</P></LI><LI CLASS="li-enumerate"><TT>case </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="case"></A><A NAME="@default586"></A><A NAME="@tactic91"></A><P>The tactic <TT>case</TT> is a more basic tactic to perform case
analysis without recursion. It behaves as <TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I> but using
a case-analysis elimination principle and not a recursive one.</P></LI><LI CLASS="li-enumerate"><TT>case_eq </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="case_eq"></A><A NAME="@default587"></A><A NAME="@tactic92"></A><P>The tactic <TT>case_eq</TT> is a variant of the <TT>case</TT> tactic that
allow to perform case analysis on a term without completely
forgetting its original form. This is done by generating equalities
between the original form of the term and the outcomes of the case
analysis. The effect of this tactic is similar to the effect of <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in |- *</TT> with the exception that no new hypotheses 
are introduced in the context.</P></LI><LI CLASS="li-enumerate"><TT>case </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>Analogous to <TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I> above.</P></LI><LI CLASS="li-enumerate"><TT>ecase </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default588"></A><A NAME="@tactic93"></A><BR>
 <TT>ecase </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>In case the type of <I><FONT COLOR=maroon>term</FONT></I> has dependent premises, or dependent
premises whose values are not inferable from the <TT>with
</TT><I><FONT COLOR=maroon>bindings_list</FONT></I> clause, <TT>ecase</TT> turns them into existential
variables to be resolved later on.</P></LI><LI CLASS="li-enumerate"><TT>simple destruct </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default589"></A><A NAME="@tactic94"></A><P>This tactic behaves as <TT>intros until
</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; case </TT><I><FONT COLOR=maroon>ident</FONT></I> when <I><FONT COLOR=maroon>ident</FONT></I> is a quantified
variable of the goal.</P></LI><LI CLASS="li-enumerate"><TT>simple destruct </TT><I><FONT COLOR=maroon>num</FONT></I><P>This tactic behaves as <TT>intros until
</TT><I><FONT COLOR=maroon>num</FONT></I><TT>; case </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the name given by
<TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> to the <I><FONT COLOR=maroon>num</FONT></I>-th non-dependent premise of
the goal.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc253">8.7.3</A>  <TT>intros </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><TT>
</TT><A NAME="intros-pattern"></A><TT>
</TT><A NAME="@default590"></A><A NAME="@tactic95"></A></H3><P>
<A NAME="@default591"></A>
<A NAME="@default592"></A>
<A NAME="@default593"></A></P><P>This extension of the tactic <TT>intros</TT> combines introduction of
variables or hypotheses and case analysis. An <EM>introduction pattern</EM> is
either:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
A <EM>naming introduction pattern</EM>, i.e. either one of:
<UL CLASS="itemize"><LI CLASS="li-itemize">
the pattern <TT>?</TT>
</LI><LI CLASS="li-itemize">the pattern <TT>?</TT><I><FONT COLOR=maroon>ident</FONT></I>
</LI><LI CLASS="li-itemize">an identifier
</LI></UL>
</LI><LI CLASS="li-itemize">A <EM>disjunctive/conjunctive introduction pattern</EM>, i.e. either one of:
<UL CLASS="itemize"><LI CLASS="li-itemize">
a disjunction of lists of patterns:
<TT>[</TT><TT><I>p</I></TT><SUB><TT>11</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT><I>p</I></TT><SUB><TT>1<I>m</I></TT><SUB><TT>1</TT></SUB></SUB><TT> | </TT><TT>&#X2026;</TT><TT> | </TT><TT><I>p</I></TT><SUB><TT>11</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT><I>p</I></TT><SUB><TT><I>nm</I></TT><SUB><TT><I>n</I></TT></SUB></SUB><TT>]</TT>
</LI><LI CLASS="li-itemize">a conjunction of patterns: <TT>(</TT> <I>p</I><SUB>1</SUB> <TT>,</TT> &#X2026; <TT>,</TT> <I>p</I><SUB><I>n</I></SUB> <TT>)</TT>
</LI><LI CLASS="li-itemize">a list of patterns <TT>(</TT> <I>p</I><SUB>1</SUB> <TT>&amp;</TT> &#X2026; <TT>&amp;</TT> <I>p</I><SUB><I>n</I></SUB> <TT>)</TT>
for sequence of right-associative binary constructs
</LI></UL>
</LI><LI CLASS="li-itemize">the wildcard: <TT>_</TT>
</LI><LI CLASS="li-itemize">the rewriting orientations: <TT>-&gt;</TT> or <TT>&lt;-</TT>
</LI></UL><P>Assuming a goal of type <TT><I>Q</I></TT><TT> -&gt; </TT><TT><I>P</I></TT> (non dependent product), or
of type <TT>forall </TT><TT><I>x</I></TT><TT>:</TT><TT><I>T</I></TT><TT>, </TT><TT><I>P</I></TT> (dependent product), the behavior of
<TT>intros </TT><TT><I>p</I></TT> is defined inductively over the structure of the
introduction pattern <I>p</I>:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
introduction on <TT>?</TT> performs the introduction, and lets <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
choose a fresh name for the variable;
</LI><LI CLASS="li-itemize">introduction on <TT>?</TT><I><FONT COLOR=maroon>ident</FONT></I> performs the introduction, and
lets <SPAN STYLE="font-variant:small-caps">Coq</SPAN> choose a fresh name for the variable based on <I><FONT COLOR=maroon>ident</FONT></I>;
</LI><LI CLASS="li-itemize">introduction on <I><FONT COLOR=maroon>ident</FONT></I> behaves as described in
Section <A HREF="#intro">8.3.5</A>;
</LI><LI CLASS="li-itemize">introduction over a disjunction of list of patterns <TT>[</TT><TT><I>p</I></TT><SUB><TT>11</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT><I>p</I></TT><SUB><TT>1<I>m</I></TT><SUB><TT>1</TT></SUB></SUB><TT> | </TT><TT>&#X2026;</TT><TT> | </TT><TT><I>p</I></TT><SUB><TT>11</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT>
</TT><TT><I>p</I></TT><SUB><TT><I>nm</I></TT><SUB><TT><I>n</I></TT></SUB></SUB><TT>]</TT> expects the product to be over an inductive type
whose number of constructors is <I>n</I> (or more generally over a type
of conclusion an inductive type built from <I>n</I> constructors,
e.g. <TT>C -&gt; A</TT><TT>\</TT><TT>/B if </TT><TT><I>n</I>=2</TT>): it destructs the introduced
hypothesis as <TT>destruct</TT> (see Section <A HREF="#destruct">8.7.2</A>) would and
applies on each generated subgoal the corresponding tactic;
<TT>intros</TT> <I>p</I><SUB><I>i</I>1</SUB> &#X2026; <I>p</I><SUB><I>im</I><SUB><I>i</I></SUB></SUB>; if the disjunctive
pattern is part of a sequence of patterns and is not the last
pattern of the sequence, then <SPAN STYLE="font-variant:small-caps">Coq</SPAN> completes the pattern so as all
the argument of the constructors of the inductive type are
introduced (for instance, the list of patterns <TT>[</TT><TT> </TT><TT>|</TT><TT> </TT><TT>] H</TT>
applied on goal <TT>forall x:nat, x=0 -&gt; 0=x</TT> behaves the same as
the list of patterns <TT>[</TT><TT> </TT><TT>|</TT><TT> </TT><TT>?</TT><TT> </TT><TT>] H</TT>);
</LI><LI CLASS="li-itemize">introduction over a conjunction of patterns <TT>(</TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT>, &#X2026;,
</TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT> expects the goal to be a product over an inductive type <I>I</I> with a
single constructor that itself has at least <I>n</I> arguments: it
performs a case analysis over the hypothesis, as <TT>destruct</TT>
would, and applies the patterns <I>p</I><SUB>1</SUB> &#X2026; <I>p</I><SUB><I>n</I></SUB> to the arguments
of the constructor of <I>I</I> (observe that <TT>(</TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT>, </TT><TT>&#X2026;</TT><TT>,
</TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT> is an alternative notation for <TT>[</TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT>
</TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT>]</TT>);
</LI><LI CLASS="li-itemize">introduction via <TT>( </TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT> &amp; &#X2026;&amp; </TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT> )</TT>
is a shortcut for introduction via
<TT>(</TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT>,(&#X2026;,(&#X2026;,</TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)&#X2026;))</TT>; it expects the
hypothesis to be a sequence of right-associative binary inductive 
constructors such as <TT>conj</TT> or <TT>ex_intro</TT>; for instance, an
hypothesis with type <TT>A</TT><CODE><TT>/\</TT></CODE><TT>exists x, B</TT><CODE><TT>/\</TT></CODE><TT>C</TT><CODE><TT>/\</TT></CODE><TT>D</TT> can be
introduced via pattern <TT>(a &amp; x &amp; b &amp; c &amp; d)</TT>;
</LI><LI CLASS="li-itemize">introduction on the wildcard depends on whether the product is
dependent or not: in the non dependent case, it erases the
corresponding hypothesis (i.e. it behaves as an <TT>intro</TT> followed
by a <TT>clear</TT>, cf Section <A HREF="#clear">8.3.2</A>) while in the dependent
case, it succeeds and erases the variable only if the wildcard is
part of a more complex list of introduction patterns that also
erases the hypotheses depending on this variable;
</LI><LI CLASS="li-itemize">introduction over <TT>-&gt;</TT> (respectively <TT>&lt;-</TT>) expects the
hypothesis to be an equality and the right-hand-side (respectively
the left-hand-side) is replaced by the left-hand-side (respectively
the right-hand-side) in both the conclusion and the context of the goal;
if moreover the term to substitute is a variable, the hypothesis is
removed.
</LI></UL><P><BR>
<B>Remark: </B><TT>intros </TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026; <I>p</I></TT><SUB><TT><I>n</I></TT></SUB> is not equivalent to <TT>intros
</TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT>;&#X2026;; intros </TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB> for the following reasons:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
A wildcard pattern never succeeds when applied isolated on a
dependent product, while it succeeds as part of a list of
introduction patterns if the hypotheses that depends on it are
erased too.
</LI><LI CLASS="li-itemize">A disjunctive or conjunctive pattern followed by an introduction
pattern forces the introduction in the context of all arguments of
the constructors before applying the next pattern while a terminal
disjunctive or conjunctive pattern does not. Here is an example<DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall n:nat, n = 0 -</TT><TT>&gt;</TT><TT> n = 0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, n = 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> n = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros [ | ] H.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : 0 = 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 = 0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> S n = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Show 2.</TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : S n = 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   S n = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Undo.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, n = 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> n = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros [ | ]; intros H.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : 0 = 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 = 0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> S H = 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> S H = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Show 2.</TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   S H = 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> S H = 0</I></TT><BR>
</DIV></LI></UL><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma intros_test : forall A B C:Prop, A </TT><TT>\</TT><TT>/ B /</TT><TT>\</TT><TT> C -</TT><TT>&gt;</TT><TT> (A -</TT><TT>&gt;</TT><TT> C) -</TT><TT>&gt;</TT><TT> C.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B C : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ B /</I></TT><TT><I>\</I></TT><TT><I> C -</I></TT><TT><I>&gt;</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> C) -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros A B C [a| [_ c]] f.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  a : A</I></TT><BR>
<TT><I>  f : A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply (f a).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  c : C</I></TT><BR>
<TT><I>  f : A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> exact c.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros A B C [a| (_, c)] f.</I></TT><BR>
<TT><I> apply (f a).</I></TT><BR>
<TT><I> </I></TT><BR>
<TT><I> exact c.</I></TT><BR>
<TT><I> </I></TT><BR>
<TT><I>intros_test is defined</I></TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc254">8.7.4</A>  <TT>double induction </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB></H3><P>
This tactic is deprecated and should be replaced by <TT>induction </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>; induction </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB> (or <TT>induction </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>; destruct </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB> depending on the exact needs).</P><P><BR>
<B>Variant: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>double induction </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>2</TT></SUB><P>This tactic is deprecated and should be replaced by <TT>induction
</TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT>; induction </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>3</TT></SUB> where <I><FONT COLOR=maroon>num</FONT></I><SUB>3</SUB> is the result of
<I><FONT COLOR=maroon>num</FONT></I><SUB>2</SUB>-<I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc255">8.7.5</A>  <TT>dependent induction </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default594"></A><A NAME="@tactic96"></A><TT>
</TT><A NAME="DepInduction"></A></H3><P>The <EM>experimental</EM> tactic <TT>dependent induction</TT> performs
induction-inversion on an instantiated inductive predicate.
One needs to first require the <TT>Coq.Program.Equality</TT> module to use
this tactic. The tactic is based on the BasicElim tactic by Conor
McBride [<A HREF="biblio.html#DBLP:conf/types/McBride00">98</A>] and the work of Cristina Cornes
around inversion [<A HREF="biblio.html#DBLP:conf/types/CornesT95">35</A>]. From an instantiated
inductive predicate and a goal it generates an equivalent goal where the
hypothesis has been generalized over its indexes which are then
constrained by equalities to be the right instances. This permits to
state lemmas without resorting to manually adding these equalities and
still get enough information in the proofs. 
A simple example is the following:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma le_minus : forall n:nat, n </TT><TT>&lt;</TT><TT> 1 -</TT><TT>&gt;</TT><TT> n = 0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, n </I></TT><TT><I>&lt;</I></TT><TT><I> 1 -</I></TT><TT><I>&gt;</I></TT><TT><I> n = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros n H ; induction H.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   n = 0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> n = 0</I></TT><BR>
</DIV><P>Here we didn&#X2019;t get any information on the indexes to help fulfill this
proof. The problem is that when we use the <TT>induction</TT> tactic
we lose information on the hypothesis instance, notably that the second
argument is <TT>1</TT> here. Dependent induction solves this problem by
adding the corresponding equality to the context.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Coq.Program.Equality.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma le_minus : forall n:nat, n </TT><TT>&lt;</TT><TT> 1 -</TT><TT>&gt;</TT><TT> n = 0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, n </I></TT><TT><I>&lt;</I></TT><TT><I> 1 -</I></TT><TT><I>&gt;</I></TT><TT><I> n = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros n H ; dependent induction H.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 = 0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> n = 0</I></TT><BR>
</DIV><P>The subgoal is cleaned up as the tactic tries to automatically
simplify the subgoals with respect to the generated equalities.
In this enriched context it becomes possible to solve this subgoal.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> reflexivity.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : S n </I></TT><TT><I>&lt;</I></TT><TT><I>= 0</I></TT><BR>
<TT><I>  IHle : 0 = 1 -</I></TT><TT><I>&gt;</I></TT><TT><I> n = 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   n = 0</I></TT><BR>
</DIV><P>Now we are in a contradictory context and the proof can be solved.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> inversion H.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>This technique works with any inductive predicate.
In fact, the <TT>dependent induction</TT> tactic is just a wrapper around
the <TT>induction</TT> tactic. One can make its own variant by just
writing a new tactic based on the definition found in
<TT>Coq.Program.Equality</TT>. Common useful variants are the following,
defined in the same file:</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>dependent induction </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> generalizing </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><A NAME="@default595"></A><A NAME="@tactic97"></A><P>Does dependent induction on the hypothesis <I><FONT COLOR=maroon>ident</FONT></I> but first
generalizes the goal by the given variables so that they are
universally quantified in the goal. This is generally what one wants
to do with the variables that are inside some constructors in the
induction hypothesis. The other ones need not be further generalized.</P></LI><LI CLASS="li-enumerate"><TT>dependent destruction </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default596"></A><A NAME="@tactic98"></A><P>Does the generalization of the instance <I><FONT COLOR=maroon>ident</FONT></I> but uses <TT>destruct</TT>
instead of <TT>induction</TT> on the generalized hypothesis. This gives
results equivalent to <TT>inversion</TT> or <TT>dependent inversion</TT> if
the hypothesis is dependent.
</P></LI></OL><P>A larger example of dependent induction and an explanation of the
underlying technique are developed in section <A HREF="Reference-Manual013.html#dependent-induction-example">10.6</A>.</P><H3 CLASS="subsection"><A NAME="htoc256">8.7.6</A>  <TT>decompose [ </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> ] </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="decompose"></A><TT>
</TT><A NAME="@default597"></A><A NAME="@tactic99"></A></H3><P>This tactic allows to recursively decompose a
complex proposition in order to obtain atomic ones.
Example: </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma ex1 : forall A B C:Prop, A /</TT><TT>\</TT><TT> B /</TT><TT>\</TT><TT> C </TT><TT>\</TT><TT>/ B /</TT><TT>\</TT><TT> C </TT><TT>\</TT><TT>/ C /</TT><TT>\</TT><TT> A -</TT><TT>&gt;</TT><TT> C.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B C : Prop, A /</I></TT><TT><I>\</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> C </I></TT><TT><I>\</I></TT><TT><I>/ B /</I></TT><TT><I>\</I></TT><TT><I> C </I></TT><TT><I>\</I></TT><TT><I>/ C /</I></TT><TT><I>\</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros A B C H; decompose [and or] H; assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><P><TT>decompose</TT> does not work on right-hand sides of implications or products.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>decompose sum </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default598"></A><A NAME="@tactic100"></A>
This decomposes sum types (like <TT>or</TT>).
</LI><LI CLASS="li-enumerate"><TT>decompose record </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default599"></A><A NAME="@tactic101"></A>
This decomposes record types (inductive types with one constructor,
like <TT>and</TT> and <TT>exists</TT> and those defined with the
<TT>Record</TT> macro, see Section <A HREF="Reference-Manual004.html#Record">2.1</A>).
</LI></OL><H3 CLASS="subsection"><A NAME="htoc257">8.7.7</A>  <TT>functional induction (</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>).
</TT><A NAME="@default600"></A><A NAME="@tactic102"></A><TT>
</TT><A NAME="FunInduction"></A></H3><P>The <EM>experimental</EM> tactic <TT>functional induction</TT> performs
case analysis and induction following the definition of a function. It
makes use of a principle generated by <TT>Function</TT>
(see Section <A HREF="Reference-Manual004.html#Function">2.3</A>) or <TT>Functional Scheme</TT>
(see Section <A HREF="#FunScheme">8.15</A>).</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Functional Scheme minus_ind := Induction for minus Sort Prop.</TT><BR>
<TT><I>minus_equation is defined</I></TT><BR>
<TT><I>minus_ind is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma le_minus : forall n m:nat, (n - m </TT><TT>&lt;</TT><TT>= n).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n m : nat, n - m </I></TT><TT><I>&lt;</I></TT><TT><I>= n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros n m.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   n - m </I></TT><TT><I>&lt;</I></TT><TT><I>= n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> functional induction (minus n m); simpl; auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><P><BR>
<B>Remark: </B><TT>(</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)</TT> must be a correct
full application of <I><FONT COLOR=maroon>qualid</FONT></I>. In particular, the rules for implicit
arguments are the same as usual. For example use <TT>@</TT><I><FONT COLOR=maroon>qualid</FONT></I> if
you want to write implicit arguments explicitly.</P><P><BR>
<B>Remark: </B>Parenthesis over <I><FONT COLOR=maroon>qualid</FONT></I>&#X2026;<I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> are mandatory.</P><P><BR>
<B>Remark: </B><TT>functional induction (f x1 x2 x3)</TT> is actually a wrapper
for <TT>induction x1 x2 x3 (f x1 x2 x3) using </TT><I><FONT COLOR=maroon>qualid</FONT></I> followed by
a cleaning phase, where <I><FONT COLOR=maroon>qualid</FONT></I> is the induction principle
registered for <I>f</I> (by the <TT>Function</TT> (see Section <A HREF="Reference-Manual004.html#Function">2.3</A>)
or <TT>Functional Scheme</TT> (see Section <A HREF="#FunScheme">8.15</A>) command)
corresponding to the sort of the goal. Therefore <TT>functional
induction</TT> may fail if the induction scheme (<I><FONT COLOR=maroon>qualid</FONT></I>) is
not defined. See also Section <A HREF="Reference-Manual004.html#Function">2.3</A> for the function terms
accepted by <TT>Function</TT>.</P><P><BR>
<B>Remark: </B>There is a difference between obtaining an induction scheme for a
function by using <TT>Function</TT> (see Section <A HREF="Reference-Manual004.html#Function">2.3</A>) and by
using <TT>Functional Scheme</TT> after a normal definition using
<TT>Fixpoint</TT> or <TT>Definition</TT>. See <A HREF="Reference-Manual004.html#Function">2.3</A> for
details.</P><P><BR>
<B>See also: </B><A HREF="Reference-Manual004.html#Function">2.3</A>,<A HREF="#FunScheme">8.15</A>,<A HREF="Reference-Manual013.html#FunScheme-examples">10.4</A>,
<A HREF="#sec:functional-inversion">8.10.3</A></P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Cannot find induction information on </TT><I><FONT COLOR=maroon>qualid</FONT></I><A NAME="@error94"></A><P> </P></LI><LI CLASS="li-enumerate"><TT>Not the right number of induction arguments</TT><A NAME="@error95"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>functional induction (</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)
using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>m</I>+1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I>+1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>m</I></TT></SUB><P>Similar to <TT>Induction</TT> and <TT>elim</TT>
(see Section <A HREF="#Tac-induction">8.7</A>), allows to give explicitly the
induction principle and the values of dependent premises of the
elimination scheme, including <EM>predicates</EM> for mutual induction
when <I><FONT COLOR=maroon>qualid</FONT></I> is part of a mutually recursive definition.</P></LI><LI CLASS="li-enumerate"><TT>functional induction (</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)
using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>m</I>+1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT>1</TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I>+1</TT></SUB><TT> &#X2026;
 </TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><P>Similar to <TT>induction</TT> and <TT>elim</TT>
(see Section <A HREF="#Tac-induction">8.7</A>).</P></LI><LI CLASS="li-enumerate">All previous variants can be extended by the usual <TT>as
</TT><I><FONT COLOR=maroon>intro_pattern</FONT></I> construction, similar for example to
<TT>induction</TT> and <TT>elim</TT> (see Section <A HREF="#Tac-induction">8.7</A>).</LI></OL><H2 CLASS="section"><A NAME="toc58"></A><A NAME="htoc258">8.8</A>  Equality</H2><P>These tactics use the equality <TT>eq:forall A:Type, A-&gt;A-&gt;Prop</TT>
defined in file <TT>Logic.v</TT> (see Section <A HREF="Reference-Manual005.html#Equality">3.1.2</A>). The
notation for <TT>eq</TT> <I>T</I> <I>t</I> <I>u</I> is simply <TT><I>t</I></TT><TT>=</TT><TT><I>u</I></TT> dropping the
implicit type of <I>t</I> and <I>u</I>.</P><H3 CLASS="subsection"><A NAME="htoc259">8.8.1</A>  <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="rewrite"></A><TT>
</TT><A NAME="@default601"></A><A NAME="@tactic103"></A></H3><P>This tactic applies to any goal. The type of <I><FONT COLOR=maroon>term</FONT></I>
must have the form</P><P><TT>forall (x</TT><SUB><TT>1</TT></SUB><TT>:A</TT><SUB><TT>1</TT></SUB><TT>) &#X2026; (x</TT><SUB><TT><I>n</I></TT></SUB><TT>:A</TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT><TT>eq</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>. </P><P>where <TT>eq</TT> is the Leibniz equality or a registered
setoid equality.</P><P>Then <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I> finds the first subterm matching
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> in the goal, resulting in instances <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>&#X2032; and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>&#X2032;
and then replaces every occurrence of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>&#X2032; by <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>&#X2032;.
Hence, some of the variables x<SUB><I>i</I></SUB> are
solved by unification, and some of the types <TT>A</TT><SUB>1</SUB>, &#X2026;,
<TT>A</TT><SUB><I>n</I></SUB> become new subgoals.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>The term provided does not end with an equation</TT><A NAME="@error96"></A></LI><LI CLASS="li-enumerate"><TT>Tactic generated a subgoal identical to the original goal</TT><A NAME="@error97"></A><BR>
This happens if <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> does not occur in the goal.
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>rewrite -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default602"></A><A NAME="@tactic104"></A><BR>
 Is equivalent to <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I></LI><LI CLASS="li-enumerate"><TT>rewrite &lt;- </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default603"></A><A NAME="@tactic105"></A><BR>
 Uses the equality <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> from right to left</LI><LI CLASS="li-enumerate"><TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><TT><I>clause</I></TT>
<A NAME="@default604"></A><A NAME="@tactic106"></A><BR>
 Analogous to <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I> but rewriting is done following
<I>clause</I> (similarly to <A HREF="#Conversion-tactics">8.5</A>). For
instance:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>rewrite H in H1</TT> will rewrite <TT>H</TT> in the hypothesis
<TT>H1</TT> instead of the current goal.
</LI><LI CLASS="li-itemize"><TT>rewrite H in H1 at 1, H2 at - 2 |- *</TT> means <TT>rewrite H; rewrite H in H1 at 1;
rewrite H in H2 at - 2</TT>. In particular a failure will happen if any of
these three simpler tactics fails. 
</LI><LI CLASS="li-itemize"><TT>rewrite H in * |- </TT> will do <TT>rewrite H in
H</TT><SUB><TT><I>i</I></TT></SUB> for all hypothesis <TT>H</TT><SUB><TT><I>i</I></TT></SUB><TT> &lt;&gt; H</TT>. A success will happen
as soon as at least one of these simpler tactics succeeds.
</LI><LI CLASS="li-itemize"><TT>rewrite H in *</TT> is a combination of <TT>rewrite H</TT> 
and <TT>rewrite H in * |-</TT> that succeeds if at
least one of these two tactics succeeds. 
</LI></UL>
Orientation <TT>-&gt;</TT> or <TT>&lt;-</TT> can be
inserted before the term to rewrite.</LI><LI CLASS="li-enumerate"><TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><TT> at </TT><I><FONT COLOR=maroon>occurrences</FONT></I>
<A NAME="@default605"></A><A NAME="@tactic107"></A><P>Rewrite only the given occurrences of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>&#X2032;. Occurrences are
specified from left to right as for <TT>pattern</TT> (§<A HREF="#pattern">8.5.7</A>). The rewrite is always performed using setoid
rewriting, even for Leibniz&#X2019;s equality, so one has to 
<TT>Import Setoid</TT> to use this variant.</P></LI><LI CLASS="li-enumerate"><TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I>
<A NAME="@default606"></A><A NAME="@tactic108"></A><P>Use <I><FONT COLOR=maroon>tactic</FONT></I> to completely solve the side-conditions arising from the
rewrite.</P></LI><LI CLASS="li-enumerate"><TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>, &#X2026;, </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><BR>
 Is equivalent to the <I>n</I> successive tactics <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB>
up to <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>, each one working on the first subgoal
generated by the previous one.
Orientation <TT>-&gt;</TT> or <TT>&lt;-</TT> can be
inserted before each term to rewrite. One unique <I>clause</I>
can be added at the end after the keyword <TT>in</TT>; it will 
then affect all rewrite operations.</LI><LI CLASS="li-enumerate">In all forms of <TT>rewrite</TT> described above, a term to rewrite
can be immediately prefixed by one of the following modifiers:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>?</TT> : the tactic <TT>rewrite ?</TT><I><FONT COLOR=maroon>term</FONT></I> performs the
rewrite of <I><FONT COLOR=maroon>term</FONT></I> as many times as possible (perhaps zero time).
This form never fails. 
</LI><LI CLASS="li-itemize"><TT><I>n</I></TT><TT>?</TT> : works similarly, except that it will do at most 
<I>n</I> rewrites. 
</LI><LI CLASS="li-itemize"><TT>!</TT> : works as <TT>?</TT>, except that at least one rewrite 
should succeed, otherwise the tactic fails. 
</LI><LI CLASS="li-itemize"><TT><I>n</I></TT><TT>!</TT> (or simply <TT><I>n</I></TT>) : precisely <I>n</I> rewrites 
of <I><FONT COLOR=maroon>term</FONT></I> will be done, leading to failure if these <I>n</I> rewrites are not possible. 
</LI></UL></LI><LI CLASS="li-enumerate"><TT>erewrite </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default607"></A><A NAME="@tactic109"></A><P>This tactic works as <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I> but turning unresolved
bindings into existential variables, if any, instead of failing. It has
the same variants as <TT>rewrite</TT> has.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc260">8.8.2</A>  <TT>cutrewrite -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> = </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="cutrewrite"></A><TT>
</TT><A NAME="@default608"></A><A NAME="@tactic110"></A></H3><P>This tactic acts like <TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB>
(see below).</P><H3 CLASS="subsection"><A NAME="htoc261">8.8.3</A>  <TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="tactic:replace"></A><TT>
</TT><A NAME="@default609"></A><A NAME="@tactic111"></A></H3><P>This tactic applies to any goal. It replaces all free occurrences of
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> in the current goal with <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> and generates the
equality <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> as a subgoal. This equality is
automatically solved if it occurs amongst the assumption, or if its
symmetric form occurs. It is equivalent to <TT>cut
</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>; [intro H</TT><TT><I><FONT COLOR=maroon>n</FONT></I></TT><TT>; rewrite &lt;- H</TT><TT><I><FONT COLOR=maroon>n</FONT></I></TT><TT>; clear H</TT><TT><I><FONT COLOR=maroon>n</FONT></I></TT><TT>| assumption || symmetry; try assumption]</TT>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>terms do not have convertible types</TT><A NAME="@error98"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><BR>
This acts
as <TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> but applies <I><FONT COLOR=maroon>tactic</FONT></I>
to solve the generated subgoal <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB>.
</LI><LI CLASS="li-enumerate"><TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><BR>
Replace <I><FONT COLOR=maroon>term</FONT></I> with <I><FONT COLOR=maroon>term</FONT></I>&#X2019; using the
first assumption whose type has the form <I><FONT COLOR=maroon>term</FONT></I><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>&#X2019;</TT> or <I><FONT COLOR=maroon>term</FONT></I><TT>&#X2019;=</TT><I><FONT COLOR=maroon>term</FONT></I>
</LI><LI CLASS="li-enumerate"><TT>replace -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><BR>
Replace <I><FONT COLOR=maroon>term</FONT></I> with <I><FONT COLOR=maroon>term</FONT></I>&#X2019; using the
first assumption whose type has the form <I><FONT COLOR=maroon>term</FONT></I><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>&#X2019;</TT>
</LI><LI CLASS="li-enumerate"><TT>replace &lt;- </TT><I><FONT COLOR=maroon>term</FONT></I><BR>
Replace <I><FONT COLOR=maroon>term</FONT></I> with <I><FONT COLOR=maroon>term</FONT></I>&#X2019; using the
first assumption whose type has the form <I><FONT COLOR=maroon>term</FONT></I><TT>&#X2019;=</TT><I><FONT COLOR=maroon>term</FONT></I>
</LI><LI CLASS="li-enumerate"><TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> </TT><TT><I>clause</I></TT><TT> </TT><BR>
 <TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> </TT><TT><I>clause</I></TT><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><BR>
 <TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I>clause</I></TT><BR>
 <TT>replace -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I>clause</I></TT><BR>
 <TT>replace &lt;- </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I>clause</I></TT><BR>
 Act as before but the replacements take place in
<I>clause</I> (see Section <A HREF="#Conversion-tactics">8.5</A>) and not only
in the conclusion of the goal.<BR>
 The <I>clause</I> argument must not contain any <TT>type of</TT> nor <TT>value of</TT>.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc262">8.8.4</A>  <TT>reflexivity
</TT><A NAME="reflexivity"></A><TT>
</TT><A NAME="@default610"></A><A NAME="@tactic112"></A></H3><P>This tactic applies to a goal which has the form <TT>t=u</TT>. It checks
that <TT>t</TT> and <TT>u</TT> are convertible and then solves the goal.
It is equivalent to <TT>apply refl_equal</TT>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>The conclusion is not a substitutive equation</TT><A NAME="@error99"></A>
</LI><LI CLASS="li-enumerate"><TT>Impossible to unify &#X2026; with &#X2026;.</TT><A NAME="@error100"></A>
</LI></OL><H3 CLASS="subsection"><A NAME="htoc263">8.8.5</A>  <TT>symmetry
</TT><A NAME="@default611"></A><A NAME="@tactic113"></A><TT>
</TT><A NAME="@default612"></A><A NAME="@tactic114"></A></H3><P>
This tactic applies to a goal which has the form <TT>t=u</TT> and changes it
into <TT>u=t</TT>.</P><P><BR>
<B>Variant: </B><TT>symmetry in </TT><I><FONT COLOR=maroon>ident</FONT></I><BR>
If the statement of the hypothesis <I><FONT COLOR=maroon>ident</FONT></I> has the form <TT>t=u</TT>,
the tactic changes it to <TT>u=t</TT>.</P><H3 CLASS="subsection"><A NAME="htoc264">8.8.6</A>  <TT>transitivity </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default613"></A><A NAME="@tactic115"></A></H3><P>
This tactic applies to a goal which has the form <TT>t=u</TT>
and transforms it into the two subgoals 
<TT>t=</TT><I><FONT COLOR=maroon>term</FONT></I> and <I><FONT COLOR=maroon>term</FONT></I><TT>=u</TT>.</P><H3 CLASS="subsection"><A NAME="htoc265">8.8.7</A>  <TT>subst </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default614"></A><A NAME="@tactic116"></A></H3><P>This tactic applies to a goal which has <I><FONT COLOR=maroon>ident</FONT></I> in its context and
(at least) one hypothesis, say <TT>H</TT>, of type <I><FONT COLOR=maroon>ident</FONT></I><TT>=t</TT> or <TT>t=</TT><I><FONT COLOR=maroon>ident</FONT></I>. Then it replaces 
<I><FONT COLOR=maroon>ident</FONT></I> by <TT>t</TT> everywhere in the goal (in the hypotheses 
and in the conclusion) and clears <I><FONT COLOR=maroon>ident</FONT></I> and <TT>H</TT> from the context.</P><P><BR>
<B>Remark: </B>When several hypotheses have the form <I><FONT COLOR=maroon>ident</FONT></I><TT>=t</TT> or <TT>t=</TT><I><FONT COLOR=maroon>ident</FONT></I>, the first one is used. </P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>subst </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><BR>
 Is equivalent to <TT>subst </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>; &#X2026;; subst </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB>.
</LI><LI CLASS="li-enumerate"><TT>subst</TT><BR>
 Applies <TT>subst</TT> repeatedly to all identifiers from the context
for which an equality exists.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc266">8.8.8</A>  <TT>stepl </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default615"></A><A NAME="@tactic117"></A></H3><P>This tactic is for chaining rewriting steps. It assumes a goal of the
form &#X201C;<I>R</I> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>&#X201D; where <I>R</I> is a binary relation
and relies on a database of lemmas of the form <TT>forall</TT> <I>x</I> <I>y</I>
<I>z</I>, <I>R</I> <I>x</I> <I>y</I> <TT>-&gt;</TT> <I>eq</I> <I>x</I> <I>z</I> <TT>-&gt;</TT> <I>R</I> <I>z</I> <I>y</I> where <I>eq</I>
is typically a setoid equality. The application of <TT>stepl </TT><I><FONT COLOR=maroon>term</FONT></I>
then replaces the goal by &#X201C;<I>R</I> <I><FONT COLOR=maroon>term</FONT></I> <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>&#X201D; and adds a new
goal stating &#X201C;<I>eq</I> <I><FONT COLOR=maroon>term</FONT></I> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>&#X201D;.</P><P>Lemmas are added to the database using the command 
<A NAME="@default616"></A><A NAME="@command209"></A>
</P><BLOCKQUOTE CLASS="quote">
<TT>Declare Left Step </TT><I><FONT COLOR=maroon>term</FONT></I><TT>.</TT>
</BLOCKQUOTE><P>The tactic is especially useful for parametric setoids which are not
accepted as regular setoids for <TT>rewrite</TT> and <TT>setoid_replace</TT> (see Chapter <A HREF="Reference-Manual031.html#setoid_replace">25</A>).</P><P><A NAME="@default617"></A><A NAME="@tactic118"></A>
<A NAME="@default618"></A><A NAME="@command210"></A>
<BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>stepl </TT><I><FONT COLOR=maroon>term</FONT></I><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><BR>
This applies <TT>stepl </TT><I><FONT COLOR=maroon>term</FONT></I> then applies <I><FONT COLOR=maroon>tactic</FONT></I> to the second goal.</LI><LI CLASS="li-enumerate"><TT>stepr </TT><I><FONT COLOR=maroon>term</FONT></I><BR>
 <TT>stepr </TT><I><FONT COLOR=maroon>term</FONT></I><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><BR>
This behaves as <TT>stepl</TT> but on the right-hand-side of the binary relation.
Lemmas are expected to be of the form
&#X201C;<TT>forall</TT> <I>x</I> <I>y</I>
<I>z</I>, <I>R</I> <I>x</I> <I>y</I> <TT>-&gt;</TT> <I>eq</I> <I>y</I> <I>z</I> <TT>-&gt;</TT> <I>R</I> <I>x</I> <I>z</I>&#X201D;
and are registered using the command
<BLOCKQUOTE CLASS="quote">
<TT>Declare Right Step </TT><I><FONT COLOR=maroon>term</FONT></I><TT>.</TT>
</BLOCKQUOTE>
</LI></OL><H3 CLASS="subsection"><A NAME="htoc267">8.8.9</A>  <TT>f_equal
</TT><A NAME="f-equal"></A><TT>
</TT><A NAME="@default619"></A><A NAME="@tactic119"></A></H3><P>This tactic applies to a goal of the form <I>f</I> <I>a</I><SUB>1</SUB> &#X2026; <I>a</I><SUB><I>n</I></SUB> = <I>f</I>&#X2032;
<I>a</I>&#X2032;<SUB>1</SUB> &#X2026; <I>a</I>&#X2032;<SUB><I>n</I></SUB>. Using <TT>f_equal</TT> on such a goal leads to
subgoals <I>f</I>=<I>f</I>&#X2032; and <I>a</I><SUB>1</SUB>=<I>a</I>&#X2032;<SUB>1</SUB> and so on up to <I>a</I><SUB><I>n</I></SUB>=<I>a</I>&#X2032;<SUB><I>n</I></SUB>. Amongst 
these subgoals, the simple ones (e.g. provable by
reflexivity or congruence) are automatically solved by <TT>f_equal</TT>.</P><H2 CLASS="section"><A NAME="toc59"></A><A NAME="htoc268">8.9</A>  Equality and inductive sets</H2><P>We describe in this section some special purpose tactics dealing with
equality and inductive sets or types. These tactics use the equality
<TT>eq:forall (A:Type), A-&gt;A-&gt;Prop</TT>, simply written with the
infix symbol <TT>=</TT>.</P><H3 CLASS="subsection"><A NAME="htoc269">8.9.1</A>  <TT>decide equality
</TT><A NAME="decideequality"></A><TT>
</TT><A NAME="@default620"></A><A NAME="@tactic120"></A></H3><P>This tactic solves a goal of the form
<TT>forall </TT><TT><I>x</I></TT><TT> </TT><TT><I>y</I></TT><TT>:</TT><TT><I>R</I></TT><TT>, {</TT><TT><I>x</I></TT><TT>=</TT><TT><I>y</I></TT><TT>}+{</TT><CODE><TT>~</TT></CODE><TT><I>x</I></TT><TT>=</TT><TT><I>y</I></TT><TT>}</TT>, where <I>R</I>
is an inductive type such that its constructors do not take proofs or
functions as arguments, nor objects in dependent types.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>decide equality </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> </TT>.<BR>
 Solves a goal of the form <TT>{</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB><TT>}+{</TT><CODE><TT>~</TT></CODE><I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB><TT>}</TT>.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc270">8.9.2</A>  <TT>compare </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="@default621"></A><A NAME="@tactic121"></A></H3><P>This tactic compares two given objects <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> 
of an inductive datatype. If <I>G</I> is the current goal, it leaves the sub-goals
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> <TT>-&gt;</TT> <I>G</I> and <CODE>~</CODE><I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>
<TT>-&gt;</TT> <I>G</I>. The type
of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> must satisfy the same restrictions as in the tactic
<TT>decide equality</TT>.</P><H3 CLASS="subsection"><A NAME="htoc271">8.9.3</A>  <TT>discriminate </TT><I><FONT COLOR=maroon>term</FONT></I><TT>
</TT><A NAME="discriminate"></A><TT>
</TT><A NAME="@default622"></A><A NAME="@tactic122"></A><TT>
</TT><A NAME="@default623"></A><A NAME="@tactic123"></A></H3><P>This tactic proves any goal from an assumption stating that two
structurally different terms of an inductive set are equal. For
example, from <TT>(S (S O))=(S O)</TT> we can derive by absurdity any
proposition.</P><P>The argument <I><FONT COLOR=maroon>term</FONT></I> is assumed to be a proof of a statement
of conclusion <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> = </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> with <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and
<I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> being elements of an inductive set. To build the proof,
the tactic traverses the normal forms<SUP><A NAME="text18" HREF="#note18">4</A></SUP> of
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> looking for a couple of subterms <TT>u</TT>
and <TT>w</TT> (<TT>u</TT> subterm of the normal form of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and
<TT>w</TT> subterm of the normal form of <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>), placed at the same
positions and whose head symbols are two different constructors. If
such a couple of subterms exists, then the proof of the current goal
is completed, otherwise the tactic fails.</P><P><BR>
<B>Remark: </B>The syntax <TT>discriminate </TT><I><FONT COLOR=maroon>ident</FONT></I> can be used to refer to a
hypothesis quantified in the goal. In this case, the quantified
hypothesis whose name is <I><FONT COLOR=maroon>ident</FONT></I> is first introduced in the local
context using <TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>No primitive equality found</TT><A NAME="@error101"></A>
</LI><LI CLASS="li-enumerate"><TT>Not a discriminable equality</TT><A NAME="@error102"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>discriminate</TT> <I><FONT COLOR=maroon>num</FONT></I><P>This does the same thing as <TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> followed by
<TT>discriminate </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the identifier for
the last introduced hypothesis.</P></LI><LI CLASS="li-enumerate"><TT>discriminate</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>with</TT> <I><FONT COLOR=maroon>bindings_list</FONT></I><P>This does the same thing as <TT>discriminate </TT><I><FONT COLOR=maroon>term</FONT></I> but using
the given bindings to instantiate parameters or hypotheses of <I><FONT COLOR=maroon>term</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>ediscriminate</TT> <I><FONT COLOR=maroon>num</FONT></I><BR>
 <TT>ediscriminate</TT> <I><FONT COLOR=maroon>term</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>with</TT> <I><FONT COLOR=maroon>bindings_list</FONT></I><I><FONT COLOR=maroon>]</FONT></I><P>This works the same as <TT>discriminate</TT> but if the type of <I><FONT COLOR=maroon>term</FONT></I>,
or the type of the hypothesis referred to by <I><FONT COLOR=maroon>num</FONT></I>, has uninstantiated
parameters, these parameters are left as existential variables.</P></LI><LI CLASS="li-enumerate"><TT>discriminate</TT><P>This behaves like <TT>discriminate </TT><I><FONT COLOR=maroon>ident</FONT></I> if <I><FONT COLOR=maroon>ident</FONT></I> is the
name of an hypothesis to which <TT>discriminate</TT> is applicable; if
the current goal is of the form <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <TT>&lt;&gt;</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>,
this behaves as <TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; injection </TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<TT>No discriminable equalities</TT><A NAME="@error103"></A><BR>
 occurs when the goal does not verify the expected preconditions.
</LI></OL></LI></OL><H3 CLASS="subsection"><A NAME="htoc272">8.9.4</A>  <TT>injection </TT><I><FONT COLOR=maroon>term</FONT></I><TT>
</TT><A NAME="injection"></A><TT>
</TT><A NAME="@default624"></A><A NAME="@tactic124"></A><TT>
</TT><A NAME="@default625"></A><A NAME="@tactic125"></A></H3><P>The <TT>injection</TT> tactic is based on the fact that constructors of
inductive sets are injections. That means that if <I>c</I> is a constructor
of an inductive set, and if (<I>c</I> <B><I>t</I></B><SUB><B>1</B></SUB>) and (<I>c</I> <B><I>t</I></B><SUB><B>2</B></SUB>) are two
terms that are equal then  <B><I>t</I></B><SUB><B>1</B></SUB> and  <B><I>t</I></B><SUB><B>2</B></SUB> are equal
too.</P><P>If <I><FONT COLOR=maroon>term</FONT></I> is a proof of a statement of conclusion
<I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> = </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB>,
then <TT>injection</TT> applies injectivity as deep as possible to
derive the equality of all the subterms of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>
placed in the same positions. For example, from <TT>(S
(S n))=(S (S (S m))</TT> we may derive <TT>n=(S m)</TT>. To use this
tactic <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> should be elements of an inductive
set and they should be neither explicitly equal, nor structurally
different. We mean by this that, if <TT>n</TT><SUB><TT>1</TT></SUB> and <TT>n</TT><SUB><TT>2</TT></SUB> are
their respective normal forms, then:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>n</TT><SUB><TT>1</TT></SUB> and <TT>n</TT><SUB><TT>2</TT></SUB> should not be syntactically equal,
</LI><LI CLASS="li-itemize">there must not exist any pair of subterms <TT>u</TT> and <TT>w</TT>,
<TT>u</TT> subterm of <TT>n</TT><SUB><TT>1</TT></SUB> and <TT>w</TT> subterm of <TT>n</TT><SUB><TT>2</TT></SUB> ,
placed in the same positions and having different constructors as
head symbols.
</LI></UL><P>
If these conditions are satisfied, then, the tactic derives the
equality of all the subterms of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> placed in
the same positions and puts them as antecedents of the current goal.</P><P><BR>
<B>Example: </B>Consider the following goal:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive list : Set :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | nil : list</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | cons : nat -</TT><TT>&gt;</TT><TT> list -</TT><TT>&gt;</TT><TT> list.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable P : list -</TT><TT>&gt;</TT><TT> Prop.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Show.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  l : list</I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : P nil</I></TT><BR>
<TT><I>  H0 : cons n l = cons 0 nil</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   P l</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> injection H0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  l : list</I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : P nil</I></TT><BR>
<TT><I>  H0 : cons n l = cons 0 nil</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   l = nil -</I></TT><TT><I>&gt;</I></TT><TT><I> n = 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> P l</I></TT><BR>
</DIV><P>Beware that <TT>injection</TT> yields always an equality in a sigma type
whenever the injected object has a dependent type.</P><P><BR>
<B>Remark: </B>There is a special case for dependent pairs. If we have a decidable 
equality over the type of the first argument, then it is safe to do 
the projection on the second one, and so <TT>injection</TT> will work fine.
To define such an equality, you have to use the <TT>Scheme</TT> command 
(see <A HREF="#Scheme">8.14</A>).</P><P><BR>
<B>Remark: </B>If some quantified hypothesis of the goal is named <I><FONT COLOR=maroon>ident</FONT></I>, then
<TT>injection </TT><I><FONT COLOR=maroon>ident</FONT></I> first introduces the hypothesis in the local
context using <TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not a projectable equality but a discriminable one</TT><A NAME="@error104"></A>
</LI><LI CLASS="li-enumerate"><TT>Nothing to do, it is an equality between convertible terms</TT><A NAME="@error105"></A>
</LI><LI CLASS="li-enumerate"><TT>Not a primitive equality</TT><A NAME="@error106"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>injection</TT> <I><FONT COLOR=maroon>num</FONT></I><P>This does the same thing as <TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> followed by
<TT>injection </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the identifier for the last
introduced hypothesis.</P></LI><LI CLASS="li-enumerate"><TT>injection</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>with</TT> <I><FONT COLOR=maroon>bindings_list</FONT></I><P>This does the same as <TT>injection </TT><I><FONT COLOR=maroon>term</FONT></I> but using
the given bindings to instantiate parameters or hypotheses of <I><FONT COLOR=maroon>term</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>einjection</TT> <I><FONT COLOR=maroon>num</FONT></I><BR>
 <TT>einjection</TT> <I><FONT COLOR=maroon>term</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>with</TT> <I><FONT COLOR=maroon>bindings_list</FONT></I><I><FONT COLOR=maroon>]</FONT></I><P>This works the same as <TT>injection</TT> but if the type of <I><FONT COLOR=maroon>term</FONT></I>,
or the type of the hypothesis referred to by <I><FONT COLOR=maroon>num</FONT></I>, has uninstantiated
parameters, these parameters are left as existential variables.</P></LI><LI CLASS="li-enumerate"><TT>injection</TT><P>If the current goal is of the form <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <TT>&lt;&gt;</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>,
this behaves as <TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; injection </TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Error message: </B><TT>goal does not satisfy the expected preconditions</TT><A NAME="@error107"></A></P></LI><LI CLASS="li-enumerate"><TT>injection</TT> <I><FONT COLOR=maroon>term</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>with</TT> <I><FONT COLOR=maroon>bindings_list</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>intro_pattern</FONT></I><BR>
<TT>injection</TT> <I><FONT COLOR=maroon>num</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> &#X2026; <I><FONT COLOR=maroon>intro_pattern</FONT></I><BR>
<TT>injection</TT> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> &#X2026; <I><FONT COLOR=maroon>intro_pattern</FONT></I><BR>
<TT>einjection</TT> <I><FONT COLOR=maroon>term</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>with</TT> <I><FONT COLOR=maroon>bindings_list</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>intro_pattern</FONT></I><BR>
<TT>einjection</TT> <I><FONT COLOR=maroon>num</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> &#X2026; <I><FONT COLOR=maroon>intro_pattern</FONT></I><BR>
<TT>einjection</TT> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> &#X2026; <I><FONT COLOR=maroon>intro_pattern</FONT></I><BR>
<A NAME="@default626"></A><A NAME="@tactic126"></A><P>These variants apply <TT>intros</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>intro_pattern</FONT></I> after
the call to <TT>injection</TT> or <TT>einjection</TT>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc273">8.9.5</A>  <TT>simplify_eq </TT><I><FONT COLOR=maroon>term</FONT></I><TT>
</TT><A NAME="@default627"></A><A NAME="@tactic127"></A><TT>
</TT><A NAME="@default628"></A><A NAME="@tactic128"></A><TT>
</TT><A NAME="simplify-eq"></A></H3><P>Let <I><FONT COLOR=maroon>term</FONT></I> be the proof of a statement of conclusion <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB>. If <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and
<I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> are structurally different (in the sense described for the
tactic <TT>discriminate</TT>), then the tactic <TT>simplify_eq</TT> behaves as <TT>discriminate </TT><I><FONT COLOR=maroon>term</FONT></I>, otherwise it behaves as <TT>injection
</TT><I><FONT COLOR=maroon>term</FONT></I>.</P><P><BR>
<B>Remark: </B>If some quantified hypothesis of the goal is named <I><FONT COLOR=maroon>ident</FONT></I>, then
<TT>simplify_eq </TT><I><FONT COLOR=maroon>ident</FONT></I> first introduces the hypothesis in the local
context using <TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>simplify_eq</TT> <I><FONT COLOR=maroon>num</FONT></I><P>This does the same thing as <TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> then
<TT>simplify_eq </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the identifier for the last
introduced hypothesis.</P></LI><LI CLASS="li-enumerate"><TT>simplify_eq</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>with</TT> <I><FONT COLOR=maroon>bindings_list</FONT></I><P>This does the same as <TT>simplify_eq </TT><I><FONT COLOR=maroon>term</FONT></I> but using
the given bindings to instantiate parameters or hypotheses of <I><FONT COLOR=maroon>term</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>esimplify_eq</TT> <I><FONT COLOR=maroon>num</FONT></I><BR>
 <TT>esimplify_eq</TT> <I><FONT COLOR=maroon>term</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>with</TT> <I><FONT COLOR=maroon>bindings_list</FONT></I><I><FONT COLOR=maroon>]</FONT></I><P>This works the same as <TT>simplify_eq</TT> but if the type of <I><FONT COLOR=maroon>term</FONT></I>,
or the type of the hypothesis referred to by <I><FONT COLOR=maroon>num</FONT></I>, has uninstantiated
parameters, these parameters are left as existential variables.</P></LI><LI CLASS="li-enumerate"><TT>simplify_eq</TT><P>If the current goal has form <I>t</I><SUB>1</SUB><CODE>&lt;&gt;</CODE><I>t</I><SUB>2</SUB>, it behaves as
<TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; simplify_eq </TT><I><FONT COLOR=maroon>ident</FONT></I>.
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc274">8.9.6</A>  <TT>dependent rewrite -&gt; </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default629"></A><A NAME="@tactic129"></A><TT>
</TT><A NAME="dependent-rewrite"></A></H3><P>This tactic applies to any goal. If <I><FONT COLOR=maroon>ident</FONT></I> has type 
<CODE>(existT B a b)=(existT B a' b')</CODE> 
in the local context (i.e. each term of the
equality has a sigma type { <I>a</I>:<I>A</I>  &amp; (<I>B</I> <I>a</I>)}) this tactic rewrites
<CODE>a</CODE> into <CODE>a'</CODE> and <CODE>b</CODE> into <CODE>b'</CODE> in the current
goal. This tactic works even if <I>B</I> is also a sigma type. This kind
of equalities between dependent pairs may be derived by the injection
and inversion tactics.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>dependent rewrite &lt;- </TT><I><FONT COLOR=maroon>ident</FONT></I>
<A NAME="@default630"></A><A NAME="@tactic130"></A><BR>
Analogous to <TT>dependent rewrite -&gt;</TT> but uses the equality from
right to left.
</LI></OL><H2 CLASS="section"><A NAME="toc60"></A><A NAME="htoc275">8.10</A>  Inversion
<A NAME="inversion"></A></H2><H3 CLASS="subsection"><A NAME="htoc276">8.10.1</A>  <TT>inversion </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default631"></A><A NAME="@tactic131"></A></H3><P>Let the type of <I><FONT COLOR=maroon>ident</FONT></I>  in the local context be (<I>I</I> <B><I>t</I></B>),
where <I>I</I> is a (co)inductive predicate. Then,
<TT>inversion</TT> applied to <I><FONT COLOR=maroon>ident</FONT></I>  derives for each possible
constructor <I>c</I><SUB><I>i</I></SUB> of (<I>I</I> <B><I>t</I></B>), <B>all</B> the necessary
conditions that should hold for the instance (<I>I</I> <B><I>t</I></B>) to be
proved by <I>c</I><SUB><I>i</I></SUB>.</P><P><BR>
<B>Remark: </B>If <I><FONT COLOR=maroon>ident</FONT></I> does not denote a hypothesis in the local context
but refers to a hypothesis quantified in the goal, then the
latter is first introduced in the local context using
<TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>inversion</TT> <I><FONT COLOR=maroon>num</FONT></I><P>This does the same thing as <TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> then
<TT>inversion </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the identifier for the
last introduced hypothesis.</P></LI><LI CLASS="li-enumerate"><A NAME="@default632"></A><A NAME="@tactic132"></A> <TT>inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I><P>This behaves as <TT>inversion</TT> and then erases <I><FONT COLOR=maroon>ident</FONT></I>  from the
context.</P></LI><LI CLASS="li-enumerate"><A NAME="@default633"></A><A NAME="@tactic133"></A> <TT>inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I><P>This behaves as <TT>inversion</TT> but using names in
<I><FONT COLOR=maroon>intro_pattern</FONT></I> for naming hypotheses. The <I><FONT COLOR=maroon>intro_pattern</FONT></I> must have
the form <TT>[</TT> <I>p</I><SUB>11</SUB> &#X2026;<I>p</I><SUB>1<I>n</I><SUB>1</SUB></SUB> <TT>|</TT> &#X2026; <TT>|</TT>
<I>p</I><SUB><I>m</I>1</SUB> &#X2026;<I>p</I><SUB><I>mn</I><SUB><I>m</I></SUB></SUB> <TT>]</TT> with <I>m</I> being the number of
constructors of the type of <I><FONT COLOR=maroon>ident</FONT></I>. Be careful that the list must
be of length <I>m</I> even if <TT>inversion</TT> discards some cases (which
is precisely one of its roles): for the discarded cases, just use an
empty list (i.e. <I>n</I><SUB><I>i</I></SUB>=0).</P><P>The arguments of the <I>i</I><SUP><I>th</I></SUP> constructor and the
equalities that <TT>inversion</TT> introduces in the context of the
goal corresponding to the <I>i</I><SUP><I>th</I></SUP> constructor, if it exists, get
their names from the list <I>p</I><SUB><I>i</I>1</SUB> &#X2026;<I>p</I><SUB><I>in</I><SUB><I>i</I></SUB></SUB> in order. If
there are not enough names, <TT>induction</TT> invents names for the
remaining variables to introduce. In case an equation splits into
several equations (because <TT>inversion</TT> applies <TT>injection</TT>
on the equalities it generates), the corresponding name <I>p</I><SUB><I>ij</I></SUB> in
the list must be replaced by a sublist of the form <TT>[</TT><TT><I>p</I></TT><SUB><TT><I>ij</I>1</TT></SUB><TT>
&#X2026;</TT><TT><I>p</I></TT><SUB><TT><I>ijq</I></TT></SUB><TT>]</TT> (or, equivalently, <TT>(</TT><TT><I>p</I></TT><SUB><TT><I>ij</I>1</TT></SUB><TT>,
&#X2026;, </TT><TT><I>p</I></TT><SUB><TT><I>ijq</I></TT></SUB><TT>)</TT>) where <I>q</I> is the number of subequalities
obtained from splitting the original equation. Here is an example.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive contains0 : list nat -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | in_hd : forall l, contains0 (0 :: l)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | in_tl : forall l b, contains0 l -</TT><TT>&gt;</TT><TT> contains0 (b :: l).</TT><BR>
<TT><I>contains0 is defined</I></TT><BR>
<TT><I>contains0_ind is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall l:list nat, contains0 (1 :: l) -</TT><TT>&gt;</TT><TT> contains0 l.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall l : Datatypes.list nat, contains0 (1 :: l) -</I></TT><TT><I>&gt;</I></TT><TT><I> contains0 l</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros l H; inversion H as [ | l&#X2019; p Hl&#X2019; [Heqp Heql&#X2019;] ].</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  l : Datatypes.list nat</I></TT><BR>
<TT><I>  H : contains0 (1 :: l)</I></TT><BR>
<TT><I>  l&#X2019; : Datatypes.list nat</I></TT><BR>
<TT><I>  p : nat</I></TT><BR>
<TT><I>  Hl&#X2019; : contains0 l</I></TT><BR>
<TT><I>  Heqp : p = 1</I></TT><BR>
<TT><I>  Heql&#X2019; : l&#X2019; = l</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   contains0 l</I></TT><BR>
</DIV></LI><LI CLASS="li-enumerate"><TT>inversion</TT> <I><FONT COLOR=maroon>num</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> <P>This allows to name the hypotheses introduced by
<TT>inversion</TT> <I><FONT COLOR=maroon>num</FONT></I> in the context.</P></LI><LI CLASS="li-enumerate"><A NAME="@default634"></A><A NAME="@tactic134"></A> <TT>inversion_clear</TT>
<I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> <P>This allows to name the hypotheses introduced by
<TT>inversion_clear</TT> in the context.</P></LI><LI CLASS="li-enumerate"><A NAME="@default635"></A><A NAME="@tactic135"></A> <TT>inversion </TT> <I><FONT COLOR=maroon>ident</FONT></I>
<TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>Let <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>, be identifiers in the local context. This
tactic behaves as generalizing <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>, and
then performing <TT>inversion</TT>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default636"></A><A NAME="@tactic136"></A> <TT>inversion </TT>
<I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; 
<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>This allows to name the hypotheses introduced in the context by
<TT>inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; 
<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default637"></A><A NAME="@tactic137"></A> <TT>inversion_clear</TT>
<I><FONT COLOR=maroon>ident</FONT></I> <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>Let <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>, be identifiers in the local context. This
tactic behaves as generalizing <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>, and
then performing <TT>inversion_clear</TT>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default638"></A><A NAME="@tactic138"></A>
<TT>inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I>
<TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>This allows to name the hypotheses introduced in the context by
<TT>inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default639"></A><A NAME="@tactic139"></A> <TT>dependent inversion</TT>
<I><FONT COLOR=maroon>ident</FONT></I> <P>That must be used when <I><FONT COLOR=maroon>ident</FONT></I> appears in the current goal. It acts
like <TT>inversion</TT> and then substitutes <I><FONT COLOR=maroon>ident</FONT></I> for the
corresponding term in the goal.</P></LI><LI CLASS="li-enumerate"><A NAME="@default640"></A><A NAME="@tactic140"></A> <TT>dependent
inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> <P>This allows to name the hypotheses introduced in the context by
<TT>dependent inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default641"></A><A NAME="@tactic141"></A> <TT>dependent
inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I> <P>Like <TT>dependent inversion</TT>, except that <I><FONT COLOR=maroon>ident</FONT></I> is cleared
from the local context.</P></LI><LI CLASS="li-enumerate"><A NAME="@default642"></A><A NAME="@tactic142"></A>
<TT>dependent inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I><TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I><P>This allows to name the hypotheses introduced in the context by
<TT>dependent inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default643"></A><A NAME="@tactic143"></A> <TT>dependent
inversion </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I><P>This variant allows you to specify the generalization of the goal. It
is useful when the system fails to generalize the goal automatically. If
<I><FONT COLOR=maroon>ident</FONT></I> has type (<I>I</I> <B><I>t</I></B>) and <I>I</I> has type
<I>forall</I> (<B><I>x</I></B>:<B><I>T</I></B>), <I>s</I>, then <I><FONT COLOR=maroon>term</FONT></I>  must be of type
<I>I</I>:<I>forall</I> (<B><I>x</I></B>:<B><I>T</I></B>), <I>I</I> <B><I>x</I></B>&#X2192; <I>s</I>&#X2032; where <I>s</I>&#X2032; is the
type of the goal.</P></LI><LI CLASS="li-enumerate"><A NAME="@default644"></A><A NAME="@tactic144"></A>
<TT>dependent inversion </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I>
<TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I><P>This allows to name the hypotheses introduced in the context by
<TT>dependent inversion </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default645"></A><A NAME="@tactic145"></A>
<TT>dependent inversion_clear </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I><P>Like <TT>dependent inversion &#X2026; with</TT> but clears <I><FONT COLOR=maroon>ident</FONT></I> from
the local context.</P></LI><LI CLASS="li-enumerate"><A NAME="@default646"></A><A NAME="@tactic146"></A>
<TT>dependent inversion_clear </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT>
<I><FONT COLOR=maroon>intro_pattern</FONT></I> <TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I><P>This allows to name the hypotheses introduced in the context by
<TT>dependent inversion_clear </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default647"></A><A NAME="@tactic147"></A> <TT>simple inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I><P>It is a very primitive inversion tactic that derives all the necessary
equalities but it does not simplify the constraints as
<TT>inversion</TT> does.</P></LI><LI CLASS="li-enumerate"><A NAME="@default648"></A><A NAME="@tactic148"></A> <TT>simple inversion</TT>
<I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> <P>This allows to name the hypotheses introduced in the context by
<TT>simple inversion</TT>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default649"></A><A NAME="@tactic149"></A> <TT>inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I><TT> using</TT> <I><FONT COLOR=maroon>ident</FONT></I>&#X2032; <P>Let <I><FONT COLOR=maroon>ident</FONT></I> have type (<I>I</I> <B><I>t</I></B>) (<I>I</I> an inductive
predicate) in the local context, and <I><FONT COLOR=maroon>ident</FONT></I>&#X2032; be a (dependent) inversion
lemma. Then, this tactic refines the current goal with the specified
lemma.</P></LI><LI CLASS="li-enumerate"><A NAME="@default650"></A><A NAME="@tactic150"></A> <TT>inversion</TT>
<I><FONT COLOR=maroon>ident</FONT></I> <TT>using</TT> <I><FONT COLOR=maroon>ident</FONT></I>&#X2032; <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>This tactic behaves as generalizing <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>,
then doing <TT>inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>using</TT> <I><FONT COLOR=maroon>ident</FONT></I>&#X2032;.</P></LI></OL><P><BR>
<B>See also: </B> <A HREF="Reference-Manual013.html#inversion-examples">10.5</A> for detailed examples</P><H3 CLASS="subsection"><A NAME="htoc277">8.10.2</A>  <TT>Derive Inversion </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> with
</TT><TT><I>forall</I> (</TT><TT><B><I>x</I></B></TT><TT>:</TT><TT><B><I>T</I></B></TT><TT>),</TT><TT> <I>I</I> </TT><TT><B><I>t</I></B></TT><TT> Sort </TT><I><FONT COLOR=maroon>sort</FONT></I><A NAME="Derive-Inversion"></A><TT>
</TT><A NAME="@default651"></A><A NAME="@command211"></A></H3><P>This command generates an inversion principle for the
<TT>inversion &#X2026; using</TT> tactic.
Let <I>I</I> be an inductive predicate and <B><I>x</I></B> the variables
occurring in <B><I>t</I></B>. This command generates and stocks the
inversion lemma for the sort <I><FONT COLOR=maroon>sort</FONT></I>  corresponding to the instance
<I>forall</I> (<B><I>x</I></B>:<B><I>T</I></B>), <I>I</I> <B><I>t</I></B> with the name <I><FONT COLOR=maroon>ident</FONT></I> in the <B>global</B> environment. When applied it is equivalent to have inverted
the instance with the tactic <TT>inversion</TT>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Derive Inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>with</TT>
<A NAME="@default652"></A><A NAME="@command212"></A>
<I>forall</I> (<B><I>x</I></B>:<B><I>T</I></B>), <I>I</I> <B><I>t</I></B> <TT>Sort</TT> <I><FONT COLOR=maroon>sort</FONT></I> <BR>
 <A NAME="@default653"></A>
When applied it is equivalent to having
inverted the instance with the tactic <TT>inversion</TT>
replaced by the tactic <TT>inversion_clear</TT>.
</LI><LI CLASS="li-enumerate"><TT>Derive Dependent Inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>with</TT>
<I>forall</I> (<B><I>x</I></B>:<B><I>T</I></B>), <I>I</I> <B><I>t</I></B> <TT>Sort</TT> <I><FONT COLOR=maroon>sort</FONT></I> <BR>
 <A NAME="@default654"></A><A NAME="@command213"></A>
When applied it is equivalent to having
inverted the instance with the tactic <TT>dependent inversion</TT>.
</LI><LI CLASS="li-enumerate"><TT>Derive Dependent Inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>with</TT>
<I>forall</I> (<B><I>x</I></B>:<B><I>T</I></B>), <I>I</I> <B><I>t</I></B> <TT>Sort</TT> <I><FONT COLOR=maroon>sort</FONT></I> <BR>
 <A NAME="@default655"></A><A NAME="@command214"></A>
When applied it is equivalent to having
inverted the instance with the tactic <TT>dependent inversion_clear</TT>.
</LI></OL><P><BR>
<B>See also: </B><A HREF="Reference-Manual013.html#inversion-examples">10.5</A> for examples</P><H3 CLASS="subsection"><A NAME="htoc278">8.10.3</A>  <TT>functional inversion </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="sec:functional-inversion"></A></H3><P><TT>functional inversion</TT> is a <EM>highly</EM> experimental tactic
which performs inversion on hypothesis <I><FONT COLOR=maroon>ident</FONT></I> of the form
<I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> = </TT><I><FONT COLOR=maroon>term</FONT></I> or <I><FONT COLOR=maroon>term</FONT></I><TT> =
</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> where <I><FONT COLOR=maroon>qualid</FONT></I> must have been
defined using <TT>Function</TT> (see Section <A HREF="Reference-Manual004.html#Function">2.3</A>).</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Hypothesis </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> must contain at least one Function</TT><A NAME="@error108"></A>
</LI><LI CLASS="li-enumerate"><TT>Cannot find inversion information for hypothesis </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@error109"></A>
This error may be raised when some inversion lemma failed to be
generated by Function.
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>functional inversion </TT><I><FONT COLOR=maroon>num</FONT></I><P>This does the same thing as <TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> then
<TT>functional inversion </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the
identifier for the last introduced hypothesis.
</P></LI><LI CLASS="li-enumerate"><TT>functional inversion </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>qualid</FONT></I><BR>
 <TT>functional inversion </TT><I><FONT COLOR=maroon>num</FONT></I><TT> </TT><I><FONT COLOR=maroon>qualid</FONT></I><P>In case the hypothesis <I><FONT COLOR=maroon>ident</FONT></I> (or <I><FONT COLOR=maroon>num</FONT></I>) has a type of the form
<I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> = </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>2</TT></SUB><TT>
 </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I>+1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I>+<I>m</I></TT></SUB> where <I><FONT COLOR=maroon>qualid</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>qualid</FONT></I><SUB>2</SUB>
are valid candidates to functional inversion, this variant allows to
choose which must be inverted.
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc279">8.10.4</A>  <TT>quote </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default656"></A><A NAME="@tactic151"></A><TT>
</TT><A NAME="@default657"></A></H3><P>This kind of inversion has nothing to do with the tactic
<TT>inversion</TT> above. This tactic does <TT>change (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
 t)</TT>, where <TT>t</TT> is a term built in order to ensure the
convertibility. In other words, it does inversion of the function
<I><FONT COLOR=maroon>ident</FONT></I>. This function must be a fixpoint on a simple recursive
datatype: see <A HREF="Reference-Manual013.html#quote-examples">10.8</A> for the full details.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>quote: not a simple fixpoint</TT><A NAME="@error110"></A><BR>
 Happens when <TT>quote</TT> is not able to perform inversion properly.
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>quote </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> [ </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> ]</TT><BR>
 All terms that are built only with <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> will be
considered by <TT>quote</TT> as constants rather than variables.
</LI></OL><H2 CLASS="section"><A NAME="toc61"></A><A NAME="htoc280">8.11</A>  Classical tactics<A NAME="ClassicalTactics"></A></H2><P>In order to ease the proving process, when the <TT>Classical</TT> module is loaded. A few more tactics are available. Make sure to load the module using the <TT>Require Import</TT> command.</P><H3 CLASS="subsection"><A NAME="htoc281">8.11.1</A>  <TT>classical_left, classical_right</TT> <A NAME="@default658"></A><A NAME="@tactic152"></A> <A NAME="@default659"></A><A NAME="@tactic153"></A></H3><P>The tactics <TT>classical_left</TT> and <TT>classical_right</TT> are the analog of the <TT>left</TT> and <TT>right</TT> but using classical logic. They can only be used for disjunctions.
Use <TT>classical_left</TT> to prove the left part of the disjunction with the assumption that the negation of right part holds. 
Use <TT>classical_right</TT> to prove the right part of the disjunction with the assumption that the negation of left part holds. </P><H2 CLASS="section"><A NAME="toc62"></A><A NAME="htoc282">8.12</A>  Automatizing
<A NAME="Automatizing"></A></H2><H3 CLASS="subsection"><A NAME="htoc283">8.12.1</A>  <TT>auto
</TT><A NAME="auto"></A><TT>
</TT><A NAME="@default660"></A><A NAME="@tactic154"></A></H3><P>This tactic implements a Prolog-like resolution procedure to solve the
current goal. It first tries to solve the goal using the <TT>assumption</TT> tactic, then it reduces the goal to an atomic one using
<TT>intros</TT> and introducing the newly generated hypotheses as hints.
Then it looks at the list of tactics associated to the head symbol of
the goal and tries to apply one of them (starting from the tactics
with lower cost). This process is recursively applied to the generated
subgoals. </P><P>By default, <TT>auto</TT> only uses the hypotheses of the current goal and the
hints of the database named <TT>core</TT>. </P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>auto </TT><I><FONT COLOR=maroon>num</FONT></I><P>Forces the search depth to be <I><FONT COLOR=maroon>num</FONT></I>. The maximal search depth is 5 by
default. </P></LI><LI CLASS="li-enumerate"><TT>auto with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><P>Uses the hint databases <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> in addition to
the database <TT>core</TT>. See Section <A HREF="#Hints-databases">8.13.1</A> for the
list of pre-defined databases and the way to create or extend a
database. This option can be combined with the previous one.</P></LI><LI CLASS="li-enumerate"><TT>auto with *</TT><P>Uses all existing hint databases, minus the special database
<TT>v62</TT>. See Section <A HREF="#Hints-databases">8.13.1</A></P></LI><LI CLASS="li-enumerate"><TT>auto using </TT><I><FONT COLOR=maroon>lemma</FONT></I><SUB><TT>1</TT></SUB><TT> , &#X2026;, </TT><I><FONT COLOR=maroon>lemma</FONT></I><SUB><TT><I>n</I></TT></SUB><P>Uses <I><FONT COLOR=maroon>lemma</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>lemma</FONT></I><SUB><I>n</I></SUB> in addition to
hints (can be combined with the <TT>with </TT><I><FONT COLOR=maroon>ident</FONT></I> option). If
<I>lemma</I><SUB><I>i</I></SUB> is an inductive type, it is the collection of its
constructors which is added as hints.</P></LI><LI CLASS="li-enumerate"><TT>auto using </TT><I><FONT COLOR=maroon>lemma</FONT></I><SUB><TT>1</TT></SUB><TT> , &#X2026;, </TT><I><FONT COLOR=maroon>lemma</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><P>This combines the effects of the <TT>using</TT> and <TT>with</TT> options.</P></LI><LI CLASS="li-enumerate"><TT>trivial</TT><A NAME="@default661"></A><A NAME="@tactic155"></A><P>This tactic is a restriction of <TT>auto</TT> that is not recursive and 
tries only hints which cost 0. Typically it solves trivial
equalities like <I>X</I>=<I>X</I>.</P></LI><LI CLASS="li-enumerate"><TT>trivial with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB></LI><LI CLASS="li-enumerate"><TT>trivial with *</TT></LI></OL><P><BR>
<B>Remark: </B><TT>auto</TT> either solves completely the goal or else leaves it
intact. <TT>auto</TT> and <TT>trivial</TT> never fail.</P><P><BR>
<B>See also: </B>Section <A HREF="#Hints-databases">8.13.1</A></P><H3 CLASS="subsection"><A NAME="htoc284">8.12.2</A>  <TT>eauto
</TT><A NAME="@default662"></A><A NAME="@tactic156"></A><TT>
</TT><A NAME="eauto"></A></H3><P>This tactic generalizes <TT>auto</TT>. In contrast with 
the latter, <TT>eauto</TT> uses unification of the goal
against the hints rather than pattern-matching
(in other words, it uses <TT>eapply</TT> instead of
<TT>apply</TT>).
As a consequence, <TT>eauto</TT> can solve such a goal:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Hint Resolve ex_intro.</TT><BR>
<TT><I>Warning: the hint: eapply ex_intro will only be used by eauto</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall P:nat -</TT><TT>&gt;</TT><TT> Prop, P 0 -</TT><TT>&gt;</TT><TT>  exists n, P n.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall P0 : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop, P0 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> exists n : nat, P0 n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> eauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>Note that <TT>ex_intro</TT> should be declared as an
hint.</P><P><BR>
<B>See also: </B>Section <A HREF="#Hints-databases">8.13.1</A></P><H3 CLASS="subsection"><A NAME="htoc285">8.12.3</A>  <TT>autounfold with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>
</TT><A NAME="@default663"></A><A NAME="@tactic157"></A><TT>
</TT><A NAME="autounfold"></A></H3><P>This tactic unfolds constants that were declared through a <TT>Hint
Unfold</TT> in the given databases.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>autounfold with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> in </TT><TT><I>clause</I></TT><P>Perform the unfolding in the given clause.</P></LI><LI CLASS="li-enumerate"><TT>autounfold with *</TT><P>Uses the unfold hints declared in all the hint databases.
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc286">8.12.4</A>  <TT>tauto
</TT><A NAME="@default664"></A><A NAME="@tactic158"></A><TT>
</TT><A NAME="tauto"></A></H3><P>This tactic implements a decision procedure for intuitionistic propositional
calculus based on the contraction-free sequent calculi LJT* of Roy Dyckhoff
[<A HREF="biblio.html#Dyc92">54</A>]. Note that <TT>tauto</TT> succeeds on any instance of an
intuitionistic tautological proposition. <TT>tauto</TT> unfolds negations
and logical equivalence but does not unfold any other definition.</P><P>The following goal can be proved by <TT>tauto</TT> whereas <TT>auto</TT>
would fail:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall (x:nat) (P:nat -</TT><TT>&gt;</TT><TT> Prop), x = 0 </TT><TT>\</TT><TT>/ P x -</TT><TT>&gt;</TT><TT> x </TT><TT>&lt;</TT><TT>&gt;</TT><TT> 0 -</TT><TT>&gt;</TT><TT> P x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall (x : nat) (P0 : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop), x = 0 </I></TT><TT><I>\</I></TT><TT><I>/ P0 x -</I></TT><TT><I>&gt;</I></TT><TT><I> x </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> P0 x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  P0 : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  H : x = 0 </I></TT><TT><I>\</I></TT><TT><I>/ P0 x</I></TT><BR>
<TT><I>  H0 : x </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   P0 x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   tauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>Moreover, if it has nothing else to do, <TT>tauto</TT> performs
introductions. Therefore, the use of <TT>intros</TT> in the previous
proof is unnecessary. <TT>tauto</TT> can for instance prove the
following:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> (* auto would fail *)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall (A:Prop) (P:nat -</TT><TT>&gt;</TT><TT> Prop),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     A </TT><TT>\</TT><TT>/ (forall x:nat, </TT><TT>~</TT><TT> A -</TT><TT>&gt;</TT><TT> P x) -</TT><TT>&gt;</TT><TT> forall x:nat, </TT><TT>~</TT><TT> A -</TT><TT>&gt;</TT><TT> P x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall (A : Prop) (P0 : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop),</I></TT><BR>
<TT><I>   A </I></TT><TT><I>\</I></TT><TT><I>/ (forall x : nat, </I></TT><TT><I>~</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> P0 x) -</I></TT><TT><I>&gt;</I></TT><TT><I> forall x : nat, </I></TT><TT><I>~</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> P0 x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   tauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P><BR>
<B>Remark: </B>In contrast, <TT>tauto</TT> cannot solve the following goal</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall (A:Prop) (P:nat -</TT><TT>&gt;</TT><TT> Prop),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     A </TT><TT>\</TT><TT>/ (forall x:nat, </TT><TT>~</TT><TT> A -</TT><TT>&gt;</TT><TT> P x) -</TT><TT>&gt;</TT><TT> forall x:nat, </TT><TT>~</TT><TT> </TT><TT>~</TT><TT> (A </TT><TT>\</TT><TT>/ P x).</TT><BR>
</DIV><P>because <CODE>(forall x:nat, ~ A -&gt; P x)</CODE> cannot be treated as atomic and an
instantiation of <CODE>x</CODE> is necessary.</P><H3 CLASS="subsection"><A NAME="htoc287">8.12.5</A>  <TT>intuition </TT><I><FONT COLOR=maroon>tactic</FONT></I><TT>
</TT><A NAME="@default665"></A><A NAME="@tactic159"></A><TT>
</TT><A NAME="intuition"></A></H3><P>The tactic <TT>intuition</TT> takes advantage of the search-tree built
by the decision procedure involved in the tactic <TT>tauto</TT>. It uses
this information to generate a set of subgoals equivalent to the
original one (but simpler than it) and applies the tactic 
<I><FONT COLOR=maroon>tactic</FONT></I> to them [<A HREF="biblio.html#Mun94">104</A>]. If this tactic fails on some goals then
<TT>intuition</TT> fails. In fact, <TT>tauto</TT> is simply <TT>intuition
fail</TT>.</P><P>For instance, the tactic <TT>intuition auto</TT> applied to the goal
</P><PRE CLASS="verbatim">(forall (x:nat), P x)/\B -&gt; (forall (y:nat),P y)/\ P O \/B/\ P O
</PRE><P>internally replaces it by the equivalent one:
</P><PRE CLASS="verbatim">(forall (x:nat), P x), B |- P O
</PRE><P>and then uses <TT>auto</TT> which completes the proof.</P><P>Originally due to César Muñoz, these tactics (<TT>tauto</TT> and <TT>intuition</TT>)
have been completely re-engineered by David Delahaye using mainly the tactic
language (see Chapter <A HREF="Reference-Manual012.html#TacticLanguage">9</A>). The code is now much shorter and
a significant increase in performance has been noticed. The general behavior
with respect to dependent types, unfolding and introductions has
slightly changed to get clearer semantics. This may lead to some
incompatibilities.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>intuition</TT><BR>
 Is equivalent to <TT>intuition auto with *</TT>.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc288">8.12.6</A>  <TT>rtauto
</TT><A NAME="@default666"></A><A NAME="@tactic160"></A><TT>
</TT><A NAME="rtauto"></A></H3><P>The <TT>rtauto</TT> tactic solves propositional tautologies similarly to what <TT>tauto</TT> does. The main difference is that the proof term is built using a reflection scheme applied to a sequent calculus proof of the goal. The search procedure is also implemented using a different technique. </P><P>Users should be aware that this difference may result in faster proof-search but slower proof-checking, and <TT>rtauto</TT> might not solve goals that <TT>tauto</TT> would be able to solve (e.g. goals involving universal quantifiers). </P><H3 CLASS="subsection"><A NAME="htoc289">8.12.7</A>  <TT>firstorder</TT>
<A NAME="@default667"></A><A NAME="@tactic161"></A>
<A NAME="firstorder"></A></H3><P>The tactic <TT>firstorder</TT> is an <I>experimental</I> extension of
<TT>tauto</TT> to 
first-order reasoning, written by Pierre Corbineau. 
It is not restricted to usual logical connectives but
instead may reason about any first-order class inductive definition.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>firstorder </TT><I><FONT COLOR=maroon>tactic</FONT></I>
<A NAME="@default668"></A><A NAME="@tactic162"></A><P>Tries to solve the goal with <I><FONT COLOR=maroon>tactic</FONT></I> when no logical rule may apply.</P></LI><LI CLASS="li-enumerate"><TT>firstorder with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> </TT>
<A NAME="@default669"></A><A NAME="@tactic163"></A><P>Adds lemmas <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> to the proof-search
environment.</P></LI><LI CLASS="li-enumerate"><TT>firstorder using </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT> , &#X2026; , </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> </TT>
<A NAME="@default670"></A><A NAME="@tactic164"></A><P>Adds lemmas in <TT>auto</TT> hints bases <I><FONT COLOR=maroon>qualid</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>qualid</FONT></I><SUB><I>n</I></SUB>
to the proof-search environment. If <I><FONT COLOR=maroon>qualid</FONT></I><SUB><I>i</I></SUB> refers to an inductive
type, it is the collection of its constructors which is added as hints.</P></LI><LI CLASS="li-enumerate"><TT>firstorder using </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT> , &#X2026; , </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><P>This combines the effects of the <TT>using</TT> and <TT>with</TT> options.</P></LI></OL><P>Proof-search is bounded by a depth parameter which can be set by typing the
<TT>Set Firstorder Depth </TT><TT><I>n</I></TT> <A NAME="@default671"></A><A NAME="@command215"></A> 
vernacular command.</P><H3 CLASS="subsection"><A NAME="htoc290">8.12.8</A>  <TT>congruence
</TT><A NAME="@default672"></A><A NAME="@tactic165"></A><TT>
</TT><A NAME="congruence"></A></H3><P>The tactic <TT>congruence</TT>, by Pierre Corbineau, implements the standard Nelson and Oppen
congruence closure algorithm, which is a decision procedure for ground
equalities with uninterpreted symbols. It also include the constructor theory
(see <A HREF="#injection">8.9.4</A> and <A HREF="#discriminate">8.9.3</A>).
If the goal is a non-quantified equality, <TT>congruence</TT> tries to
prove it with non-quantified equalities in the context. Otherwise it
tries to infer a discriminable equality from those in the context. Alternatively, congruence tries to prove that a hypothesis is equal to the goal or to the negation of another hypothesis.</P><P><TT>congruence</TT> is also able to take advantage of hypotheses stating quantified equalities, you have to provide a bound for the number of extra equalities generated that way. Please note that one of the members of the equality must contain all the quantified variables in order for <TT>congruence</TT> to match against it. </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem T: </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   a=(f a) -</TT><TT>&gt;</TT><TT> (g b (f a))=(f (f a)) -</TT><TT>&gt;</TT><TT> (g a b)=(f (g b a)) -</TT><TT>&gt;</TT><TT> (g a b)=a.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   a = f a -</I></TT><TT><I>&gt;</I></TT><TT><I> g b (f a) = f (f a) -</I></TT><TT><I>&gt;</I></TT><TT><I> g a b = f (g b a) -</I></TT><TT><I>&gt;</I></TT><TT><I> g a b = a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : a = f a</I></TT><BR>
<TT><I>  H0 : g b (f a) = f (f a)</I></TT><BR>
<TT><I>  H1 : g a b = f (g b a)</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   g a b = a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> congruence.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem inj : f = pair a -</TT><TT>&gt;</TT><TT> Some (f c) = Some (f d) -</TT><TT>&gt;</TT><TT> c=d.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   f = pair a -</I></TT><TT><I>&gt;</I></TT><TT><I> Some (f c) = Some (f d) -</I></TT><TT><I>&gt;</I></TT><TT><I> c = d</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : f = pair a</I></TT><BR>
<TT><I>  H0 : Some (f c) = Some (f d)</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   c = d</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> congruence.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>congruence </TT><TT><I><FONT COLOR=maroon>n</FONT></I></TT><BR>
 Tries to add at most <TT><I><FONT COLOR=maroon>n</FONT></I></TT> instances of hypotheses stating quantified equalities to the problem in order to solve it. A bigger value of <TT><I><FONT COLOR=maroon>n</FONT></I></TT> does not make success slower, only failure. You might consider adding some lemmas as hypotheses using <TT>assert</TT> in order for congruence to use them.</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>congruence with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><BR>
 Adds <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> to the pool of terms used by
<TT>congruence</TT>. This helps in case you have partially applied
constructors in your goal.
</LI></OL><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>I don&#X2019;t know how to handle dependent equality</TT><A NAME="@error111"></A><BR>
 The decision procedure managed to find a proof of the goal or of
a discriminable equality but this proof couldn&#X2019;t be built in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
because of dependently-typed functions.
</LI><LI CLASS="li-enumerate"><TT>I couldn&#X2019;t solve goal</TT><A NAME="@error112"></A><BR>
 The decision procedure didn&#X2019;t find any way to solve the goal.
</LI><LI CLASS="li-enumerate"><TT>Goal is solvable by congruence but some arguments are missing. Try "congruence with &#X2026;", replacing metavariables by arbitrary terms.</TT><A NAME="@error113"></A><BR>
 The decision procedure could solve the goal with the provision
that additional arguments are supplied for some partially applied
constructors. Any term of an appropriate type will allow the
tactic to successfully solve the goal. Those additional arguments
can be given to <TT>congruence</TT> by filling in the holes in the
terms given in the error message, using the <TT>with</TT> variant
described above.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc291">8.12.9</A>  <TT>omega
</TT><A NAME="@default673"></A><A NAME="@tactic166"></A><TT>
</TT><A NAME="omega"></A></H3><P>The tactic <TT>omega</TT>, due to Pierre Crégut,
is an automatic decision procedure for Presburger
arithmetic. It solves quantifier-free 
formulas built with <CODE>~</CODE>, <CODE>\/</CODE>, <CODE>/\</CODE>,
<CODE>-&gt;</CODE> on top of equalities, inequalities and disequalities on
both the type <TT>nat</TT> of natural numbers and <TT>Z</TT> of binary
integers. This tactic must be loaded by the command <TT>Require Import
Omega</TT>. See the additional documentation about <TT>omega</TT>
(see Chapter <A HREF="Reference-Manual025.html#OmegaChapter">19</A>).</P><H3 CLASS="subsection"><A NAME="htoc292">8.12.10</A>  <TT>ring</TT> and <TT>ring_simplify </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>
<A NAME="@default674"></A><A NAME="@tactic167"></A>
<A NAME="@default675"></A><A NAME="@tactic168"></A>
<A NAME="@default676"></A><A NAME="@command216"></A></H3><P>The <TT>ring</TT> tactic solves equations upon polynomial expressions of
a ring (or semi-ring) structure. It proceeds by normalizing both hand
sides of the equation (w.r.t. associativity, commutativity and
distributivity, constant propagation) and comparing syntactically the
results.</P><P><TT>ring_simplify</TT> applies the normalization procedure described
above to the terms given. The tactic then replaces all occurrences of
the terms given in the conclusion of the goal by their normal
forms. If no term is given, then the conclusion should be an equation
and both hand sides are normalized.</P><P>See Chapter <A HREF="Reference-Manual029.html#ring">23</A> for more information on the tactic and how to
declare new ring structures.</P><H3 CLASS="subsection"><A NAME="htoc293">8.12.11</A>  <TT>field</TT>, <TT>field_simplify </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>
and <TT>field_simplify_eq</TT>
<A NAME="@default677"></A><A NAME="@tactic169"></A>
<A NAME="@default678"></A><A NAME="@tactic170"></A>
<A NAME="@default679"></A><A NAME="@tactic171"></A>
<A NAME="@default680"></A><A NAME="@command217"></A></H3><P>The <TT>field</TT> tactic is built on the same ideas as <TT>ring</TT>: this
is a reflexive tactic that solves or simplifies equations in a field
structure. The main idea is to reduce a field expression (which is an
extension of ring expressions with the inverse and division
operations) to a fraction made of two polynomial expressions.</P><P>Tactic <TT>field</TT> is used to solve subgoals, whereas <TT>field_simplify </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> replaces the provided terms
by their reduced fraction. <TT>field_simplify_eq</TT> applies when the
conclusion is an equation: it simplifies both hand sides and multiplies
so as to cancel denominators. So it produces an equation without
division nor inverse.</P><P>All of these 3 tactics may generate a subgoal in order to prove that
denominators are different from zero.</P><P>See Chapter <A HREF="Reference-Manual029.html#ring">23</A> for more information on the tactic and how to
declare new field structures.</P><P><BR>
<B>Example: </B>
</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Reals.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y:R,</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     (x * y </TT><TT>&gt;</TT><TT> 0)%R -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     (x * (1 / x + x / (x + y)))%R =</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     ((- 1 / y) * y * (- x * (x / (x + y)) - 1))%R.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros; field.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : R</I></TT><BR>
<TT><I>  y : R</I></TT><BR>
<TT><I>  H : (x * y </I></TT><TT><I>&gt;</I></TT><TT><I> 0)%R</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (x + y)%R </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0%R /</I></TT><TT><I>\</I></TT><TT><I> y </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0%R /</I></TT><TT><I>\</I></TT><TT><I> x </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0%R</I></TT><BR>
</DIV><P><BR>
<B>See also: </B>file <TT>plugins/setoid_ring/RealField.v</TT> for an example of instantiation,<BR>
    theory <TT>theories/Reals</TT> for many examples of use of <TT>field</TT>.</P><H3 CLASS="subsection"><A NAME="htoc294">8.12.12</A>  <TT>fourier
</TT><A NAME="@default681"></A><A NAME="@tactic172"></A></H3><P>This tactic written by Loïc Pottier solves linear inequalities on
real numbers using Fourier&#X2019;s method [<A HREF="biblio.html#Fourier">63</A>]. This tactic must
be loaded by <TT>Require Import Fourier</TT>.</P><P><BR>
<B>Example: </B>
</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Reals.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Fourier.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y:R, (x </TT><TT>&lt;</TT><TT> y)%R -</TT><TT>&gt;</TT><TT> (y + 1 </TT><TT>&gt;</TT><TT>= x - 1)%R.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros; fourier.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc295">8.12.13</A>  <TT>autorewrite with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>.
</TT><A NAME="tactic:autorewrite"></A><TT>
</TT><A NAME="@default682"></A><A NAME="@tactic173"></A></H3><P>This tactic <SUP><A NAME="text19" HREF="#note19">5</A></SUP> carries out rewritings according
the rewriting rule bases <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB>.</P><P>Each rewriting rule of a base <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> is applied to the main subgoal until
it fails. Once all the rules have been processed, if the main subgoal has
progressed (e.g., if it is distinct from the initial main goal) then the rules
of this base are processed again. If the main subgoal has not progressed then
the next base is processed. For the bases, the behavior is exactly similar to
the processing of the rewriting rules.</P><P>The rewriting rule bases are built with the <TT>Hint Rewrite</TT> vernacular
command.</P><P><BR>
<B>Warning: </B> This tactic may loop if you build non terminating rewriting systems.</P><P><BR>
<B>Variant: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>autorewrite with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> using </TT><I><FONT COLOR=maroon>tactic</FONT></I><BR>
Performs, in the same way, all the rewritings of the bases <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>...</TT><TT>
</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB> applying <I><FONT COLOR=maroon>tactic</FONT></I> to the main subgoal after each rewriting step.</LI><LI CLASS="li-enumerate"><TT>autorewrite with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> in </TT><I><FONT COLOR=maroon>qualid</FONT></I><P>Performs all the rewritings in hypothesis <I><FONT COLOR=maroon>qualid</FONT></I>.
</P></LI><LI CLASS="li-enumerate"><TT>autorewrite with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> in </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> using </TT><I><FONT COLOR=maroon>tactic</FONT></I><P>Performs all the rewritings in hypothesis <I><FONT COLOR=maroon>qualid</FONT></I> applying <I><FONT COLOR=maroon>tactic</FONT></I> to the main subgoal after each rewriting step.</P></LI><LI CLASS="li-enumerate"><TT>autorewrite with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> in </TT><TT><I>clause</I></TT>
Performs all the rewritings in the clause <I>clause</I>.<BR>
 The <I>clause</I> argument must not contain any <TT>type of</TT> nor <TT>value of</TT>.</LI></OL><P><BR>
<B>See also: </B>Section <A HREF="#HintRewrite">8.13.4</A> for feeding the database of lemmas used by <TT>autorewrite</TT>.</P><P><BR>
<B>See also: </B>Section <A HREF="Reference-Manual013.html#autorewrite-example">10.7</A> for examples showing the use of
this tactic. </P><H2 CLASS="section"><A NAME="toc63"></A><A NAME="htoc296">8.13</A>  Controlling automation</H2><H3 CLASS="subsection"><A NAME="htoc297">8.13.1</A>  The hints databases for <TT>auto</TT> and <TT>eauto</TT>
<A NAME="@default683"></A>
<A NAME="Hints-databases"></A>
<A NAME="@default684"></A><A NAME="@command218"></A></H3><P>The hints for <TT>auto</TT> and <TT>eauto</TT> are stored in
databases. Each database maps head symbols to a list of hints. One can
use the command <TT>Print Hint </TT><I><FONT COLOR=maroon>ident</FONT></I> to display the hints
associated to the head symbol <I><FONT COLOR=maroon>ident</FONT></I> (see <A HREF="#PrintHint">8.13.3</A>). Each
hint has a cost that is an nonnegative integer, and an optional pattern. 
The hints with lower cost are tried first. A hint is tried by 
<TT>auto</TT> when the conclusion of the current goal
matches its pattern or when it has no pattern. </P><H4 CLASS="subsubsection">Creating Hint databases
<A NAME="CreateHintDb"></A><A NAME="@default685"></A><A NAME="@command219"></A></H4><P>One can optionally declare a hint database using the command
<TT>Create HintDb</TT>. If a hint is added to an unknown database, it
will be automatically created. </P><P><BR>
<TT>Create HintDb</TT> <I><FONT COLOR=maroon>ident</FONT></I> [<TT>discriminated</TT>]
<BR>
</P><P>This command creates a new database named <I><FONT COLOR=maroon>ident</FONT></I>.
The database is implemented by a Discrimination Tree (DT) that serves as
an index of all the lemmas. The DT can use transparency information to decide
if a constant should be indexed or not (c.f. <A HREF="#HintTransparency">8.13.1</A>),
making the retrieval more efficient.
The legacy implementation (the default one for new databases) uses the
DT only on goals without existentials (i.e., auto goals), for non-Immediate
hints and do not make use of transparency hints, putting more work on the
unification that is run after retrieval (it keeps a list of the lemmas
in case the DT is not used). The new implementation enabled by
the <TT>discriminated</TT> option makes use of DTs in all cases and takes
transparency information into account. However, the order in which hints
are retrieved from the DT may differ from the order in which they were
inserted, making this implementation observationaly different from the
legacy one. </P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Local Hint</TT> <I><FONT COLOR=maroon>hint_definition</FONT></I> <TT>:</TT>
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>This is used to declare a hint database that must not be exported to the other
modules that require and import the current module. Inside a
section, the option <TT>Local</TT> is useless since hints do not
survive anyway to the closure of sections.</P></LI></OL><P>The general
command to add a hint to some database <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> is:
</P><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD ALIGN=left NOWRAP>
<TT>Hint</TT> <I><FONT COLOR=maroon>hint_definition</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>
</TD></TR>
</TABLE><P>
where <I><FONT COLOR=maroon>hint_definition</FONT></I> is one of the following expressions:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Resolve</TT> <I><FONT COLOR=maroon>term</FONT></I> 
<A NAME="@default686"></A><A NAME="@command220"></A><P>This command adds <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I> to the hint list
with the head symbol of the type of <I><FONT COLOR=maroon>term</FONT></I>. The cost of that hint is
the number of subgoals generated by <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I>.</P><P>In case the inferred type of <I><FONT COLOR=maroon>term</FONT></I> does not start with a product the
tactic added in the hint list is <TT>exact </TT><I><FONT COLOR=maroon>term</FONT></I>. In case this
type can be reduced to a type starting with a product, the tactic <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I> is also stored in the hints list.</P><P>If the inferred type of <I><FONT COLOR=maroon>term</FONT></I> contains a dependent
quantification on a predicate, it is added to the hint list of <TT>eapply</TT> instead of the hint list of <TT>apply</TT>. In this case, a
warning is printed since the hint is only used by the tactic <TT>eauto</TT> (see <A HREF="#eauto">8.12.2</A>). A typical example of a hint that is used
only by <TT>eauto</TT> is a transitivity lemma.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Bound head variable</TT><A NAME="@error114"></A><P>The head symbol of the type of <I><FONT COLOR=maroon>term</FONT></I> is a bound variable such
that this tactic cannot be associated to a constant.</P></LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>term</FONT></I> <TT>cannot be used as a hint</TT><A NAME="@error115"></A><P>The type of <I><FONT COLOR=maroon>term</FONT></I> contains products over variables which do not
appear in the conclusion. A typical example is a transitivity axiom.
In that case the <TT>apply</TT> tactic fails, and thus is useless.</P></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Resolve</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>term</FONT></I><SUB><I>m</I></SUB><P>Adds each <TT>Resolve</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>i</I></SUB>.</P></LI></OL></LI><LI CLASS="li-itemize"><TT>Immediate </TT><I><FONT COLOR=maroon>term</FONT></I> 
<A NAME="@default687"></A><A NAME="@command221"></A><P>This command adds <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT>; trivial</TT> to the hint list
associated with the head symbol of the type of <I><FONT COLOR=maroon>ident</FONT></I> in the given
database. This tactic will fail if all the subgoals generated by
<TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I> are not solved immediately by the <TT>trivial</TT>
tactic (which only tries tactics with cost 0).</P><P>This command is useful for theorems such as the symmetry of equality
or <I>n</I>+1=<I>m</I>+1 &#X2192; <I>n</I>=<I>m</I> that we may like to introduce with a
limited use in order to avoid useless proof-search.</P><P>The cost of this tactic (which never generates subgoals) is always 1,
so that it is not used by <TT>trivial</TT> itself.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Bound head variable</TT><A NAME="@error116"></A></LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>term</FONT></I> <TT>cannot be used as a hint</TT><A NAME="@error117"></A> </LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Immediate</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>term</FONT></I><SUB><I>m</I></SUB> <P>Adds each <TT>Immediate</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>i</I></SUB>.</P></LI></OL></LI><LI CLASS="li-itemize"><TT>Constructors</TT> <I><FONT COLOR=maroon>ident</FONT></I>
<A NAME="@default688"></A><A NAME="@command222"></A><P>If <I><FONT COLOR=maroon>ident</FONT></I> is an inductive type, this command adds all its
constructors as hints of type <TT>Resolve</TT>. Then, when the
conclusion of current goal has the form <TT>(</TT><I><FONT COLOR=maroon>ident</FONT></I><TT> &#X2026;)</TT>,
<TT>auto</TT> will try to apply each constructor.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I> <TT>is not an inductive type</TT><A NAME="@error118"></A></LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I> <TT>not declared</TT><A NAME="@error119"></A></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Constructors</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB> <P>Adds each <TT>Constructors</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB>.</P></LI></OL></LI><LI CLASS="li-itemize"><TT>Unfold</TT> <I><FONT COLOR=maroon>qualid</FONT></I>
<A NAME="@default689"></A><A NAME="@command223"></A><P>This adds the tactic <TT>unfold </TT><I><FONT COLOR=maroon>qualid</FONT></I> to the hint list that
will only be used when the head constant of the goal is <I><FONT COLOR=maroon>ident</FONT></I>. Its
cost is 4.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Unfold</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB> <P>Adds each <TT>Unfold</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB>.</P></LI></OL></LI><LI CLASS="li-itemize"><TT>Transparent</TT>, <TT>Opaque</TT> <I><FONT COLOR=maroon>qualid</FONT></I>
<A NAME="HintTransparency"></A>
<A NAME="@default690"></A><A NAME="@command224"></A>
<A NAME="@default691"></A><A NAME="@command225"></A><P>This adds a transparency hint to the database, making <I><FONT COLOR=maroon>qualid</FONT></I>
a transparent or opaque constant during resolution. This information 
is used during unification of the goal with any lemma in the database
and inside the discrimination network to relax or constrain it in the
case of <TT>discriminated</TT> databases.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Transparent</TT>, <TT>Opaque</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB> <P>Declares each <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> as a transparent or opaque constant.</P></LI></OL></LI><LI CLASS="li-itemize"><TT>Extern </TT><I><FONT COLOR=maroon>num</FONT></I><TT> [</TT><I><FONT COLOR=maroon>pattern</FONT></I><TT>] =&gt; </TT><I><FONT COLOR=maroon>tactic</FONT></I>
<A NAME="@default692"></A><A NAME="@command226"></A><P>This hint type is to extend <TT>auto</TT> with tactics other than
<TT>apply</TT> and <TT>unfold</TT>. For that, we must specify a
cost, an optional pattern and a tactic to execute. Here is an example:</P><BLOCKQUOTE CLASS="quotation">
<PRE CLASS="verbatim">Hint Extern 4 (~(_ = _)) =&gt; discriminate.
</PRE></BLOCKQUOTE><P>Now, when the head of the goal is a disequality, <TT>auto</TT> will
try <TT>discriminate</TT> if it does not manage to solve the goal
with hints with a cost less than 4.</P><P>One can even use some sub-patterns of the pattern in the tactic
script. A sub-pattern is a question mark followed by an ident, like
<TT>?X1</TT> or <TT>?X2</TT>. Here is an example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import List.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hint Extern 5   ({?X1 = ?X2} + {?X1 </TT><TT>&lt;</TT><TT>&gt;</TT><TT> ?X2}) =</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  generalize X1, X2; decide equality : eqdec.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> forall a b:list (nat * nat), {a = b} + {a </TT><TT>&lt;</TT><TT>&gt;</TT><TT> b}.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall a b : list (nat * nat), {a = b} + {a </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> b}</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> info auto with eqdec.</TT><BR>
<TT><I> == intro a; intro b; generalize a, b; decide equality; </I></TT><BR>
<TT><I>    generalize a1, p; decide equality.</I></TT><BR>
<TT><I>    generalize b1, n0; decide equality.</I></TT><BR>
<TT><I>    </I></TT><BR>
<TT><I>    generalize a3, n; decide equality.</I></TT><BR>
<TT><I>    </I></TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV></LI></UL><P><BR>
<B>Remark: </B>One can use an <TT>Extern</TT> hint with no pattern to do
pattern-matching on hypotheses using <TT>match goal with</TT> inside 
the tactic.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Hint</TT> <I><FONT COLOR=maroon>hint_definition</FONT></I> <P>No database name is given: the hint is registered in the <TT>core</TT> 
database. </P></LI><LI CLASS="li-enumerate"><TT>Hint Local</TT> <I><FONT COLOR=maroon>hint_definition</FONT></I> <TT>:</TT>
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>This is used to declare hints that must not be exported to the other
modules that require and import the current module. Inside a
section, the option <TT>Local</TT> is useless since hints do not
survive anyway to the closure of sections.</P></LI><LI CLASS="li-enumerate"><TT>Hint Local</TT> <I><FONT COLOR=maroon>hint_definition</FONT></I> <P>Idem for the <TT>core</TT> database.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc298">8.13.2</A>  Hint databases defined in the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library</H3><P>Several hint databases are defined in the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library. The
actual content of a database is the collection of the hints declared
to belong to this database in each of the various modules currently
loaded. Especially, requiring new modules potentially extend a
database. At <SPAN STYLE="font-variant:small-caps">Coq</SPAN> startup, only the <TT>core</TT> and <TT>v62</TT>
databases are non empty and can be used.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>core</TT></B></DT><DD CLASS="dd-description"> This special database is automatically used by
<TT>auto</TT>. It contains only basic lemmas about negation,
conjunction, and so on from. Most of the hints in this database come 
from the <TT>Init</TT> and <TT>Logic</TT> directories.</DD><DT CLASS="dt-description"><B><TT>arith</TT></B></DT><DD CLASS="dd-description"> This database contains all lemmas about Peano&#X2019;s
arithmetic proved in the directories <TT>Init</TT> and
<TT>Arith</TT></DD><DT CLASS="dt-description"><B><TT>zarith</TT></B></DT><DD CLASS="dd-description"> contains lemmas about binary signed integers from
the directories <TT>theories/ZArith</TT>. When required, the module
<TT>Omega</TT> also extends the database <TT>zarith</TT> with a high-cost
hint that calls <TT>omega</TT> on equations and inequalities in <TT>nat</TT> or <TT>Z</TT>.</DD><DT CLASS="dt-description"><B><TT>bool</TT></B></DT><DD CLASS="dd-description"> contains lemmas about booleans, mostly from directory
<TT>theories/Bool</TT>.</DD><DT CLASS="dt-description"><B><TT>datatypes</TT></B></DT><DD CLASS="dd-description"> is for lemmas about lists, streams and so on that 
are mainly proved in the <TT>Lists</TT> subdirectory.</DD><DT CLASS="dt-description"><B><TT>sets</TT></B></DT><DD CLASS="dd-description"> contains lemmas about sets and relations from the 
directories <TT>Sets</TT> and <TT>Relations</TT>.</DD><DT CLASS="dt-description"><B><TT>typeclass_instances</TT></B></DT><DD CLASS="dd-description"> contains all the type class instances
declared in the environment, including those used for <TT>setoid_rewrite</TT>,
from the <TT>Classes</TT> directory.
</DD></DL><P>There is also a special database called <TT>v62</TT>. It collects all
hints that were declared in the versions of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> prior to version
6.2.4 when the databases <TT>core</TT>, <TT>arith</TT>, and so on were
introduced. The purpose of the database <TT>v62</TT> is to ensure
compatibility with further versions of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> for developments done in
versions prior to 6.2.4 (<TT>auto</TT> being replaced by <TT>auto with v62</TT>).
The database <TT>v62</TT> is intended not to be extended (!). It is not
included in the hint databases list used in the <TT>auto with *</TT> tactic.</P><P>Furthermore, you are advised not to put your own hints in the
<TT>core</TT> database, but use one or several databases specific to your
development.</P><H3 CLASS="subsection"><A NAME="htoc299">8.13.3</A>  <TT>Print Hint
</TT><A NAME="PrintHint"></A><TT>
</TT><A NAME="@default693"></A><A NAME="@command227"></A></H3><P>This command displays all hints that apply to the current goal. It
fails if no proof is being edited, while the two variants can be used at
every moment.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Print Hint </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><P>This command displays only tactics associated with <I><FONT COLOR=maroon>ident</FONT></I> in the
hints list. This is independent of the goal being edited, so this
command will not fail if no goal is being edited.</P></LI><LI CLASS="li-enumerate"><TT>Print Hint *</TT><P>This command displays all declared hints. </P></LI><LI CLASS="li-enumerate"><TT>Print HintDb </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT>
<A NAME="PrintHintDb"></A>
<A NAME="@default694"></A><A NAME="@command228"></A><P>This command displays all hints from database <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc300">8.13.4</A>  <TT>Hint Rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> : </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="HintRewrite"></A><TT>
</TT><A NAME="@default695"></A><A NAME="@command229"></A></H3><P>This vernacular command adds the terms <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>
(their types must be equalities) in the rewriting base <I><FONT COLOR=maroon>ident</FONT></I>
with the default orientation (left to right). Notice that the
rewriting bases are distinct from the <TT>auto</TT> hint bases and that
<TT>auto</TT> does not take them into account.</P><P>This command is synchronous with the section mechanism (see <A HREF="Reference-Manual004.html#Section">2.4</A>):
when closing a section, all aliases created by <TT>Hint Rewrite</TT> in that
section are lost. Conversely, when loading a module, all <TT>Hint Rewrite</TT>
declarations at the global level of that module are loaded.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Hint Rewrite -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> : </TT><I><FONT COLOR=maroon>ident</FONT></I><BR>
This is strictly equivalent to the command above (we only make explicit the
orientation which otherwise defaults to <TT>-&gt;</TT>).</LI><LI CLASS="li-enumerate"><TT>Hint Rewrite &lt;- </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> : </TT><I><FONT COLOR=maroon>ident</FONT></I><BR>
Adds the rewriting rules <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> with a right-to-left
orientation in the base <I><FONT COLOR=maroon>ident</FONT></I>.</LI><LI CLASS="li-enumerate"><TT>Hint Rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> using </TT><I><FONT COLOR=maroon>tactic</FONT></I><TT> : </TT><I><FONT COLOR=maroon>ident</FONT></I><BR>
When the rewriting rules <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> in <I><FONT COLOR=maroon>ident</FONT></I> will
be used, the tactic <I><FONT COLOR=maroon>tactic</FONT></I> will be applied to the generated subgoals, the
main subgoal excluded.</LI><LI CLASS="li-enumerate"><TT>Print Rewrite HintDb </TT><I><FONT COLOR=maroon>ident</FONT></I><P>This command displays all rewrite hints contained in <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc301">8.13.5</A>  Hints and sections
<A NAME="Hint-and-Section"></A></H3><P>Hints provided by the <TT>Hint</TT> commands are erased when closing a
section. Conversely, all hints of a module <TT>A</TT> that are not
defined inside a section (and not defined with option <TT>Local</TT>) become
available when the module <TT>A</TT> is imported (using
e.g. <TT>Require Import A.</TT>).</P><H3 CLASS="subsection"><A NAME="htoc302">8.13.6</A>  Setting implicit automation tactics</H3><H4 CLASS="subsubsection"><TT>Proof with </TT><I><FONT COLOR=maroon>tactic</FONT></I><TT>.</TT><A NAME="ProofWith"></A><TT>
</TT><A NAME="@default696"></A><A NAME="@command230"></A></H4><P>This command may be used to start a proof. It defines a default
tactic to be used each time a tactic command <I><FONT COLOR=maroon>tactic</FONT></I><SUB>1</SUB> is ended by
&#X201C;<CODE>...</CODE>&#X201D;. In this case the tactic command typed by the user is
equivalent to <I><FONT COLOR=maroon>tactic</FONT></I><SUB>1</SUB>;<I><FONT COLOR=maroon>tactic</FONT></I>.</P><P><BR>
<B>See also: </B><TT>Proof.</TT> in Section <A HREF="Reference-Manual010.html#BeginProof">7.1.4</A>.</P><H4 CLASS="subsubsection"><TT>Declare Implicit Tactic </TT><I><FONT COLOR=maroon>tactic</FONT></I><TT>.</TT><A NAME="@default697"></A><A NAME="@command231"></A></H4><P>This command declares a tactic to be used to solve implicit arguments
that <SPAN STYLE="font-variant:small-caps">Coq</SPAN> does not know how to solve by unification. It is used
every time the term argument of a tactic has one of its holes not
fully resolved.</P><P>Here is an example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Parameter quo : nat -</TT><TT>&gt;</TT><TT> forall n:nat, n</TT><TT>&lt;</TT><TT>&gt;</TT><TT>0 -</TT><TT>&gt;</TT><TT> nat.</TT><BR>
<TT><I>quo is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Notation "x // y" := (quo x y _) (at level 40).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Declare Implicit Tactic assumption.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall n m, m</TT><TT>&lt;</TT><TT>&gt;</TT><TT>0 -</TT><TT>&gt;</TT><TT> { q:nat &amp; { r | q * m + r = n } }.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n m : nat, m </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> {q : nat &amp; {r : nat | q * m + r = n}}</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  H : m </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   {q : nat &amp; {r : nat | q * m + r = n}}</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> exists (n // m).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  H : m </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   {r : nat | n // m * m + r = n}</I></TT><BR>
</DIV><P>The tactic <TT>exists (n // m)</TT> did not fail. The hole was solved by
<TT>assumption</TT> so that it behaved as <TT>exists (quo n m H)</TT>.</P><H2 CLASS="section"><A NAME="toc64"></A><A NAME="htoc303">8.14</A>  Generation of induction principles with <TT>Scheme</TT>
<A NAME="Scheme"></A>
<A NAME="@default698"></A>
<A NAME="@default699"></A><A NAME="@command232"></A></H2><P>The <TT>Scheme</TT> command is a high-level tool for generating
automatically (possibly mutual) induction principles for given types
and sorts. Its syntax follows the schema:
</P><BLOCKQUOTE CLASS="quote">
<TT>Scheme </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> := Induction for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2019;</TT><SUB><TT>1</TT></SUB><TT> Sort </TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT>1</TT></SUB><TT><BR>
 with<BR>
  &#X2026;<BR>
 with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> := Induction for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2019;</TT><SUB><TT><I>m</I></TT></SUB><TT> Sort
</TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT><I>m</I></TT></SUB>
</BLOCKQUOTE><P>
where <I><FONT COLOR=maroon>ident</FONT></I>&#X2019;<SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I>&#X2019;<SUB><I>m</I></SUB> are different inductive type
identifiers belonging to the same package of mutual inductive
definitions. This command generates <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB>
to be mutually recursive definitions. Each term <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> proves a
general principle of mutual induction for objects in type <I><FONT COLOR=maroon>term</FONT></I><SUB><I>i</I></SUB>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Scheme </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> := Minimality for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2019;</TT><SUB><TT>1</TT></SUB><TT> Sort </TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT>1</TT></SUB><TT><BR>
 with<BR>
  &#X2026;<BR>
 with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> := Minimality for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2019;</TT><SUB><TT><I>m</I></TT></SUB><TT> Sort
</TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT><I>m</I></TT></SUB><P>Same as before but defines a non-dependent elimination principle more
natural in case of inductively defined relations. </P></LI><LI CLASS="li-enumerate"><TT>Scheme Equality for </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><A NAME="@default700"></A><A NAME="@command233"></A><P>Tries to generate a boolean equality and a proof of the
decidability of the usual equality.</P></LI><LI CLASS="li-enumerate"><TT>Scheme Induction for </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> Sort </TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT>1</TT></SUB><TT><BR>
 with<BR>
  &#X2026;<BR>
 with Induction for </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> Sort
</TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT><I>m</I></TT></SUB><P>If you do not provide the name of the schemes, they will be automatically 
computed from the sorts involved (works also with Minimality).</P></LI></OL><P><BR>
<B>See also: </B>Section <A HREF="Reference-Manual013.html#Scheme-examples">10.3</A></P><H3 CLASS="subsection"><A NAME="htoc304">8.14.1</A>  Automatic declaration of schemes</H3><P>
<A NAME="@default701"></A><A NAME="@command234"></A>
<A NAME="@default702"></A><A NAME="@command235"></A>
It is possible to deactivate the automatic declaration of the induction
principles when defining a new inductive type with the
<TT>Unset Elimination Schemes</TT> command. It may be
reactivated at any time with <TT>Set Elimination Schemes</TT>.<BR>

You can also activate the automatic declaration of those boolean equalities 
(see the second variant of <TT>Scheme</TT>) with the <TT>Set Equality Schemes</TT>
command. However you have to be careful with this option since
<SPAN STYLE="font-variant:small-caps">Coq</SPAN>  may now reject well-defined inductive types because it cannot compute
a boolean equality for them.</P><H3 CLASS="subsection"><A NAME="htoc305">8.14.2</A>  <TT>Combined Scheme</TT><A NAME="CombinedScheme"></A><TT>
</TT><A NAME="@default703"></A><A NAME="@command236"></A></H3><P>
The <TT>Combined Scheme</TT> command is a tool for combining 
induction principles generated by the <TT>Scheme</TT> command.
Its syntax follows the schema :</P><P><TT>Combined Scheme </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>0</TT></SUB><TT> from </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>, .., </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><BR>
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> are different inductive principles that must belong to
the same package of mutual inductive principle definitions. This command
generates <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> to be the conjunction of the principles: it is
built from the common premises of the principles and concluded by the
conjunction of their conclusions.</P><P><BR>
<B>See also: </B>Section <A HREF="Reference-Manual013.html#CombinedScheme-examples">10.3.1</A></P><H2 CLASS="section"><A NAME="toc65"></A><A NAME="htoc306">8.15</A>  Generation of induction principles with <TT>Functional Scheme</TT>
<A NAME="FunScheme"></A>
<A NAME="@default704"></A><A NAME="@command237"></A></H2><P>The <TT>Functional Scheme</TT> command is a high-level experimental
tool for generating automatically induction principles
corresponding to (possibly mutually recursive) functions. Its
syntax follows the schema:
</P><BLOCKQUOTE CLASS="quote">
<TT>Functional Scheme </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> := Induction for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2019;</TT><SUB><TT>1</TT></SUB><TT> Sort </TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT>1</TT></SUB><TT><BR>
 with<BR>
  &#X2026;<BR>
 with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> := Induction for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2019;</TT><SUB><TT><I>m</I></TT></SUB><TT> Sort
</TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT><I>m</I></TT></SUB>
</BLOCKQUOTE><P> 
where <I><FONT COLOR=maroon>ident</FONT></I>&#X2019;<SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I>&#X2019;<SUB><I>m</I></SUB> are different mutually defined function
names (they must be in the same order as when they were defined).
This command generates the induction principles
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB>, following the recursive structure and case
analyses of the functions <I><FONT COLOR=maroon>ident</FONT></I>&#X2019;<SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I>&#X2019;<SUB><I>m</I></SUB>.</P><H5 CLASS="paragraph"><TT>Functional Scheme</TT></H5><P> 
There is a difference between obtaining an induction scheme by using
<TT>Functional Scheme</TT> on a function defined by <TT>Function</TT>
or not. Indeed <TT>Function</TT> generally produces smaller
principles, closer to the definition written by the user.</P><P><BR>
<B>See also: </B>Section <A HREF="Reference-Manual013.html#FunScheme-examples">10.4</A></P><H2 CLASS="section"><A NAME="toc66"></A><A NAME="htoc307">8.16</A>  Simple tactic macros
<A NAME="@default705"></A>
<A NAME="@default706"></A><A NAME="@command238"></A>
<A NAME="TacticDefinition"></A></H2><P>A simple example has more value than a long explanation: </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Ltac Solve := simpl; intros; auto.</TT><BR>
<TT><I>Solve is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Ltac ElimBoolRewrite b H1 H2 :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   elim b; [ intros; rewrite H1; eauto | intros; rewrite H2; eauto ].</TT><BR>
<TT><I>ElimBoolRewrite is defined</I></TT><BR>
</DIV><P>The tactics macros are synchronous with the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> section mechanism:
a tactic definition is deleted from the current environment
when you close the section (see also <A HREF="Reference-Manual004.html#Section">2.4</A>) 
where it was defined. If you want that a
tactic macro defined in a module is usable in the modules that
require it, you should put it outside of any section.</P><P>Chapter <A HREF="Reference-Manual012.html#TacticLanguage">9</A> gives examples of more complex
user-defined tactics.</P><HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note15" HREF="#text15">1</A></DT><DD CLASS="dd-thefootnotes">but it does not rename the hypothesis in the
proof-term...
</DD><DT CLASS="dt-thefootnotes"><A NAME="note16" HREF="#text16">2</A></DT><DD CLASS="dd-thefootnotes">Actually, only the second subgoal will be
generated since the other one can be automatically checked.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note17" HREF="#text17">3</A></DT><DD CLASS="dd-thefootnotes">This corresponds to the
cut rule of sequent calculus.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note18" HREF="#text18">4</A></DT><DD CLASS="dd-thefootnotes">Reminder: opaque
constants will not be expanded by &#X3B4; reductions
</DD><DT CLASS="dt-thefootnotes"><A NAME="note19" HREF="#text19">5</A></DT><DD CLASS="dd-thefootnotes">The behavior of this tactic has much changed compared to
the versions available in the previous distributions (V6). This may cause
significant changes in your theories to obtain the same result. As a drawback
of the re-engineering of the code, this tactic has also been completely revised
to get a very compact and readable version.
</DD></DL>

<div id="sidebarWrapper">
<div id="sidebar">

<div class="block">
<h2 class="title">Navigation</h2>
<div class="content">

<ul class="menu">

<li class="leaf"><a href="index.html">Cover</a></li>
<li class="leaf"><a href="toc.html">Table of contents</a></li>
<li class="leaf">Index
  <ul class="menu">
  <li><a href="general-index.html">General</a></li>
  <li><a href="command-index.html">Commands</a></li>
  <li><a href="tactic-index.html">Tactics</a></li>
  <li><a href="error-index.html">Errors</a></li>
  </ul>
</li>

</ul>

</div>
</div>

</div>
</div>


</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:www-coq at lix.polytechnique.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/check?uri=referer">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/check/referer">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</BODY>
</HTML>
