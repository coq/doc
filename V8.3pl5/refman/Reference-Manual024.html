<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">

<LINK rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<STYLE type="text/css" media="all">@import "/modules/node/node.css";</STYLE>

<STYLE type="text/css" media="all">@import "/modules/system/defaults.css";</STYLE>
<STYLE type="text/css" media="all">@import "/modules/system/system.css";</STYLE>
<STYLE type="text/css" media="all">@import "/modules/user/user.css";</STYLE>

<STYLE type="text/css" media="all">@import "/sites/all/themes/coq/style.css";</STYLE>
<STYLE type="text/css" media="all">@import "/sites/all/themes/coq/coqdoc.css";</STYLE>
<STYLE type="text/css" media="all">@import "/sites/all/themes/coq/hevea.css";</STYLE>
<TITLE>Chapter 18  Type Classes</TITLE>
</HEAD>
<BODY >

<div id="container">
<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="http://coq.inria.fr/" class="active">Home</a></li>

    <li><a href="http://coq.inria.fr/about-coq" title="More about coq">About Coq</a></li>    
    <li><a href="http://coq.inria.fr/download">Get Coq</a></li>
    <li><a href="http://coq.inria.fr/documentation">Documentation</a></li>
    <li><a href="http://coq.inria.fr/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">

<div id="logoWrapper">

<div id="logo"><a href="http://coq.inria.fr/" title="Home"><img src="/files/barron_logo.png" alt="Home"></a>
</div>
<div id="siteName"><a href="http://coq.inria.fr/" title="Home">The Coq Proof Assistant</a>
</div>

</div>
</div>

<div id="content">

<H1 CLASS="chapter"><A NAME="htoc459">Chapter 18</A>  Type Classes</H1><UL>
<LI><A HREF="Reference-Manual024.html#toc132">18.1  Class and Instance declarations</A>
</LI><LI><A HREF="Reference-Manual024.html#toc133">18.2  Binding classes</A>
</LI><LI><A HREF="Reference-Manual024.html#toc134">18.3  Parameterized Instances</A>
</LI><LI><A HREF="Reference-Manual024.html#toc135">18.4  Sections and contexts</A>
</LI><LI><A HREF="Reference-Manual024.html#toc136">18.5  Building hierarchies</A>
</LI><LI><A HREF="Reference-Manual024.html#toc137">18.6  Summary of the commands
</A>
</LI></UL>
<P>
<FONT SIZE=5><B>Matthieu Sozeau</B></FONT> <BR>
<BR>

<A NAME="typeclasses"></A></P><DIV CLASS="flushleft">
<EM>The status of Type Classes is experimental.
</EM></DIV><P>This chapter presents a quick reference of the commands related to type
classes. For an actual introduction to type classes, there is a
description of the system [<A HREF="biblio.html#sozeau08">127</A>] and the literature on type
classes in <SPAN STYLE="font-variant:small-caps">Haskell</SPAN> which also applies.</P><H2 CLASS="section"><A NAME="toc132"></A><A NAME="htoc460">18.1</A>  Class and Instance declarations</H2><P>
<A NAME="ClassesInstances"></A></P><P>The syntax for class and instance declarations is the same as
record syntax of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>:

</P><DIV CLASS="center">
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>Class</TT> <TT>Id</TT> (&#X3B1;<SUB>1</SUB> : &#X3C4;<SUB>1</SUB>) &#X22EF; (&#X3B1;<SUB><I>n</I></SUB> : &#X3C4;<SUB><I>n</I></SUB>) 
[: <I><FONT COLOR=maroon>sort</FONT></I>] := {</TD></TR>
<TR><TD ALIGN=left NOWRAP><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP><FONT COLOR=purple>f</FONT><SUB>1</SUB></TD><TD VALIGN=top ALIGN=center NOWRAP>:</TD><TD VALIGN=top ALIGN=left NOWRAP><I><FONT COLOR=maroon>type</FONT></I><SUB>1</SUB> ; </TD></TR>
<TR><TD VALIGN=top ALIGN=left>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>&#X22EE;</TD><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=left>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP><FONT COLOR=purple>f</FONT><SUB><I>m</I></SUB></TD><TD VALIGN=top ALIGN=center NOWRAP>:</TD><TD VALIGN=top ALIGN=left NOWRAP><I><FONT COLOR=maroon>type</FONT></I><SUB><I>m</I></SUB> }.</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE>
</DIV><DIV CLASS="center">
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>Instance</TT> <I><FONT COLOR=maroon>ident</FONT></I> : <TT>Id</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X22EF; <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> := {</TD></TR>
<TR><TD ALIGN=left NOWRAP><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP><FONT COLOR=purple>f</FONT><SUB>1</SUB></TD><TD VALIGN=top ALIGN=center NOWRAP>:=</TD><TD VALIGN=top ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I><SUB><I>f</I><SUB>1</SUB></SUB> ; </TD></TR>
<TR><TD VALIGN=top ALIGN=left>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>&#X22EE;</TD><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=left>&nbsp;</TD><TD VALIGN=top ALIGN=left NOWRAP><FONT COLOR=purple>f</FONT><SUB><I>m</I></SUB></TD><TD VALIGN=top ALIGN=center NOWRAP>:=</TD><TD VALIGN=top ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I><SUB><I>f</I><SUB><I>m</I></SUB></SUB> }.</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE>
</DIV><P>The &#X3B1;<SUB><I>i</I></SUB> : &#X3C4;<SUB><I>i</I></SUB> variables are called the <EM>parameters</EM>
of the class and the <I>f</I><SUB><I>k</I></SUB> : <I><FONT COLOR=maroon>type</FONT></I><SUB><I>k</I></SUB> are called the
<EM>methods</EM>. Each class definition gives rise to a corresponding
record declaration and each instance is a regular definition whose name
is given by <I><FONT COLOR=maroon>ident</FONT></I> and type is an instantiation of the record type.</P><P>We&#X2019;ll use the following example class in the rest of the chapter:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Class EqDec (A : Type) := {</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   eqb : A -</TT><TT>&gt;</TT><TT> A -</TT><TT>&gt;</TT><TT> bool ;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   eqb_leibniz : forall x y, eqb x y = true -</TT><TT>&gt;</TT><TT> x = y }.</TT><BR>
</DIV><P>This class implements a boolean equality test which is compatible with
Leibniz equality on some type. An example implementation is:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Instance unit_EqDec : EqDec unit :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> { eqb x y := true ;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   eqb_leibniz x y H := </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     match x, y return x = y with tt, tt =</TT><TT>&gt;</TT><TT> refl_equal tt end }.</TT><BR>
</DIV><P>If one does not give all the members in the <TT>Instance</TT>
declaration, Coq enters the proof-mode and the user is asked to build
inhabitants of the remaining fields, e.g.:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Instance eq_bool : EqDec bool :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> { eqb x y := if x then y else negb y }.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof. intros x y H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : bool</I></TT><BR>
<TT><I>  y : bool</I></TT><BR>
<TT><I>  H : (if x then y else negb y) = true</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = y</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   destruct x ; destruct y ; (discriminate || reflexivity). </TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Defined.</TT><BR>
<TT><I>refine {|</I></TT><BR>
<TT><I>       eqb := fun x y : bool =</I></TT><TT><I>&gt;</I></TT><TT><I> if x then y else negb y;</I></TT><BR>
<TT><I>       eqb_leibniz := _</I></TT><BR>
<TT><I>                      :forall x y : bool,</I></TT><BR>
<TT><I>                       (if x then y else negb y) = true -</I></TT><TT><I>&gt;</I></TT><TT><I> x = y |}.</I></TT><BR>
<TT><I>intros x y H.</I></TT><BR>
<TT><I>destruct x; destruct y; discriminate || reflexivity.</I></TT><BR>
<TT><I>eq_bool is defined</I></TT><BR>
</DIV><P>One has to take care that the transparency of every field is determined
by the transparency of the <TT>Instance</TT> proof. One can use
alternatively the <TT>Program</TT> <TT>Instance</TT> <A NAME="@default860"></A><A NAME="@command292"></A> variant which has
richer facilities for dealing with obligations.</P><H2 CLASS="section"><A NAME="toc133"></A><A NAME="htoc461">18.2</A>  Binding classes</H2><P>Once a type class is declared, one can use it in class binders:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition neqb {A} {eqa : EqDec A} (x y : A) := negb (eqb x y).</TT><BR>
<TT><I>neqb is defined</I></TT><BR>
</DIV><P>When one calls a class method, a constraint is generated that is
satisfied only in contexts where the appropriate instances can be
found. In the example above, a constraint <TT>EqDec A</TT> is generated and
satisfied by <TT>eqa : EqDec A</TT>. In case no satisfying constraint can be
found, an error is raised:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition neqb&#X2019; (A : Type) (x y : A) := negb (eqb x y).</TT><BR>
<TT><I>Toplevel input, characters 47-50:</I></TT><BR>
<TT><I>&gt;</I></TT><TT><I> Definition neqb&#X2019; (A : Type) (x y : A) := negb (eqb x y).</I></TT><BR>
<TT><I>&gt;</I></TT><TT><I>                                                </I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><BR>
<TT><I>Error: Cannot infer the implicit parameter EqDec of</I></TT><BR>
<TT><I>eqb.</I></TT><BR>
<TT><I>Could not find an instance for "EqDec A" in environment:</I></TT><BR>
<TT><I>A : Type</I></TT><BR>
<TT><I>x : A</I></TT><BR>
<TT><I>y : A</I></TT><BR>
</DIV><P>The algorithm used to solve constraints is a variant of the eauto tactic
that does proof search with a set of lemmas (the instances). It will use
local hypotheses as well as declared lemmas in the
<TT>typeclass_instances</TT> database. Hence the example can also be
written:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition neqb&#X2019; A (eqa : EqDec A) (x y : A) := negb (eqb x y).</TT><BR>
<TT><I>neqb&#X2019; is defined</I></TT><BR>
</DIV><P>However, the generalizing binders should be used instead as they have
particular support for type classes:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
They automatically set the maximally implicit status for type
class arguments, making derived functions as easy to use as class
methods. In the example above, <TT>A</TT> and <TT>eqa</TT> should be
set maximally implicit.
</LI><LI CLASS="li-itemize">They support implicit quantification on partialy applied type
classes.
</LI><LI CLASS="li-itemize">They also support implicit quantification on superclasses
(§<A HREF="#classes:superclasses">18.5.1</A>)
</LI></UL><P>Following the previous example, one can write:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition neqb_impl &#X2018;{eqa : EqDec A} (x y : A) := negb (eqb x y).</TT><BR>
<TT><I>neqb_impl is defined</I></TT><BR>
</DIV><P>Here <TT>A</TT> is implicitly generalized, and the resulting function
is equivalent to the one above.</P><P>The parsing of generalized type-class binders is different from regular
binders:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Implicit arguments of the class type are ignored.
</LI><LI CLASS="li-itemize">Superclasses arguments are automatically generalized.
</LI><LI CLASS="li-itemize">Any remaining arguments not given as part of a type class binder
will be automatically generalized. In other words, the rightmost
parameters are automatically generalized if not mentionned.
</LI></UL><P>One can switch off this special treatment using the ! mark in front of
the class name (see example below).</P><H2 CLASS="section"><A NAME="toc134"></A><A NAME="htoc462">18.3</A>  Parameterized Instances</H2><P>One can declare parameterized instances as in <SPAN STYLE="font-variant:small-caps">Haskell</SPAN> simply by giving
the constraints as a binding context before the instance, e.g.:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Instance prod_eqb &#X2018;(EA : EqDec A, EB : EqDec B) : EqDec (A * B) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> { eqb x y := match x, y with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | (la, ra), (lb, rb) =</TT><TT>&gt;</TT><TT> andb (eqb la lb) (eqb ra rb)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end }.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Type</I></TT><BR>
<TT><I>  EA : EqDec A</I></TT><BR>
<TT><I>  B : Type</I></TT><BR>
<TT><I>  EB : EqDec B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y : A * B,</I></TT><BR>
<TT><I>   (let (la, ra) := x in let (lb, rb) := y in (eqb la lb &amp;&amp; eqb ra rb)%bool) =</I></TT><BR>
<TT><I>   true -</I></TT><TT><I>&gt;</I></TT><TT><I> x = y</I></TT><BR>
</DIV><P>These instances are used just as well as lemmas in the instance hint database.</P><H2 CLASS="section"><A NAME="toc135"></A><A NAME="htoc463">18.4</A>  Sections and contexts</H2><P>
<A NAME="SectionContext"></A>
To ease the parametrization of developments by type classes, we provide
a new way to introduce variables into section contexts, compatible with 
the implicit argument mechanism. 
The new command works similarly to the <TT>Variables</TT> vernacular
(see <A HREF="Reference-Manual003.html#Variable">1.3.1</A>), except it accepts any binding context as argument.
For example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section EqDec_defs.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Context &#X2018;{EA : EqDec A}.</TT><BR>
<TT><I>A is assumed</I></TT><BR>
<TT><I>EA is assumed</I></TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT>   Global Instance option_eqb : EqDec (option A) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   { eqb x y := match x, y with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     | Some x, Some y =</TT><TT>&gt;</TT><TT> eqb x y</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     | None, None =</TT><TT>&gt;</TT><TT> true</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     | _, _ =</TT><TT>&gt;</TT><TT> false</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     end }.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> End EqDec_defs.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> About option_eqb.</TT><BR>
<TT><I>option_eqb : forall A : Type, EqDec A -</I></TT><TT><I>&gt;</I></TT><TT><I> EqDec (option A)</I></TT><BR>
<TT><I>Arguments A, EA are implicit and maximally inserted</I></TT><BR>
<TT><I>Argument scopes are [type_scope _]</I></TT><BR>
<TT><I>option_eqb is transparent</I></TT><BR>
<TT><I>Expands to: Constant Top.option_eqb</I></TT><BR>
</DIV><P>Here the <TT>Global</TT> modifier redeclares the instance at the end of 
the section, once it has been generalized by the context variables it uses.</P><H2 CLASS="section"><A NAME="toc136"></A><A NAME="htoc464">18.5</A>  Building hierarchies</H2><H3 CLASS="subsection"><A NAME="htoc465">18.5.1</A>  Superclasses</H3><P>
<A NAME="classes:superclasses"></A>
One can also parameterize classes by other classes, generating a
hierarchy of classes and superclasses. In the same way, we give the
superclasses as a binding context:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Class Ord &#X2018;(E : EqDec A) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   { le : A -</TT><TT>&gt;</TT><TT> A -</TT><TT>&gt;</TT><TT> bool }.</TT><BR>
</DIV><P>Contrary to <SPAN STYLE="font-variant:small-caps">Haskell</SPAN>, we have no special syntax for superclasses, but
this declaration is morally equivalent to:
</P><PRE CLASS="verbatim">Class `(E : EqDec A) =&gt; Ord A :=
  { le : A -&gt; A -&gt; bool }.
</PRE><P>This declaration means that any instance of the <TT>Ord</TT> class must
have an instance of <TT>EqDec</TT>. The parameters of the subclass contain
at least all the parameters of its superclasses in their order of
appearance (here <TT>A</TT> is the only one).
As we have seen, <TT>Ord</TT> is encoded as a record type with two parameters:
a type <TT>A</TT> and an <TT>E</TT> of type <TT>EqDec A</TT>. However, one can
still use it as if it had a single parameter inside generalizing binders: the
generalization of superclasses will be done automatically. 

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition le_eqb &#X2018;{Ord A} (x y : A) := andb (le x y) (le y x).</TT><BR>
</DIV><P>In some cases, to be able to specify sharing of structures, one may want to give
explicitly the superclasses. It is possible to do it directly in regular
generalized binders, and using the <TT>!</TT> modifier in class
binders. For example:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition lt &#X2018;{eqa : EqDec A, ! Ord eqa} (x y : A) := </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   andb (le x y) (neqb x y).</TT><BR>
</DIV><P>The <TT>!</TT> modifier switches the way a binder is parsed back to the
regular interpretation of Coq. In particular, it uses the implicit
arguments mechanism if available, as shown in the example.</P><H3 CLASS="subsection"><A NAME="htoc466">18.5.2</A>  Substructures</H3><P>Substructures are components of a class which are instances of a class
themselves. They often arise when using classes for logical properties,
e.g.:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Class Reflexive (A : Type) (R : relation A) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   reflexivity : forall x, R x x.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Class Transitive (A : Type) (R : relation A) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   transitivity : forall x y z, R x y -</TT><TT>&gt;</TT><TT> R y z -</TT><TT>&gt;</TT><TT> R x z.</TT><BR>
</DIV><P>This declares singleton classes for reflexive and transitive relations,
(see <A HREF="#SingletonClass">1</A> for an explanation).
These may be used as part of other classes:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Class PreOrder (A : Type) (R : relation A) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> { PreOrder_Reflexive :</TT><TT>&gt;</TT><TT> Reflexive A R ;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   PreOrder_Transitive :</TT><TT>&gt;</TT><TT> Transitive A R }.</TT><BR>
</DIV><P>The syntax <TT>:&gt;</TT> indicates that each <TT>PreOrder</TT> can be seen
as a <TT>Reflexive</TT> relation. So each time a reflexive relation is
needed, a preorder can be used instead. This is very similar to the
coercion mechanism of <TT>Structure</TT> declarations.
The implementation simply declares each projection as an instance. </P><P>One can also declare existing objects or structure
projections using the <TT>Existing Instance</TT> command to achieve the 
same effect.</P><H2 CLASS="section"><A NAME="toc137"></A><A NAME="htoc467">18.6</A>  Summary of the commands
<A NAME="TypeClassCommands"></A></H2><H3 CLASS="subsection"><A NAME="htoc468">18.6.1</A>  <TT>Class </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> 
: </TT><I><FONT COLOR=maroon>sort</FONT></I><TT>:= { field</TT><SUB><TT>1</TT></SUB><TT> ; &#X2026;; field</TT><SUB><TT><I>k</I></TT></SUB><TT> }.</TT></H3><P>
<A NAME="@default861"></A><A NAME="@command293"></A>
<A NAME="Class"></A></P><P>The <TT>Class</TT> command is used to declare a type class with
parameters <I><FONT COLOR=maroon>binder</FONT></I><SUB>1</SUB> to <I><FONT COLOR=maroon>binder</FONT></I><SUB><I>n</I></SUB> and fields <TT>field</TT><SUB><TT>1</TT></SUB> to
<TT>field</TT><SUB><TT><I>k</I></TT></SUB>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<A NAME="SingletonClass"></A> <TT>Class </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> 
: </TT><I><FONT COLOR=maroon>sort</FONT></I><TT>:= </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><SUB><TT>1</TT></SUB><TT>.</TT>
This variant declares a <EM>singleton</EM> class whose only method is
<I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB>. This singleton class is a so-called definitional
class, represented simply as a definition 
<I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> := </TT><I><FONT COLOR=maroon>type</FONT></I><SUB><TT>1</TT></SUB> and whose
instances are themselves objects of this type. Definitional classes
are not wrapped inside records, and the trivial projection of an
instance of such a class is convertible to the instance itself. This can
be useful to make instances of existing objects easily and to reduce 
proof size by not inserting useless projections. The class
constant itself is declared rigid during resolution so that the class 
abstraction is maintained. </LI><LI CLASS="li-enumerate"><A NAME="ExistingClass"></A> <TT>Existing Class </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT><A NAME="@default862"></A><A NAME="@command294"></A>
This variant declares a class a posteriori from a constant or
inductive definition. No methods or instances are defined.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc469">18.6.2</A>  <TT>Instance </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> :
</TT><TT>Class</TT><TT> </TT><TT>t</TT><SUB><TT>1</TT></SUB><TT> &#X2026;t</TT><SUB><TT><I>n</I></TT></SUB><TT> [| </TT><TT><I>priority</I></TT><TT>]
:= { field</TT><SUB><TT>1</TT></SUB><TT> := b</TT><SUB><TT>1</TT></SUB><TT> ; &#X2026;; field</TT><SUB><TT><I>i</I></TT></SUB><TT> := b</TT><SUB><TT><I>i</I></TT></SUB><TT> }</TT></H3><P>
<A NAME="@default863"></A><A NAME="@command295"></A>
<A NAME="Instance"></A></P><P>The <TT>Instance</TT> command is used to declare a type class instance
named <I><FONT COLOR=maroon>ident</FONT></I> of the class <EM>Class</EM> with parameters t<SUB>1</SUB> to t<SUB><I>n</I></SUB> and
fields <TT>b</TT><SUB><TT>1</TT></SUB> to <TT>b</TT><SUB><TT><I>i</I></TT></SUB>, where each field must be a declared
field of the class. Missing fields must be filled in interactive proof mode.</P><P>An arbitrary context of the form <I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB>
can be put after the name of the instance and before the colon to
declare a parameterized instance.
An optional <I>priority</I> can be declared, 0 being the highest
priority as for auto hints.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Instance </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> :
forall </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I>+1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>m</I></TT></SUB><TT>,
</TT><TT>Class</TT><TT> </TT><TT>t</TT><SUB><TT>1</TT></SUB><TT> &#X2026;t</TT><SUB><TT><I>n</I></TT></SUB><TT> [| </TT><TT><I>priority</I></TT><TT>] := </TT><I><FONT COLOR=maroon>term</FONT></I> 
This syntax is used for declaration of singleton class instances or
for directly giving an explicit term of type
<TT>forall </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I>+1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>m</I></TT></SUB><TT>, </TT><TT>Class</TT><TT> </TT><TT>t</TT><SUB><TT>1</TT></SUB><TT> &#X2026;t</TT><SUB><TT><I>n</I></TT></SUB>.
One need not even mention the unique field name for singleton classes.</LI><LI CLASS="li-enumerate"><TT>Global Instance</TT> One can use the <TT>Global</TT> modifier on
instances declared in a section so that their generalization is automatically
redeclared after the section is closed.</LI><LI CLASS="li-enumerate"><TT>Program Instance</TT> <A NAME="@default864"></A><A NAME="@command296"></A>
Switches the type-checking to <SPAN STYLE="font-variant:small-caps">Program</SPAN> (chapter <A HREF="Reference-Manual028.html#Program">22</A>)
and uses the obligation mechanism to manage missing fields.</LI><LI CLASS="li-enumerate"><TT>Declare Instance</TT> <A NAME="@default865"></A><A NAME="@command297"></A>
In a <TT>Module Type</TT>, this command states that a corresponding
concrete instance should exist in any implementation of this
<TT>Module Type</TT>. This is similar to the distinction between
<TT>Parameter</TT> vs. <TT>Definition</TT>, or between <TT>Declare Module</TT>
and <TT>Module</TT>.</LI></OL><P>Besides the <TT>Class</TT> and <TT>Instance</TT> vernacular commands, there
are a few other commands related to type classes.</P><H3 CLASS="subsection"><A NAME="htoc470">18.6.3</A>  <TT>Existing Instance </TT><I><FONT COLOR=maroon>ident</FONT></I></H3><P>
<A NAME="@default866"></A><A NAME="@command298"></A>
<A NAME="ExistingInstance"></A></P><P>This commands adds an arbitrary constant whose type ends with an applied
type class to the instance database. It can be used for redeclaring
instances at the end of sections, or declaring structure projections as
instances. This is almost equivalent to <TT>Hint Resolve </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> :
typeclass_instances</TT>.</P><H3 CLASS="subsection"><A NAME="htoc471">18.6.4</A>  <TT>Context </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB></H3><P>
<A NAME="@default867"></A><A NAME="@command299"></A>
<A NAME="Context"></A></P><P>Declares variables according to the given binding context, which might
use implicit generalization (see <A HREF="#SectionContext">18.4</A>).</P><H3 CLASS="subsection"><A NAME="htoc472">18.6.5</A>  <TT>Typeclasses Transparent, Opaque </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB></H3><P>
<A NAME="@default868"></A><A NAME="@command300"></A>
<A NAME="@default869"></A><A NAME="@command301"></A>
<A NAME="TypeclassesTransparency"></A></P><P>This commands defines the transparency of <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> 
during type class resolution. It is useful when some constants prevent some
unifications and make resolution fail. It is also useful to declare
constants which should never be unfolded during proof-search, like
fixpoints or anything which does not look like an abbreviation. This can
additionally speed up proof search as the typeclass map can be indexed
by such rigid constants (see <A HREF="Reference-Manual011.html#HintTransparency">8.13.1</A>).
By default, all constants and local variables are considered transparent.
One should take care not to make opaque any constant that is used to
abbreviate a type, like <TT>relation A := A -&gt; A -&gt; Prop</TT>.</P><P>This is equivalent to <TT>Hint Transparent,Opaque</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>: typeclass_instances</TT>.</P><H3 CLASS="subsection"><A NAME="htoc473">18.6.6</A>  <TT>Typeclasses eauto := [debug] [dfs | bfs] [</TT><TT><EM>depth</EM></TT><TT>]</TT></H3><P>
<A NAME="@default870"></A><A NAME="@command302"></A>
<A NAME="TypeclassesEauto"></A></P><P>This commands allows to customize the type class resolution tactic,
based on a variant of eauto. The flags semantics are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>debug</TT> In debug mode, the trace of successfully applied
tactics is printed.
</LI><LI CLASS="li-itemize"><TT>dfs, bfs</TT> This sets the search strategy to depth-first search
(the default) or breadth-first search.
</LI><LI CLASS="li-itemize"><EM>depth</EM> This sets the depth of the search (the default is 100).
</LI></UL>
<div id="sidebarWrapper">
<div id="sidebar">

<div class="block">
<h2 class="title">Navigation</h2>
<div class="content">

<ul class="menu">

<li class="leaf"><a href="index.html">Cover</a></li>
<li class="leaf"><a href="toc.html">Table of contents</a></li>
<li class="leaf">Index
  <ul class="menu">
  <li><a href="general-index.html">General</a></li>
  <li><a href="command-index.html">Commands</a></li>
  <li><a href="tactic-index.html">Tactics</a></li>
  <li><a href="error-index.html">Errors</a></li>
  </ul>
</li>

</ul>

</div>
</div>

</div>
</div>


</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:www-coq at lix.polytechnique.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/check?uri=referer">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/check/referer">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</BODY>
</HTML>
