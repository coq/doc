<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">

<LINK rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<STYLE type="text/css" media="all">@import "/modules/node/node.css";</STYLE>

<STYLE type="text/css" media="all">@import "/modules/system/defaults.css";</STYLE>
<STYLE type="text/css" media="all">@import "/modules/system/system.css";</STYLE>
<STYLE type="text/css" media="all">@import "/modules/user/user.css";</STYLE>

<STYLE type="text/css" media="all">@import "/sites/all/themes/coq/style.css";</STYLE>
<STYLE type="text/css" media="all">@import "/sites/all/themes/coq/coqdoc.css";</STYLE>
<STYLE type="text/css" media="all">@import "/sites/all/themes/coq/hevea.css";</STYLE>
<TITLE>Chapter 2  Extensions of Gallina</TITLE>
</HEAD>
<BODY >

<div id="container">
<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="http://coq.inria.fr/" class="active">Home</a></li>

    <li><a href="http://coq.inria.fr/about-coq" title="More about coq">About Coq</a></li>    
    <li><a href="http://coq.inria.fr/download">Get Coq</a></li>
    <li><a href="http://coq.inria.fr/documentation">Documentation</a></li>
    <li><a href="http://coq.inria.fr/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">

<div id="logoWrapper">

<div id="logo"><a href="http://coq.inria.fr/" title="Home"><img src="/files/barron_logo.png" alt="Home"></a>
</div>
<div id="siteName"><a href="http://coq.inria.fr/" title="Home">The Coq Proof Assistant</a>
</div>

</div>
</div>

<div id="content">

<H1 CLASS="chapter"><A NAME="htoc25">Chapter 2</A>  Extensions of <SPAN STYLE="font-variant:small-caps">Gallina</SPAN><A NAME="Gallina-extension"></A><A NAME="@default65"></A></H1><UL>
<LI><A HREF="Reference-Manual004.html#toc14">2.1  Record types

</A>
</LI><LI><A HREF="Reference-Manual004.html#toc15">2.2  Variants and extensions of <TT>match</TT>

</A>
</LI><LI><A HREF="Reference-Manual004.html#toc16">2.3  Advanced recursive functions</A>
</LI><LI><A HREF="Reference-Manual004.html#toc17">2.4  Section mechanism

</A>
</LI><LI><A HREF="Reference-Manual004.html#toc18">2.5  Module system

</A>
</LI><LI><A HREF="Reference-Manual004.html#toc19">2.6  Libraries and qualified names</A>
</LI><LI><A HREF="Reference-Manual004.html#toc20">2.7  Implicit arguments

</A>
</LI><LI><A HREF="Reference-Manual004.html#toc21">2.8  Coercions

</A>
</LI><LI><A HREF="Reference-Manual004.html#toc22">2.9  Printing constructions in full</A>
</LI><LI><A HREF="Reference-Manual004.html#toc23">2.10  Printing universes</A>
</LI></UL>
<P><SPAN STYLE="font-variant:small-caps">Gallina</SPAN> is the kernel language of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. We describe here extensions of
the Gallina&#X2019;s syntax.</P><H2 CLASS="section"><A NAME="toc14"></A><A NAME="htoc26">2.1</A>  Record types
<A NAME="@default66"></A><A NAME="@command28"></A>
<A NAME="Record"></A></H2><P>The <CODE>Record</CODE> construction is a macro allowing the definition of
records as is done in many programming languages. Its syntax is
described on Figure <A HREF="#record-syntax">2.1</A>. In fact, the <CODE>Record</CODE>
macro is more general than the usual record types, since it allows
also for &#X201C;manifest&#X201D; expressions. In this sense, the <CODE>Record</CODE>
construction allows to define &#X201C;signatures&#X201D;.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>sentence</FONT></I></TD><TD ALIGN=center NOWRAP>++=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>record</FONT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>record</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP> <TT>Record</TT> <I><FONT COLOR=maroon>ident</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>binders</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>:</TT> <I><FONT COLOR=maroon>sort</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <CODE>:=</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>    <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>ident</FONT></I><I><FONT COLOR=maroon>]</FONT></I>
<CODE>{</CODE> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>field</FONT></I> <TT>;</TT> &#X2026; <TT>;</TT> <I><FONT COLOR=maroon>field</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <CODE>}</CODE> <CODE>.</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>field</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>name</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>binders</FONT></I><I><FONT COLOR=maroon>]</FONT></I> : <I><FONT COLOR=maroon>type</FONT></I> [ <TT>where</TT> <I>notation</I> ]</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>name</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>binders</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>:</TT> <I><FONT COLOR=maroon>term</FONT></I><I><FONT COLOR=maroon>]</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.1: Syntax for the definition of <TT>Record</TT></TD></TR>
</TABLE></DIV>
<A NAME="record-syntax"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>In the expression</P><P><BR>
<TT>Record</TT> <I><FONT COLOR=maroon>ident</FONT></I> <I><FONT COLOR=maroon>params</FONT></I> <TT>:</TT> 
<I><FONT COLOR=maroon>sort</FONT></I> := <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> <CODE>{</CODE>
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>binders</FONT></I><SUB>1</SUB> <TT>:</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>; 
&#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> <I><FONT COLOR=maroon>binders</FONT></I><SUB><I>n</I></SUB> <TT>:</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> <CODE>}</CODE>.
<BR>
</P><P>the identifier <I><FONT COLOR=maroon>ident</FONT></I> is the name of the defined record
and <I><FONT COLOR=maroon>sort</FONT></I> is its type. The identifier <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> is the name of
its constructor. If <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> is omitted, the default name <TT>Build_</TT><I><FONT COLOR=maroon>ident</FONT></I> is used. If <I><FONT COLOR=maroon>sort</FONT></I> is omitted, the default sort is &#X201C;<FONT COLOR=purple>Type</FONT>&#X201D;.
The identifiers <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>, ..,
<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> are the names of fields and <TT>forall</TT> <I><FONT COLOR=maroon>binders</FONT></I><SUB>1</SUB><TT>,</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>, ..., <TT>forall</TT> <I><FONT COLOR=maroon>binders</FONT></I><SUB><I>n</I></SUB><TT>,</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB>
their respective types. Remark that the type of <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> may
depend on the previous <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>j</I></SUB> (for <I>j</I>&lt;<I>i</I>). Thus the order of the
fields is important. Finally, <I><FONT COLOR=maroon>params</FONT></I> are the parameters of the
record.</P><P>More generally, a record may have explicitly defined (a.k.a.
manifest) fields. For instance, <TT>Record</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>[</TT>
<I><FONT COLOR=maroon>params</FONT></I> <TT>]</TT> <TT>:</TT> <I><FONT COLOR=maroon>sort</FONT></I> := <CODE>{</CODE> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>
<TT>:</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB>1</SUB> <CODE>;</CODE> <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>
<CODE>;</CODE> <I><FONT COLOR=maroon>ident</FONT></I><SUB>3</SUB> <TT>:</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB>3</SUB> <CODE>}</CODE> in which case
the correctness of <I><FONT COLOR=maroon>type</FONT></I><SUB>3</SUB> may rely on the instance <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> of
<I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> in turn may depend on <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>.</P><P><BR>
<B>Example: </B>The set of rational numbers may be defined as:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Record Rat : Set := mkRat</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   {sign : bool;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    top : nat;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    bottom : nat;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    Rat_bottom_cond : 0 </TT><TT>&lt;</TT><TT>&gt;</TT><TT> bottom;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    Rat_irred_cond :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     forall x y z:nat, (x * y) = top /</TT><TT>\</TT><TT> (x * z) = bottom -</TT><TT>&gt;</TT><TT> x = 1}.</TT><BR>
<TT><I>Rat is defined</I></TT><BR>
<TT><I>Rat_rect is defined</I></TT><BR>
<TT><I>Rat_ind is defined</I></TT><BR>
<TT><I>Rat_rec is defined</I></TT><BR>
<TT><I>sign is defined</I></TT><BR>
<TT><I>top is defined</I></TT><BR>
<TT><I>bottom is defined</I></TT><BR>
<TT><I>Rat_bottom_cond is defined</I></TT><BR>
<TT><I>Rat_irred_cond is defined</I></TT><BR>
</DIV><P>Remark here that the field
<CODE>Rat_cond</CODE> depends on the field <CODE>bottom</CODE>. </P><P>Let us now see the work done by the <TT>Record</TT> macro. First the
macro generates an inductive definition with just one constructor:
</P><BLOCKQUOTE CLASS="quote">
<TT>Inductive </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>params</FONT></I><TT> :</TT><I><FONT COLOR=maroon>sort</FONT></I><TT> :=</TT><BR>
    <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>0</TT></SUB><TT> (</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>:</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>) .. (</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>:</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>).</TT>
</BLOCKQUOTE><P>
To build an object of type <I><FONT COLOR=maroon>ident</FONT></I>, one should provide the
constructor <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> with <I>n</I> terms filling the fields of
the record.</P><P>As an example, let us define the rational 1/2:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Arith.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem one_two_irred :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall x y z:nat, x * y = 1 /</TT><TT>\</TT><TT> x * z = 2 -</TT><TT>&gt;</TT><TT> x = 1.</TT><BR>
</DIV><P>

&#X2026;
</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition half := mkRat true 1 2 (O_S 1) one_two_irred.</TT><BR>
<TT><I>half is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check half.</TT><BR>
<TT><I>half</I></TT><BR>
<TT><I>     : Rat</I></TT><BR>
</DIV><P>The macro generates also, when it is possible, the projection
functions for destructuring an object of type <I><FONT COLOR=maroon>ident</FONT></I>. These
projection functions have the same name that the corresponding
fields. If a field is named &#X201C;<CODE>_</CODE>&#X201D; then no projection is built
for it. In our example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Eval compute in half.(top).</TT><BR>
<TT><I>     = 1</I></TT><BR>
<TT><I>     : nat</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Eval compute in half.(bottom).</TT><BR>
<TT><I>     = 2</I></TT><BR>
<TT><I>     : nat</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Eval compute in half.(Rat_bottom_cond).</TT><BR>
<TT><I>     = O_S 1</I></TT><BR>
<TT><I>     : 0 </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> bottom half</I></TT><BR>
</DIV><P><BR>
<B>Warnings: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Warning: </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>i</I></TT></SUB><TT> cannot be defined.</TT><P>It can happen that the definition of a projection is impossible.
This message is followed by an explanation of this impossibility.
There may be three reasons:
</P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
The name <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> already exists in the environment (see
Section <A HREF="Reference-Manual003.html#Axiom">1.3.1</A>).
</LI><LI CLASS="li-enumerate">The body of <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> uses an incorrect elimination for
<I><FONT COLOR=maroon>ident</FONT></I> (see Sections <A HREF="Reference-Manual003.html#Fixpoint">1.3.4</A> and <A HREF="Reference-Manual006.html#Caseexpr">4.5.4</A>).
</LI><LI CLASS="li-enumerate">The type of the projections <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> depends on previous
projections which themselves could not be defined.
</LI></OL></LI></OL><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>A record cannot be recursive</TT><A NAME="@error11"></A><P>The record name <I><FONT COLOR=maroon>ident</FONT></I> appears in the type of its fields.</P></LI><LI CLASS="li-enumerate">During the definition of the one-constructor inductive
definition, all the errors of inductive definitions, as described in
Section <A HREF="Reference-Manual003.html#gal_Inductive_Definitions">1.3.3</A>, may also occur.</LI></OL><P><BR>
<B>See also: </B>Coercions and records in Section <A HREF="Reference-Manual023.html#Coercions-and-records">17.9</A>
of the chapter devoted to coercions.</P><P><BR>
<B>Remark: </B><TT>Structure</TT> is a synonym of the keyword <TT>Record</TT>.</P><P><BR>
<B>Remark: </B>Creation of an object of record type can be done by calling <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB>
and passing arguments in the correct order.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Record point := { x : nat; y : nat }.</TT><BR>
<TT><I>point is defined</I></TT><BR>
<TT><I>point_rect is defined</I></TT><BR>
<TT><I>point_ind is defined</I></TT><BR>
<TT><I>point_rec is defined</I></TT><BR>
<TT><I>x is defined</I></TT><BR>
<TT><I>y is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition a := Build_point 5 3.</TT><BR>
<TT><I>a is defined</I></TT><BR>
</DIV><P>The following syntax allows to create objects by using named fields. The
fields do not have to be in any particular order, nor do they have to be all
present if the missing ones can be inferred or prompted for (see
Section <A HREF="Reference-Manual028.html#Program">22</A>).</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition b := {| x := 5; y := 3 |}.</TT><BR>
<TT><I>b is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition c := {| y := 3; x := 5 |}.</TT><BR>
<TT><I>c is defined</I></TT><BR>
</DIV><P>This syntax can also be used for pattern matching.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Eval compute in (</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match b with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | {| y := S n |} =</TT><TT>&gt;</TT><TT> n</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | _ =</TT><TT>&gt;</TT><TT> 0</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end).</TT><BR>
<TT><I>     = 2</I></TT><BR>
<TT><I>     : nat</I></TT><BR>
</DIV><P><BR>
<B>Remark: </B>An experimental syntax for projections based on a dot notation is
available. The command to activate it is
</P><BLOCKQUOTE CLASS="quote">
<TT>Set Printing Projections.</TT>
</BLOCKQUOTE><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I></TD><TD ALIGN=center NOWRAP>++=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I> <TT>.(</TT> <I><FONT COLOR=maroon>qualid</FONT></I> <TT>)</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I> <TT>.(</TT> <I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>arg</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>arg</FONT></I> <TT>)</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I> <TT>.(</TT> @<I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>term</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.2: Syntax of <TT>Record</TT> projections</TD></TR>
</TABLE></DIV>
<A NAME="fig:projsyntax"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The corresponding grammar rules are given Figure <A HREF="#fig:projsyntax">2.2</A>.
When <I><FONT COLOR=maroon>qualid</FONT></I> denotes a projection, the syntax <I><FONT COLOR=maroon>term</FONT></I><TT>.(</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>)</TT> is equivalent to <I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>term</FONT></I>, the syntax
<I><FONT COLOR=maroon>term</FONT></I><TT>.(</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>arg</FONT></I><SUB><TT>1</TT></SUB><TT>  &#X2026;  </TT><I><FONT COLOR=maroon>arg</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)</TT> to
<I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>arg</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>arg</FONT></I><SUB><I>n</I></SUB> <I><FONT COLOR=maroon>term</FONT></I>, and the syntax
<I><FONT COLOR=maroon>term</FONT></I><TT>.(@</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)</TT> to
@<I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> <I><FONT COLOR=maroon>term</FONT></I>. In each case, <I><FONT COLOR=maroon>term</FONT></I>
is the object projected and the other arguments are the parameters of
the inductive type.</P><P>To deactivate the printing of projections, use 
<TT>Unset Printing Projections</TT>.</P><H2 CLASS="section"><A NAME="toc15"></A><A NAME="htoc27">2.2</A>  Variants and extensions of <TT>match</TT>
<A NAME="Extensions-of-match"></A>
<A NAME="@default67"></A></H2><H3 CLASS="subsection"><A NAME="htoc28">2.2.1</A>  Multiple and nested pattern-matching
<A NAME="@default68"></A>
<A NAME="Mult-match"></A></H3><P>The basic version of <CODE>match</CODE> allows pattern-matching on simple
patterns. As an extension, multiple nested patterns or disjunction of
patterns are allowed, as in ML-like languages.</P><P>The extension just acts as a macro that is expanded during parsing
into a sequence of <TT>match</TT> on simple patterns. Especially, a
construction defined using the extended <TT>match</TT> is generally
printed under its expanded form (see <TT>Set Printing Matching</TT> in
section <A HREF="#SetPrintingMatching">2.2.4</A>).</P><P><BR>
<B>See also: </B>Chapter <A HREF="Reference-Manual022.html#Mult-match-full">16</A>.</P><H3 CLASS="subsection"><A NAME="htoc29">2.2.2</A>  Pattern-matching on boolean values: the <TT>if</TT> expression
<A NAME="if-then-else"></A>
<A NAME="@default69"></A></H3><P>For inductive types with exactly two constructors and for
pattern-matchings expressions which do not depend on the arguments of
the constructors, it is possible to use a <TT>if ... then ... else</TT>
notation. For instance, the definition</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition not (b:bool) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match b with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | true =</TT><TT>&gt;</TT><TT> false</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | false =</TT><TT>&gt;</TT><TT> true</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
<TT><I>not is defined</I></TT><BR>
</DIV><P>can be alternatively written</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition not (b:bool) := if b then false else true.</TT><BR>
<TT><I>not is defined</I></TT><BR>
</DIV><P>More generally, for an inductive type with constructors <TT>C</TT><SUB><TT>1</TT></SUB>
and <TT>C</TT><SUB><TT>2</TT></SUB>, we have the following equivalence</P><P><BR>
</P><P><TT>if </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>dep_ret_type</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> then </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> else </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> &#X2261;
</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>match </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>dep_ret_type</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> with</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE><TT>|</TT></CODE><TT> C</TT><SUB><TT>1</TT></SUB><TT> _ </TT><TT>&#X2026;</TT><TT> _ </TT><CODE><TT>=&gt;</TT></CODE><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE><TT>|</TT></CODE><TT> C</TT><SUB><TT>2</TT></SUB><TT> _ </TT><TT>&#X2026;</TT><TT> _ </TT><CODE><TT>=&gt;</TT></CODE><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>end</TT></TD></TR>
</TABLE><P>Here is an example.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check (fun x (H:{x=0}+{x</TT><TT>&lt;</TT><TT>&gt;</TT><TT>0}) =</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match H with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | left _ =</TT><TT>&gt;</TT><TT> true</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | right _ =</TT><TT>&gt;</TT><TT> false</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end).</TT><BR>
<TT><I>fun (x : nat) (H : {x = 0} + {x </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0}) =</I></TT><TT><I>&gt;</I></TT><TT><I> if H then true else false</I></TT><BR>
<TT><I>     : forall x : nat, {x = 0} + {x </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0} -</I></TT><TT><I>&gt;</I></TT><TT><I> bool</I></TT><BR>
</DIV><P>Notice that the printing uses the <TT>if</TT> syntax because <TT>sumbool</TT> is
declared as such (see Section <A HREF="#printing-options">2.2.4</A>).</P><H3 CLASS="subsection"><A NAME="htoc30">2.2.3</A>  Irrefutable patterns: the destructuring <TT>let</TT> variants 
<A NAME="@default70"></A>
<A NAME="Letin"></A></H3><P>Pattern-matching on terms inhabiting inductive type having only one
constructor can be alternatively written using <TT>let ... in ...</TT>
constructions. There are two variants of them.</P><H4 CLASS="subsubsection">First destructuring <TT>let</TT> syntax</H4><P>
The expression <TT>let
(</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>,&#X2026;,<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> <TT>) :=</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>0</SUB> <TT>in</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> performs case analysis on a <I><FONT COLOR=maroon>term</FONT></I><SUB>0</SUB> which must be in
an inductive type with one constructor having itself <I>n</I> arguments. Variables
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> are bound to the <I>n</I> arguments of the
constructor in expression <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>. For instance, the definition</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition fst (A B:Set) (H:A * B) := match H with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                                       | pair x y =</TT><TT>&gt;</TT><TT> x</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                                       end.</TT><BR>
<TT><I>fst is defined</I></TT><BR>
</DIV><P>can be alternatively written </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition fst (A B:Set) (p:A * B) := let (x, _) := p in x.</TT><BR>
<TT><I>fst is defined</I></TT><BR>
</DIV><P>

Notice that reduction is different from regular <TT>let ... in ...</TT>
construction since it happens only if <I><FONT COLOR=maroon>term</FONT></I><SUB>0</SUB> is in constructor
form. Otherwise, the reduction is blocked.</P><P>The pretty-printing of a definition by matching on a
irrefutable pattern can either be done using <TT>match</TT> or the <TT>let</TT> construction (see Section <A HREF="#printing-options">2.2.4</A>).</P><P>If <I><FONT COLOR=maroon>term</FONT></I> inhabits an inductive type with one constructor <TT>C</TT>,
we have an equivalence between</P><P><TT>let (</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>,&#X2026;,</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>) </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>dep_ret_type</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>term</FONT></I><TT>&#X2019;</TT></P><P>and</P><P><TT>match </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>dep_ret_type</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> with C </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> </TT><CODE><TT>=&gt;</TT></CODE><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT>&#X2019; end</TT></P><H4 CLASS="subsubsection">Second destructuring <TT>let</TT> syntax<A NAME="@default71"></A></H4><P>Another destructuring <TT>let</TT> syntax is available for inductive types with
one constructor by giving an arbitrary pattern instead of just a tuple
for all the arguments. For example, the preceding example can be written:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition fst (A B:Set) (p:A*B) := let &#X2019;pair x _ := p in x.</TT><BR>
<TT><I>fst is defined</I></TT><BR>
</DIV><P>This is useful to match deeper inside tuples and also to use notations
for the pattern, as the syntax <TT>let &#X2019;p := t in b</TT> allows arbitrary
patterns to do the deconstruction. For example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition deep_tuple (A:Set) (x:(A*A)*(A*A)) : A*A*A*A :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   let &#X2019;((a,b), (c, d)) := x in (a,b,c,d).</TT><BR>
<TT><I>deep_tuple is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Notation " x &#X2019;with&#X2019; p " := (exist _ x p) (at level 20).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition proj1_sig&#X2019; (A:Set) (P:A-</TT><TT>&gt;</TT><TT>Prop) (t:{ x:A | P x }) : A :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   let &#X2019;x with p := t in x.</TT><BR>
<TT><I>proj1_sig&#X2019; is defined</I></TT><BR>
</DIV><P>When printing definitions which are written using this construct it
takes precedence over <TT>let</TT> printing directives for the datatype
under consideration (see Section <A HREF="#printing-options">2.2.4</A>).</P><H3 CLASS="subsection"><A NAME="htoc31">2.2.4</A>  Controlling pretty-printing of <TT>match</TT> expressions
<A NAME="printing-options"></A></H3><P>The following commands give some control over the pretty-printing of
<TT>match</TT> expressions.</P><H4 CLASS="subsubsection">Printing nested patterns
<A NAME="SetPrintingMatching"></A>
<A NAME="@default72"></A><A NAME="@command29"></A>
<A NAME="@default73"></A><A NAME="@command30"></A>
<A NAME="@default74"></A><A NAME="@command31"></A></H4><P>The Calculus of Inductive Constructions knows pattern-matching only
over simple patterns. It is however convenient to re-factorize nested
pattern-matching into a single pattern-matching over a nested pattern.
<SPAN STYLE="font-variant:small-caps">Coq</SPAN>&#X2019;s printer try to do such limited re-factorization.</P><BLOCKQUOTE CLASS="quote">
<TT>Set Printing Matching.</TT>
</BLOCKQUOTE><P>
This tells <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to try to use nested patterns. This is the default
behavior.</P><BLOCKQUOTE CLASS="quote">
<TT>Unset Printing Matching.</TT>
</BLOCKQUOTE><P>
This tells <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to print only simple pattern-matching problems in
the same way as the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> kernel handles them.</P><BLOCKQUOTE CLASS="quote">
<TT>Test Printing Matching.</TT>
</BLOCKQUOTE><P>
This tells if the printing matching mode is on or off. The default is
on.</P><H4 CLASS="subsubsection">Printing of wildcard pattern
<A NAME="@default75"></A><A NAME="@command32"></A>
<A NAME="@default76"></A><A NAME="@command33"></A>
<A NAME="@default77"></A><A NAME="@command34"></A></H4><P>Some variables in a pattern may not occur in the right-hand side of
the pattern-matching clause. There are options to control the
display of these variables.</P><BLOCKQUOTE CLASS="quote">
<TT>Set Printing Wildcard.</TT>
</BLOCKQUOTE><P>
The variables having no occurrences in the right-hand side of the
pattern-matching clause are just printed using the wildcard symbol
&#X201C;<TT>_</TT>&#X201D;.</P><BLOCKQUOTE CLASS="quote">
<TT>Unset Printing Wildcard.</TT>
</BLOCKQUOTE><P>
The variables, even useless, are printed using their usual name. But some
non dependent variables have no name. These ones are still printed
using a &#X201C;<TT>_</TT>&#X201D;.</P><BLOCKQUOTE CLASS="quote">
<TT>Test Printing Wildcard.</TT>
</BLOCKQUOTE><P>
This tells if the wildcard printing mode is on or off. The default is
to print wildcard for useless variables.</P><H4 CLASS="subsubsection">Printing of the elimination predicate
<A NAME="@default78"></A><A NAME="@command35"></A>
<A NAME="@default79"></A><A NAME="@command36"></A>
<A NAME="@default80"></A><A NAME="@command37"></A></H4><P>In most of the cases, the type of the result of a matched term is
mechanically synthesizable. Especially, if the result type does not
depend of the matched term.</P><BLOCKQUOTE CLASS="quote">
<TT>Set Printing Synth.</TT>
</BLOCKQUOTE><P>
The result type is not printed when <SPAN STYLE="font-variant:small-caps">Coq</SPAN> knows that it can
re-synthesize it.</P><BLOCKQUOTE CLASS="quote">
<TT>Unset Printing Synth.</TT>
</BLOCKQUOTE><P>
This forces the result type to be always printed.</P><BLOCKQUOTE CLASS="quote">
<TT>Test Printing Synth.</TT>
</BLOCKQUOTE><P>
This tells if the non-printing of synthesizable types is on or off.
The default is to not print synthesizable types.</P><H4 CLASS="subsubsection">Printing matching on irrefutable pattern
<A NAME="@default81"></A><A NAME="@command38"></A>
<A NAME="@default82"></A><A NAME="@command39"></A>
<A NAME="@default83"></A><A NAME="@command40"></A>
<A NAME="@default84"></A><A NAME="@command41"></A></H4><P>If an inductive type has just one constructor,
pattern-matching can be written using <TT>let</TT> ... <TT>:=</TT>
... <TT>in</TT> ...</P><BLOCKQUOTE CLASS="quote">
<TT>Add Printing Let </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE><P>
This adds <I><FONT COLOR=maroon>ident</FONT></I> to the list of inductive types for which
pattern-matching is written using a <TT>let</TT> expression.</P><BLOCKQUOTE CLASS="quote">
<TT>Remove Printing Let </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE><P>
This removes <I><FONT COLOR=maroon>ident</FONT></I> from this list.</P><BLOCKQUOTE CLASS="quote">
<TT>Test Printing Let for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE><P>
This tells if <I><FONT COLOR=maroon>ident</FONT></I> belongs to the list.</P><BLOCKQUOTE CLASS="quote">
<TT>Print Table Printing Let.</TT>
</BLOCKQUOTE><P>
This prints the list of inductive types for which pattern-matching is
written using a <TT>let</TT> expression.</P><P>The list of inductive types for which pattern-matching is written
using a <TT>let</TT> expression is managed synchronously. This means that
it is sensible to the command <TT>Reset</TT>.</P><H4 CLASS="subsubsection">Printing matching on booleans
<A NAME="@default85"></A><A NAME="@command42"></A>
<A NAME="@default86"></A><A NAME="@command43"></A>
<A NAME="@default87"></A><A NAME="@command44"></A>
<A NAME="@default88"></A><A NAME="@command45"></A></H4><P>If an inductive type is isomorphic to the boolean type,
pattern-matching can be written using <TT>if</TT> ... <TT>then</TT> ... <TT>else</TT> ...</P><BLOCKQUOTE CLASS="quote">
<TT>Add Printing If </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE><P>
This adds <I><FONT COLOR=maroon>ident</FONT></I> to the list of inductive types for which
pattern-matching is written using an <TT>if</TT> expression.</P><BLOCKQUOTE CLASS="quote">
<TT>Remove Printing If </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE><P>
This removes <I><FONT COLOR=maroon>ident</FONT></I> from this list.</P><BLOCKQUOTE CLASS="quote">
<TT>Test Printing If for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE><P>
This tells if <I><FONT COLOR=maroon>ident</FONT></I> belongs to the list.</P><BLOCKQUOTE CLASS="quote">
<TT>Print Table Printing If.</TT>
</BLOCKQUOTE><P>
This prints the list of inductive types for which pattern-matching is
written using an <TT>if</TT> expression.</P><P>The list of inductive types for which pattern-matching is written
using an <TT>if</TT> expression is managed synchronously. This means that
it is sensible to the command <TT>Reset</TT>.</P><H4 CLASS="subsubsection">Example</H4><P>This example emphasizes what the printing options offer.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Test Printing Let for prod.</TT><BR>
<TT><I>Cases on elements of prod are printed using a &#X2018;let&#X2019; form</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print fst.</TT><BR>
<TT><I>fst = </I></TT><BR>
<TT><I>fun (A B : Set) (p : A * B) =</I></TT><TT><I>&gt;</I></TT><TT><I> let &#X2019;(x, _) := p in x</I></TT><BR>
<TT><I>     : forall A B : Set, A * B -</I></TT><TT><I>&gt;</I></TT><TT><I> A</I></TT><BR>
<TT><I>Argument scopes are [type_scope type_scope _]</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Remove Printing Let prod.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Unset Printing Synth.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Unset Printing Wildcard.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print fst.</TT><BR>
<TT><I>fst = </I></TT><BR>
<TT><I>fun (A B : Set) (p : A * B) =</I></TT><TT><I>&gt;</I></TT><TT><I> let &#X2019;(x, a) := p return A in x</I></TT><BR>
<TT><I>     : forall A B : Set, A * B -</I></TT><TT><I>&gt;</I></TT><TT><I> A</I></TT><BR>
<TT><I>Argument scopes are [type_scope type_scope _]</I></TT><BR>
</DIV><H2 CLASS="section"><A NAME="toc16"></A><A NAME="htoc32">2.3</A>  Advanced recursive functions</H2><P>The <EM>experimental</EM> command 
</P><DIV CLASS="center">
<TT>Function </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>
{decrease_annot} : type</TT><SUB><TT>0</TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>0</TT></SUB>
<A NAME="@default89"></A><A NAME="@command46"></A>
<A NAME="Function"></A>
</DIV><P>
can be seen as a generalization of <TT>Fixpoint</TT>. It is actually a
wrapper for several ways of defining a function <EM>and other useful
related objects</EM>, namely: an induction principle that reflects the
recursive structure of the function (see <A HREF="Reference-Manual011.html#FunInduction">8.7.7</A>), and its
fixpoint equality. The meaning of this
declaration is to define a function <I>ident</I>, similarly to <TT>Fixpoint</TT>. Like in <TT>Fixpoint</TT>, the decreasing argument must be
given (unless the function is not recursive), but it must not
necessary be <EM>structurally</EM> decreasing. The point of the <TT>{}</TT> annotation is to name the decreasing argument <EM>and</EM> to
describe which kind of decreasing criteria must be used to ensure
termination of recursive calls.</P><P>The <TT>Function</TT> construction enjoys also the <TT>with</TT> extension
to define mutually recursive definitions. However, this feature does
not work for non structural recursive functions. </P><P>See the documentation of <TT>functional induction</TT>
(see Section <A HREF="Reference-Manual011.html#FunInduction">8.7.7</A>) and <TT>Functional Scheme</TT>
(see Section <A HREF="Reference-Manual011.html#FunScheme">8.15</A> and <A HREF="Reference-Manual013.html#FunScheme-examples">10.4</A>) for how to use the
induction principle to easily reason about the function.</P><P><B>Remark: </B> To obtain the right principle, it is better
to put rigid parameters of the function as first arguments. For
example it is better to define plus like this:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Function plus (m n : nat) {struct n} : nat :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | 0 =</TT><TT>&gt;</TT><TT> m</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S p =</TT><TT>&gt;</TT><TT> S (plus m p)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
</DIV><P>

than like this:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Function plus (n m : nat) {struct n} : nat :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | 0 =</TT><TT>&gt;</TT><TT> m</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S p =</TT><TT>&gt;</TT><TT> S (plus p m)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
</DIV><H5 CLASS="paragraph">Limitations<A NAME="sec:Function-limitations"></A></H5><P>
<I><FONT COLOR=maroon>term</FONT></I><SUB>0</SUB> must be build as a <EM>pure pattern-matching tree</EM>
(<TT>match...with</TT>) with applications only <EM>at the end</EM> of
each branch. For now dependent cases are not treated.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>The recursive argument must be specified</TT><A NAME="@error12"></A>
</LI><LI CLASS="li-enumerate"><TT>No argument name </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@error13"></A>
</LI><LI CLASS="li-enumerate"><TT>Cannot use mutual definition with well-founded
recursion or measure</TT><A NAME="@error14"></A></LI><LI CLASS="li-enumerate"><TT>Cannot define graph for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2026;</TT><A NAME="@error15"></A> (warning)<P>The generation of the graph relation <TT>(R_</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>)</TT> used to
compute the induction scheme of <I><FONT COLOR=maroon>ident</FONT></I> raised a typing error. Only
the ident is defined, the induction scheme will not be generated.</P><P>This error happens generally when:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the definition uses pattern matching on dependent types, which
<TT>Function</TT> cannot deal with yet.
</LI><LI CLASS="li-itemize">the definition is not a <EM>pattern-matching tree</EM> as
explained above.
</LI></UL></LI><LI CLASS="li-enumerate"><TT>Cannot define principle(s) for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>&#X2026;</TT><A NAME="@error16"></A> (warning)<P>The generation of the graph relation <TT>(R_</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>)</TT> succeeded
but the induction principle could not be built. Only the ident is
defined. Please report.</P></LI><LI CLASS="li-enumerate"><TT>Cannot build functional inversion principle</TT><A NAME="@error17"></A> (warning)<P><TT>functional inversion</TT> will not be available for the
function.
</P></LI></OL><P><BR>
<B>See also: </B><A HREF="Reference-Manual011.html#FunScheme">8.15</A>, <A HREF="Reference-Manual013.html#FunScheme-examples">10.4</A>, <A HREF="Reference-Manual011.html#FunInduction">8.7.7</A></P><P>Depending on the <TT>{</TT><TT>&#X2026;</TT><TT>}</TT> annotation, different definition
mechanisms are used by <TT>Function</TT>. More precise description
given below.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT> Function </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>
: type</TT><SUB><TT>0</TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>0</TT></SUB><P>Defines the not recursive function <I><FONT COLOR=maroon>ident</FONT></I> as if declared with
<TT>Definition</TT>. Moreover the following are defined:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I><FONT COLOR=maroon>ident</FONT></I><TT>_rect</TT>, <I><FONT COLOR=maroon>ident</FONT></I><TT>_rec</TT> and <I><FONT COLOR=maroon>ident</FONT></I><TT>_ind</TT>,
which reflect the pattern matching structure of <I><FONT COLOR=maroon>term</FONT></I><SUB>0</SUB> (see the
documentation of <TT>Inductive</TT> <A HREF="Reference-Manual003.html#Inductive">1.3.3</A>);
</LI><LI CLASS="li-itemize">The inductive <TT>R_</TT><I><FONT COLOR=maroon>ident</FONT></I> corresponding to the graph of
<I><FONT COLOR=maroon>ident</FONT></I> (silently);
</LI><LI CLASS="li-itemize"><I><FONT COLOR=maroon>ident</FONT></I><TT>_complete</TT> and <I><FONT COLOR=maroon>ident</FONT></I><TT>_correct</TT> which are
inversion information linking the function and its graph.
</LI></UL></LI><LI CLASS="li-enumerate"><TT>Function </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>
</TT><TT>{</TT><TT>struct</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>0</TT></SUB><TT>}</TT><TT> : type</TT><SUB><TT>0</TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>0</TT></SUB><P>Defines the structural recursive function <I><FONT COLOR=maroon>ident</FONT></I> as if declared
with <TT>Fixpoint</TT>. Moreover the following are defined:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The same objects as above;
</LI><LI CLASS="li-itemize">The fixpoint equation of <I><FONT COLOR=maroon>ident</FONT></I>: <I><FONT COLOR=maroon>ident</FONT></I><TT>_equation</TT>.
</LI></UL></LI><LI CLASS="li-enumerate"><TT>Function </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> </TT><TT>{</TT><TT>measure </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>0</TT></SUB><TT>}</TT><TT> : type</TT><SUB><TT>0</TT></SUB><TT> :=
</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>0</TT></SUB>
</LI><LI CLASS="li-enumerate"><TT>Function </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>binder</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>
</TT><TT>{</TT><TT>wf </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>0</TT></SUB><TT>}</TT><TT> : type</TT><SUB><TT>0</TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>0</TT></SUB><P>Defines a recursive function by well founded recursion. <B>The
module </B><B><TT>Recdef</TT></B><B> of the standard library must be loaded for this
feature</B>. The <TT>{}</TT> annotation is mandatory and must be one of
the following:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>{measure</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB><TT>}</TT> with <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB>
being the decreasing argument and <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> being a function
from type of <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> to <TT>nat</TT> for which value on the
decreasing argument decreases (for the <TT>lt</TT> order on <TT>nat</TT>) at each recursive call of <I><FONT COLOR=maroon>term</FONT></I><SUB>0</SUB>, parameters of the
function are bound in <I><FONT COLOR=maroon>term</FONT></I><SUB>0</SUB>;
</LI><LI CLASS="li-itemize"><TT>{wf</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB><TT>}</TT> with <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> being
the decreasing argument and <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> an ordering relation on
the type of <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> (i.e. of type T<SUB><I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB></SUB>
&#X2192; T<SUB><I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB></SUB> &#X2192; <TT>Prop</TT>) for which
the decreasing argument decreases at each recursive call of
<I><FONT COLOR=maroon>term</FONT></I><SUB>0</SUB>. The order must be well founded. parameters of the
function are bound in <I><FONT COLOR=maroon>term</FONT></I><SUB>0</SUB>.
</LI></UL><P>Depending on the annotation, the user is left with some proof
obligations that will be used to define the function. These proofs
are: proofs that each recursive call is actually decreasing with
respect to the given criteria, and (if the criteria is <TT>wf</TT>) a
proof that the ordering relation is well founded.</P><P>Once proof obligations are discharged, the following objects are
defined:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The same objects as with the <TT>struct</TT>;
</LI><LI CLASS="li-itemize">The lemma <I><FONT COLOR=maroon>ident</FONT></I><TT>_tcc</TT> which collects all proof
obligations in one property;
</LI><LI CLASS="li-itemize">The lemmas <I><FONT COLOR=maroon>ident</FONT></I><TT>_terminate</TT> and <I><FONT COLOR=maroon>ident</FONT></I><TT>_F</TT>
which is needed to be inlined during extraction of <I><FONT COLOR=maroon>ident</FONT></I>.
</LI></UL><P>The way this recursive function is defined is the subject of several
papers by Yves Bertot and Antonia Balaa on the one hand, and Gilles Barthe,
Julien Forest, David Pichardie, and Vlad Rusu on the other hand.</P><P><BR>
<BR>
</P><P><B>Remark: </B> Proof obligations are presented as several
subgoals belonging to a Lemma <I><FONT COLOR=maroon>ident</FONT></I><TT>_tcc</TT>. </P></LI></OL><H2 CLASS="section"><A NAME="toc17"></A><A NAME="htoc33">2.4</A>  Section mechanism
<A NAME="@default90"></A>
<A NAME="Section"></A></H2><P>The sectioning mechanism allows to organize a proof in structured
sections. Then local declarations become available (see
Section <A HREF="Reference-Manual003.html#Basic-definitions">1.3.2</A>).</P><H3 CLASS="subsection"><A NAME="htoc34">2.4.1</A>  <TT>Section </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default91"></A><A NAME="@command47"></A></H3><P>This command is used to open a section named <I><FONT COLOR=maroon>ident</FONT></I>.</P><H3 CLASS="subsection"><A NAME="htoc35">2.4.2</A>  <TT>End </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default92"></A><A NAME="@command48"></A></H3><P>This command closes the section named <I><FONT COLOR=maroon>ident</FONT></I>. After closing of the
section, the local declarations (variables and local definitions) get
<EM>discharged</EM>, meaning that they stop being visible and that all
global objects defined in the section are generalized with respect to
the variables and local definitions they each depended on in the
section.</P><P>Here is an example :

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section s1.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variables x y : nat.</TT><BR>
<TT><I>x is assumed</I></TT><BR>
<TT><I>y is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Let y&#X2019; := y.</TT><BR>
<TT><I>y&#X2019; is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition x&#X2019; := S x.</TT><BR>
<TT><I>x&#X2019; is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition x&#X2019;&#X2019; := x&#X2019; + y&#X2019;.</TT><BR>
<TT><I>x&#X201D; is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print x&#X2019;.</TT><BR>
<TT><I>x&#X2019; = S x</I></TT><BR>
<TT><I>     : nat</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End s1.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print x&#X2019;.</TT><BR>
<TT><I>x&#X2019; = fun x : nat =</I></TT><TT><I>&gt;</I></TT><TT><I> S x</I></TT><BR>
<TT><I>     : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>Argument scope is [nat_scope]</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print x&#X2019;&#X2019;.</TT><BR>
<TT><I>x&#X201D; = fun x y : nat =</I></TT><TT><I>&gt;</I></TT><TT><I> let y&#X2019; := y in x&#X2019; x + y&#X2019;</I></TT><BR>
<TT><I>     : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>Argument scopes are [nat_scope nat_scope]</I></TT><BR>
</DIV><P>

Notice the difference between the value of <TT>x&#X2019;</TT> and <TT>x&#X2019;&#X2019;</TT>
inside section <TT>s1</TT> and outside.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>This is not the last opened section</TT><A NAME="@error18"></A>
</LI></OL><P><BR>
<B>Remarks: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Most commands, like <TT>Hint</TT>, <TT>Notation</TT>, option management, ...
which appear inside a section are canceled when the
section is closed.
</LI></OL><H2 CLASS="section"><A NAME="toc18"></A><A NAME="htoc36">2.5</A>  Module system
<A NAME="@default93"></A>
<A NAME="section:Modules"></A></H2><P>The module system provides a way of packaging related elements
together, as well as a mean of massive abstraction.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I><FONT COLOR=maroon>module_type</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>qualid</FONT></I></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>module_type</FONT></I> <TT> with Definition </TT><I><FONT COLOR=maroon>qualid</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>module_type</FONT></I> <TT> with Module </TT><I><FONT COLOR=maroon>qualid</FONT></I> := <I><FONT COLOR=maroon>qualid</FONT></I></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>qualid</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>qualid</FONT></I></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP>!<I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>qualid</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>qualid</FONT></I></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><FONT COLOR=maroon>module_binding</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><TT>( [Import|Export] </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>  </TT><TT>&#X2026;</TT><TT>  </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>module_type</FONT></I><TT> )</TT></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><FONT COLOR=maroon>module_bindings</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>module_binding</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>module_binding</FONT></I></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>
<I><FONT COLOR=maroon>module_expression</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>qualid</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>qualid</FONT></I></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP>!<I><FONT COLOR=maroon>qualid</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>qualid</FONT></I></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.3: Syntax of modules</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>In the syntax of module application, the ! prefix indicates that
any <TT>Inline</TT> directive in the type of the functor arguments
will be ignored (see <A HREF="#Inline">2.5.4</A> below).</P><H3 CLASS="subsection"><A NAME="htoc37">2.5.1</A>  <TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default94"></A><A NAME="@command49"></A></H3><P>This command is used to start an interactive module named <I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><P>Starts an interactive functor with parameters given by <I><FONT COLOR=maroon>module_bindings</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><CODE><TT>:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><P>Starts an interactive module specifying its module type. </P></LI><LI CLASS="li-enumerate"><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><P>Starts an interactive functor with parameters given by
<I><FONT COLOR=maroon>module_bindings</FONT></I>, and output module type <I><FONT COLOR=maroon>module_type</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><TT>&#X2026;</TT><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><SUB><TT><I>n</I></TT></SUB><P>Starts an interactive module satisfying each <I><FONT COLOR=maroon>module_type</FONT></I><SUB><I>i</I></SUB>. </P></LI><LI CLASS="li-enumerate"><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><TT>&#X2026;</TT><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><SUB><TT><I>n</I></TT></SUB><P>Starts an interactive functor with parameters given by
<I><FONT COLOR=maroon>module_bindings</FONT></I>. The output module type is verified against each
module type <I><FONT COLOR=maroon>module_type</FONT></I><SUB><I>i</I></SUB>.</P></LI><LI CLASS="li-enumerate"><TT>Module [Import|Export]</TT><P>Behaves like <TT>Module</TT>, but automatically imports or exports
the module.</P></LI></OL><H4 CLASS="subsubsection">Reserved commands inside an interactive module:
<A NAME="@default95"></A><A NAME="@command50"></A></H4><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Include </TT><I><FONT COLOR=maroon>module</FONT></I><P>Includes the content of <I><FONT COLOR=maroon>module</FONT></I> in the current interactive
module. Here <I><FONT COLOR=maroon>module</FONT></I> can be a module expresssion or a module type
expression. If <I><FONT COLOR=maroon>module</FONT></I> is a high-order module or module type
expression then the system tries to instanciate <I><FONT COLOR=maroon>module</FONT></I>
by the current interactive module.</P></LI><LI CLASS="li-enumerate"><TT>Include </TT><I><FONT COLOR=maroon>module</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><CODE><TT>&lt;+</TT></CODE><TT> </TT><TT>&#X2026;</TT><TT> </TT><CODE><TT>&lt;+</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module</FONT></I><SUB><TT><I>n</I></TT></SUB> <P>is a shortcut for <TT>Include </TT><I><FONT COLOR=maroon>module</FONT></I><SUB><TT>1</TT></SUB> &#X2026; <TT>Include </TT><I><FONT COLOR=maroon>module</FONT></I><SUB><TT><I>n</I></TT></SUB>
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc38">2.5.2</A>  <TT>End </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default96"></A><A NAME="@command51"></A></H3><P>This command closes the interactive module <I><FONT COLOR=maroon>ident</FONT></I>. If the module type
was given the content of the module is matched against it and an error
is signaled if the matching fails. If the module is basic (is not a
functor) its components (constants, inductive types, submodules etc) are
now available through the dot notation.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>No such label </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@error19"></A>
</LI><LI CLASS="li-enumerate"><TT>Signature components for label </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> do not match</TT><A NAME="@error20"></A>
</LI><LI CLASS="li-enumerate"><TT>This is not the last opened module</TT><A NAME="@error21"></A>
</LI></OL><H3 CLASS="subsection"><A NAME="htoc39">2.5.3</A>  <TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> := </TT><I><FONT COLOR=maroon>module_expression</FONT></I><TT>
</TT><A NAME="@default97"></A><A NAME="@command52"></A></H3><P>This command defines the module identifier <I><FONT COLOR=maroon>ident</FONT></I> to be equal to
<I><FONT COLOR=maroon>module_expression</FONT></I>. </P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> := </TT><I><FONT COLOR=maroon>module_expression</FONT></I><P>Defines a functor with parameters given by <I><FONT COLOR=maroon>module_bindings</FONT></I> and body <I><FONT COLOR=maroon>module_expression</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><TT> :=
</TT><I><FONT COLOR=maroon>module_expression</FONT></I><P>Defines a functor with parameters given by <I><FONT COLOR=maroon>module_bindings</FONT></I> (possibly none),
and output module type <I><FONT COLOR=maroon>module_type</FONT></I>, with body <I><FONT COLOR=maroon>module_expression</FONT></I>. </P></LI><LI CLASS="li-enumerate"><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><TT>&#X2026;</TT><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>:=
</TT><I><FONT COLOR=maroon>module_expression</FONT></I><P>Defines a functor with parameters given by <I><FONT COLOR=maroon>module_bindings</FONT></I> (possibly none) 
with body <I><FONT COLOR=maroon>module_expression</FONT></I>. The body is checked against each <I><FONT COLOR=maroon>module_type</FONT></I><SUB><I>i</I></SUB>.</P></LI><LI CLASS="li-enumerate"><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> := </TT><I><FONT COLOR=maroon>module_expression</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><CODE><TT>&lt;+</TT></CODE><TT> </TT><TT>&#X2026;</TT><TT> </TT><CODE><TT>&lt;+</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_expression</FONT></I><SUB><TT><I>n</I></TT></SUB><P>is equivalent to an interactive module where each <I><FONT COLOR=maroon>module_expression</FONT></I><SUB><I>i</I></SUB> are included.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc40">2.5.4</A>  <TT>Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default98"></A><A NAME="@command53"></A></H3><P>This command is used to start an interactive module type <I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><P>Starts an interactive functor type with parameters given by <I><FONT COLOR=maroon>module_bindings</FONT></I>.</P></LI></OL><H4 CLASS="subsubsection">Reserved commands inside an interactive module type:
<A NAME="@default99"></A><A NAME="@command54"></A><A NAME="@default100"></A><A NAME="@command55"></A></H4><P>
<A NAME="Inline"></A>
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Include </TT><I><FONT COLOR=maroon>module</FONT></I><P>Same as <TT>Include</TT> inside a module.</P></LI><LI CLASS="li-enumerate"><TT>Include </TT><I><FONT COLOR=maroon>module</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><CODE><TT>&lt;+</TT></CODE><TT> </TT><TT>&#X2026;</TT><TT> </TT><CODE><TT>&lt;+</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module</FONT></I><SUB><TT><I>n</I></TT></SUB> <P>is a shortcut for <TT>Include </TT><I><FONT COLOR=maroon>module</FONT></I><SUB><TT>1</TT></SUB> &#X2026; <TT>Include </TT><I><FONT COLOR=maroon>module</FONT></I><SUB><TT><I>n</I></TT></SUB></P></LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>assumption_keyword</FONT></I><TT> Inline </TT><I><FONT COLOR=maroon>assums</FONT></I><TT> </TT><P>The instance of this assumption will be automatically expanded at functor
application, except when this functor application is prefixed by a ! annotation.
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc41">2.5.5</A>  <TT>End </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default101"></A><A NAME="@command56"></A></H3><P>This command closes the interactive module type <I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>This is not the last opened module type</TT><A NAME="@error22"></A>
</LI></OL><H3 CLASS="subsection"><A NAME="htoc42">2.5.6</A>  <TT>Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> := </TT><I><FONT COLOR=maroon>module_type</FONT></I></H3><P>Defines a module type <I><FONT COLOR=maroon>ident</FONT></I> equal to <I><FONT COLOR=maroon>module_type</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> := </TT><I><FONT COLOR=maroon>module_type</FONT></I><P>Defines a functor type <I><FONT COLOR=maroon>ident</FONT></I> specifying functors taking arguments
<I><FONT COLOR=maroon>module_bindings</FONT></I> and returning <I><FONT COLOR=maroon>module_type</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> := </TT><I><FONT COLOR=maroon>module_type</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><CODE><TT>&lt;+</TT></CODE><TT> </TT><TT>&#X2026;</TT><TT> </TT><CODE><TT>&lt;+</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><SUB><TT><I>n</I></TT></SUB><P>is equivalent to an interactive module type were each <I><FONT COLOR=maroon>module_type</FONT></I><SUB><I>i</I></SUB> are included.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc43">2.5.7</A>  <TT>Declare Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>module_type</FONT></I></H3><P>Declares a module <I><FONT COLOR=maroon>ident</FONT></I> of type <I><FONT COLOR=maroon>module_type</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Declare Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><P>Declares a functor with parameters <I><FONT COLOR=maroon>module_bindings</FONT></I> and output module
type <I><FONT COLOR=maroon>module_type</FONT></I>.</P></LI></OL><H4 CLASS="subsubsection">Example</H4><P>Let us define a simple module.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Module M.</TT><BR>
<TT><I>Interactive Module M started</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Definition T := nat.</TT><BR>
<TT><I>T is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Definition x := 0.</TT><BR>
<TT><I>x is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Definition y : bool.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   bool</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     exact true.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Defined.</TT><BR>
<TT><I>exact true.</I></TT><BR>
<TT><I>y is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End M.</TT><BR>
<TT><I>Module M is defined</I></TT><BR>
</DIV><P>

Inside a module one can define constants, prove theorems and do any
other things that can be done in the toplevel. Components of a closed
module can be accessed using the dot notation:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Print M.x.</TT><BR>
<TT><I>M.x = 0</I></TT><BR>
<TT><I>     : nat</I></TT><BR>
</DIV><P>

A simple module type:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Module Type SIG.</TT><BR>
<TT><I>Interactive Module Type SIG started</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Parameter T : Set.</TT><BR>
<TT><I>T is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Parameter x : T.</TT><BR>
<TT><I>x is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End SIG.</TT><BR>
<TT><I>Module Type SIG is defined</I></TT><BR>
</DIV><P>Now we can create a new module from <TT>M</TT>, giving it a less
precise specification: the <TT>y</TT> component is dropped as well
as the body of <TT>x</TT>.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Module N  :  SIG with Definition T := nat  :=  M.</TT><BR>
<TT><I>Coq </I></TT><TT><I>&lt;</I></TT><TT><I> Coq </I></TT><TT><I>&lt;</I></TT><TT><I> Module N is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print N.T.</TT><BR>
<TT><I>N.T = nat</I></TT><BR>
<TT><I>     : Set</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print N.x.</TT><BR>
<TT><I>*** [ N.x : N.T ]</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print N.y.</TT><BR>
<TT><I>Error: N.y not a defined object.</I></TT><BR>
</DIV><P>The definition of <TT>N</TT> using the module type expression
<TT>SIG with Definition T:=nat</TT> is equivalent to the following
one:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Module Type SIG&#X2019;.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Definition T : Set := nat.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Parameter x : T.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End SIG&#X2019;.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Module N : SIG&#X2019; := M.</TT><BR>
</DIV><P>

If we just want to be sure that the our implementation satisfies a
given module type without restricting the interface, we can use a
transparent constraint

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Module P </TT><TT>&lt;</TT><TT>: SIG := M.</TT><BR>
<TT><I>Module P is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print P.y.</TT><BR>
<TT><I>P.y = true</I></TT><BR>
<TT><I>     : bool</I></TT><BR>
</DIV><P>

Now let us create a functor, i.e. a parametric module

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Module Two (X Y: SIG).</TT><BR>
<TT><I>Interactive Module Two started</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Definition T := (X.T * Y.T)%type.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Definition x := (X.x, Y.x).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End Two.</TT><BR>
<TT><I>Module Two is defined</I></TT><BR>
</DIV><P>

and apply it to our modules and do some computations

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Module Q := Two M N.</TT><BR>
<TT><I>Module Q is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Eval compute in (fst Q.x + snd Q.x).</TT><BR>
<TT><I>     = N.x</I></TT><BR>
<TT><I>     : nat</I></TT><BR>
</DIV><P>

In the end, let us define a module type with two sub-modules, sharing
some of the fields and give one of its possible implementations:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Module Type SIG2.</TT><BR>
<TT><I>Interactive Module Type SIG2 started</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Declare Module M1 : SIG.</TT><BR>
<TT><I>Module M1 is declared</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Module M2 </TT><TT>&lt;</TT><TT>: SIG.</TT><BR>
<TT><I>Interactive Module M2 started</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     Definition T := M1.T.</TT><BR>
<TT><I>T is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     Parameter x : T.</TT><BR>
<TT><I>x is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   End M2.</TT><BR>
<TT><I>Module M2 is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End SIG2.</TT><BR>
<TT><I>Module Type SIG2 is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Module Mod </TT><TT>&lt;</TT><TT>: SIG2.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Module M1.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     Definition T := nat.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     Definition x := 1.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   End M1.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Module M2 := M.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End Mod.</TT><BR>
<TT><I>Module Mod is defined</I></TT><BR>
</DIV><P>

Notice that <TT>M</TT> is a correct body for the component <TT>M2</TT>
since its <TT>T</TT> component is equal <TT>nat</TT> and hence
<TT>M1.T</TT> as specified.</P><P><BR>
<B>Remarks: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Modules and module types can be nested components of each other.
</LI><LI CLASS="li-enumerate">One can have sections inside a module or a module type, but
not a module or a module type inside a section.
</LI><LI CLASS="li-enumerate">Commands like <TT>Hint</TT> or <TT>Notation</TT> can
also appear inside modules and module types. Note that in case of a
module definition like:<P><BR>
<TT>Module N : SIG := M.</TT> 
<BR>
</P><P>or</P><P><BR>
<TT>Module N : SIG.<BR>
   &#X2026;<BR>
 End N.</TT>
<BR>
</P><P>hints and the like valid for <TT>N</TT> are not those defined in
<TT>M</TT> (or the module body) but the ones defined in
<TT>SIG</TT>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc44">2.5.8</A>  <TT>Import </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>
</TT><A NAME="@default102"></A><A NAME="@command57"></A><TT>
</TT><A NAME="Import"></A></H3><P>If <I><FONT COLOR=maroon>qualid</FONT></I> denotes a valid basic module (i.e. its module type is a
signature), makes its components available by their short names.</P><P>Example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Module Mod.</TT><BR>
<TT><I>Interactive Module Mod started</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Definition T:=nat.</TT><BR>
<TT><I>T is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Check T.</TT><BR>
<TT><I>T</I></TT><BR>
<TT><I>     : Set</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End Mod.</TT><BR>
<TT><I>Module Mod is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check Mod.T.</TT><BR>
<TT><I>Mod.T</I></TT><BR>
<TT><I>     : Set</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check T. (* Incorrect ! *)</TT><BR>
<TT><I>Toplevel input, characters 6-7:</I></TT><BR>
<TT><I>&gt;</I></TT><TT><I> Check T.</I></TT><BR>
<TT><I>&gt;</I></TT><TT><I>       </I></TT><TT><I>^</I></TT><BR>
<TT><I>Error: The reference T was not found in the current environment.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Import Mod.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check T. (* Now correct *)</TT><BR>
<TT><I>T</I></TT><BR>
<TT><I>     : Set</I></TT><BR>
</DIV><P>Some features defined in modules are activated only when a module is
imported. This is for instance the case of notations (see
Section <A HREF="Reference-Manual015.html#Notation">12.1</A>).</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Export </TT><I><FONT COLOR=maroon>qualid</FONT></I><A NAME="@default103"></A><A NAME="@command58"></A><P>When the module containing the command <TT>Export </TT><I><FONT COLOR=maroon>qualid</FONT></I> is
imported, <I><FONT COLOR=maroon>qualid</FONT></I> is imported as well.
</P></LI></OL><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<I><FONT COLOR=maroon>qualid</FONT></I><TT> is not a module</TT><A NAME="@error23"></A>
</LI></OL><P><BR>
<B>Warnings: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Warning: Trying to mask the absolute name <I><FONT COLOR=maroon>qualid</FONT></I> !
</LI></OL><H3 CLASS="subsection"><A NAME="htoc45">2.5.9</A>  <TT>Print Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default104"></A><A NAME="@command59"></A></H3><P>Prints the module type and (optionally) the body of the module <I><FONT COLOR=maroon>ident</FONT></I>.</P><H3 CLASS="subsection"><A NAME="htoc46">2.5.10</A>  <TT>Print Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default105"></A><A NAME="@command60"></A></H3><P>Prints the module type corresponding to <I><FONT COLOR=maroon>ident</FONT></I>.</P><H3 CLASS="subsection"><A NAME="htoc47">2.5.11</A>  <TT>Locate Module </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>
</TT><A NAME="@default106"></A><A NAME="@command61"></A></H3><P>Prints the full name of the module <I><FONT COLOR=maroon>qualid</FONT></I>.</P><H2 CLASS="section"><A NAME="toc19"></A><A NAME="htoc48">2.6</A>  Libraries and qualified names</H2><H3 CLASS="subsection"><A NAME="htoc49">2.6.1</A>  Names of libraries and files
<A NAME="Libraries"></A>
<A NAME="@default107"></A>
<A NAME="@default108"></A>
<A NAME="@default109"></A></H3><H5 CLASS="paragraph">Libraries</H5><P>The theories developed in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> are stored in <EM>library files</EM>
which are hierarchically classified into <EM>libraries</EM> and <EM>sublibraries</EM>. To express this hierarchy, library names are
represented by qualified identifiers <I><FONT COLOR=maroon>qualid</FONT></I>, i.e. as list of
identifiers separated by dots (see Section <A HREF="Reference-Manual003.html#qualid">1.2.3</A>). For
instance, the library file <TT>Mult</TT> of the standard <SPAN STYLE="font-variant:small-caps">Coq</SPAN> library
<TT>Arith</TT> has name <TT>Coq.Arith.Mult</TT>. The identifier
that starts the name of a library is called a <EM>library root</EM>.
All library files of the standard library of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> have reserved root
<TT>Coq</TT> but library file names based on other roots can be obtained
by using <TT>coqc</TT> options <TT>-I</TT> or <TT>-R</TT> (see
Section <A HREF="Reference-Manual017.html#coqoptions">13.5</A>). Also, when an interactive <SPAN STYLE="font-variant:small-caps">Coq</SPAN> session
starts, a library of root <TT>Top</TT> is started, unless option <TT>-top</TT> or <TT>-notop</TT> is set (see Section <A HREF="Reference-Manual017.html#coqoptions">13.5</A>).</P><P>As library files are stored on the file system of the underlying
operating system, a translation from file-system names to <SPAN STYLE="font-variant:small-caps">Coq</SPAN> names
is needed. In this translation, names in the file system are called
<EM>physical</EM> paths while <SPAN STYLE="font-variant:small-caps">Coq</SPAN> names are contrastingly called <EM>logical</EM> names. Logical names are mapped to physical paths using the
commands <TT>Add LoadPath</TT> or <TT>Add Rec LoadPath</TT> (see
Sections <A HREF="Reference-Manual009.html#AddLoadPath">6.6.3</A> and <A HREF="Reference-Manual009.html#AddRecLoadPath">6.6.4</A>).</P><H3 CLASS="subsection"><A NAME="htoc50">2.6.2</A>  Qualified names
<A NAME="LongNames"></A>
<A NAME="@default110"></A>
<A NAME="@default111"></A></H3><P>Library files are modules which possibly contain submodules which
eventually contain constructions (axioms, parameters, definitions,
lemmas, theorems, remarks or facts). The <EM>absolute name</EM>, or <EM>full name</EM>, of a construction in some library file is a qualified
identifier starting with the logical name of the library file,
followed by the sequence of submodules names encapsulating the
construction and ended by the proper name of the construction.
Typically, the absolute name <TT>Coq.Init.Logic.eq</TT> denotes Leibniz&#X2019;
equality defined in the module <TT>Logic</TT> in the sublibrary <TT>Init</TT> of the standard library of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P><P>The proper name that ends the name of a construction is the <I>short
name</I> (or sometimes <I>base name</I>) of the construction (for
instance, the short name of <TT>Coq.Init.Logic.eq</TT> is <TT>eq</TT>). Any
partial suffix of the absolute name is a <EM>partially qualified name</EM>
(e.g. <TT>Logic.eq</TT> is a partially qualified name for <TT>Coq.Init.Logic.eq</TT>). Especially, the short name of a construction is
its shortest partially qualified name.</P><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> does not accept two constructions (definition, theorem, ...)
with the same absolute name but different constructions can have the
same short name (or even same partially qualified names as soon as the
full names are different).</P><P>Notice that the notion of absolute, partially qualified and
short names also applies to library file names.</P><H5 CLASS="paragraph">Visibility</H5><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> maintains a table called <I>name table</I> which maps partially
qualified names of constructions to absolute names. This table is
updated by the commands <TT>Require</TT> (see <A HREF="Reference-Manual009.html#Require">6.5.1</A>), <TT>Import</TT> and <TT>Export</TT> (see <A HREF="#Import">2.5.8</A>) and also each time a new
declaration is added to the context. An absolute name is called <I>visible</I> from a given short or partially qualified name when this
latter name is enough to denote it. This means that the short or
partially qualified name is mapped to the absolute name in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> name
table.</P><P>A similar table exists for library file names. It is updated by the
vernacular commands <TT>Add LoadPath</TT> and <TT>Add Rec LoadPath</TT> (or
their equivalent as options of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> executables, <TT>-I</TT> and
<TT>-R</TT>).</P><P>It may happen that a visible name is hidden by the short name or a
qualified name of another construction. In this case, the name that
has been hidden must be referred to using one more level of
qualification. To ensure that a construction always remains
accessible, absolute names can never be hidden.</P><P>Examples:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check 0.</TT><BR>
<TT><I>0</I></TT><BR>
<TT><I>     : nat</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition nat := bool.</TT><BR>
<TT><I>nat is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check 0.</TT><BR>
<TT><I>0</I></TT><BR>
<TT><I>     : Datatypes.nat</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check Datatypes.nat.</TT><BR>
<TT><I>Datatypes.nat</I></TT><BR>
<TT><I>     : Set</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Locate nat.</TT><BR>
<TT><I>Constant Top.nat</I></TT><BR>
<TT><I>Inductive Coq.Init.Datatypes.nat</I></TT><BR>
<TT><I>  (shorter name to refer to it in current context is Datatypes.nat)</I></TT><BR>
</DIV><P><BR>
<B>See also: </B>Command <TT>Locate</TT> in Section <A HREF="Reference-Manual009.html#Locate">6.3.10</A> and <TT>Locate
Library</TT> in Section <A HREF="Reference-Manual009.html#Locate Library">6.6.11</A>.</P><H2 CLASS="section"><A NAME="toc20"></A><A NAME="htoc51">2.7</A>  Implicit arguments
<A NAME="@default112"></A>
<A NAME="Implicit Arguments"></A></H2><P>An implicit argument of a function is an argument which can be
inferred from contextual knowledge. There are different kinds of
implicit arguments that can be considered implicit in different
ways. There are also various commands to control the setting or the
inference of implicit arguments.</P><H3 CLASS="subsection"><A NAME="htoc52">2.7.1</A>  The different kinds of implicit arguments</H3><H4 CLASS="subsubsection">Implicit arguments inferable from the knowledge of other 
arguments of a function</H4><P>The first kind of implicit arguments covers the arguments that are
inferable from the knowledge of the type of other arguments of the
function, or of the type of the surrounding context of the
application. Especially, such implicit arguments correspond to 
parameters dependent in the type of the function. Typical implicit
arguments are the type arguments in polymorphic functions. 
There are several kinds of such implicit arguments.</P><H5 CLASS="paragraph">Strict Implicit Arguments.</H5><P> 
An implicit argument can be either strict or non strict. An implicit
argument is said <EM>strict</EM> if, whatever the other arguments of the
function are, it is still inferable from the type of some other
argument. Technically, an implicit argument is strict if it
corresponds to a parameter which is not applied to a variable which
itself is another parameter of the function (since this parameter
may erase its arguments), not in the body of a <TT>match</TT>, and not
itself applied or matched against patterns (since the original
form of the argument can be lost by reduction).</P><P>For instance, the first argument of
</P><BLOCKQUOTE CLASS="quote">
<CODE>cons: forall A:Set, A -&gt; list A -&gt; list A</CODE>
</BLOCKQUOTE><P>
in module <TT>List.v</TT> is strict because <TT>list</TT> is an inductive
type and <TT>A</TT> will always be inferable from the type <TT>list A</TT> of the third argument of <TT>cons</TT>.
On the contrary, the second argument of a term of type 
</P><BLOCKQUOTE CLASS="quote">
<CODE>forall P:nat-&gt;Prop, forall n:nat, P n -&gt; ex nat P</CODE>
</BLOCKQUOTE><P>
is implicit but not strict, since it can only be inferred from the
type <TT>P n</TT> of the third argument and if <TT>P</TT> is, e.g., <TT>fun _ =&gt; True</TT>, it reduces to an expression where <TT>n</TT> does not
occur any longer. The first argument <TT>P</TT> is implicit but not
strict either because it can only be inferred from <TT>P n</TT> and <TT>P</TT> is not canonically inferable from an arbitrary <TT>n</TT> and the
normal form of <TT>P n</TT> (consider e.g. that <TT>n</TT> is <TT>0</TT> and
the third argument has type <TT>True</TT>, then any <TT>P</TT> of the form
<TT>fun n =&gt; match n with 0 =&gt; True | _ =&gt; </TT><TT><EM>anything</EM></TT><TT> end</TT> would
be a solution of the inference problem).</P><H5 CLASS="paragraph">Contextual Implicit Arguments.</H5><P> 
An implicit argument can be <EM>contextual</EM> or not. An implicit
argument is said <EM>contextual</EM> if it can be inferred only from the
knowledge of the type of the context of the current expression. For
instance, the only argument of
</P><BLOCKQUOTE CLASS="quote">
<CODE>nil : forall A:Set, list A</CODE>
</BLOCKQUOTE><P>
is contextual. Similarly, both arguments of a term of type
</P><BLOCKQUOTE CLASS="quote">
<CODE>forall P:nat-&gt;Prop, forall n:nat, P n \/ n = 0</CODE>
</BLOCKQUOTE><P>
are contextual (moreover, <TT>n</TT> is strict and <TT>P</TT> is not).</P><H5 CLASS="paragraph">Reversible-Pattern Implicit Arguments.</H5><P>
There is another class of implicit arguments that can be reinferred
unambiguously if all the types of the remaining arguments are
known. This is the class of implicit arguments occurring in the type
of another argument in position of reversible pattern, which means it
is at the head of an application but applied only to uninstantiated
distinct variables. Such an implicit argument is called <EM>reversible-pattern implicit argument</EM>. A typical example is the
argument <TT>P</TT> of <TT>nat_rec</TT> in
</P><BLOCKQUOTE CLASS="quote">
<TT>nat_rec : forall P : nat -&gt; Set,
P 0 -&gt; (forall n : nat, P n -&gt; P (S n)) -&gt; forall x : nat, P x</TT>.
</BLOCKQUOTE><P>
(<TT>P</TT> is reinferable by abstracting over <TT>n</TT> in the type <TT>P n</TT>).</P><P>See Section <A HREF="#SetReversiblePatternImplicit">2.7.9</A> for the automatic declaration
of reversible-pattern implicit arguments.</P><H4 CLASS="subsubsection">Implicit arguments inferable by resolution</H4><P>This corresponds to a class of non dependent implicit arguments that
are solved based on the structure of their type only.</P><H3 CLASS="subsection"><A NAME="htoc53">2.7.2</A>  Maximal or non maximal insertion of implicit arguments</H3><P>In case a function is partially applied, and the next argument to be
applied is an implicit argument, two disciplines are applicable. In the
first case, the function is considered to have no arguments furtherly:
one says that the implicit argument is not maximally inserted. In
the second case, the function is considered to be implicitly applied
to the implicit arguments it is waiting for: one says that the
implicit argument is maximally inserted.</P><P>Each implicit argument can be declared to have to be inserted
maximally or non maximally. This can be governed argument per argument
by the command <TT>Implicit Arguments</TT> (see <A HREF="#ImplicitArguments">2.7.4</A>)
or globally by the command <TT>Set Maximal Implicit Insertion</TT>
(see <A HREF="#SetMaximalImplicitInsertion">2.7.10</A>). See also
Section <A HREF="#PrintImplicit">2.7.12</A>.</P><H3 CLASS="subsection"><A NAME="htoc54">2.7.3</A>  Casual use of implicit arguments</H3><P>In a given expression, if it is clear that some argument of a function
can be inferred from the type of the other arguments, the user can
force the given argument to be guessed by replacing it by &#X201C;<TT>_</TT>&#X201D;. If
possible, the correct argument will be automatically generated.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Cannot infer a term for this placeholder</TT><A NAME="@error24"></A><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> was not able to deduce an instantiation of a &#X201C;<TT>_</TT>&#X201D;.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc55">2.7.4</A>  Declaration of implicit arguments for a constant
<A NAME="@default113"></A><A NAME="@command62"></A></H3><P>
<A NAME="ImplicitArguments"></A></P><P>In case one wants that some arguments of a given object (constant,
inductive types, constructors, assumptions, local or not) are always
inferred by Coq, one may declare once and for all which are the expected
implicit arguments of this object. There are two ways to do this,
a-priori and a-posteriori. </P><H4 CLASS="subsubsection">Implicit Argument Binders</H4><P>In the first setting, one wants to explicitly give the implicit
arguments of a constant as part of its definition. To do this, one has
to surround the bindings of implicit arguments by curly braces:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition id {A : Type} (x : A) : A := x.</TT><BR>
<TT><I>id is defined</I></TT><BR>
</DIV><P>This automatically declares the argument <TT>A</TT> of <TT>id</TT> as a
maximally inserted implicit argument. One can then do as-if the argument
was absent in every situation but still be able to specify it if needed:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition compose {A B C} (g : B -</TT><TT>&gt;</TT><TT> C) (f : A -</TT><TT>&gt;</TT><TT> B) := </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   fun x =</TT><TT>&gt;</TT><TT> g (f x).</TT><BR>
<TT><I>compose is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A, compose id id = id (A:=A).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A : Type, compose id id = id</I></TT><BR>
</DIV><P>The syntax is supported in all top-level definitions: <TT>Definition</TT>,
<TT>Fixpoint</TT>, <TT>Lemma</TT> and so on. For (co-)inductive datatype
declarations, the semantics are the following: an inductive parameter
declared as an implicit argument need not be repeated in the inductive
definition but will become implicit for the constructors of the
inductive only, not the inductive type itself. For example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive list {A : Type} : Type :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> | nil : list</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> | cons : A -</TT><TT>&gt;</TT><TT> list -</TT><TT>&gt;</TT><TT> list.</TT><BR>
<TT><I>list is defined</I></TT><BR>
<TT><I>list_rect is defined</I></TT><BR>
<TT><I>list_ind is defined</I></TT><BR>
<TT><I>list_rec is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print list.</TT><BR>
<TT><I>Inductive list (A : Type) : Type :=  nil : list | cons : A -</I></TT><TT><I>&gt;</I></TT><TT><I> list -</I></TT><TT><I>&gt;</I></TT><TT><I> list</I></TT><BR>
<TT><I>For list: Argument A is implicit and maximally inserted</I></TT><BR>
<TT><I>For nil: Argument A is implicit and maximally inserted</I></TT><BR>
<TT><I>For cons: Argument A is implicit and maximally inserted</I></TT><BR>
<TT><I>For list: Argument scope is [type_scope]</I></TT><BR>
<TT><I>For nil: Argument scope is [type_scope]</I></TT><BR>
<TT><I>For cons: Argument scopes are [type_scope _ _]</I></TT><BR>
</DIV><P>One can always specify the parameter if it is not uniform using the
usual implicit arguments disambiguation syntax.</P><H4 CLASS="subsubsection">The Implicit Arguments Vernacular Command</H4><P>To set implicit arguments for a constant a-posteriori, one can use the
command:
</P><BLOCKQUOTE CLASS="quote">
<TT>Implicit Arguments </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> [ </TT><I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I><TT>  </TT><TT>&#X2026;</TT><TT>  </TT><I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I><TT> ]
</TT></BLOCKQUOTE><P>
where the list of <I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I> is the list of parameters
to be declared implicit, each of the identifier of the list being
optionally surrounded by square brackets, then meaning that this
parameter has to be maximally inserted.</P><P>After the above declaration is issued, implicit arguments can just (and
have to) be skipped in any expression involving an application of
<I><FONT COLOR=maroon>qualid</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Global Implicit Arguments </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> [ </TT><I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I><TT>  </TT><TT>&#X2026;</TT><TT>  </TT><I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I><TT> ]
</TT><A NAME="@default114"></A><A NAME="@command63"></A><P>Tells to recompute the implicit arguments of <I><FONT COLOR=maroon>qualid</FONT></I> after ending of
the current section if any, enforcing the implicit arguments known
from inside the section to be the ones declared by the command.</P></LI><LI CLASS="li-enumerate"><TT>Local Implicit Arguments </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> [ </TT><I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I><TT>  </TT><TT>&#X2026;</TT><TT>  </TT><I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I><TT> ]
</TT><A NAME="@default115"></A><A NAME="@command64"></A><P>When in a module, tells not to activate the implicit arguments of
<I><FONT COLOR=maroon>qualid</FONT></I> declared by this commands to contexts that requires the
module.</P></LI><LI CLASS="li-enumerate"><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>Global </TT><TT><I><FONT COLOR=maroon>|</FONT></I></TT><TT> Local</TT><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT> Implicit Arguments </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><TT><I><FONT COLOR=maroon>[</FONT></I></TT><TT>[ </TT><I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I><TT>  </TT><TT>&#X2026;</TT><TT>  </TT><I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I><TT> ]</TT><TT>  </TT><TT>&#X2026;</TT><TT>  </TT><TT>[ </TT><I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I><TT>  </TT><TT>&#X2026;</TT><TT>  </TT><I><FONT COLOR=maroon>possibly_bracketed_ident</FONT></I><TT> ]</TT><TT><I><FONT COLOR=maroon>]</FONT></I></TT><P>For names of constants, inductive types, constructors, lemmas which
can only be applied to a fixed number of arguments (this excludes for
instance constants whose type is polymorphic), multiple lists
of implicit arguments can be given. These lists must be of different
length, and, depending on the number of arguments <I><FONT COLOR=maroon>qualid</FONT></I> is applied
to in practice, the longest applicable list of implicit arguments is
used to select which implicit arguments are inserted.</P><P>For printing, the omitted arguments are the ones of the longest list
of implicit arguments of the sequence.</P></LI></OL><P><BR>
<B>Example: </B>
</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive list (A:Type) : Type :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  | nil : list A </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  | cons : A -</TT><TT>&gt;</TT><TT> list A -</TT><TT>&gt;</TT><TT> list A.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check (cons nat 3 (nil nat)).</TT><BR>
<TT><I>cons nat 3 (nil nat)</I></TT><BR>
<TT><I>     : list nat</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Implicit Arguments cons [A].</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Implicit Arguments nil [A].</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check (cons 3 nil).</TT><BR>
<TT><I>cons 3 nil</I></TT><BR>
<TT><I>     : list nat</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint map (A B:Type) (f:A-</TT><TT>&gt;</TT><TT>B) (l:list A) : list B :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match l with nil =</TT><TT>&gt;</TT><TT> nil | cons a t =</TT><TT>&gt;</TT><TT> cons (f a) (map A B f t) end.</TT><BR>
<TT><I>map is recursively defined (decreasing on 4th argument)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint length (A:Type) (l:list A) : nat :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match l with nil =</TT><TT>&gt;</TT><TT> 0 | cons _ m =</TT><TT>&gt;</TT><TT> S (length A m) end.</TT><BR>
<TT><I>length is recursively defined (decreasing on 2nd argument)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Implicit Arguments map [A B].</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Implicit Arguments length [[A]]. (* A has to be maximally inserted *)</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check (fun l:list (list nat) =</TT><TT>&gt;</TT><TT> map length l).</TT><BR>
<TT><I>fun l : list (list nat) =</I></TT><TT><I>&gt;</I></TT><TT><I> map length l</I></TT><BR>
<TT><I>     : list (list nat) -</I></TT><TT><I>&gt;</I></TT><TT><I> list nat</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Implicit Arguments map [A B] [A] [].</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check (fun l =</TT><TT>&gt;</TT><TT> map length l = map (list nat) nat length l).</TT><BR>
<TT><I>fun l : list (list nat) =</I></TT><TT><I>&gt;</I></TT><TT><I> map length l = map length l</I></TT><BR>
<TT><I>     : list (list nat) -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
</DIV><P><BR>
<B>Remark: </B>To know which are the implicit arguments of an object, use the command
<TT>Print Implicit</TT> (see <A HREF="#PrintImplicit">2.7.12</A>).</P><P><BR>
<B>Remark: </B>If the list of arguments is empty, the command removes the
implicit arguments of <I><FONT COLOR=maroon>qualid</FONT></I>.</P><H3 CLASS="subsection"><A NAME="htoc56">2.7.5</A>  Automatic declaration of implicit arguments for a constant</H3><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> can also automatically detect what are the implicit arguments
of a defined object. The command is just
</P><BLOCKQUOTE CLASS="quote">
<TT>Implicit Arguments </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>
</TT><A NAME="@default116"></A><A NAME="@command65"></A>
</BLOCKQUOTE><P>
The auto-detection is governed by options telling if strict,
contextual, or reversible-pattern implicit arguments must be
considered or not (see
Sections <A HREF="#SetStrictImplicit">2.7.7</A>, <A HREF="#SetContextualImplicit">2.7.8</A>, <A HREF="#SetReversiblePatternImplicit">2.7.9</A>
and also <A HREF="#SetMaximalImplicitInsertion">2.7.10</A>).</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Global Implicit Arguments </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>
</TT><A NAME="@default117"></A><A NAME="@command66"></A><P>Tells to recompute the implicit arguments of <I><FONT COLOR=maroon>qualid</FONT></I> after ending of
the current section if any.</P></LI><LI CLASS="li-enumerate"><TT>Local Implicit Arguments </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>
</TT><A NAME="@default118"></A><A NAME="@command67"></A><P>When in a module, tells not to activate the implicit arguments of
<I><FONT COLOR=maroon>qualid</FONT></I> computed by this declaration to contexts that requires the
module.</P></LI></OL><P><BR>
<B>Example: </B>
</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive list (A:Set) : Set := </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | nil : list A </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | cons : A -</TT><TT>&gt;</TT><TT> list A -</TT><TT>&gt;</TT><TT> list A.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Implicit Arguments cons.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print Implicit cons.</TT><BR>
<TT><I>cons : forall A : Set, A -</I></TT><TT><I>&gt;</I></TT><TT><I> list A -</I></TT><TT><I>&gt;</I></TT><TT><I> list A</I></TT><BR>
<TT><I>Argument A is implicit</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Implicit Arguments nil.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print Implicit nil.</TT><BR>
<TT><I>nil : forall A : Set, list A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Set Contextual Implicit.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Implicit Arguments nil.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print Implicit nil.</TT><BR>
<TT><I>nil : forall A : Set, list A</I></TT><BR>
<TT><I>Argument A is implicit and maximally inserted</I></TT><BR>
</DIV><P>The computation of implicit arguments takes account of the
unfolding of constants. For instance, the variable <TT>p</TT> below has
type <TT>(Transitivity R)</TT> which is reducible to <TT>forall x,y:U, R x
y -&gt; forall z:U, R y z -&gt; R x z</TT>. As the variables <TT>x</TT>, <TT>y</TT> and
<TT>z</TT> appear strictly in body of the type, they are implicit.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Variable X : Type.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition Relation := X -</TT><TT>&gt;</TT><TT> X -</TT><TT>&gt;</TT><TT> Prop.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition Transitivity (R:Relation) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall x y:X, R x y -</TT><TT>&gt;</TT><TT> forall z:X, R y z -</TT><TT>&gt;</TT><TT> R x z.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variables (R : Relation) (p : Transitivity R).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Implicit Arguments p.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print p.</TT><BR>
<TT><I>*** [ p : Transitivity R ]</I></TT><BR>
<TT><I>Expanded type for implicit arguments</I></TT><BR>
<TT><I>p : forall x y : X, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> forall z : X, R y z -</I></TT><TT><I>&gt;</I></TT><TT><I> R x z</I></TT><BR>
<TT><I>Arguments x, y, z are implicit</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print Implicit p.</TT><BR>
<TT><I>p : forall x y : X, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> forall z : X, R y z -</I></TT><TT><I>&gt;</I></TT><TT><I> R x z</I></TT><BR>
<TT><I>Arguments x, y, z are implicit</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variables (a b c : X) (r1 : R a b) (r2 : R b c).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check (p r1 r2).</TT><BR>
<TT><I>p r1 r2</I></TT><BR>
<TT><I>     : R a c</I></TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc57">2.7.6</A>  Mode for automatic declaration of implicit arguments
<A NAME="Auto-implicit"></A>
<A NAME="@default119"></A><A NAME="@command68"></A>
<A NAME="@default120"></A><A NAME="@command69"></A></H3><P>In case one wants to systematically declare implicit the arguments
detectable as such, one may switch to the automatic declaration of
implicit arguments mode by using the command
</P><BLOCKQUOTE CLASS="quote">
<TT>Set Implicit Arguments.
</TT></BLOCKQUOTE><P>
Conversely, one may unset the mode by using <TT>Unset Implicit
Arguments</TT>. The mode is off by default. Auto-detection of implicit
arguments is governed by options controlling whether strict and
contextual implicit arguments have to be considered or not.</P><H3 CLASS="subsection"><A NAME="htoc58">2.7.7</A>  Controlling strict implicit arguments
<A NAME="@default121"></A><A NAME="@command70"></A>
<A NAME="@default122"></A><A NAME="@command71"></A>
<A NAME="SetStrictImplicit"></A></H3><P>When the mode for automatic declaration of implicit arguments is on,
the default is to automatically set implicit only the strict implicit
arguments plus, for historical reasons, a small subset of the non
strict implicit arguments. To relax this constraint and to
set implicit all non strict implicit arguments by default, use the command
</P><BLOCKQUOTE CLASS="quote">
<TT>Unset Strict Implicit.
</TT></BLOCKQUOTE><P>
Conversely, use the command <TT>Set Strict Implicit</TT> to
restore the original mode that declares implicit only the strict implicit arguments plus a small subset of the non strict implicit arguments.</P><P>In the other way round, to capture exactly the strict implicit arguments and no more than the strict implicit arguments, use the command:
<A NAME="@default123"></A><A NAME="@command72"></A>
<A NAME="@default124"></A><A NAME="@command73"></A>
</P><BLOCKQUOTE CLASS="quote">
<TT>Set Strongly Strict Implicit.
</TT></BLOCKQUOTE><P>
Conversely, use the command <TT>Unset Strongly Strict Implicit</TT> to
let the option &#X201C;<TT>Strict Implicit</TT>&#X201D; decide what to do.</P><P><BR>
<B>Remark: </B>In versions of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> prior to version 8.0, the default was to
declare the strict implicit arguments as implicit.</P><H3 CLASS="subsection"><A NAME="htoc59">2.7.8</A>  Controlling contextual implicit arguments
<A NAME="@default125"></A><A NAME="@command74"></A>
<A NAME="@default126"></A><A NAME="@command75"></A>
<A NAME="SetContextualImplicit"></A></H3><P>By default, <SPAN STYLE="font-variant:small-caps">Coq</SPAN> does not automatically set implicit the contextual
implicit arguments. To tell <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to infer also contextual implicit
argument, use command 
</P><BLOCKQUOTE CLASS="quote">
<TT>Set Contextual Implicit. 
</TT></BLOCKQUOTE><P>
Conversely, use command <TT>Unset Contextual Implicit</TT> to
unset the contextual implicit mode.</P><H3 CLASS="subsection"><A NAME="htoc60">2.7.9</A>  Controlling reversible-pattern implicit arguments
<A NAME="@default127"></A><A NAME="@command76"></A>
<A NAME="@default128"></A><A NAME="@command77"></A>
<A NAME="SetReversiblePatternImplicit"></A></H3><P>By default, <SPAN STYLE="font-variant:small-caps">Coq</SPAN> does not automatically set implicit the reversible-pattern
implicit arguments. To tell <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to infer also reversible-pattern implicit
argument, use command 
</P><BLOCKQUOTE CLASS="quote">
<TT>Set Reversible Pattern Implicit. 
</TT></BLOCKQUOTE><P>
Conversely, use command <TT>Unset Reversible Pattern Implicit</TT> to
unset the reversible-pattern implicit mode.</P><H3 CLASS="subsection"><A NAME="htoc61">2.7.10</A>  Controlling the insertion of implicit arguments not followed by explicit arguments
<A NAME="@default129"></A><A NAME="@command78"></A>
<A NAME="@default130"></A><A NAME="@command79"></A>
<A NAME="SetMaximalImplicitInsertion"></A></H3><P>Implicit arguments can be declared to be automatically inserted when a
function is partially applied and the next argument of the function is
an implicit one. In case the implicit arguments are automatically
declared (with the command <TT>Set Implicit Arguments</TT>), the command
</P><BLOCKQUOTE CLASS="quote">
<TT>Set Maximal Implicit Insertion. 
</TT></BLOCKQUOTE><P>
is used to tell to declare the implicit arguments with a maximal
insertion status. By default, automatically declared implicit
arguments are not declared to be insertable maximally. To restore the
default mode for maximal insertion, use command <TT>Unset Maximal
Implicit Insertion</TT>.</P><H3 CLASS="subsection"><A NAME="htoc62">2.7.11</A>  Explicit applications
<A NAME="@default131"></A>
<A NAME="Implicits-explicitation"></A>
<A NAME="@default132"></A></H3><P>In presence of non strict or contextual argument, or in presence of
partial applications, the synthesis of implicit arguments may fail, so
one may have to give explicitly certain implicit arguments of an
application. The syntax for this is <TT>(</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>:=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>)</TT> where <I><FONT COLOR=maroon>ident</FONT></I>
is the name of the implicit argument and <I><FONT COLOR=maroon>term</FONT></I> is its corresponding
explicit term. Alternatively, one can locally deactivate the hiding of
implicit arguments of a function by using the notation
<TT>@</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>..</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>. This syntax extension is
given Figure <A HREF="#fig:explicitations">2.4</A>.
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I></TD><TD ALIGN=center NOWRAP>++=</TD><TD ALIGN=left NOWRAP>@ <I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>term</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>term</FONT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP>@ <I><FONT COLOR=maroon>qualid</FONT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>argument</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>argument</FONT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>argument</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>(</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>:=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>)</TT></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.4: Syntax for explicitly giving implicit arguments</TD></TR>
</TABLE></DIV>
<A NAME="fig:explicitations"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P><B>Example (continued): </B>

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check (p r1 (z:=c)).</TT><BR>
<TT><I>p r1 (z:=c)</I></TT><BR>
<TT><I>     : R b c -</I></TT><TT><I>&gt;</I></TT><TT><I> R a c</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check (p (x:=a) (y:=b) r1 (z:=c) r2).</TT><BR>
<TT><I>p r1 r2</I></TT><BR>
<TT><I>     : R a c</I></TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc63">2.7.12</A>  Displaying what the implicit arguments are
<A NAME="@default133"></A><A NAME="@command80"></A>
<A NAME="PrintImplicit"></A></H3><P>To display the implicit arguments associated to an object, and to know
if each of them is to be used maximally or not, use the command
</P><BLOCKQUOTE CLASS="quote">
<TT>Print Implicit </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>.
</TT></BLOCKQUOTE><H3 CLASS="subsection"><A NAME="htoc64">2.7.13</A>  Explicit displaying of implicit arguments for pretty-printing
<A NAME="@default134"></A><A NAME="@command81"></A>
<A NAME="@default135"></A><A NAME="@command82"></A>
<A NAME="@default136"></A><A NAME="@command83"></A>
<A NAME="@default137"></A><A NAME="@command84"></A></H3><P>By default the basic pretty-printing rules hide the inferable implicit
arguments of an application. To force printing all implicit arguments,
use command
</P><BLOCKQUOTE CLASS="quote">
<TT>Set Printing Implicit.</TT>
</BLOCKQUOTE><P>
Conversely, to restore the hiding of implicit arguments, use command
</P><BLOCKQUOTE CLASS="quote">
<TT>Unset Printing Implicit.</TT>
</BLOCKQUOTE><P>By default the basic pretty-printing rules display the implicit arguments that are not detected as strict implicit arguments. This &#X201C;defensive&#X201D; mode can quickly make the display cumbersome so this can be deactivated by using the command
</P><BLOCKQUOTE CLASS="quote">
<TT>Unset Printing Implicit Defensive.</TT>
</BLOCKQUOTE><P>
Conversely, to force the display of non strict arguments, use command
</P><BLOCKQUOTE CLASS="quote">
<TT>Set Printing Implicit Defensive.</TT>
</BLOCKQUOTE><P><BR>
<B>See also: </B><TT>Set Printing All</TT> in Section <A HREF="#SetPrintingAll">2.9</A>.</P><H3 CLASS="subsection"><A NAME="htoc65">2.7.14</A>  Interaction with subtyping</H3><P>When an implicit argument can be inferred from the type of more than
one of the other arguments, then only the type of the first of these
arguments is taken into account, and not an upper type of all of
them. As a consequence, the inference of the implicit argument of
&#X201C;=&#X201D; fails in</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check nat = Prop.</TT><BR>
</DIV><P>but succeeds in </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check Prop = nat.</TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc66">2.7.15</A>  Canonical structures
<A NAME="@default138"></A><A NAME="@command85"></A></H3><P>A canonical structure is an instance of a record/structure type that
can be used to solve equations involving implicit arguments. Assume
that <I><FONT COLOR=maroon>qualid</FONT></I> denotes an object (<I>Build</I>_<I>struc</I>  <I>c</I><SUB>1</SUB>  &#X2026;  <I>c</I><SUB><I>n</I></SUB>) in the
structure <EM>struct</EM> of which the fields are <I>x</I><SUB>1</SUB>, ...,
<I>x</I><SUB><I>n</I></SUB>. Assume that <I><FONT COLOR=maroon>qualid</FONT></I> is declared as a canonical structure
using the command
</P><BLOCKQUOTE CLASS="quote">
<TT>Canonical Structure </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>.</TT>
</BLOCKQUOTE><P>
Then, each time an equation of the form (<I>x</I><SUB><I>i</I></SUB> 
_)=<SUB>&#X3B2;&#X3B4;&#X3B9;&#X3B6;</SUB><I>c</I><SUB><I>i</I></SUB> has to be solved during the
type-checking process, <I><FONT COLOR=maroon>qualid</FONT></I> is used as a solution. Otherwise
said, <I><FONT COLOR=maroon>qualid</FONT></I> is canonically used to extend the field <I>c</I><SUB><I>i</I></SUB> into a
complete structure built on <I>c</I><SUB><I>i</I></SUB>.</P><P>Canonical structures are particularly useful when mixed with
coercions and strict implicit arguments. Here is an example.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Relations.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import EqNat.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Set Implicit Arguments.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Unset Strict Implicit.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Structure Setoid : Type := </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   {Carrier :</TT><TT>&gt;</TT><TT> Set;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    Equal : relation Carrier;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    Prf_equiv : equivalence Carrier Equal}.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition is_law (A B:Setoid) (f:A -</TT><TT>&gt;</TT><TT> B) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall x y:A, Equal x y -</TT><TT>&gt;</TT><TT> Equal (f x) (f y).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Axiom eq_nat_equiv : equivalence nat eq_nat.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition nat_setoid : Setoid := Build_Setoid eq_nat_equiv.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Canonical Structure nat_setoid.</TT><BR>
</DIV><P>Thanks to <TT>nat_setoid</TT> declared as canonical, the implicit
arguments <TT>A</TT> and <TT>B</TT> can be synthesized in the next statement.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma is_law_S : is_law S.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   is_law (A:=nat_setoid) (B:=nat_setoid) S</I></TT><BR>
</DIV><P><BR>
<B>Remark: </B>If a same field occurs in several canonical structure, then
only the structure declared first as canonical is considered.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Canonical Structure </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><TT>.</TT><BR>
 <TT>Canonical Structure </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><TT>.</TT><BR>
 <TT>Canonical Structure </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><TT>.</TT><P>These are equivalent to a regular definition of <I><FONT COLOR=maroon>ident</FONT></I> followed by
the declaration </P><P><TT>Canonical Structure </TT><I><FONT COLOR=maroon>ident</FONT></I>.
</P></LI></OL><P><BR>
<B>See also: </B>more examples in user contribution <TT>category</TT>
(<TT>Rocq/ALGEBRA</TT>).</P><H4 CLASS="subsubsection">Print Canonical Projections.
<A NAME="@default139"></A><A NAME="@command86"></A></H4><P>This displays the list of global names that are components of some
canonical structure. For each of them, the canonical structure of
which it is a projection is indicated. For instance, the above example 
gives the following output:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Print Canonical Projections.</TT><BR>
<TT><I>eq_nat_equiv </I></TT><TT><I>&lt;</I></TT><TT><I>- Prf_equiv ( nat_setoid )</I></TT><BR>
<TT><I>eq_nat </I></TT><TT><I>&lt;</I></TT><TT><I>- Equal ( nat_setoid )</I></TT><BR>
<TT><I>nat </I></TT><TT><I>&lt;</I></TT><TT><I>- Carrier ( nat_setoid )</I></TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc67">2.7.16</A>  Implicit types of variables</H3><P>
<A NAME="@default140"></A><A NAME="@command87"></A></P><P>It is possible to bind variable names to a given type (e.g. in a
development using arithmetic, it may be convenient to bind the names
<TT>n</TT> or <TT>m</TT> to the type <TT>nat</TT> of natural numbers). The
command for that is
</P><BLOCKQUOTE CLASS="quote">
<TT>Implicit Types </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>  </TT><TT>&#X2026;</TT><TT>  </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><TT>
</TT></BLOCKQUOTE><P>
The effect of the command is to automatically set the type of bound
variables starting with <I><FONT COLOR=maroon>ident</FONT></I> (either <I><FONT COLOR=maroon>ident</FONT></I> itself or
<I><FONT COLOR=maroon>ident</FONT></I> followed by one or more single quotes, underscore or digits)
to be <I><FONT COLOR=maroon>type</FONT></I> (unless the bound variable is already declared with an
explicit type in which case, this latter type is considered).</P><P><BR>
<B>Example: </B>
</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import List.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Implicit Types m n : nat.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma cons_inj_nat : forall m n l, n :: l = m :: l -</TT><TT>&gt;</TT><TT> n = m.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall m n (l : Datatypes.list nat), n :: l = m :: l -</I></TT><TT><I>&gt;</I></TT><TT><I> n = m</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros m n.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall l : Datatypes.list nat, n :: l = m :: l -</I></TT><TT><I>&gt;</I></TT><TT><I> n = m</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma cons_inj_bool : forall (m n:bool) l, n :: l = m :: l -</TT><TT>&gt;</TT><TT> n = m.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall (m n : bool) (l : Datatypes.list bool), n :: l = m :: l -</I></TT><TT><I>&gt;</I></TT><TT><I> n = m</I></TT><BR>
</DIV><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Implicit Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><BR>
This is useful for declaring the implicit type of a single variable.
</LI><LI CLASS="li-enumerate"><TT>Implicit Types ( </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1,1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1,<I>k</I></TT><SUB><TT>1</TT></SUB></SUB><TT> </TT><TT>:</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>)</TT><TT> &#X2026; </TT><TT>(</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I>,1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I>,<I>k</I></TT><SUB><TT><I>n</I></TT></SUB></SUB><TT> </TT><TT>:</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> </TT><TT>)</TT><TT>.</TT><BR>
 Adds <I>n</I> blocks of implicit types with different specifications.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc68">2.7.17</A>  Implicit generalization
<A NAME="implicit-generalization"></A>
<A NAME="@default141"></A><A NAME="@command88"></A></H3><P>Implicit generalization is an automatic elaboration of a statement with
free variables into a closed statement where these variables are
quantified explicitly. Implicit generalization is done inside binders
starting with a <CODE>`</CODE> and terms delimited by <CODE>`{ }</CODE> and
<CODE>`( )</CODE>, always introducing maximally inserted implicit arguments for
the generalized variables. Inside implicit generalization
delimiters, free variables in the current context are automatically
quantified using a product or a lambda abstraction to generate a closed
term. In the following statement for example, the variables <TT>n</TT>
and <TT>m</TT> are automatically generalized and become explicit
arguments of the lemma as we are using <CODE>`( )</CODE>:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Generalizable All Variables.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma nat_comm : &#X2018;(n = n + 0).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n, n = n + 0</I></TT><BR>
</DIV><P>

One can control the set of generalizable identifiers with the
<TT>Generalizable</TT> vernacular command to avoid unexpected
generalizations when mistyping identifiers. There are three variants of
the command:</P><BLOCKQUOTE CLASS="quote">
<TT>(Global)? Generalizable (All|No) Variable(s)? (</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)?.</TT>
</BLOCKQUOTE><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Generalizable All Variables.</TT> All variables are candidate for 
generalization if they appear free in the context under a
generalization delimiter. This may result in confusing errors in
case of typos. In such cases, the context will probably contain some
unexpected generalized variable.</LI><LI CLASS="li-enumerate"><TT>Generalizable No Variables.</TT> Disable implicit generalization 
entirely. This is the default behavior.</LI><LI CLASS="li-enumerate"><TT>Generalizable Variable(s)? </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>.</TT> 
Allow generalization of the given identifiers only. Calling this
command multiple times adds to the allowed identifiers.</LI><LI CLASS="li-enumerate"><TT>Global Generalizable</TT> Allows to export the choice of
generalizable variables.
</LI></OL><P>One can also use implicit generalization for binders, in which case the
generalized variables are added as binders and set maximally implicit.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition id &#X2018;(x : A) : A := x.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print id.</TT><BR>
<TT><I>id = fun (A : Type) (x : A) =</I></TT><TT><I>&gt;</I></TT><TT><I> x</I></TT><BR>
<TT><I>     : forall A : Type, A -</I></TT><TT><I>&gt;</I></TT><TT><I> A</I></TT><BR>
<TT><I>Argument A is implicit and maximally inserted</I></TT><BR>
<TT><I>Argument scopes are [type_scope _]</I></TT><BR>
</DIV><P>The generalizing binders <CODE>`{ }</CODE> and <CODE>`( )</CODE> work similarly to
their explicit counterparts, only binding the generalized variables
implicitly, as maximally-inserted arguments. In these binders, the
binding name for the bound object is optional, whereas the type is
mandatory, dually to regular binders.</P><H2 CLASS="section"><A NAME="toc21"></A><A NAME="htoc69">2.8</A>  Coercions
<A NAME="Coercions"></A>
<A NAME="@default142"></A></H2><P>Coercions can be used to implicitly inject terms from one <EM>class</EM> in
which they reside into another one. A <EM>class</EM> is either a sort
(denoted by the keyword <TT>Sortclass</TT>), a product type (denoted by the
keyword <TT>Funclass</TT>), or a type constructor (denoted by its name),
e.g. an inductive type or any constant with a type of the form
<TT>forall</TT> (<I>x</I><SUB>1</SUB>:<I>A</I><SUB>1</SUB>) .. (<I>x</I><SUB><I>n</I></SUB>:<I>A</I><SUB><I>n</I></SUB>), <I>s</I> where <I>s</I> is a sort.</P><P>Then the user is able to apply an
object that is not a function, but can be coerced to a function, and
more generally to consider that a term of type A is of type B provided
that there is a declared coercion between A and B. The main command is
<A NAME="@default143"></A><A NAME="@command89"></A>
</P><BLOCKQUOTE CLASS="quote">
<TT>Coercion </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> : </TT><I><FONT COLOR=maroon>class</FONT></I><SUB><TT>1</TT></SUB><TT> &gt;-&gt; </TT><I><FONT COLOR=maroon>class</FONT></I><SUB><TT>2</TT></SUB><TT>.
</TT></BLOCKQUOTE><P>
which declares the construction denoted by <I><FONT COLOR=maroon>qualid</FONT></I> as a
coercion between <I><FONT COLOR=maroon>class</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>class</FONT></I><SUB>2</SUB>.</P><P>More details and examples, and a description of the commands related
to coercions are provided in Chapter <A HREF="Reference-Manual023.html#Coercions-full">17</A>.</P><H2 CLASS="section"><A NAME="toc22"></A><A NAME="htoc70">2.9</A>  Printing constructions in full<A NAME="SetPrintingAll"></A>
<A NAME="@default144"></A><A NAME="@command90"></A>
<A NAME="@default145"></A><A NAME="@command91"></A></H2><P>Coercions, implicit arguments, the type of pattern-matching, but also
notations (see Chapter <A HREF="Reference-Manual015.html#Addoc-syntax">12</A>) can obfuscate the behavior
of some tactics (typically the tactics applying to occurrences of
subterms are sensitive to the implicit arguments). The command
</P><BLOCKQUOTE CLASS="quote">
<TT>Set Printing All.</TT>
</BLOCKQUOTE><P>
deactivates all high-level printing features such as coercions,
implicit arguments, returned type of pattern-matching, notations and
various syntactic sugar for pattern-matching or record projections.
Otherwise said, <TT>Set Printing All</TT> includes the effects
of the commands <TT>Set Printing Implicit</TT>, <TT>Set Printing
Coercions</TT>, <TT>Set Printing Synth</TT>, <TT>Unset Printing Projections</TT>
and <TT>Unset Printing Notations</TT>. To reactivate the high-level
printing features, use the command
</P><BLOCKQUOTE CLASS="quote">
<TT>Unset Printing All.</TT>
</BLOCKQUOTE><H2 CLASS="section"><A NAME="toc23"></A><A NAME="htoc71">2.10</A>  Printing universes<A NAME="PrintingUniverses"></A>
<A NAME="@default146"></A><A NAME="@command92"></A>
<A NAME="@default147"></A><A NAME="@command93"></A></H2><P>The following command:
</P><BLOCKQUOTE CLASS="quote">
<TT>Set Printing Universes</TT>
</BLOCKQUOTE><P>
activates the display of the actual level of each occurrence of
<FONT COLOR=purple>Type</FONT>. See Section <A HREF="Reference-Manual006.html#Sorts">4.1.1</A> for details. This wizard option, in
combination with <TT>Set Printing All</TT> (see
section <A HREF="#SetPrintingAll">2.9</A>) can help to diagnose failures to unify
terms apparently identical but internally different in the Calculus of
Inductive Constructions. To reactivate the display of the actual level
of the occurrences of <FONT COLOR=purple>Type</FONT>, use
</P><BLOCKQUOTE CLASS="quote">
<TT>Unset Printing Universes.</TT>
</BLOCKQUOTE><P><A NAME="@default148"></A><A NAME="@command94"></A></P><P>The constraints on the internal level of the occurrences of <FONT COLOR=purple>Type</FONT>
(see Section <A HREF="Reference-Manual006.html#Sorts">4.1.1</A>) can be printed using the command
</P><BLOCKQUOTE CLASS="quote">
<TT>Print Universes.</TT>
</BLOCKQUOTE>
<div id="sidebarWrapper">
<div id="sidebar">

<div class="block">
<h2 class="title">Navigation</h2>
<div class="content">

<ul class="menu">

<li class="leaf"><a href="index.html">Cover</a></li>
<li class="leaf"><a href="toc.html">Table of contents</a></li>
<li class="leaf">Index
  <ul class="menu">
  <li><a href="general-index.html">General</a></li>
  <li><a href="command-index.html">Commands</a></li>
  <li><a href="tactic-index.html">Tactics</a></li>
  <li><a href="error-index.html">Errors</a></li>
  </ul>
</li>

</ul>

</div>
</div>

</div>
</div>


</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:www-coq at lix.polytechnique.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/check?uri=referer">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/check/referer">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</BODY>
</HTML>
