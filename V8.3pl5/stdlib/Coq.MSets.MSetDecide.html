<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Standard Library | The Coq Proof Assistant</title>

<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<style type="text/css" media="all">@import "/modules/node/node.css";</style>

<style type="text/css" media="all">@import "/modules/system/defaults.css";</style>
<style type="text/css" media="all">@import "/modules/system/system.css";</style>
<style type="text/css" media="all">@import "/modules/user/user.css";</style>

<style type="text/css" media="all">@import "/sites/all/themes/coq/style.css";</style>
<style type="text/css" media="all">@import "/sites/all/themes/coq/coqdoc.css";</style>

</head>

<body>

<div id="container">
<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="http://coq.inria.fr/" class="active">Home</a></li>
    
    <li><a href="http://coq.inria.fr/about-coq" title="More about coq">About Coq</a></li>    
    <li><a href="http://coq.inria.fr/download">Get Coq</a></li>
    <li><a href="http://coq.inria.fr/documentation">Documentation</a></li>
    <li><a href="http://coq.inria.fr/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">

<div id="logoWrapper">

<div id="logo"><a href="http://coq.inria.fr/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
</div>
<div id="siteName"><a href="http://coq.inria.fr/" title="Home">The Coq Proof Assistant</a>
</div>

</div>
</div>

<div id="content">

<h1 class="libtitle">Library Coq.MSets.MSetDecide</h1>

<div class="code">

<br/>

<br/>

<br/>
</div>

<div class="doc">
This file implements a decision procedure for a certain
    class of propositions involving finite sets.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="Coq.Logic.Decidable.html#"><span class="id" type="library">Decidable</span></a> <a class="idref" href="Coq.Structures.DecidableTypeEx.html#"><span class="id" type="library">DecidableTypeEx</span></a> <a class="idref" href="Coq.MSets.MSetFacts.html#"><span class="id" type="library">MSetFacts</span></a>.<br/>

<br/>
</div>

<div class="doc">
First, a version for Weak Sets in functorial presentation 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <a name="WDecideOn"><span class="id" type="module">WDecideOn</span></a> (<span class="id" type="var">E</span> : <a class="idref" href="Coq.Structures.Equalities.html#"><span class="id" type="module">DecidableType</span></a>)(<span class="id" type="keyword">Import</span> <span class="id" type="var">M</span> : <a class="idref" href="Coq.MSets.MSetInterface.html#"><span class="id" type="module">WSetsOn</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#"><span class="id" type="module">E</span></a>).<br/>
&nbsp;<span class="id" type="keyword">Module</span> <a name="WDecideOn.F"><span class="id" type="module">F</span></a> := <a class="idref" href="Coq.MSets.MSetFacts.html#"><span class="id" type="module">MSetFacts.WFactsOn</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#"><span class="id" type="module">E</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#"><span class="id" type="module">M</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab546"></a><h1 class="section">Overview</h1>

    This functor defines the tactic <span class="inlinecode"><span class="id" type="var">fsetdec</span></span>, which will
    solve any valid goal of the form
<pre>
    forall s1 ... sn,
    forall x1 ... xm,
    P1 -&gt; ... -&gt; Pk -&gt; P
</pre>
    where <span class="inlinecode"><span class="id" type="var">P</span></span>'s are defined by the grammar:
<pre>

P ::=
| Q
| Empty F
| Subset F F'
| Equal F F'

Q ::=
| E.eq X X'
| In X F
| Q /\ Q'
| Q \/ Q'
| Q -&gt; Q'
| Q &lt;-&gt; Q'
| ~ Q
| True
| False

F ::=
| S
| empty
| singleton X
| add X F
| remove X F
| union F F'
| inter F F'
| diff F F'

X ::= x1 | ... | xm
S ::= s1 | ... | sn

</pre>

<br/> <br/>
The tactic will also work on some goals that vary slightly from
the above form:
<ul>
<li> The variables and hypotheses may be mixed in any order and may
  have already been introduced into the context.  Moreover,
  there may be additional, unrelated hypotheses mixed in (these
  will be ignored).

</li>
<li> A conjunction of hypotheses will be handled as easily as
  separate hypotheses, i.e., <span class="inlinecode"><span class="id" type="var">P1</span> /\ <span class="id" type="var">P2</span> -&gt; <span class="id" type="var">P</span></span> can be solved iff
  <span class="inlinecode"><span class="id" type="var">P1</span> -&gt; <span class="id" type="var">P2</span> -&gt; <span class="id" type="var">P</span></span> can be solved.

</li>
<li> <span class="inlinecode"><span class="id" type="var">fsetdec</span></span> should solve any goal if the MSet-related hypotheses
  are contradictory.

</li>
<li> <span class="inlinecode"><span class="id" type="var">fsetdec</span></span> will first perform any necessary zeta and beta
  reductions and will invoke <span class="inlinecode"><span class="id" type="tactic">subst</span></span> to eliminate any Coq
  equalities between finite sets or their elements.

</li>
<li> If <span class="inlinecode"><span class="id" type="var">E.eq</span></span> is convertible with Coq's equality, it will not
  matter which one is used in the hypotheses or conclusion.

</li>
<li> The tactic can solve goals where the finite sets or set
  elements are expressed by Coq terms that are more complicated
  than variables.  However, non-local definitions are not
  expanded, and Coq equalities between non-variable terms are
  not used.  For example, this goal will be solved:
<pre>
    forall (f : t -&gt; t),
    forall (g : elt -&gt; elt),
    forall (s1 s2 : t),
    forall (x1 x2 : elt),
    Equal s1 (f s2) -&gt;
    E.eq x1 (g (g x2)) -&gt;
    In x1 s1 -&gt;
    In (g (g x2)) (f s2)
</pre>
  This one will not be solved:
<pre>
    forall (f : t -&gt; t),
    forall (g : elt -&gt; elt),
    forall (s1 s2 : t),
    forall (x1 x2 : elt),
    Equal s1 (f s2) -&gt;
    E.eq x1 (g x2) -&gt;
    In x1 s1 -&gt;
    g x2 = g (g x2) -&gt;
    In (g (g x2)) (f s2)
</pre>

</li>
</ul>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab547"></a><h1 class="section">Facts and Tactics for Propositional Logic</h1>

      These lemmas and tactics are in a module so that they do
      not affect the namespace if you import the enclosing
      module <span class="inlinecode"><span class="id" type="var">Decide</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Module</span> <a name="WDecideOn.MSetLogicalFacts"><span class="id" type="module">MSetLogicalFacts</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Coq.Logic.Decidable.html#"><span class="id" type="library">Decidable</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Coq.Setoids.Setoid.html#"><span class="id" type="library">Setoid</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab548"></a><h2 class="section">Lemmas and Tactics About Decidable Propositions</h2>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab549"></a><h2 class="section">Propositional Equivalences Involving Negation</h2>

        These are all written with the unfolded form of
        negation, since I am not sure if setoid rewriting will
        always perform conversion. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab550"></a><h2 class="section">Tactics for Negations</h2>

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "fold" "any" "not" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">fold</span> (<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">P</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">fold</span> (<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">P</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">push</span> <span class="id" type="var">not</span> <span class="id" type="keyword">using</span> <span class="id" type="var">db</span></span> will pushes all negations to the
        leaves of propositions in the goal, using the lemmas in
        <span class="inlinecode"><span class="id" type="var">db</span></span> to assist in checking the decidability of the
        propositions involved.  If <span class="inlinecode"><span class="id" type="keyword">using</span> <span class="id" type="var">db</span></span> is omitted, then
        <span class="inlinecode"><span class="id" type="var">core</span></span> will be used.  Additional versions are provided
        to manipulate the hypotheses or the hypotheses and goal
        together.

<br/> <br/>
        XXX: This tactic and the similar subsequent ones should
        have been defined using <span class="inlinecode"><span class="id" type="var">autorewrite</span></span>. However, dealing
        with multiples rewrite sites and side-conditions is
        done more cleverly with the following explicit
        analysis of goals. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Ltac</span> <span class="id" type="var">or_not_l_iff</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">tac</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#or_not_l_iff_1"><span class="id" type="lemma">or_not_l_iff_1</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">tac</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#or_not_l_iff_2"><span class="id" type="lemma">or_not_l_iff_2</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">tac</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Ltac</span> <span class="id" type="var">or_not_r_iff</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">tac</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#or_not_r_iff_1"><span class="id" type="lemma">or_not_r_iff_1</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">tac</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#or_not_r_iff_2"><span class="id" type="lemma">or_not_r_iff_2</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">tac</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Ltac</span> <span class="id" type="var">or_not_l_iff_in</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span> <span class="id" type="var">tac</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#or_not_l_iff_1"><span class="id" type="lemma">or_not_l_iff_1</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">tac</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#or_not_l_iff_2"><span class="id" type="lemma">or_not_l_iff_2</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">tac</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Ltac</span> <span class="id" type="var">or_not_r_iff_in</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span> <span class="id" type="var">tac</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#or_not_r_iff_1"><span class="id" type="lemma">or_not_r_iff_1</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">tac</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#or_not_r_iff_2"><span class="id" type="lemma">or_not_r_iff_2</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">tac</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "push" "not" "using" <span class="id" type="var">ident</span>(<span class="id" type="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">dec</span> := <span class="id" type="var">solve_decidable</span> <span class="id" type="keyword">using</span> <span class="id" type="var">db</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>, <span class="id" type="var">iff</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> <a class="idref" href="Coq.Logic.Decidable.html#not_true_iff"><span class="id" type="lemma">not_true_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> <a class="idref" href="Coq.Logic.Decidable.html#not_false_iff"><span class="id" type="lemma">not_false_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#not_not_iff"><span class="id" type="lemma">not_not_iff</span></a> <span class="id" type="var">P</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; (?<span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>)] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#contrapositive"><span class="id" type="lemma">contrapositive</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Q</span>] =&gt; <span class="id" type="var">or_not_l_iff</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a>] =&gt; <span class="id" type="var">or_not_r_iff</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; ?<span class="id" type="var">Q</span>] =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#imp_not_l"><span class="id" type="lemma">imp_not_l</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#not_or_iff"><span class="id" type="lemma">not_or_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#not_and_iff"><span class="id" type="lemma">not_and_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; ?<span class="id" type="var">Q</span>) -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#not_imp_iff"><span class="id" type="lemma">not_imp_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">fold</span> <span class="id" type="var">any</span> <span class="id" type="var">not</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "push" "not" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">push</span> <span class="id" type="var">not</span> <span class="id" type="keyword">using</span> <span class="id" type="var">core</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"push" "not" "in" "*" "|-" "using" <span class="id" type="var">ident</span>(<span class="id" type="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">dec</span> := <span class="id" type="var">solve_decidable</span> <span class="id" type="keyword">using</span> <span class="id" type="var">db</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>, <span class="id" type="var">iff</span> <span class="id" type="keyword">in</span> * |-;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">rewrite</span> <a class="idref" href="Coq.Logic.Decidable.html#not_true_iff"><span class="id" type="lemma">not_true_iff</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">rewrite</span> <a class="idref" href="Coq.Logic.Decidable.html#not_false_iff"><span class="id" type="lemma">not_false_iff</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#not_not_iff"><span class="id" type="lemma">not_not_iff</span></a> <span class="id" type="var">P</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; (?<span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>)] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#contrapositive"><span class="id" type="lemma">contrapositive</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Q</span>] |- <span class="id" type="var">_</span> =&gt; <span class="id" type="var">or_not_l_iff_in</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a>] |- <span class="id" type="var">_</span> =&gt; <span class="id" type="var">or_not_r_iff_in</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; ?<span class="id" type="var">Q</span>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#imp_not_l"><span class="id" type="lemma">imp_not_l</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#not_or_iff"><span class="id" type="lemma">not_or_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#not_and_iff"><span class="id" type="lemma">not_and_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; ?<span class="id" type="var">Q</span>) -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#not_imp_iff"><span class="id" type="lemma">not_imp_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">fold</span> <span class="id" type="var">any</span> <span class="id" type="var">not</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "push" "not" "in" "*" "|-"  :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">push</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> * |- <span class="id" type="keyword">using</span> <span class="id" type="var">core</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "push" "not" "in" "*" "using" <span class="id" type="var">ident</span>(<span class="id" type="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">push</span> <span class="id" type="var">not</span> <span class="id" type="keyword">using</span> <span class="id" type="var">db</span>; <span class="id" type="var">push</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> * |- <span class="id" type="keyword">using</span> <span class="id" type="var">db</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "push" "not" "in" "*" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">push</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> * <span class="id" type="keyword">using</span> <span class="id" type="var">core</span>.<br/>

<br/>
</div>

<div class="doc">
A simple test case to see how this works.  
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetLogicalFacts.test_push"><span class="id" type="lemma">test_push</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Logic.Decidable.html#decidable"><span class="id" type="definition">decidable</span></a> <span class="id" type="var">P</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Logic.Decidable.html#decidable"><span class="id" type="definition">decidable</span></a> <span class="id" type="var">Q</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">P</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">Q</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a> -&gt; <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">R</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">Q</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">R</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">Q</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <span class="id" type="var">R</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">R</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">Q</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">R</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">Q</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">P</span> -&gt; <span class="id" type="var">R</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">R</span> -&gt; <span class="id" type="var">P</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">Q</span> -&gt; <span class="id" type="var">R</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">R</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> -&gt; <span class="id" type="var">R</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">pull</span> <span class="id" type="var">not</span> <span class="id" type="keyword">using</span> <span class="id" type="var">db</span></span> will pull as many negations as
        possible toward the top of the propositions in the goal,
        using the lemmas in <span class="inlinecode"><span class="id" type="var">db</span></span> to assist in checking the
        decidability of the propositions involved.  If <span class="inlinecode"><span class="id" type="keyword">using</span>
        <span class="id" type="var">db</span></span> is omitted, then <span class="inlinecode"><span class="id" type="var">core</span></span> will be used.  Additional
        versions are provided to manipulate the hypotheses or
        the hypotheses and goal together. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "pull" "not" "using" <span class="id" type="var">ident</span>(<span class="id" type="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">dec</span> := <span class="id" type="var">solve_decidable</span> <span class="id" type="keyword">using</span> <span class="id" type="var">db</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>, <span class="id" type="var">iff</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> <a class="idref" href="Coq.Logic.Decidable.html#not_true_iff"><span class="id" type="lemma">not_true_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> <a class="idref" href="Coq.Logic.Decidable.html#not_false_iff"><span class="id" type="lemma">not_false_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#not_not_iff"><span class="id" type="lemma">not_not_iff</span></a> <span class="id" type="var">P</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; (?<span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>)] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#contrapositive"><span class="id" type="lemma">contrapositive</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Q</span>] =&gt; <span class="id" type="var">or_not_l_iff</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a>] =&gt; <span class="id" type="var">or_not_r_iff</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; ?<span class="id" type="var">Q</span>] =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#imp_not_l"><span class="id" type="lemma">imp_not_l</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a>] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> &lt;- (<a class="idref" href="Coq.Logic.Decidable.html#not_or_iff"><span class="id" type="lemma">not_or_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> -&gt; ?<span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> &lt;- (<a class="idref" href="Coq.Logic.Decidable.html#not_and_iff"><span class="id" type="lemma">not_and_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a>] =&gt; <span class="id" type="tactic">rewrite</span> &lt;- (<a class="idref" href="Coq.Logic.Decidable.html#not_imp_iff"><span class="id" type="lemma">not_imp_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">P</span>] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> &lt;- (<a class="idref" href="Coq.Logic.Decidable.html#not_imp_rev_iff"><span class="id" type="lemma">not_imp_rev_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">fold</span> <span class="id" type="var">any</span> <span class="id" type="var">not</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "pull" "not" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pull</span> <span class="id" type="var">not</span> <span class="id" type="keyword">using</span> <span class="id" type="var">core</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"pull" "not" "in" "*" "|-" "using" <span class="id" type="var">ident</span>(<span class="id" type="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">dec</span> := <span class="id" type="var">solve_decidable</span> <span class="id" type="keyword">using</span> <span class="id" type="var">db</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>, <span class="id" type="var">iff</span> <span class="id" type="keyword">in</span> * |-;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">rewrite</span> <a class="idref" href="Coq.Logic.Decidable.html#not_true_iff"><span class="id" type="lemma">not_true_iff</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">rewrite</span> <a class="idref" href="Coq.Logic.Decidable.html#not_false_iff"><span class="id" type="lemma">not_false_iff</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#not_not_iff"><span class="id" type="lemma">not_not_iff</span></a> <span class="id" type="var">P</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; (?<span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>)] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#contrapositive"><span class="id" type="lemma">contrapositive</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Q</span>] |- <span class="id" type="var">_</span> =&gt; <span class="id" type="var">or_not_l_iff_in</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a>] |- <span class="id" type="var">_</span> =&gt; <span class="id" type="var">or_not_r_iff_in</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [(?<span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt; ?<span class="id" type="var">Q</span>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Decidable.html#imp_not_l"><span class="id" type="lemma">imp_not_l</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">P</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> &lt;- (<a class="idref" href="Coq.Logic.Decidable.html#not_or_iff"><span class="id" type="lemma">not_or_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> -&gt; ?<span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> &lt;- (<a class="idref" href="Coq.Logic.Decidable.html#not_and_iff"><span class="id" type="lemma">not_and_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [?<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> &lt;- (<a class="idref" href="Coq.Logic.Decidable.html#not_imp_iff"><span class="id" type="lemma">not_imp_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>: <span class="id" type="var">context</span> [<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(?</span></a><span class="id" type="var">Q</span> -&gt; <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">?</span></a><span class="id" type="var">P</span>] |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> &lt;- (<a class="idref" href="Coq.Logic.Decidable.html#not_imp_rev_iff"><span class="id" type="lemma">not_imp_rev_iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="var">dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">fold</span> <span class="id" type="var">any</span> <span class="id" type="var">not</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "pull" "not" "in" "*" "|-"  :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pull</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> * |- <span class="id" type="keyword">using</span> <span class="id" type="var">core</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "pull" "not" "in" "*" "using" <span class="id" type="var">ident</span>(<span class="id" type="var">db</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pull</span> <span class="id" type="var">not</span> <span class="id" type="keyword">using</span> <span class="id" type="var">db</span>; <span class="id" type="var">pull</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> * |- <span class="id" type="keyword">using</span> <span class="id" type="var">db</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Tactic Notation</span> "pull" "not" "in" "*" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pull</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> * <span class="id" type="keyword">using</span> <span class="id" type="var">core</span>.<br/>

<br/>
</div>

<div class="doc">
A simple test case to see how this works.  
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetLogicalFacts.test_pull"><span class="id" type="lemma">test_pull</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Logic.Decidable.html#decidable"><span class="id" type="definition">decidable</span></a> <span class="id" type="var">P</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Logic.Decidable.html#decidable"><span class="id" type="definition">decidable</span></a> <span class="id" type="var">Q</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">P</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">Q</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a> -&gt; <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">R</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">Q</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">R</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">Q</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <span class="id" type="var">R</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">R</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">Q</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">R</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">Q</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">P</span> -&gt; <span class="id" type="var">R</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">R</span> -&gt; <span class="id" type="var">P</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">Q</span> -&gt; <span class="id" type="var">R</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">R</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">P</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">R</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <span class="id" type="var">R</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <span class="id" type="var">P</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="Coq.MSets.MSetDecide.html#MSetLogicalFacts"><span class="id" type="module">MSetLogicalFacts</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Import</span> <span class="id" type="var">MSetLogicalFacts</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab551"></a><h1 class="section">Auxiliary Tactics</h1>

      Again, these lemmas and tactics are in a module so that
      they do not affect the namespace if you import the
      enclosing module <span class="inlinecode"><span class="id" type="var">Decide</span></span>.  
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Module</span> <a name="WDecideOn.MSetDecideAuxiliary"><span class="id" type="module">MSetDecideAuxiliary</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab552"></a><h2 class="section">Generic Tactics</h2>

        We begin by defining a few generic, useful tactics. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
remove logical hypothesis inter-dependencies (fix 2136). *)

    Ltac no_logical_interdep :=
      match goal with
        | H : ?P |- _ =>
          match type of P with
            | Prop =>
              match goal with H' : context [ H ] |- _ => clear dependent H' end
            | _ => fail
          end; no_logical_interdep
        | _ => idtac
      end.

    (** [if t then t1 else t2] executes [t] and, if it does not
        fail, then [t1] will be applied to all subgoals
        produced.  If [t] fails, then [t2] is executed. *)
    Tactic Notation
      "if" tactic(t)
      "then" tactic(t1)
      "else" tactic(t2) :=
      first [ t; first [ t1 | fail 2 ] | t2 ].

    Ltac abstract_term t :=
      if (is_var t) then fail "no need to abstract a variable"
      else (let x := fresh "x" in set (x := t) in *; try clearbody x).

    Ltac abstract_elements :=
      repeat
        (match goal with
           | |- context [ singleton ?t ] => abstract_term t
           | _ : context [ singleton ?t ] |- _ => abstract_term t
           | |- context [ add ?t _ ] => abstract_term t
           | _ : context [ add ?t _ ] |- _ => abstract_term t
           | |- context [ remove ?t _ ] => abstract_term t
           | _ : context [ remove ?t _ ] |- _ => abstract_term t
           | |- context [ In ?t _ ] => abstract_term t
           | _ : context [ In ?t _ ] |- _ => abstract_term t
         end).

    (** [prop P holds by t] succeeds (but does not modify the
        goal or context) if the proposition [P] can be proved by
        [t] in the current context.  Otherwise, the tactic
        fails. *)
    Tactic Notation "prop" constr(P) "holds" "by" tactic(t) :=
      let H := fresh in
      assert P as H by t;
      clear H.

    (** This tactic acts just like [assert ... by ...] but will
        fail if the context already contains the proposition. *)
    Tactic Notation "assert" "new" constr(e) "by" tactic(t) :=
      match goal with
      | H: e |- _ => fail 1
      | _ => assert e by t
      end.

    (** [subst++] is similar to [subst] except that
        - it never fails (as [subst] does on recursive
          equations),
        - it substitutes locally defined variable for their
          definitions,
        - it performs beta reductions everywhere, which may
          arise after substituting a locally defined function
          for its definition.
        *)
    Tactic Notation "subst" "++" :=
      repeat (
        match goal with
        | x : _ |- _ => subst x
        end);
      cbv zeta beta in *.

    (** [decompose records] calls [decompose record H] on every
        relevant hypothesis [H]. *)
    Tactic Notation "decompose" "records" :=
      repeat (
        match goal with
        | H: _ |- _ => progress (decompose record H); clear H
        end).

    (** ** Discarding Irrelevant Hypotheses
        We will want to clear the context of any
        non-MSet-related hypotheses in order to increase the
        speed of the tactic.  To do this, we will need to be
        able to decide which are relevant.  We do this by making
        a simple inductive definition classifying the
        propositions of interest. *)

    Inductive MSet_elt_Prop : Prop -> Prop :=
    | eq_Prop : forall (S : Type) (x y : S),
        MSet_elt_Prop (x = y)
    | eq_elt_prop : forall x y,
        MSet_elt_Prop (E.eq x y)
    | In_elt_prop : forall x s,
        MSet_elt_Prop (In x s)
    | True_elt_prop :
        MSet_elt_Prop True
    | False_elt_prop :
        MSet_elt_Prop False
    | conj_elt_prop : forall P Q,
        MSet_elt_Prop P ->
        MSet_elt_Prop Q ->
        MSet_elt_Prop (P /\ Q)
    | disj_elt_prop : forall P Q,
        MSet_elt_Prop P ->
        MSet_elt_Prop Q ->
        MSet_elt_Prop (P \/ Q)
    | impl_elt_prop : forall P Q,
        MSet_elt_Prop P ->
        MSet_elt_Prop Q ->
        MSet_elt_Prop (P -> Q)
    | not_elt_prop : forall P,
        MSet_elt_Prop P ->
        MSet_elt_Prop (~ P).

    Inductive MSet_Prop : Prop -> Prop :=
    | elt_MSet_Prop : forall P,
        MSet_elt_Prop P ->
        MSet_Prop P
    | Empty_MSet_Prop : forall s,
        MSet_Prop (Empty s)
    | Subset_MSet_Prop : forall s1 s2,
        MSet_Prop (Subset s1 s2)
    | Equal_MSet_Prop : forall s1 s2,
        MSet_Prop (Equal s1 s2).

    (** Here is the tactic that will throw away hypotheses that
        are not useful (for the intended scope of the [fsetdec]
        tactic). *)
    Hint Constructors MSet_elt_Prop MSet_Prop : MSet_Prop.
    Ltac discard_nonMSet :=
      repeat (
        match goal with
        | H : context [ @Logic.eq ?T ?x ?y ] |- _ =>
          if (change T with E.t in H) then fail
          else if (change T with t in H) then fail
          else clear H
        | H : ?P |- _ =>
          if prop (MSet_Prop P) holds by
            (auto 100 with MSet_Prop)
          then fail
          else clear H
        end).

    (** ** Turning Set Operators into Propositional Connectives
        The lemmas from [MSetFacts] will be used to break down
        set operations into propositional formulas built over
        the predicates [In] and [E.eq] applied only to
        variables.  We are going to use them with [autorewrite].
        *)

    Hint Rewrite
      F.empty_iff F.singleton_iff F.add_iff F.remove_iff
      F.union_iff F.inter_iff F.diff_iff
    : set_simpl.

    Lemma eq_refl_iff (x : E.t) : E.eq x x <-> True.
    Proof.
     now split.
    Qed.

    Hint Rewrite eq_refl_iff : set_eq_simpl.

    (** ** Decidability of MSet Propositions *)

    (** [In] is decidable. *)
    Lemma dec_In : forall x s,
      decidable (In x s).
    Proof.
      red; intros; generalize (F.mem_iff s x); case (mem x s); intuition.
    Qed.

    (** [E.eq] is decidable. *)
    Lemma dec_eq : forall (x y : E.t),
      decidable (E.eq x y).
    Proof.
      red; intros x y; destruct (E.eq_dec x y); auto.
    Qed.

    (** The hint database [MSet_decidability] will be given to
        the [push_neg] tactic from the module [Negation]. *)
    Hint Resolve dec_In dec_eq : MSet_decidability.

    (** ** Normalizing Propositions About Equality
        We have to deal with the fact that [E.eq] may be
        convertible with Coq's equality.  Thus, we will find the
        following tactics useful to replace one form with the
        other everywhere. *)

    (** The next tactic, [Logic_eq_to_E_eq], mentions the term
        [E.t]; thus, we must ensure that [E.t] is used in favor
        of any other convertible but syntactically distinct
        term. *)
    Ltac change_to_E_t :=
      repeat (
        match goal with
        | H : ?T |- _ =>
          progress (change T with E.t in H);
          repeat (
            match goal with
            | J : _ |- _ => progress (change T with E.t in J)
            | |- _ => progress (change T with E.t)
            end )
        | H : forall x : ?T, _ |- _ =>
          progress (change T with E.t in H);
          repeat (
            match goal with
            | J : _ |- _ => progress (change T with E.t in J)
            | |- _ => progress (change T with E.t)
            end )
       end).

    (** These two tactics take us from Coq's built-in equality
        to [E.eq] (and vice versa) when possible. *)

    Ltac Logic_eq_to_E_eq :=
      repeat (
        match goal with
        | H: _ |- _ =>
          progress (change (@Logic.eq E.t) with E.eq in H)
        | |- _ =>
          progress (change (@Logic.eq E.t) with E.eq)
        end).

    Ltac E_eq_to_Logic_eq :=
      repeat (
        match goal with
        | H: _ |- _ =>
          progress (change E.eq with (@Logic.eq E.t) in H)
        | |- _ =>
          progress (change E.eq with (@Logic.eq E.t))
        end).

    (** This tactic works like the built-in tactic [subst], but
        at the level of set element equality (which may not be
        the convertible with Coq's equality). *)
    Ltac substMSet :=
      repeat (
        match goal with
        | H: E.eq ?x ?x |- _ => clear H
        | H: E.eq ?x ?y |- _ => rewrite H in *; clear H
        end);
      autorewrite with set_eq_simpl in *.

    (** ** Considering Decidability of Base Propositions
        This tactic adds assertions about the decidability of
        [E.eq] and [In] to the context.  This is necessary for
        the completeness of the [fsetdec] tactic.  However, in
        order to minimize the cost of proof search, we should be
        careful to not add more than we need.  Once negations
        have been pushed to the leaves of the propositions, we
        only need to worry about decidability for those base
        propositions that appear in a negated form. *)
    Ltac assert_decidability :=
      (** We actually don't want these rules to fire if the
          syntactic context in the patterns below is trivially
          empty, but we'll just do some clean-up at the
          afterward.  *)
      repeat (
        match goal with
        | H: context [~ E.eq ?x ?y] |- _ =>
          assert new (E.eq x y \/ ~ E.eq x y) by (apply dec_eq)
        | H: context [~ In ?x ?s] |- _ =>
          assert new (In x s \/ ~ In x s) by (apply dec_In)
        | |- context [~ E.eq ?x ?y] =>
          assert new (E.eq x y \/ ~ E.eq x y) by (apply dec_eq)
        | |- context [~ In ?x ?s] =>
          assert new (In x s \/ ~ In x s) by (apply dec_In)
        end);
      (** Now we eliminate the useless facts we added (because
          they would likely be very harmful to performance). *)
      repeat (
        match goal with
        | _: ~ ?P, H : ?P \/ ~ ?P |- _ => clear H
        end).

    (** ** Handling [Empty], [Subset], and [Equal]
        This tactic instantiates universally quantified
        hypotheses (which arise from the unfolding of [Empty],
        [Subset], and [Equal]) for each of the set element
        expressions that is involved in some membership or
        equality fact.  Then it throws away those hypotheses,
        which should no longer be needed. *)
    Ltac inst_MSet_hypotheses :=
      repeat (
        match goal with
        | H : forall a : E.t, _,
          _ : context [ In ?x _ ] |- _ =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        | H : forall a : E.t, _
          |- context [ In ?x _ ] =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        | H : forall a : E.t, _,
          _ : context [ E.eq ?x _ ] |- _ =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        | H : forall a : E.t, _
          |- context [ E.eq ?x _ ] =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        | H : forall a : E.t, _,
          _ : context [ E.eq _ ?x ] |- _ =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        | H : forall a : E.t, _
          |- context [ E.eq _ ?x ] =>
          let P := type of (H x) in
          assert new P by (exact (H x))
        end);
      repeat (
        match goal with
        | H : forall a : E.t, _ |- _ =>
          clear H
        end).

    (** ** The Core [fsetdec] Auxiliary Tactics *)

    (** Here is the crux of the proof search.  Recursion through
        [intuition]!  (This will terminate if I correctly
        understand the behavior of [intuition].) *)
    Ltac fsetdec_rec := progress substMSet; intuition fsetdec_rec.

    (** If we add [unfold Empty, Subset, Equal in *; intros;] to
        the beginning of this tactic, it will satisfy the same
        specification as the [fsetdec] tactic; however, it will
        be much slower than necessary without the pre-processing
        done by the wrapper tactic [fsetdec]. *)
    Ltac fsetdec_body :=
      autorewrite with set_eq_simpl in *;
      inst_MSet_hypotheses;
      autorewrite with set_simpl set_eq_simpl in *;
      push not in * using MSet_decidability;
      substMSet;
      assert_decidability;
      auto;
      (intuition fsetdec_rec) ||
      fail 1
        "because the goal is beyond the scope of this tactic".

  End MSetDecideAuxiliary.
  Import MSetDecideAuxiliary.

  (** * The [fsetdec] Tactic
      Here is the top-level tactic (the only one intended for
      clients of this library).  It's specification is given at
      the top of the file. *)
  Ltac fsetdec :=
    (** We first unfold any occurrences of [iff]. *)
    unfold iff in *;
    (** We fold occurrences of [not] because it is better for
        [intros] to leave us with a goal of [~ P] than a goal of
        [False]. *)
    fold any not; intros;
    (** We don't care about the value of elements : complex ones are
        abstracted as new variables (avoiding potential dependencies,
        see bug 2464) 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab553"></a><h1 class="section">Examples</h1>

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Module</span> <a name="WDecideOn.MSetDecideTestCases"><span class="id" type="module">MSetDecideTestCases</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_eq_trans_1"><span class="id" type="lemma">test_eq_trans_1</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">z</span> <span class="id" type="var">y</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">s</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">z</span> <span class="id" type="var">s</span>.<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_eq_trans_2"><span class="id" type="lemma">test_eq_trans_2</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">r</span> <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.singleton"><span class="id" type="axiom">singleton</span></a> <span class="id" type="var">y</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">z</span> <span class="id" type="var">r</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">z</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">y</span> <span class="id" type="var">r</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">s</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">z</span> <span class="id" type="var">s</span>.<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_eq_neq_trans_1"><span class="id" type="lemma">test_eq_neq_trans_1</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">w</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">w</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">w</span> <span class="id" type="var">s</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">w</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.remove"><span class="id" type="axiom">remove</span></a> <span class="id" type="var">z</span> <span class="id" type="var">s</span>).<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_eq_neq_trans_2"><span class="id" type="lemma">test_eq_neq_trans_2</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">w</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">r1</span> <span class="id" type="var">r2</span> <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.singleton"><span class="id" type="axiom">singleton</span></a> <span class="id" type="var">w</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">r1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">y</span> <span class="id" type="var">r1</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">y</span> <span class="id" type="var">r2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">y</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.remove"><span class="id" type="axiom">remove</span></a> <span class="id" type="var">z</span> <span class="id" type="var">r2</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">w</span> <span class="id" type="var">s</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">w</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.remove"><span class="id" type="axiom">remove</span></a> <span class="id" type="var">z</span> <span class="id" type="var">s</span>).<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_In_singleton"><span class="id" type="lemma">test_In_singleton</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.singleton"><span class="id" type="axiom">singleton</span></a> <span class="id" type="var">x</span>).<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_add_In"><span class="id" type="lemma">test_add_In</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">y</span> <span class="id" type="var">s</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">s</span>.<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_Subset_add_remove"><span class="id" type="lemma">test_Subset_add_remove</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">s</span> <a class="idref" href="Coq.MSets.MSetInterface.html#WSetsOn.::x_'[<=]'_x"><span class="id" type="notation">[&lt;=]</span></a> <a class="idref" href="Coq.MSets.MSetInterface.html#WSetsOn.::x_'[<=]'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.remove"><span class="id" type="axiom">remove</span></a> <span class="id" type="var">x</span> <span class="id" type="var">s</span>)<a class="idref" href="Coq.MSets.MSetInterface.html#WSetsOn.::x_'[<=]'_x"><span class="id" type="notation">)</span></a>.<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_eq_disjunction"><span class="id" type="lemma">test_eq_disjunction</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">w</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">w</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">y</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.singleton"><span class="id" type="axiom">singleton</span></a> <span class="id" type="var">z</span>))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">w</span> <span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">w</span> <span class="id" type="var">y</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">w</span> <span class="id" type="var">z</span>.<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_not_In_disj"><span class="id" type="lemma">test_not_In_disj</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">s1</span> <span class="id" type="var">s2</span> <span class="id" type="var">s3</span> <span class="id" type="var">s4</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.union"><span class="id" type="axiom">union</span></a> <span class="id" type="var">s1</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.union"><span class="id" type="axiom">union</span></a> <span class="id" type="var">s2</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.union"><span class="id" type="axiom">union</span></a> <span class="id" type="var">s3</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">y</span> <span class="id" type="var">s4</span>)))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">s1</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">s4</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">y</span> <span class="id" type="var">x</span><a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_not_In_conj"><span class="id" type="lemma">test_not_In_conj</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">s1</span> <span class="id" type="var">s2</span> <span class="id" type="var">s3</span> <span class="id" type="var">s4</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.union"><span class="id" type="axiom">union</span></a> <span class="id" type="var">s1</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.union"><span class="id" type="axiom">union</span></a> <span class="id" type="var">s2</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.union"><span class="id" type="axiom">union</span></a> <span class="id" type="var">s3</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">y</span> <span class="id" type="var">s4</span>)))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">s1</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">s4</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">/\</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">y</span> <span class="id" type="var">x</span>.<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_iff_conj"><span class="id" type="lemma">test_iff_conj</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">a</span> <span class="id" type="var">x</span> <span class="id" type="var">s</span> <span class="id" type="var">s'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">a</span> <span class="id" type="var">s'</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">&lt;-&gt;</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">a</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">\/</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">a</span> <span class="id" type="var">s</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">a</span> <span class="id" type="var">s'</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">&lt;-&gt;</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">a</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">x</span> <span class="id" type="var">s</span>)).<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_set_ops_1"><span class="id" type="lemma">test_set_ops_1</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">q</span> <span class="id" type="var">r</span> <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetInterface.html#WSetsOn.::x_'[<=]'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Coq.MSets.MSetDecide.html#M.singleton"><span class="id" type="axiom">singleton</span></a> <span class="id" type="var">x</span><a class="idref" href="Coq.MSets.MSetInterface.html#WSetsOn.::x_'[<=]'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Coq.MSets.MSetInterface.html#WSetsOn.::x_'[<=]'_x"><span class="id" type="notation">[&lt;=]</span></a> <span class="id" type="var">s</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.Empty"><span class="id" type="definition">Empty</span></a> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.union"><span class="id" type="axiom">union</span></a> <span class="id" type="var">q</span> <span class="id" type="var">r</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.Empty"><span class="id" type="definition">Empty</span></a> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.inter"><span class="id" type="axiom">inter</span></a> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.diff"><span class="id" type="axiom">diff</span></a> <span class="id" type="var">s</span> <span class="id" type="var">q</span>) (<a class="idref" href="Coq.MSets.MSetDecide.html#M.diff"><span class="id" type="axiom">diff</span></a> <span class="id" type="var">s</span> <span class="id" type="var">r</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">s</span>.<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.eq_chain_test"><span class="id" type="lemma">eq_chain_test</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">x3</span> <span class="id" type="var">x4</span> <span class="id" type="var">s1</span> <span class="id" type="var">s2</span> <span class="id" type="var">s3</span> <span class="id" type="var">s4</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.Empty"><span class="id" type="definition">Empty</span></a> <span class="id" type="var">s1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x2</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">x1</span> <span class="id" type="var">s1</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x3</span> <span class="id" type="var">s2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x3</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.remove"><span class="id" type="axiom">remove</span></a> <span class="id" type="var">x2</span> <span class="id" type="var">s2</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x4</span> <span class="id" type="var">s3</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x4</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">x3</span> <span class="id" type="var">s3</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x1</span> <span class="id" type="var">s4</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.Subset"><span class="id" type="definition">Subset</span></a> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">x4</span> <span class="id" type="var">s4</span>) <span class="id" type="var">s4</span>.<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_too_complex"><span class="id" type="lemma">test_too_complex</span></a> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">r</span> <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.singleton"><span class="id" type="axiom">singleton</span></a> <span class="id" type="var">y</span>) -&gt; <span class="id" type="var">r</span> <a class="idref" href="Coq.MSets.MSetInterface.html#WSetsOn.::x_'[<=]'_x"><span class="id" type="notation">[&lt;=]</span></a> <span class="id" type="var">s</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">z</span> <span class="id" type="var">r</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">z</span> <span class="id" type="var">s</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">fsetdec</span></span> is not intended to solve this directly. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.function_test_1"><span class="id" type="lemma">function_test_1</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">f</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.t"><span class="id" type="axiom">t</span></a> -&gt; <a class="idref" href="Coq.MSets.MSetDecide.html#M.t"><span class="id" type="axiom">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">g</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.elt"><span class="id" type="definition">elt</span></a> -&gt; <a class="idref" href="Coq.MSets.MSetDecide.html#M.elt"><span class="id" type="definition">elt</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">s1</span> <span class="id" type="var">s2</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.t"><span class="id" type="axiom">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">x1</span> <span class="id" type="var">x2</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.elt"><span class="id" type="definition">elt</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.Equal"><span class="id" type="definition">Equal</span></a> <span class="id" type="var">s1</span> (<span class="id" type="var">f</span> <span class="id" type="var">s2</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">x1</span> (<span class="id" type="var">g</span> (<span class="id" type="var">g</span> <span class="id" type="var">x2</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x1</span> <span class="id" type="var">s1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> (<span class="id" type="var">g</span> (<span class="id" type="var">g</span> <span class="id" type="var">x2</span>)) (<span class="id" type="var">f</span> <span class="id" type="var">s2</span>).<br/>
 
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.function_test_2"><span class="id" type="lemma">function_test_2</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">f</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.t"><span class="id" type="axiom">t</span></a> -&gt; <a class="idref" href="Coq.MSets.MSetDecide.html#M.t"><span class="id" type="axiom">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">g</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.elt"><span class="id" type="definition">elt</span></a> -&gt; <a class="idref" href="Coq.MSets.MSetDecide.html#M.elt"><span class="id" type="definition">elt</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">s1</span> <span class="id" type="var">s2</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.t"><span class="id" type="axiom">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">x1</span> <span class="id" type="var">x2</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.elt"><span class="id" type="definition">elt</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.Equal"><span class="id" type="definition">Equal</span></a> <span class="id" type="var">s1</span> (<span class="id" type="var">f</span> <span class="id" type="var">s2</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">x1</span> (<span class="id" type="var">g</span> <span class="id" type="var">x2</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x1</span> <span class="id" type="var">s1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">g</span> <span class="id" type="var">x2</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">g</span> (<span class="id" type="var">g</span> <span class="id" type="var">x2</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> (<span class="id" type="var">g</span> (<span class="id" type="var">g</span> <span class="id" type="var">x2</span>)) (<span class="id" type="var">f</span> <span class="id" type="var">s2</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">fsetdec</span></span> is not intended to solve this directly. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="WDecideOn.MSetDecideTestCases.test_baydemir"><span class="id" type="lemma">test_baydemir</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">f</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.t"><span class="id" type="axiom">t</span></a> -&gt; <a class="idref" href="Coq.MSets.MSetDecide.html#M.t"><span class="id" type="axiom">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">s</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.t"><span class="id" type="axiom">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="Coq.MSets.MSetDecide.html#M.elt"><span class="id" type="definition">elt</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> (<a class="idref" href="Coq.MSets.MSetDecide.html#M.add"><span class="id" type="axiom">add</span></a> <span class="id" type="var">y</span> (<span class="id" type="var">f</span> <span class="id" type="var">s</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E.eq"><span class="id" type="axiom">E.eq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Coq.MSets.MSetDecide.html#M.In"><span class="id" type="axiom">In</span></a> <span class="id" type="var">x</span> (<span class="id" type="var">f</span> <span class="id" type="var">s</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="Coq.MSets.MSetDecide.html#MSetDecideTestCases"><span class="id" type="module">MSetDecideTestCases</span></a>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Coq.MSets.MSetDecide.html#"><span class="id" type="module">WDecideOn</span></a>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="Coq.MSets.MSetInterface.html#"><span class="id" type="library">MSetInterface</span></a>.<br/>

<br/>
</div>

<div class="doc">
Now comes variants for self-contained weak sets and for full sets.
    For these variants, only one argument is necessary. Thanks to
    the subtyping <span class="inlinecode"><span class="id" type="var">WS</span>&lt;=<span class="id" type="var">S</span></span>, the <span class="inlinecode"><span class="id" type="var">Decide</span></span> functor which is meant to be
    used on modules <span class="inlinecode">(<span class="id" type="var">M</span>:<span class="id" type="var">S</span>)</span> can simply be an alias of <span class="inlinecode"><span class="id" type="var">WDecide</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <a name="WDecide"><span class="id" type="module">WDecide</span></a> (<span class="id" type="var">M</span>:<a class="idref" href="Coq.MSets.MSetInterface.html#"><span class="id" type="module">WSets</span></a>) := !<a class="idref" href="Coq.MSets.MSetDecide.html#"><span class="id" type="module">WDecideOn</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#E"><span class="id" type="module">M.E</span></a> <a class="idref" href="Coq.MSets.MSetDecide.html#"><span class="id" type="module">M</span></a>.<br/>
<span class="id" type="keyword">Module</span> <a name="Decide"><span class="id" type="module">Decide</span></a> := <a class="idref" href="Coq.MSets.MSetDecide.html#"><span class="id" type="module">WDecide</span></a>.<br/>
</div>
<div id="sidebarWrapper">
<div id="sidebar">

<div class="block">
<h2 class="title">Navigation</h2>
<div class="content">

<ul class="menu">

<li class="leaf">Standard Library
  <ul class="menu">
  <li><a href="index.html">Table of contents</a></li>
  <li><a href="genindex.html">Index</a></li>
  </ul>
</li>

</ul>

</div>
</div>

</div>
</div>


</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:www-coq_@_lix.polytechnique.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/check?uri=referer">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/check/referer">CSS valid</a></li>
  </ul>

</div>
</div>

</div>

</body>
</html>

