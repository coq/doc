<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Standard Library | The Coq Proof Assistant</title>

<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<style type="text/css" media="all">@import "/modules/node/node.css";</style>

<style type="text/css" media="all">@import "/modules/system/defaults.css";</style>
<style type="text/css" media="all">@import "/modules/system/system.css";</style>
<style type="text/css" media="all">@import "/modules/user/user.css";</style>

<style type="text/css" media="all">@import "/sites/all/themes/coq/style.css";</style>
<style type="text/css" media="all">@import "/sites/all/themes/coq/coqdoc.css";</style>

</head>

<body>

<div id="container">
<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="http://coq.inria.fr/" class="active">Home</a></li>
    
    <li><a href="http://coq.inria.fr/about-coq" title="More about coq">About Coq</a></li>    
    <li><a href="http://coq.inria.fr/download">Get Coq</a></li>
    <li><a href="http://coq.inria.fr/documentation">Documentation</a></li>
    <li><a href="http://coq.inria.fr/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">

<div id="logoWrapper">

<div id="logo"><a href="http://coq.inria.fr/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
</div>
<div id="siteName"><a href="http://coq.inria.fr/" title="Home">The Coq Proof Assistant</a>
</div>

</div>
</div>

<div id="content">

<h1 class="libtitle">Library Coq.Program.Equality</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Tactics related to (dependent) equality and proof irrelevance. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Coq.Logic.ProofIrrelevance.html#"><span class="id" type="library">ProofIrrelevance</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Coq.Logic.JMeq.html#"><span class="id" type="library">JMeq</span></a>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="Coq.Program.Tactics.html#"><span class="id" type="library">Coq.Program.Tactics</span></a>.<br/>

<br/>
<span class="id" type="keyword">Local</span>&nbsp;<span class="id" type="var">Notation </span><a name=":type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">"</span></a>'Π'  x .. y , P" := (<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span>, .. (<span class="id" type="keyword">forall</span> <span class="id" type="var">y</span>, <span class="id" type="var">P</span>) ..)<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 200, <span class="id" type="var">x</span> <span class="id" type="var">binder</span>, <span class="id" type="var">y</span> <span class="id" type="var">binder</span>, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">is_ground_goal</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|- ?<span class="id" type="var">T</span> =&gt; <span class="id" type="var">is_ground</span> <span class="id" type="var">T</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Try to find a contradiction. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Hint</span> <span class="id" type="keyword">Extern</span> 10 =&gt; <span class="id" type="var">is_ground_goal</span> ; <span class="id" type="tactic">progress</span> <span class="id" type="var">exfalso</span> : <span class="id" type="var">exfalso</span>.<br/>

<br/>
</div>

<div class="doc">
We will use the <span class="inlinecode"><span class="id" type="var">block</span></span> definition to separate the goal from the 
   equalities generated by the tactic. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="block"><span class="id" type="definition">block</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">a</span> : <span class="id" type="var">A</span>) := <span class="id" type="var">a</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">block_goal</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span> [ |- ?<span class="id" type="var">T</span> ] =&gt; <span class="id" type="var">change</span> (<a class="idref" href="Coq.Program.Equality.html#block"><span class="id" type="definition">block</span></a> <span class="id" type="var">T</span>) <span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">unblock_goal</span> := <span class="id" type="tactic">unfold</span> <span class="id" type="var">block</span> <span class="id" type="tactic">at</span> 1.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">unblock_all</span> := <span class="id" type="tactic">unfold</span> <span class="id" type="var">block</span> <span class="id" type="keyword">in</span> *.<br/>

<br/>
</div>

<div class="doc">
Notation for heterogenous equality. 
</div>
<div class="code">

<br/>
<span class="id" type="var">Notation </span><a name="::x_'~='_x"><span class="id" type="notation">"</span></a> x ~= y " := (@<a class="idref" href="Coq.Logic.JMeq.html#JMeq"><span class="id" type="inductive">JMeq</span></a> <span class="id" type="var">_</span> <span class="id" type="var">x</span> <span class="id" type="var">_</span> <span class="id" type="var">y</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 70, <span class="id" type="var">no</span> <span class="id" type="var">associativity</span>).<br/>

<br/>
</div>

<div class="doc">
Notation for the single element of <span class="inlinecode"><span class="id" type="var">x</span> = <span class="id" type="var">x</span></span> and <span class="inlinecode"><span class="id" type="var">x</span> ~= <span class="id" type="var">x</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">eq_refl</span></a> [[<span class="id" type="var">A</span>] [<span class="id" type="var">x</span>]] [<span class="id" type="var">A</span>].<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Coq.Logic.JMeq.html#JMeq_refl"><span class="id" type="constructor">JMeq_refl</span></a> [[<span class="id" type="var">A</span>] [<span class="id" type="var">x</span>]] [<span class="id" type="var">A</span>].<br/>

<br/>
</div>

<div class="doc">
Do something on an heterogeneous equality appearing in the context. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">on_JMeq</span> <span class="id" type="var">tac</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" type="var">H</span> : @<a class="idref" href="Coq.Logic.JMeq.html#JMeq"><span class="id" type="inductive">JMeq</span></a> ?<span class="id" type="var">x</span> ?<span class="id" type="var">X</span> ?<span class="id" type="var">y</span> ?<span class="id" type="var">Y</span> |- <span class="id" type="var">_</span> ] =&gt; <span class="id" type="var">tac</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Try to apply <span class="inlinecode"><span class="id" type="var">JMeq_eq</span></span> to get back a regular equality when the two types are equal. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_one_JMeq</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">on_JMeq</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">H</span> =&gt; <span class="id" type="tactic">apply</span> <a class="idref" href="Coq.Logic.JMeq.html#JMeq_eq"><span class="id" type="axiom">JMeq_eq</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>).<br/>

<br/>
</div>

<div class="doc">
Repeat it for every possible hypothesis. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_JMeq</span> := <span class="id" type="tactic">repeat</span> <span class="id" type="var">simpl_one_JMeq</span>.<br/>

<br/>
</div>

<div class="doc">
Just simplify an h.eq. without clearing it. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_one_dep_JMeq</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">on_JMeq</span><br/>
&nbsp;&nbsp;<span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">H</span> =&gt; <span class="id" type="keyword">let</span> <span class="id" type="var">H'</span> := <span class="id" type="tactic">fresh</span> "H" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H'</span> := <a class="idref" href="Coq.Logic.JMeq.html#JMeq_eq"><span class="id" type="axiom">JMeq_eq</span></a> <span class="id" type="var">H</span>)).<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="Coq.Logic.Eqdep.html#"><span class="id" type="library">Eqdep</span></a>.<br/>

<br/>
</div>

<div class="doc">
Simplify dependent equality using sigmas to equality of the second projections if possible.
   Uses UIP. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_existT</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" type="var">H</span> : <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">_</span> ?<span class="id" type="var">x</span> <span class="id" type="var">_</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">_</span> ?<span class="id" type="var">x</span> <span class="id" type="var">_</span> |- <span class="id" type="var">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">Hi</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">assert</span>(<span class="id" type="var">Hi</span>:=<a class="idref" href="Coq.Logic.Eqdep.html#EqdepTheory.inj_pairT2"><span class="id" type="abbreviation">inj_pairT2</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H</span>) ; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_existTs</span> := <span class="id" type="tactic">repeat</span> <span class="id" type="var">simpl_existT</span>.<br/>

<br/>
</div>

<div class="doc">
Tries to eliminate a call to <span class="inlinecode"><span class="id" type="var">eq_rect</span></span> (the substitution principle) by any means available. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">elim_eq_rect</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- ?<span class="id" type="var">t</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">context</span> [ @<a class="idref" href="Coq.Init.Logic.html#eq_rect"><span class="id" type="definition">eq_rect</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> ?<span class="id" type="var">p</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">P</span> := <span class="id" type="tactic">fresh</span> "P" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">set</span> (<span class="id" type="var">P</span> := <span class="id" type="var">p</span>); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">P</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="tactic">case</span> <span class="id" type="var">P</span> ; <span class="id" type="tactic">clear</span> <span class="id" type="var">P</span>) || (<span class="id" type="var">clearbody</span> <span class="id" type="var">P</span>; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Eqdep.html#EqdepTheory.UIP_refl"><span class="id" type="lemma">UIP_refl</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">P</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">P</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">context</span> [ @<a class="idref" href="Coq.Init.Logic.html#eq_rect"><span class="id" type="definition">eq_rect</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> ?<span class="id" type="var">p</span> <span class="id" type="var">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">P</span> := <span class="id" type="tactic">fresh</span> "P" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">set</span> (<span class="id" type="var">P</span> := <span class="id" type="var">p</span>); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">P</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="tactic">case</span> <span class="id" type="var">P</span> ; <span class="id" type="tactic">clear</span> <span class="id" type="var">P</span>) || (<span class="id" type="var">clearbody</span> <span class="id" type="var">P</span>; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Eqdep.html#EqdepTheory.UIP_refl"><span class="id" type="lemma">UIP_refl</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">P</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">P</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Rewrite using uniqueness of indentity proofs <span class="inlinecode"><span class="id" type="var">H</span> = <span class="id" type="var">eq_refl</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_uip</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" type="var">H</span> : ?<span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">X</span> |- <span class="id" type="var">_</span> ] =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.Eqdep.html#EqdepTheory.UIP_refl"><span class="id" type="lemma">UIP_refl</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H</span>) <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Simplify equalities appearing in the context and goal. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_eq</span> := <span class="id" type="tactic">simpl</span> ; <span class="id" type="tactic">unfold</span> <span class="id" type="var">eq_rec_r</span>, <span class="id" type="var">eq_rec</span> ; <span class="id" type="tactic">repeat</span> (<span class="id" type="var">elim_eq_rect</span> ; <span class="id" type="tactic">simpl</span>) ; <span class="id" type="tactic">repeat</span> (<span class="id" type="var">simpl_uip</span> ; <span class="id" type="tactic">simpl</span>).<br/>

<br/>
</div>

<div class="doc">
Try to abstract a proof of equality, if no proof of the same equality is present in the context. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">abstract_eq_hyp</span> <span class="id" type="var">H'</span> <span class="id" type="var">p</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">ty</span> := <span class="id" type="var">type</span> <span class="id" type="var">of</span> <span class="id" type="var">p</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">tyred</span> := <span class="id" type="var">eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">ty</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">tyred</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?<span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Y</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" type="var">H</span> : <span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">Y</span> |- <span class="id" type="var">_</span> ] =&gt; <span class="id" type="tactic">fail</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">set</span> (<span class="id" type="var">H'</span>:=<span class="id" type="var">p</span>) ; <span class="id" type="tactic">try</span> (<span class="id" type="var">change</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> <span class="id" type="var">H'</span>) ; <span class="id" type="var">clearbody</span> <span class="id" type="var">H'</span> ; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Apply the tactic tac to proofs of equality appearing as coercion arguments.
   Just redefine this tactic (using <span class="inlinecode"><span class="id" type="keyword">Ltac</span> <span class="id" type="var">on_coerce_proof</span> <span class="id" type="var">tac</span> ::=</span>) to handle custom coercion operators.
   
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">on_coerce_proof</span> <span class="id" type="var">tac</span> <span class="id" type="var">T</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">T</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">context</span> [ <a class="idref" href="Coq.Init.Logic.html#eq_rect"><span class="id" type="definition">eq_rect</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> ?<span class="id" type="var">p</span> ] =&gt; <span class="id" type="var">tac</span> <span class="id" type="var">p</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">on_coerce_proof_gl</span> <span class="id" type="var">tac</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;[ |- ?<span class="id" type="var">T</span> ] =&gt; <span class="id" type="var">on_coerce_proof</span> <span class="id" type="var">tac</span> <span class="id" type="var">T</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Abstract proofs of equalities of coercions. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">abstract_eq_proof</span> := <span class="id" type="var">on_coerce_proof_gl</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">p</span> =&gt; <span class="id" type="keyword">let</span> <span class="id" type="var">H</span> := <span class="id" type="tactic">fresh</span> "eqH" <span class="id" type="keyword">in</span> <span class="id" type="var">abstract_eq_hyp</span> <span class="id" type="var">H</span> <span class="id" type="var">p</span>).<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">abstract_eq_proofs</span> := <span class="id" type="tactic">repeat</span> <span class="id" type="var">abstract_eq_proof</span>.<br/>

<br/>
</div>

<div class="doc">
Factorize proofs, by using proof irrelevance so that two proofs of the same equality
   in the goal become convertible. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">pi_eq_proof_hyp</span> <span class="id" type="var">p</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">ty</span> := <span class="id" type="var">type</span> <span class="id" type="var">of</span> <span class="id" type="var">p</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">tyred</span> := <span class="id" type="var">eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">ty</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">tyred</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;?<span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Y</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" type="var">H</span> : <span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">Y</span> |- <span class="id" type="var">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> =&gt; <span class="id" type="tactic">fail</span> 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">rewrite</span> (<a class="idref" href="Coq.Logic.ProofIrrelevance.html#proof_irrelevance"><span class="id" type="axiom">proof_irrelevance</span></a> (<span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">Y</span>) <span class="id" type="var">p</span> <span class="id" type="var">H</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">fail</span> " No hypothesis with same type "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Factorize proofs of equality appearing as coercion arguments. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">pi_eq_proof</span> := <span class="id" type="var">on_coerce_proof_gl</span> <span class="id" type="var">pi_eq_proof_hyp</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">pi_eq_proofs</span> := <span class="id" type="tactic">repeat</span> <span class="id" type="var">pi_eq_proof</span>.<br/>

<br/>
</div>

<div class="doc">
The two preceding tactics in sequence. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">clear_eq_proofs</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">abstract_eq_proofs</span> ; <span class="id" type="var">pi_eq_proofs</span>.<br/>

<br/>
<span class="id" type="keyword">Hint</span> <span class="id" type="var">Rewrite</span> &lt;- <a class="idref" href="Coq.Logic.Eqdep.html#EqdepTheory.eq_rect_eq"><span class="id" type="lemma">eq_rect_eq</span></a> : <span class="id" type="var">refl_id</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">refl_id</span></span> database should be populated with lemmas of the form
   <span class="inlinecode"><span class="id" type="var">coerce_</span>* <span class="id" type="var">t</span> <span class="id" type="var">eq_refl</span> = <span class="id" type="var">t</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="JMeq_eq_refl"><span class="id" type="lemma">JMeq_eq_refl</span></a> {<span class="id" type="var">A</span>} (<span class="id" type="var">x</span> : <span class="id" type="var">A</span>) : <a class="idref" href="Coq.Logic.JMeq.html#JMeq_eq"><span class="id" type="axiom">JMeq_eq</span></a> (@<a class="idref" href="Coq.Logic.JMeq.html#JMeq_refl"><span class="id" type="constructor">JMeq_refl</span></a> <span class="id" type="var">_</span> <span class="id" type="var">x</span>) <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">eq_refl</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="UIP_refl_refl"><span class="id" type="lemma">UIP_refl_refl</span></a> : <a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">A</span> (<span class="id" type="var">x</span> : <span class="id" type="var">A</span>)<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Coq.Logic.Eqdep.html#EqdepTheory.UIP_refl"><span class="id" type="lemma">Eqdep.EqdepTheory.UIP_refl</span></a> <span class="id" type="var">A</span> <span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">eq_refl</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">eq_refl</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="inj_pairT2_refl"><span class="id" type="lemma">inj_pairT2_refl</span></a> : <a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">A</span> (<span class="id" type="var">x</span> : <span class="id" type="var">A</span>) (<span class="id" type="var">P</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="keyword">Type</span>) (<span class="id" type="var">p</span> : <span class="id" type="var">P</span> <span class="id" type="var">x</span>)<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Coq.Logic.Eqdep.html#EqdepTheory.inj_pairT2"><span class="id" type="abbreviation">Eqdep.EqdepTheory.inj_pairT2</span></a> <span class="id" type="var">A</span> <span class="id" type="var">P</span> <span class="id" type="var">x</span> <span class="id" type="var">p</span> <span class="id" type="var">p</span> <a class="idref" href="Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">eq_refl</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">eq_refl</span></a>.<br/>
 
<br/>
<span class="id" type="keyword">Hint</span> <span class="id" type="var">Rewrite</span> @<a class="idref" href="Coq.Program.Equality.html#JMeq_eq_refl"><span class="id" type="lemma">JMeq_eq_refl</span></a> @<a class="idref" href="Coq.Program.Equality.html#UIP_refl_refl"><span class="id" type="lemma">UIP_refl_refl</span></a> @<a class="idref" href="Coq.Program.Equality.html#inj_pairT2_refl"><span class="id" type="lemma">inj_pairT2_refl</span></a> : <span class="id" type="var">refl_id</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">rewrite_refl_id</span> := <span class="id" type="var">autorewrite</span> <span class="id" type="keyword">with</span> <span class="id" type="var">refl_id</span>.<br/>

<br/>
</div>

<div class="doc">
Clear the context and goal of equality proofs. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">clear_eq_ctx</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">rewrite_refl_id</span> ; <span class="id" type="var">clear_eq_proofs</span>.<br/>

<br/>
</div>

<div class="doc">
Reapeated elimination of <span class="inlinecode"><span class="id" type="var">eq_rect</span></span> applications.
   Abstracting equalities makes it run much faster than an naive implementation. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_eqs</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> (<span class="id" type="var">elim_eq_rect</span> ; <span class="id" type="tactic">simpl</span> ; <span class="id" type="var">clear_eq_ctx</span>).<br/>

<br/>
</div>

<div class="doc">
Clear unused reflexivity proofs. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">clear_refl_eq</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span> [ <span class="id" type="var">H</span> : ?<span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">X</span> |- <span class="id" type="var">_</span> ] =&gt; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span> <span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">clear_refl_eqs</span> := <span class="id" type="tactic">repeat</span> <span class="id" type="var">clear_refl_eq</span>.<br/>

<br/>
</div>

<div class="doc">
Clear unused equality proofs. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">clear_eq</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span> [ <span class="id" type="var">H</span> : <span class="id" type="var">_</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">_</span> |- <span class="id" type="var">_</span> ] =&gt; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span> <span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">clear_eqs</span> := <span class="id" type="tactic">repeat</span> <span class="id" type="var">clear_eq</span>.<br/>

<br/>
</div>

<div class="doc">
Combine all the tactics to simplify goals containing coercions. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simplify_eqs</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span> ; <span class="id" type="var">simpl_eqs</span> ; <span class="id" type="var">clear_eq_ctx</span> ; <span class="id" type="var">clear_refl_eqs</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="tactic">subst</span> ; <span class="id" type="tactic">simpl</span> ; <span class="id" type="tactic">repeat</span> <span class="id" type="var">simpl_uip</span> ; <span class="id" type="var">rewrite_refl_id</span>.<br/>

<br/>
</div>

<div class="doc">
A tactic that tries to remove trivial equality guards in induction hypotheses coming
   from <span class="inlinecode"><span class="id" type="tactic">dependent</span> <span class="id" type="tactic">induction</span></span>/<span class="inlinecode"><span class="id" type="tactic">generalize_eqs</span></span> invocations. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simplify_IH_hyps</span> := <span class="id" type="tactic">repeat</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" type="var">hyp</span> : <span class="id" type="var">context</span> [ <a class="idref" href="Coq.Program.Equality.html#block"><span class="id" type="definition">block</span></a> <span class="id" type="var">_</span> ] |- <span class="id" type="var">_</span> ] =&gt; <span class="id" type="var">specialize_eqs</span> <span class="id" type="var">hyp</span> ; <span class="id" type="tactic">unfold</span> <span class="id" type="var">block</span> <span class="id" type="keyword">in</span> <span class="id" type="var">hyp</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We split substitution tactics in the two directions depending on which 
   names we want to keep corresponding to the generalization performed by the
   <span class="inlinecode"><span class="id" type="tactic">generalize_eqs</span></span> tactic. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">subst_left_no_fail</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> (<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" type="var">H</span> : ?<span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Y</span> |- <span class="id" type="var">_</span> ] =&gt; <span class="id" type="tactic">subst</span> <span class="id" type="var">X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>).<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">subst_right_no_fail</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> (<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" type="var">H</span> : ?<span class="id" type="var">X</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">Y</span> |- <span class="id" type="var">_</span> ] =&gt; <span class="id" type="tactic">subst</span> <span class="id" type="var">Y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>).<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">inject_left</span> <span class="id" type="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">progress</span> (<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> ; <span class="id" type="var">subst_left_no_fail</span> ; <span class="id" type="var">clear_dups</span>) ; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">inject_right</span> <span class="id" type="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">progress</span> (<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> ; <span class="id" type="var">subst_right_no_fail</span> ; <span class="id" type="var">clear_dups</span>) ; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">autoinjections_left</span> := <span class="id" type="tactic">repeat</span> <span class="id" type="var">autoinjection</span> <span class="id" type="var">ltac</span>:<span class="id" type="var">inject_left</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">autoinjections_right</span> := <span class="id" type="tactic">repeat</span> <span class="id" type="var">autoinjection</span> <span class="id" type="var">ltac</span>:<span class="id" type="var">inject_right</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_depind</span> := <span class="id" type="var">subst_no_fail</span> ; <span class="id" type="var">autoinjections</span> ; <span class="id" type="tactic">try</span> <span class="id" type="var">discriminates</span> ; <br/>
&nbsp;&nbsp;<span class="id" type="var">simpl_JMeq</span> ; <span class="id" type="var">simpl_existTs</span> ; <span class="id" type="var">simplify_IH_hyps</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_depind_l</span> := <span class="id" type="var">subst_left_no_fail</span> ; <span class="id" type="var">autoinjections_left</span> ; <span class="id" type="tactic">try</span> <span class="id" type="var">discriminates</span> ; <br/>
&nbsp;&nbsp;<span class="id" type="var">simpl_JMeq</span> ; <span class="id" type="var">simpl_existTs</span> ; <span class="id" type="var">simplify_IH_hyps</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_depind_r</span> := <span class="id" type="var">subst_right_no_fail</span> ; <span class="id" type="var">autoinjections_right</span> ; <span class="id" type="tactic">try</span> <span class="id" type="var">discriminates</span> ; <br/>
&nbsp;&nbsp;<span class="id" type="var">simpl_JMeq</span> ; <span class="id" type="var">simpl_existTs</span> ; <span class="id" type="var">simplify_IH_hyps</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">blocked</span> <span class="id" type="var">t</span> := <span class="id" type="var">block_goal</span> ; <span class="id" type="var">t</span> ; <span class="id" type="var">unblock_goal</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">DependentEliminationPackage</span></span> provides the default dependent elimination principle to
   be used by the <span class="inlinecode"><span class="id" type="var">equations</span></span> resolver. It is especially useful to register the dependent elimination
   principles for things in <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> which are not automatically generated. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Class</span> <a name="DependentEliminationPackage"><span class="id" type="record">DependentEliminationPackage</span></a> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) :=<br/>
&nbsp;&nbsp;{ <a name="elim_type"><span class="id" type="projection">elim_type</span></a> : <span class="id" type="keyword">Type</span> ; <a name="elim"><span class="id" type="projection">elim</span></a> : <a class="idref" href="Coq.Program.Equality.html#elim_type"><span class="id" type="method">elim_type</span></a> }.<br/>

<br/>
</div>

<div class="doc">
A higher-order tactic to apply a registered eliminator. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">elim_tac</span> <span class="id" type="var">tac</span> <span class="id" type="var">p</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">ty</span> := <span class="id" type="var">type</span> <span class="id" type="var">of</span> <span class="id" type="var">p</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">eliminator</span> := <span class="id" type="var">eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> (<a class="idref" href="Coq.Program.Equality.html#elim"><span class="id" type="method">elim</span></a> (<span class="id" type="var">A</span>:=<span class="id" type="var">ty</span>)) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">tac</span> <span class="id" type="var">p</span> <span class="id" type="var">eliminator</span>.<br/>

<br/>
</div>

<div class="doc">
Specialization to do case analysis or induction.
   Note: the <span class="inlinecode"><span class="id" type="var">equations</span></span> tactic tries <span class="inlinecode"><span class="id" type="tactic">case</span></span> before <span class="inlinecode"><span class="id" type="var">elim_case</span></span>: there is no need to register
   generated induction principles. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">elim_case</span> <span class="id" type="var">p</span> := <span class="id" type="var">elim_tac</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">p</span> <span class="id" type="var">el</span> =&gt; <span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span> <span class="id" type="keyword">using</span> <span class="id" type="var">el</span>) <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">elim_ind</span> <span class="id" type="var">p</span> := <span class="id" type="var">elim_tac</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">p</span> <span class="id" type="var">el</span> =&gt; <span class="id" type="tactic">induction</span> <span class="id" type="var">p</span> <span class="id" type="keyword">using</span> <span class="id" type="var">el</span>) <span class="id" type="var">p</span>.<br/>

<br/>
</div>

<div class="doc">
Lemmas used by the simplifier, mainly rephrasings of <span class="inlinecode"><span class="id" type="var">eq_rect</span></span>, <span class="inlinecode"><span class="id" type="var">eq_ind</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="solution_left"><span class="id" type="lemma">solution_left</span></a> : <a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">A</span> (<span class="id" type="var">B</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="keyword">Type</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">A</span>)<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <span class="id" type="var">B</span> <span class="id" type="var">t</span> -&gt; (<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">x</span><a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">t</span> -&gt; <span class="id" type="var">B</span> <span class="id" type="var">x</span>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="solution_right"><span class="id" type="lemma">solution_right</span></a> : <a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">A</span> (<span class="id" type="var">B</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="keyword">Type</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">A</span>)<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <span class="id" type="var">B</span> <span class="id" type="var">t</span> -&gt; (<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">x</span><a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <span class="id" type="var">t</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">x</span> -&gt; <span class="id" type="var">B</span> <span class="id" type="var">x</span>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="deletion"><span class="id" type="lemma">deletion</span></a> : <a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> (<span class="id" type="var">t</span> : <span class="id" type="var">A</span>)<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <span class="id" type="var">B</span> -&gt; (<span class="id" type="var">t</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">t</span> -&gt; <span class="id" type="var">B</span>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="simplification_heq"><span class="id" type="lemma">simplification_heq</span></a> : <a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span> (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">A</span>)<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> (<span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">y</span> -&gt; <span class="id" type="var">B</span>) -&gt; (<a class="idref" href="Coq.Logic.JMeq.html#JMeq"><span class="id" type="inductive">JMeq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> -&gt; <span class="id" type="var">B</span>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="simplification_existT2"><span class="id" type="lemma">simplification_existT2</span></a> : <a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">A</span> (<span class="id" type="var">P</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="keyword">Type</span>) <span class="id" type="var">B</span> (<span class="id" type="var">p</span> : <span class="id" type="var">A</span>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">P</span> <span class="id" type="var">p</span>)<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a><br/>
&nbsp;&nbsp;(<span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">y</span> -&gt; <span class="id" type="var">B</span>) -&gt; (<a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">P</span> <span class="id" type="var">p</span> <span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">P</span> <span class="id" type="var">p</span> <span class="id" type="var">y</span> -&gt; <span class="id" type="var">B</span>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="simplification_existT1"><span class="id" type="lemma">simplification_existT1</span></a> : <a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">A</span> (<span class="id" type="var">P</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="keyword">Type</span>) <span class="id" type="var">B</span> (<span class="id" type="var">p</span> <span class="id" type="var">q</span> : <span class="id" type="var">A</span>) (<span class="id" type="var">x</span> : <span class="id" type="var">P</span> <span class="id" type="var">p</span>) (<span class="id" type="var">y</span> : <span class="id" type="var">P</span> <span class="id" type="var">q</span>)<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a><br/>
&nbsp;&nbsp;(<span class="id" type="var">p</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">q</span> -&gt; <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">P</span> <span class="id" type="var">p</span> <span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">P</span> <span class="id" type="var">q</span> <span class="id" type="var">y</span> -&gt; <span class="id" type="var">B</span>) -&gt; (<a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">P</span> <span class="id" type="var">p</span> <span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">P</span> <span class="id" type="var">q</span> <span class="id" type="var">y</span> -&gt; <span class="id" type="var">B</span>).<br/>
 
<br/>
<span class="id" type="keyword">Lemma</span> <a name="simplification_K"><span class="id" type="lemma">simplification_K</span></a> : <a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">A</span> (<span class="id" type="var">x</span> : <span class="id" type="var">A</span>) (<span class="id" type="var">B</span> : <span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">x</span> -&gt; <span class="id" type="keyword">Type</span>)<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <span class="id" type="var">B</span> <a class="idref" href="Coq.Init.Logic.html#eq_refl"><span class="id" type="constructor">eq_refl</span></a> -&gt; (<a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">Π</span></a> <span class="id" type="var">p</span> : <span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">x</span><a class="idref" href="Coq.Program.Equality.html#:type_scope:'Π'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <span class="id" type="var">B</span> <span class="id" type="var">p</span>).<br/>
 
<br/>
</div>

<div class="doc">
This hint database and the following tactic can be used with <span class="inlinecode"><span class="id" type="var">autounfold</span></span> to 
   unfold everything to <span class="inlinecode"><span class="id" type="var">eq_rect</span></span>s. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Hint</span> <span class="id" type="keyword">Unfold</span> <a class="idref" href="Coq.Program.Equality.html#solution_left"><span class="id" type="lemma">solution_left</span></a> <a class="idref" href="Coq.Program.Equality.html#solution_right"><span class="id" type="lemma">solution_right</span></a> <a class="idref" href="Coq.Program.Equality.html#deletion"><span class="id" type="lemma">deletion</span></a> <a class="idref" href="Coq.Program.Equality.html#simplification_heq"><span class="id" type="lemma">simplification_heq</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Coq.Program.Equality.html#simplification_existT1"><span class="id" type="lemma">simplification_existT1</span></a> <a class="idref" href="Coq.Program.Equality.html#simplification_existT2"><span class="id" type="lemma">simplification_existT2</span></a> <a class="idref" href="Coq.Program.Equality.html#simplification_K"><span class="id" type="lemma">simplification_K</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#eq_rect_r"><span class="id" type="definition">eq_rect_r</span></a> <a class="idref" href="Coq.Init.Logic.html#eq_rec"><span class="id" type="definition">eq_rec</span></a> <a class="idref" href="Coq.Init.Logic.html#eq_ind"><span class="id" type="definition">eq_ind</span></a> : <span class="id" type="var">dep_elim</span>.<br/>

<br/>
</div>

<div class="doc">
Using these we can make a simplifier that will perform the unification
   steps needed to put the goal in normalised form (provided there are only
   constructor forms). Compare with the lemma 16 of the paper.
   We don't have a <span class="inlinecode"><span class="id" type="var">noCycle</span></span> procedure yet. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">block_equality</span> <span class="id" type="var">id</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">type</span> <span class="id" type="var">of</span> <span class="id" type="var">id</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| @<a class="idref" href="Coq.Init.Logic.html#eq"><span class="id" type="inductive">eq</span></a> ?<span class="id" type="var">A</span> ?<span class="id" type="var">t</span> ?<span class="id" type="var">u</span> =&gt; <span class="id" type="var">change</span> (<a class="idref" href="Coq.Program.Equality.html#block"><span class="id" type="definition">block</span></a> (@<a class="idref" href="Coq.Init.Logic.html#eq"><span class="id" type="inductive">eq</span></a> <span class="id" type="var">A</span> <span class="id" type="var">t</span> <span class="id" type="var">u</span>)) <span class="id" type="keyword">in</span> <span class="id" type="var">id</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="var">idtac</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">revert_blocking_until</span> <span class="id" type="var">id</span> := <br/>
&nbsp;&nbsp;<span class="id" type="var">Tactics.on_last_hyp</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">id'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">id'</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">id</span> =&gt; <span class="id" type="var">idtac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="var">block_equality</span> <span class="id" type="var">id'</span> ; <span class="id" type="var">revert</span> <span class="id" type="var">id'</span> ; <span class="id" type="var">revert_blocking_until</span> <span class="id" type="var">id</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>).<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simplify_one_dep_elim_term</span> <span class="id" type="var">c</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| @<a class="idref" href="Coq.Logic.JMeq.html#JMeq"><span class="id" type="inductive">JMeq</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> -&gt; <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">refine</span> (<a class="idref" href="Coq.Program.Equality.html#simplification_heq"><span class="id" type="lemma">simplification_heq</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" type="var">t</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">t</span> -&gt; <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> || <span class="id" type="tactic">refine</span> (<a class="idref" href="Coq.Program.Equality.html#simplification_K"><span class="id" type="lemma">simplification_K</span></a> <span class="id" type="var">_</span> <span class="id" type="var">t</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Coq.Init.Logic.html#eq"><span class="id" type="inductive">eq</span></a> (<a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">_</span> ?<span class="id" type="var">p</span> <span class="id" type="var">_</span>) (<a class="idref" href="Coq.Init.Specif.html#existT"><span class="id" type="constructor">existT</span></a> <span class="id" type="var">_</span> ?<span class="id" type="var">q</span> <span class="id" type="var">_</span>) -&gt; <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<a class="idref" href="Coq.Program.Equality.html#simplification_existT2"><span class="id" type="lemma">simplification_existT2</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span> : <span class="id" type="var">p</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">q</span> |- <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">intro</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">refine</span> (<a class="idref" href="Coq.Program.Equality.html#simplification_existT1"><span class="id" type="lemma">simplification_existT1</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">y</span> -&gt; <span class="id" type="var">_</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">let</span> <span class="id" type="var">hyp</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">intros</span> <span class="id" type="var">hyp</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">move</span> <span class="id" type="var">hyp</span> <span class="id" type="keyword">before</span> <span class="id" type="var">x</span> ; <span class="id" type="var">revert_blocking_until</span> <span class="id" type="var">hyp</span> ; <span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">x</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<a class="idref" href="Coq.Program.Equality.html#solution_left"><span class="id" type="lemma">solution_left</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>)) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">let</span> <span class="id" type="var">hyp</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">intros</span> <span class="id" type="var">hyp</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">move</span> <span class="id" type="var">hyp</span> <span class="id" type="keyword">before</span> <span class="id" type="var">y</span> ; <span class="id" type="var">revert_blocking_until</span> <span class="id" type="var">hyp</span> ; <span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">y</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<a class="idref" href="Coq.Program.Equality.html#solution_right"><span class="id" type="lemma">solution_right</span></a> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" type="var">f</span> ?<span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">g</span> ?<span class="id" type="var">y</span> -&gt; <span class="id" type="var">_</span> =&gt; <span class="id" type="keyword">let</span> <span class="id" type="var">H</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">progress</span> (<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span> ; <span class="id" type="tactic">injection</span> <span class="id" type="var">H</span> ; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" type="var">t</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">u</span> -&gt; <span class="id" type="var">_</span> =&gt; <span class="id" type="keyword">let</span> <span class="id" type="var">hyp</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">hyp</span> ; <span class="id" type="var">exfalso</span> ; <span class="id" type="tactic">discriminate</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" type="var">x</span> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">?</span></a><span class="id" type="var">y</span> -&gt; <span class="id" type="var">_</span> =&gt; <span class="id" type="keyword">let</span> <span class="id" type="var">hyp</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">hyp</span> ; (<span class="id" type="tactic">try</span> (<span class="id" type="tactic">clear</span> <span class="id" type="var">hyp</span> ;  <span class="id" type="tactic">fail</span> 1)) ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">case</span> <span class="id" type="var">hyp</span> ; <span class="id" type="tactic">clear</span> <span class="id" type="var">hyp</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Coq.Program.Equality.html#block"><span class="id" type="definition">block</span></a> ?<span class="id" type="var">T</span> =&gt; <span class="id" type="tactic">fail</span> 1 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span>, <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">intro</span> <span class="id" type="var">x</span> || (<span class="id" type="keyword">let</span> <span class="id" type="var">H</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">x</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">rename</span> <span class="id" type="var">x</span> <span class="id" type="var">into</span> <span class="id" type="var">H</span> ; <span class="id" type="tactic">intro</span> <span class="id" type="var">x</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">intro</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simplify_one_dep_elim</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- ?<span class="id" type="var">gl</span> ] =&gt; <span class="id" type="var">simplify_one_dep_elim_term</span> <span class="id" type="var">gl</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Repeat until no progress is possible. By construction, it should leave the goal with
   no remaining equalities generated by the <span class="inlinecode"><span class="id" type="tactic">generalize_eqs</span></span> tactic. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simplify_dep_elim</span> := <span class="id" type="tactic">repeat</span> <span class="id" type="var">simplify_one_dep_elim</span>.<br/>

<br/>
</div>

<div class="doc">
Do dependent elimination of the last hypothesis, but not simplifying yet
   (used internally). 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">destruct_last</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">on_last_hyp</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">id</span> =&gt; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">id</span> ; <span class="id" type="tactic">generalize_eqs</span> <span class="id" type="var">id</span> ; <span class="id" type="tactic">destruct</span> <span class="id" type="var">id</span>).<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">introduce</span> <span class="id" type="var">p</span> := <span class="id" type="var">first</span> [<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> <span class="id" type="var">_</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">p</span> ; <span class="id" type="tactic">intros</span> <span class="id" type="var">p</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" type="tactic">intros</span> <span class="id" type="var">until</span> <span class="id" type="var">p</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">until</span> 1 | <span class="id" type="tactic">intros</span> ].<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">do_case</span> <span class="id" type="var">p</span> := <span class="id" type="var">introduce</span> <span class="id" type="var">p</span> ; (<span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span> || <span class="id" type="var">elim_case</span> <span class="id" type="var">p</span> || (<span class="id" type="tactic">case</span> <span class="id" type="var">p</span> ; <span class="id" type="tactic">clear</span> <span class="id" type="var">p</span>)).<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">do_ind</span> <span class="id" type="var">p</span> := <span class="id" type="var">introduce</span> <span class="id" type="var">p</span> ; (<span class="id" type="tactic">induction</span> <span class="id" type="var">p</span> || <span class="id" type="var">elim_ind</span> <span class="id" type="var">p</span>).<br/>

<br/>
</div>

<div class="doc">
The following tactics allow to do induction on an already instantiated inductive predicate
   by first generalizing it and adding the proper equalities to the context, in a maner similar to
   the BasicElim tactic of "Elimination with a motive" by Conor McBride. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">do_depelim</span></span> higher-order tactic takes an elimination tactic as argument and an hypothesis 
   and starts a dependent elimination using this tactic. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">is_introduced</span> <span class="id" type="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" type="var">H'</span> : <span class="id" type="var">_</span> |- <span class="id" type="var">_</span> ] =&gt; <span class="id" type="keyword">match</span> <span class="id" type="var">H'</span> <span class="id" type="keyword">with</span> <span class="id" type="var">H</span> =&gt; <span class="id" type="var">idtac</span> <span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "intro_block" <span class="id" type="var">hyp</span>(<span class="id" type="var">H</span>) :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">is_introduced</span> <span class="id" type="var">H</span> ; <span class="id" type="var">block_goal</span> ; <span class="id" type="var">revert_until</span> <span class="id" type="var">H</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">let</span> <span class="id" type="var">H'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">intros</span> <span class="id" type="var">until</span> <span class="id" type="var">H'</span> ; <span class="id" type="var">block_goal</span>) || (<span class="id" type="tactic">intros</span> ; <span class="id" type="var">block_goal</span>).<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "intro_block_id" <span class="id" type="var">ident</span>(<span class="id" type="var">H</span>) :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">is_introduced</span> <span class="id" type="var">H</span> ; <span class="id" type="var">block_goal</span> ; <span class="id" type="var">revert_until</span> <span class="id" type="var">H</span>) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">let</span> <span class="id" type="var">H'</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="tactic">intros</span> <span class="id" type="var">until</span> <span class="id" type="var">H'</span> ; <span class="id" type="var">block_goal</span>) || (<span class="id" type="tactic">intros</span> ; <span class="id" type="var">block_goal</span>).<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">simpl_dep_elim</span> := <span class="id" type="var">simplify_dep_elim</span> ; <span class="id" type="var">simplify_IH_hyps</span> ; <span class="id" type="var">unblock_all</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">do_intros</span> <span class="id" type="var">H</span> :=<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">try</span> <span class="id" type="tactic">intros</span> <span class="id" type="var">until</span> <span class="id" type="var">H</span>) ; (<span class="id" type="var">intro_block_id</span> <span class="id" type="var">H</span> || <span class="id" type="var">intro_block</span> <span class="id" type="var">H</span>).<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">do_depelim_nosimpl</span> <span class="id" type="var">tac</span> <span class="id" type="var">H</span> := <span class="id" type="var">do_intros</span> <span class="id" type="var">H</span> ; <span class="id" type="tactic">generalize_eqs</span> <span class="id" type="var">H</span> ; <span class="id" type="var">block_goal</span> ; <span class="id" type="var">tac</span> <span class="id" type="var">H</span> ; <span class="id" type="var">unblock_goal</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">do_depelim</span> <span class="id" type="var">tac</span> <span class="id" type="var">H</span> := <span class="id" type="var">do_depelim_nosimpl</span> <span class="id" type="var">tac</span> <span class="id" type="var">H</span> ; <span class="id" type="var">simpl_dep_elim</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">do_depind</span> <span class="id" type="var">tac</span> <span class="id" type="var">H</span> := <br/>
&nbsp;&nbsp;<span class="id" type="var">do_intros</span> <span class="id" type="var">H</span> ; <span class="id" type="tactic">generalize_eqs_vars</span> <span class="id" type="var">H</span> ; <span class="id" type="var">block_goal</span> ; <span class="id" type="var">tac</span> <span class="id" type="var">H</span> ; <br/>
&nbsp;&nbsp;<span class="id" type="var">unblock_goal</span> ; <span class="id" type="var">simplify_dep_elim</span> ; <span class="id" type="var">simplify_IH_hyps</span> ; <span class="id" type="var">unblock_all</span>.<br/>

<br/>
</div>

<div class="doc">
To dependent elimination on some hyp. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">depelim</span> <span class="id" type="var">id</span> := <span class="id" type="var">do_depelim</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="var">do_case</span> <span class="id" type="var">hyp</span>) <span class="id" type="var">id</span>.<br/>

<br/>
</div>

<div class="doc">
Used internally. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">depelim_nosimpl</span> <span class="id" type="var">id</span> := <span class="id" type="var">do_depelim_nosimpl</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="var">do_case</span> <span class="id" type="var">hyp</span>) <span class="id" type="var">id</span>.<br/>

<br/>
</div>

<div class="doc">
To dependent induction on some hyp. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">depind</span> <span class="id" type="var">id</span> := <span class="id" type="var">do_depind</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="var">do_ind</span> <span class="id" type="var">hyp</span>) <span class="id" type="var">id</span>.<br/>

<br/>
</div>

<div class="doc">
A variant where generalized variables should be given by the user. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">do_depelim'</span> <span class="id" type="var">tac</span> <span class="id" type="var">H</span> :=<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">try</span> <span class="id" type="tactic">intros</span> <span class="id" type="var">until</span> <span class="id" type="var">H</span>) ; <span class="id" type="var">block_goal</span> ; <span class="id" type="tactic">generalize_eqs</span> <span class="id" type="var">H</span> ; <span class="id" type="var">block_goal</span> ; <span class="id" type="var">tac</span> <span class="id" type="var">H</span> ; <span class="id" type="var">unblock_goal</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">simplify_dep_elim</span> ; <span class="id" type="var">simplify_IH_hyps</span> ; <span class="id" type="var">unblock_all</span>.<br/>

<br/>
</div>

<div class="doc">
Calls <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> on the generalized hypothesis, results should be similar to inversion.
   By default, we don't try to generalize the hyp by its variable indices.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Tactic Notation</span> "dependent" "destruction" <span class="id" type="var">ident</span>(<span class="id" type="var">H</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="var">do_depelim'</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="var">do_case</span> <span class="id" type="var">hyp</span>) <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "dependent" "destruction" <span class="id" type="var">ident</span>(<span class="id" type="var">H</span>) "using" <span class="id" type="var">constr</span>(<span class="id" type="var">c</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="var">do_depelim'</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="tactic">destruct</span> <span class="id" type="var">hyp</span> <span class="id" type="keyword">using</span> <span class="id" type="var">c</span>) <span class="id" type="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
This tactic also generalizes the goal by the given variables before the elimination. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Tactic Notation</span> "dependent" "destruction" <span class="id" type="var">ident</span>(<span class="id" type="var">H</span>) "generalizing" <span class="id" type="var">ne_hyp_list</span>(<span class="id" type="var">l</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="var">do_depelim'</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="var">revert</span> <span class="id" type="var">l</span> ; <span class="id" type="var">do_case</span> <span class="id" type="var">hyp</span>) <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "dependent" "destruction" <span class="id" type="var">ident</span>(<span class="id" type="var">H</span>) "generalizing" <span class="id" type="var">ne_hyp_list</span>(<span class="id" type="var">l</span>) "using" <span class="id" type="var">constr</span>(<span class="id" type="var">c</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="var">do_depelim'</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="var">revert</span> <span class="id" type="var">l</span> ; <span class="id" type="tactic">destruct</span> <span class="id" type="var">hyp</span> <span class="id" type="keyword">using</span> <span class="id" type="var">c</span>) <span class="id" type="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Then we have wrappers for usual calls to induction. One can customize the induction tactic by 
   writting another wrapper calling do_depelim. We suppose the hyp has to be generalized before
   calling <span class="inlinecode"><span class="id" type="tactic">induction</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Tactic Notation</span> "dependent" "induction" <span class="id" type="var">ident</span>(<span class="id" type="var">H</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">do_depind</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="var">do_ind</span> <span class="id" type="var">hyp</span>) <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "dependent" "induction" <span class="id" type="var">ident</span>(<span class="id" type="var">H</span>) "using" <span class="id" type="var">constr</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">do_depind</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="tactic">induction</span> <span class="id" type="var">hyp</span> <span class="id" type="keyword">using</span> <span class="id" type="var">c</span>) <span class="id" type="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
This tactic also generalizes the goal by the given variables before the induction. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Tactic Notation</span> "dependent" "induction" <span class="id" type="var">ident</span>(<span class="id" type="var">H</span>) "generalizing" <span class="id" type="var">ne_hyp_list</span>(<span class="id" type="var">l</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="var">do_depelim'</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="tactic">generalize</span> <span class="id" type="var">l</span> ; <span class="id" type="tactic">clear</span> <span class="id" type="var">l</span> ; <span class="id" type="var">do_ind</span> <span class="id" type="var">hyp</span>) <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "dependent" "induction" <span class="id" type="var">ident</span>(<span class="id" type="var">H</span>) "generalizing" <span class="id" type="var">ne_hyp_list</span>(<span class="id" type="var">l</span>) "using" <span class="id" type="var">constr</span>(<span class="id" type="var">c</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="var">do_depelim'</span> <span class="id" type="var">ltac</span>:(<span class="id" type="keyword">fun</span> <span class="id" type="var">hyp</span> =&gt; <span class="id" type="tactic">generalize</span> <span class="id" type="var">l</span> ; <span class="id" type="tactic">clear</span> <span class="id" type="var">l</span> ; <span class="id" type="tactic">induction</span> <span class="id" type="var">hyp</span> <span class="id" type="keyword">using</span> <span class="id" type="var">c</span>) <span class="id" type="var">H</span>.<br/>
</div>
<div id="sidebarWrapper">
<div id="sidebar">

<div class="block">
<h2 class="title">Navigation</h2>
<div class="content">

<ul class="menu">

<li class="leaf">Standard Library
  <ul class="menu">
  <li><a href="index.html">Table of contents</a></li>
  <li><a href="genindex.html">Index</a></li>
  </ul>
</li>

</ul>

</div>
</div>

</div>
</div>


</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:www-coq_@_lix.polytechnique.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/check?uri=referer">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/check/referer">CSS valid</a></li>
  </ul>

</div>
</div>

</div>

</body>
</html>

