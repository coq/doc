<!DOCTYPE html>
<html>
<head>


<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/coqdoc.css" /><title>Chapter 24  The ring and field tactic families</title>
</head>
<body >

<div id="container">

<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="/" class="active">Home</a></li>
    <li><a href="/about-coq" title="More about coq">About Coq</a></li>
    <li><a href="/download">Get Coq</a></li>
    <li><a href="/documentation">Documentation</a></li>
    <li><a href="/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">
<div id="logoWrapper">
  <div id="logo"><a href="/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
  </div>
  <div id="siteName"><a href="/" title="Home">The Coq Proof Assistant</a>
  </div>
</div>
</div>

<div id="content">

<h1 id="sec727" class="chapter">Chapter 24  The <span style="font-family:monospace">ring</span> and <span style="font-family:monospace">field</span> tactic families</h1>
<ul>
<li><a href="Reference-Manual027.html#sec728">24.1  What does this tactic do?</a>
</li><li><a href="Reference-Manual027.html#sec729">24.2  The variables map</a>
</li><li><a href="Reference-Manual027.html#sec730">24.3  Is it automatic?</a>
</li><li><a href="Reference-Manual027.html#sec731">24.4  Concrete usage in <span style="font-variant:small-caps">Coq</span>
</a>
</li><li><a href="Reference-Manual027.html#sec732">24.5  Adding a ring structure
</a>
</li><li><a href="Reference-Manual027.html#sec733">24.6  How does it work?</a>
</li><li><a href="Reference-Manual027.html#sec734">24.7  Dealing with fields


</a>
</li><li><a href="Reference-Manual027.html#sec735">24.8  Adding a new field structure
</a>
</li><li><a href="Reference-Manual027.html#sec736">24.9  Legacy implementation</a>
</li><li><a href="Reference-Manual027.html#sec741">24.10  History of <span style="font-family:monospace">ring</span></a>
</li><li><a href="Reference-Manual027.html#sec742">24.11  Discussion</a>
</li></ul>
<p>
<span style="font-size:x-large"><span style="font-weight:bold">Bruno Barras, Benjamin Grégoire, Assia
Mahboubi, Laurent Théry</span></span><sup><a id="text33" href="#note33"><span style="font-size:x-large"><span style="font-weight:bold">1</span></span></a></sup> <br>
<br>

<a id="ring"></a>
<a id="hevea_default931"></a><a id="hevea_tactic198"></a></p><p>This chapter presents the tactics dedicated to deal with ring and
field equations.</p>
<h2 id="sec728" class="section">24.1  What does this tactic do?</h2>
<p><span style="font-family:monospace">ring</span> does associative-commutative rewriting in ring and semi-ring
structures. Assume you have two binary functions ⊕ and ⊗
that are associative and commutative, with ⊕ distributive on
⊗, and two constants 0 and 1 that are unities for ⊕ and
⊗. A <span style="font-style:italic">polynomial</span> is an expression built on variables <span style="font-style:italic">V</span><sub>0</sub>, <span style="font-style:italic">V</span><sub>1</sub>,
… and constants by application of ⊕ and ⊗.</p><p>Let an <span style="font-style:italic">ordered product</span> be a product of variables <span style="font-style:italic">V</span><sub><span style="font-style:italic">i</span><sub>1</sub></sub>
⊗ … ⊗ <span style="font-style:italic">V</span><sub><span style="font-style:italic">i</span><sub><span style="font-style:italic">n</span></sub></sub> verifying <span style="font-style:italic">i</span><sub>1</sub> ≤ <span style="font-style:italic">i</span><sub>2</sub> ≤ … ≤
<span style="font-style:italic">i</span><sub><span style="font-style:italic">n</span></sub>. Let a <span style="font-style:italic">monomial</span> be the product of a constant and an
ordered product. We can order the monomials by the lexicographic
order on products of variables. Let a <span style="font-style:italic">canonical sum</span> be an
ordered sum of monomials that are all different, i.e. each monomial in
the sum is strictly less than the following monomial according to the
lexicographic order. It is an easy theorem to show that every
polynomial is equivalent (modulo the ring properties) to exactly one
canonical sum. This canonical sum is called the <span style="font-style:italic">normal form</span>
of the polynomial. In fact, the actual representation shares monomials
with same prefixes. So what does <span style="font-family:monospace">ring</span>? It normalizes
polynomials over any ring or semi-ring structure. The basic use of
<span style="font-family:monospace">ring</span> is to simplify ring expressions, so that the user does
not have to deal manually with the theorems of associativity and
commutativity.</p><p><br>
<span style="font-weight:bold">Examples:</span>
</p><ol class="enumerate" type=1><li class="li-enumerate">
In the ring of integers, the normal form of 
<span style="font-style:italic">x</span> (3 + <span style="font-style:italic">yx</span> + 25(1 − <span style="font-style:italic">z</span>)) + <span style="font-style:italic">zx</span> is 28<span style="font-style:italic">x</span> + (−24)<span style="font-style:italic">xz</span> + <span style="font-style:italic">xxy</span>.
</li></ol><p><span style="font-family:monospace">ring</span> is also able to compute a normal form modulo monomial 
equalities. For example, under the hypothesis that 2<span style="font-style:italic">x</span><sup>2</sup> = <span style="font-style:italic">yz</span>+1,
the normal form of 2(<span style="font-style:italic">x</span> + 1)<span style="font-style:italic">x</span> − <span style="font-style:italic">x</span> − <span style="font-style:italic">zy</span> is <span style="font-style:italic">x</span>+1.</p>
<h2 id="sec729" class="section">24.2  The variables map</h2>
<p>It is frequent to have an expression built with + and
×, but rarely on variables only.
Let us associate a number to each subterm of a ring
expression in the <span style="font-variant:small-caps">Gallina</span> language. For example in the ring
<span style="font-family:monospace">nat</span>, consider the expression:</p><blockquote class="quotation">
<pre class="verbatim">(plus (mult (plus (f (5)) x) x)
      (mult (if b then (4) else (f (3))) (2)))
</pre></blockquote><p>As a ring expression, it has 3 subterms. Give each subterm a
number in an arbitrary order:</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >0</td><td style="text-align:center;white-space:nowrap" >↦</td><td style="text-align:left;white-space:nowrap" ><code>if b then (4) else (f (3))</code> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >↦</td><td style="text-align:left;white-space:nowrap" ><code>(f (5))</code> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >↦</td><td style="text-align:left;white-space:nowrap" ><code>x</code> </td></tr>
</table><p>Then normalize the “abstract” polynomial </p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">((<span style="font-style:italic">V</span><sub>1</sub> ⊗ <span style="font-style:italic">V</span><sub>2</sub>) ⊕ <span style="font-style:italic">V</span><sub>2</sub>) ⊕ (<span style="font-style:italic">V</span><sub>0</sub> ⊗ 2) </td></tr>
</table><p>In our example the normal form is:</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(2 ⊗ <span style="font-style:italic">V</span><sub>0</sub>) ⊕ (<span style="font-style:italic">V</span><sub>1</sub> ⊗ <span style="font-style:italic">V</span><sub>2</sub>) ⊕ (<span style="font-style:italic">V</span><sub>2</sub> ⊗ <span style="font-style:italic">V</span><sub>2</sub>)</td></tr>
</table><p>Then substitute the variables by their values in the variables map to
get the concrete normal polynomial:</p><blockquote class="quotation">
<pre class="verbatim">(plus (mult (2) (if b then (4) else (f (3)))) 
      (plus (mult (f (5)) x) (mult x x))) 
</pre></blockquote>
<h2 id="sec730" class="section">24.3  Is it automatic?</h2>
<p>Yes, building the variables map and doing the substitution after
normalizing is automatically done by the tactic. So you can just forget
this paragraph and use the tactic according to your intuition.</p>
<h2 id="sec731" class="section">24.4  Concrete usage in <span style="font-variant:small-caps">Coq</span><a id="hevea_default932"></a><a id="hevea_tactic199"></a>
<a id="hevea_default933"></a><a id="hevea_tactic200"></a></h2>
<p>The <span style="font-family:monospace">ring</span> tactic solves equations upon polynomial expressions of
a ring (or semi-ring) structure. It proceeds by normalizing both hand
sides of the equation (w.r.t. associativity, commutativity and
distributivity, constant propagation, rewriting of monomials) 
and comparing syntactically the results.</p><p><span style="font-family:monospace">ring_simplify</span> applies the normalization procedure described
above to the terms given. The tactic then replaces all occurrences of
the terms given in the conclusion of the goal by their normal
forms. If no term is given, then the conclusion should be an equation
and both hand sides are normalized. 
The tactic can also be applied in a hypothesis.</p><p>The tactic must be loaded by <span style="font-family:monospace">Require Import Ring</span>. The ring
structures must be declared with the <span style="font-family:monospace">Add Ring</span> command (see
below). The ring of booleans is predefined; if one wants to use the
tactic on <span style="font-family:monospace">nat</span> one must first require the module
<span style="font-family:monospace">ArithRing</span> (exported by <span style="font-family:monospace">Arith</span>);
for <span style="font-family:monospace">Z</span>, do <span style="font-family:monospace">Require Import
ZArithRing</span> or simply <span style="font-family:monospace">Require Import ZArith</span>; 
for <span style="font-family:monospace">N</span>, do <span style="font-family:monospace">Require Import NArithRing</span> or 
<span style="font-family:monospace">Require Import NArith</span>.</p><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import ZArith.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">[Loading ML file z_syntax_plugin.cmxs ... done]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">[Loading ML file quote_plugin.cmxs ... done]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">[Loading ML file newring_plugin.cmxs ... done]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">[Loading ML file omega_plugin.cmxs ... done]</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Open Scope Z_scope.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall a b c:Z,</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   (a + b + c)</span></span><span style="font-size:small"><span style="font-family:monospace">^</span></span><span style="font-size:small"><span style="font-family:monospace">2  =</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   a * a + b</span></span><span style="font-size:small"><span style="font-family:monospace">^</span></span><span style="font-size:small"><span style="font-family:monospace">2 + c * c + 2 * a * b + 2 * a * c + 2 * b * c.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   forall a b c : Z,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   (a + b + c) </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 2 =</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   a * a + b </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 2 + c * c + 2 * a * b + 2 * a * c + 2 * b * c</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros; ring.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall a b:Z, 2*a*b = 30 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">         (a+b)</span></span><span style="font-size:small"><span style="font-family:monospace">^</span></span><span style="font-size:small"><span style="font-family:monospace">2 = a</span></span><span style="font-size:small"><span style="font-family:monospace">^</span></span><span style="font-size:small"><span style="font-family:monospace">2 + b</span></span><span style="font-size:small"><span style="font-family:monospace">^</span></span><span style="font-size:small"><span style="font-family:monospace">2 + 30.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   forall a b : Z, 2 * a * b = 30 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> (a + b) </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 2 = a </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 2 + b </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 2 + 30</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros a b H; ring [H].</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">ring [</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">]</span> decides the equality of two
terms modulo ring operations and rewriting of the equalities
defined by <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>. Each of <span style="font-style:oblique">term</span><sub>1</sub>
… <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> has to be a proof of some equality <span style="font-style:italic">m</span> = <span style="font-style:italic">p</span>,
where <span style="font-style:italic">m</span> is a monomial (after “abstraction”),
<span style="font-style:italic">p</span> a polynomial and = the corresponding equality of the ring structure.</li><li class="li-enumerate"><span style="font-family:monospace">ring_simplify [</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">] </span><span style="font-style:italic">t</span><sub>1</sub> … <span style="font-style:italic">t</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> in 
</span><span style="font-style:oblique">ident</span>
performs the simplification in the hypothesis named <span style="font-family:monospace">ident</span>.
</li></ol><p><br>
<span style="font-weight:bold">Warning: </span><span style="font-family:monospace">ring_simplify </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">; ring_simplify </span><span style="font-style:oblique">term</span><sub>2</sub> is
not equivalent to <span style="font-family:monospace">ring_simplify </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>2</sub>. In the
latter case the variables map is shared between the two terms, and
common subterm <span style="font-style:italic">t</span> of <span style="font-style:oblique">term</span><sub>1</sub> and <span style="font-style:oblique">term</span><sub>2</sub> will have the same
associated variable number. So the first alternative should be
avoided for terms belonging to the same ring theory.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">not a valid ring equation</span><a id="hevea_error161"></a>
The conclusion of the goal is not provable in the corresponding ring
theory.
</li><li class="li-enumerate"><span style="font-family:monospace">arguments of ring_simplify do not have all the same type</span><a id="hevea_error162"></a>
<span style="font-family:monospace">ring_simplify</span> cannot simplify terms of several rings at the
same time. Invoke the tactic once per ring structure.
</li><li class="li-enumerate"><span style="font-family:monospace">cannot find a declared ring structure over </span><span style="font-family:monospace">term</span><a id="hevea_error163"></a>
No ring has been declared for the type of the terms to be
simplified. Use <span style="font-family:monospace">Add Ring</span> first.
</li><li class="li-enumerate"><span style="font-family:monospace">cannot find a declared ring structure for equality
</span><span style="font-family:monospace">term</span><a id="hevea_error164"></a>
Same as above is the case of the <span style="font-family:monospace">ring</span> tactic.
</li></ol>
<h2 id="sec732" class="section">24.5  Adding a ring structure
<a id="hevea_default934"></a><a id="hevea_command357"></a></h2>
<p>Declaring a new ring consists in proving that a ring signature (a
carrier set, an equality, and ring operations: <span style="font-family:monospace">Ring_theory.ring_theory</span> and <span style="font-family:monospace">Ring_theory.semi_ring_theory</span>)
satisfies the ring axioms. Semi-rings (rings without + inverse) are
also supported. The equality can be either Leibniz equality, or any
relation declared as a setoid (see <a href="Reference-Manual029.html#setoidtactics">26.7</a>). The definition
of ring and semi-rings (see module <span style="font-family:monospace">Ring_theory</span>) is:
</p><pre class="verbatim"> Record ring_theory : Prop := mk_rt {
    Radd_0_l    : forall x, 0 + x == x;
    Radd_sym    : forall x y, x + y == y + x;
    Radd_assoc  : forall x y z, x + (y + z) == (x + y) + z;
    Rmul_1_l    : forall x, 1 * x == x;
    Rmul_sym    : forall x y, x * y == y * x;
    Rmul_assoc  : forall x y z, x * (y * z) == (x * y) * z;
    Rdistr_l    : forall x y z, (x + y) * z == (x * z) + (y * z);
    Rsub_def    : forall x y, x - y == x + -y;
    Ropp_def    : forall x, x + (- x) == 0
 }.

Record semi_ring_theory : Prop := mk_srt {
    SRadd_0_l   : forall n, 0 + n == n;
    SRadd_sym   : forall n m, n + m == m + n ;
    SRadd_assoc : forall n m p, n + (m + p) == (n + m) + p;
    SRmul_1_l   : forall n, 1*n == n;
    SRmul_0_l   : forall n, 0*n == 0; 
    SRmul_sym   : forall n m, n*m == m*n;
    SRmul_assoc : forall n m p, n*(m*p) == (n*m)*p;
    SRdistr_l   : forall n m p, (n + m)*p == n*p + m*p
  }.
</pre><p>This implementation of <span style="font-family:monospace">ring</span> also features a notion of constant
that can be parameterized. This can be used to improve the handling of
closed expressions when operations are effective. It consists in
introducing a type of <em>coefficients</em> and an implementation of the
ring operations, and a morphism from the coefficient type to the ring
carrier type. The morphism needs not be injective, nor surjective. </p><p>As
an example, one can consider the real numbers. The set of coefficients
could be the rational numbers, upon which the ring operations can be
implemented. The fact that there exists a morphism is defined by the
following properties:
</p><pre class="verbatim"> Record ring_morph : Prop := mkmorph {
    morph0    : [cO] == 0;
    morph1    : [cI] == 1;
    morph_add : forall x y, [x +! y] == [x]+[y];
    morph_sub : forall x y, [x -! y] == [x]-[y];
    morph_mul : forall x y, [x *! y] == [x]*[y];
    morph_opp : forall x, [-!x] == -[x];
    morph_eq  : forall x y, x?=!y = true -&gt; [x] == [y] 
  }.

 Record semi_morph : Prop := mkRmorph {
    Smorph0 : [cO] == 0;
    Smorph1 : [cI] == 1;
    Smorph_add : forall x y, [x +! y] == [x]+[y];
    Smorph_mul : forall x y, [x *! y] == [x]*[y];
    Smorph_eq  : forall x y, x?=!y = true -&gt; [x] == [y] 
  }.
</pre><p>where <span style="font-family:monospace">c0</span> and <span style="font-family:monospace">cI</span> denote the 0 and 1 of the coefficient set,
<span style="font-family:monospace">+!</span>, <span style="font-family:monospace">*!</span>, <span style="font-family:monospace">-!</span> are the implementations of the ring
operations, <span style="font-family:monospace">==</span> is the equality of the coefficients, <span style="font-family:monospace">?+!</span> is
an implementation of this equality, and <span style="font-family:monospace">[x]</span> is a notation for
the image of <span style="font-family:monospace">x</span> by the ring morphism. Moreover, the term 
<span style="font-family:monospace">[c0]</span> (resp. <span style="font-family:monospace">[c1]</span>), image by the morphism of the 0
(resp. the 1) of the coefficient set,
should be <em>convertible</em> to the term <span style="font-family:monospace">0</span> (resp. the term
<span style="font-family:monospace">1</span>) of the ring structure. This requirement is not enforced by
the command registering a new ring but the tactic is otherwise very
much incomplete.</p><p>Since <span style="font-family:monospace">Z</span> is an initial ring (and <span style="font-family:monospace">N</span> is an initial
semi-ring), it can always be considered as a set of
coefficients. There are basically three kinds of (semi-)rings:
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">abstract rings</span></dt><dd class="dd-description"> to be used when operations are not
effective. The set of coefficients is <span style="font-family:monospace">Z</span> (or <span style="font-family:monospace">N</span> for
semi-rings).
</dd><dt class="dt-description"><span style="font-weight:bold">computational rings</span></dt><dd class="dd-description"> to be used when operations are
effective. The set of coefficients is the ring itself. The user only
has to provide an implementation for the equality.
</dd><dt class="dt-description"><span style="font-weight:bold">customized ring</span></dt><dd class="dd-description"> for other cases. The user has to provide the
coefficient set and the morphism.
</dd></dl><p>This implementation of ring can also recognize simple 
power expressions as ring expressions. A power function is specified by 
the following property:
</p><pre class="verbatim"> Section POWER.
  Variable Cpow : Set.
  Variable Cp_phi : N -&gt; Cpow.
  Variable rpow : R -&gt; Cpow -&gt; R. 
  
  Record power_theory : Prop := mkpow_th {
    rpow_pow_N : forall r n, req (rpow r (Cp_phi n)) (pow_N rI rmul r n)
  }.

 End POWER.
</pre><p>The syntax for adding a new ring is <span style="font-family:monospace">Add Ring </span><span style="font-style:italic">name</span><span style="font-family:monospace"> : </span><span style="font-style:italic">ring</span><span style="font-family:monospace">
(</span><span style="font-style:italic">mod</span><sub>1</sub><span style="font-family:monospace">,…,</span><span style="font-style:italic">mod</span><sub>2</sub><span style="font-family:monospace">)</span>. The name is not relevent. It is just used
for error messages. The term <span style="font-style:italic">ring</span> is a proof that the ring signature
satisfies the (semi-)ring axioms. The optional list of modifiers is
used to tailor the behavior of the tactic. The following list
describes their syntax and effects:
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">abstract</span></dt><dd class="dd-description"> declares the ring as abstract. This is the default.
</dd><dt class="dt-description"><span style="font-weight:bold">decidable </span><span style="font-style:oblique">term</span></dt><dd class="dd-description"> declares the ring as computational. The expression 
<span style="font-style:oblique">term</span> is
the correctness proof of an equality test <span style="font-family:monospace">?=!</span> (which should be
evaluable). Its type should be of
the form <span style="font-family:monospace">forall x y, x?=!y = true </span>→<span style="font-family:monospace"> x == y</span>.
</dd><dt class="dt-description"><span style="font-weight:bold">morphism </span><span style="font-style:oblique">term</span></dt><dd class="dd-description"> declares the ring as a customized one. The expression 
<span style="font-style:oblique">term</span> is
a proof that there exists a morphism between a set of coefficient
and the ring carrier (see <span style="font-family:monospace">Ring_theory.ring_morph</span> and <span style="font-family:monospace">Ring_theory.semi_morph</span>).
</dd><dt class="dt-description"><span style="font-weight:bold">setoid </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-weight:bold"> </span><span style="font-style:oblique">term</span><sub>2</sub></dt><dd class="dd-description"> forces the use of given setoid. The 
expression <span style="font-style:oblique">term</span><sub>1</sub> is a proof that the equality is indeed a setoid
(see <span style="font-family:monospace">Setoid.Setoid_Theory</span>), and <span style="font-style:oblique">term</span><sub>2</sub> a proof that the
ring operations are morphisms (see <span style="font-family:monospace">Ring_theory.ring_eq_ext</span> and
<span style="font-family:monospace">Ring_theory.sring_eq_ext</span>). This modifier needs not be used if the
setoid and morphisms have been declared.
</dd><dt class="dt-description"><span style="font-weight:bold">constants [</span><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">L</span></span><sub><span style="font-style:italic">tac</span></sub></dt><dd class="dd-description">] specifies a tactic expression that, given a term,
returns either an object of the coefficient set that is mapped to
the expression via the morphism, or returns <span style="font-family:monospace">InitialRing.NotConstant</span>. The default behaviour is to map only 0 and
1 to their counterpart in the coefficient set. This is generally not
desirable for non trivial computational rings.
</dd><dt class="dt-description"><span style="font-weight:bold">preprocess [</span><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">L</span></span><sub><span style="font-style:italic">tac</span></sub></dt><dd class="dd-description">]
specifies a tactic that is applied as a preliminary step for <span style="font-family:monospace">ring</span> and <span style="font-family:monospace">ring_simplify</span>. It can be used to transform a goal
so that it is better recognized. For instance, <span style="font-family:monospace">S n</span> can be
changed to <span style="font-family:monospace">plus 1 n</span>.
</dd><dt class="dt-description"><span style="font-weight:bold">postprocess [</span><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">L</span></span><sub><span style="font-style:italic">tac</span></sub></dt><dd class="dd-description">] specifies a tactic that is applied as a final step
for <span style="font-family:monospace">ring_simplify</span>. For instance, it can be used to undo
modifications of the preprocessor.
</dd><dt class="dt-description"><span style="font-weight:bold">power_tac </span><span style="font-style:oblique">term</span><span style="font-weight:bold"> [</span><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">L</span></span><sub><span style="font-style:italic">tac</span></sub></dt><dd class="dd-description">] allows <span style="font-family:monospace">ring</span> and <span style="font-family:monospace">ring_simplify</span> to
recognize power expressions with a constant positive integer exponent 
(example: <span style="font-style:italic">x</span><sup>2</sup>). The term <span style="font-style:oblique">term</span> is a proof that a given power function
satisfies the specification of a power function (<span style="font-style:oblique">term</span> has to be a
proof of <span style="font-family:monospace">Ring_theory.power_theory</span>) and <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">L</span></span><sub><span style="font-style:italic">tac</span></sub> specifies a
tactic expression that, given a term, “abstracts” it into an
object of type <span style="font-family:monospace">N</span> whose interpretation via <span style="font-family:monospace">Cp_phi</span> (the
evaluation function of power coefficient) is the original term, or
returns <span style="font-family:monospace">InitialRing.NotConstant</span> if not a constant coefficient
(i.e. <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">L</span></span><sub><span style="font-style:italic">tac</span></sub> is the inverse function of <span style="font-family:monospace">Cp_phi</span>).
See files <span style="font-family:monospace">plugins/setoid_ring/ZArithRing.v</span> and
<span style="font-family:monospace">plugins/setoid_ring/RealField.v</span> for examples.
By default the tactic does not recognize power expressions as ring
expressions.
</dd><dt class="dt-description"><span style="font-weight:bold">sign </span><span style="font-style:oblique">term</span></dt><dd class="dd-description"> allows <span style="font-family:monospace">ring_simplify</span> to use a minus operation
when outputing its normal form, i.e writing <span style="font-style:italic">x</span> − <span style="font-style:italic">y</span> instead of <span style="font-style:italic">x</span> + (−<span style="font-style:italic">y</span>). 
The term <span style="font-style:oblique">term</span> is a proof that a given sign function indicates expressions
that are signed (<span style="font-style:oblique">term</span> has to be a
proof of <span style="font-family:monospace">Ring_theory.get_sign</span>). See <span style="font-family:monospace">plugins/setoid_ring/IntialRing.v</span> for examples of sign function.
</dd><dt class="dt-description"><span style="font-weight:bold">div </span><span style="font-style:oblique">term</span></dt><dd class="dd-description"> allows <span style="font-family:monospace">ring</span> and <span style="font-family:monospace">ring_simplify</span> to use moniomals
with coefficient other than 1 in the rewriting. The term <span style="font-style:oblique">term</span> is a proof that a given division function satisfies the specification of an euclidean
division function (<span style="font-style:oblique">term</span> has to be a
proof of <span style="font-family:monospace">Ring_theory.div_theory</span>). For example, this function is
called when trying to rewrite 7<span style="font-style:italic">x</span> by 2<span style="font-style:italic">x</span> = <span style="font-style:italic">z</span> to tell that 7 = 3 * 2 + 1.
See <span style="font-family:monospace">plugins/setoid_ring/IntialRing.v</span> for examples of div function.</dd></dl><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">bad ring structure</span><a id="hevea_error165"></a>
The proof of the ring structure provided is not of the expected type.
</li><li class="li-enumerate"><span style="font-family:monospace">bad lemma for decidability of equality</span><a id="hevea_error166"></a>
The equality function provided in the case of a computational ring
has not the expected type.
</li><li class="li-enumerate"><span style="font-family:monospace">ring </span><span style="font-family:monospace"><span style="font-style:italic">operation</span></span><span style="font-family:monospace"> should be declared as a morphism</span><a id="hevea_error167"></a>
A setoid associated to the carrier of the ring structure as been
found, but the ring operation should be declared as
morphism. See <a href="Reference-Manual029.html#setoidtactics">26.7</a>.
</li></ol>
<h2 id="sec733" class="section">24.6  How does it work?</h2>
<p>The code of <span style="font-family:monospace">ring</span> is a good example of tactic written using
<span style="font-style:italic">reflection</span>. What is reflection? Basically, it is writing
<span style="font-variant:small-caps">Coq</span> tactics in <span style="font-variant:small-caps">Coq</span>, rather than in <span style="font-variant:small-caps">Objective Caml</span>. From the philosophical
point of view, it is using the ability of the Calculus of
Constructions to speak and reason about itself. For the <span style="font-family:monospace">ring</span>
tactic we used <span style="font-variant:small-caps">Coq</span> as a programming language and also as a proof
environment to build a tactic and to prove it correctness.</p><p>The interested reader is strongly advised to have a look at the file
<span style="font-family:monospace">Ring_polynom.v</span>. Here a type for polynomials is defined: </p><div class="flushleft"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">Inductive PExpr : Type :=
  | PEc : C -&gt; PExpr
  | PEX : positive -&gt; PExpr
  | PEadd : PExpr -&gt; PExpr -&gt; PExpr
  | PEsub : PExpr -&gt; PExpr -&gt; PExpr
  | PEmul : PExpr -&gt; PExpr -&gt; PExpr
  | PEopp : PExpr -&gt; PExpr
  | PEpow : PExpr -&gt; N -&gt; PExpr.
</span></pre></div><p>Polynomials in normal form are defined as:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small"> Inductive Pol : Type :=
  | Pc : C -&gt; Pol 
  | Pinj : positive -&gt; Pol -&gt; Pol                   
  | PX : Pol -&gt; positive -&gt; Pol -&gt; Pol.
</span></pre></div><p><span style="font-size:small">
</span>
where <span style="font-family:monospace">Pinj n P</span> denotes <span style="font-style:italic">P</span> in which <span style="font-style:italic">V</span><sub><span style="font-style:italic">i</span></sub> is replaced by
<span style="font-style:italic">V</span><sub><span style="font-style:italic">i</span>+<span style="font-style:italic">n</span></sub>, and <span style="font-family:monospace">PX P n Q</span> denotes <span style="font-style:italic">P</span> ⊗ <span style="font-style:italic">V</span><sub>1</sub><sup><span style="font-style:italic">n</span></sup> ⊕ <span style="font-style:italic">Q</span>′,
<span style="font-style:italic">Q</span>′ being <span style="font-style:italic">Q</span> where <span style="font-style:italic">V</span><sub><span style="font-style:italic">i</span></sub> is replaced by <span style="font-style:italic">V</span><sub><span style="font-style:italic">i</span>+1</sub>. </p><p>Variables maps are represented by list of ring elements, and two
interpretation functions, one that maps a variables map and a
polynomial to an element of the concrete ring, and the second one that
does the same for normal forms:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">Definition PEeval : list R -&gt; PExpr -&gt; R := [...].
Definition Pphi_dev : list R -&gt; Pol -&gt; R := [...].
</span></pre></div><p>A function to normalize polynomials is defined, and the big theorem is
its correctness w.r.t interpretation, that is:</p><div class="flushleft"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">Definition norm : PExpr -&gt; Pol := [...].
Lemma Pphi_dev_ok :
   forall l pe npe, norm pe = npe -&gt; PEeval l pe == Pphi_dev l npe.
</span></pre></div><p>So now, what is the scheme for a normalization proof? Let <span style="font-family:monospace">p</span>
be the polynomial expression that the user wants to normalize. First a
little piece of ML code guesses the type of <span style="font-family:monospace">p</span>, the ring
theory <span style="font-family:monospace">T</span> to use, an abstract polynomial <span style="font-family:monospace">ap</span> and a
variables map <span style="font-family:monospace">v</span> such that <span style="font-family:monospace">p</span> is
βδι-equivalent to <code>(PEeval v ap)</code>. Then we
replace it by <code>(Pphi_dev v (norm ap))</code>, using the
main correctness theorem and we reduce it to a concrete expression
<span style="font-family:monospace">p’</span>, which is the concrete normal form of
<span style="font-family:monospace">p</span>. This is summarized in this diagram:
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-family:monospace">p</span></td><td style="text-align:center;white-space:nowrap" >→<sub>βδι</sub></td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(PEeval v ap)</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=<sub>(<span style="font-style:italic">by</span> <span style="font-style:italic">the</span> <span style="font-style:italic">main</span> <span style="font-style:italic">correctness</span> <span style="font-style:italic">theorem</span>)</sub> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-family:monospace">p’</span></td><td style="text-align:center;white-space:nowrap" >←<sub>βδι</sub></td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(Pphi_dev v (norm ap))</span>
</td></tr>
</table>
</div><p>
The user do not see the right part of the diagram. 
From outside, the tactic behaves like a
βδι simplification extended with AC rewriting rules.
Basically, the proof is only the application of the main
correctness theorem to well-chosen arguments.</p>
<h2 id="sec734" class="section">24.7  Dealing with fields
<a id="hevea_default935"></a><a id="hevea_tactic201"></a>
<a id="hevea_default936"></a><a id="hevea_tactic202"></a>
<a id="hevea_default937"></a><a id="hevea_tactic203"></a></h2>
<p>The <span style="font-family:monospace">field</span> tactic is an extension of the <span style="font-family:monospace">ring</span> to deal with
rational expresision. Given a rational expression <span style="font-style:italic">F</span>=0. It first reduces the expression <span style="font-style:italic">F</span> to a common denominator <span style="font-style:italic">N</span>/<span style="font-style:italic">D</span>= 0 where <span style="font-style:italic">N</span> and <span style="font-style:italic">D</span> are two ring
expressions.
For example, if we take <span style="font-style:italic">F</span> = (1 − 1/<span style="font-style:italic">x</span>) <span style="font-style:italic">x</span> − <span style="font-style:italic">x</span> + 1, this gives 
 <span style="font-style:italic">N</span>= (<span style="font-style:italic">x</span> −1) <span style="font-style:italic">x</span> − <span style="font-style:italic">x</span><sup>2</sup> + <span style="font-style:italic">x</span> and <span style="font-style:italic">D</span>= <span style="font-style:italic">x</span>. It then calls <span style="font-family:monospace">ring</span> 
to solve <span style="font-style:italic">N</span>=0. Note that <span style="font-family:monospace">field</span> also generates non-zero conditions
for all the denominators it encounters in the reduction.
In our example, it generates the condition <span style="font-style:italic">x</span> ≠ 0. These
conditions appear as one subgoal which is a conjunction if there are
several denominators.
Non-zero conditions are <span style="font-style:italic">always</span> polynomial expressions. For example 
when reducing the expression 1/(1 + 1/<span style="font-style:italic">x</span>), two side conditions are
generated: <span style="font-style:italic">x</span>≠ 0 and <span style="font-style:italic">x</span> + 1 ≠ 0. Factorized expressions are
broken since a field is an integral domain, and when the equality test
on coefficients is complete w.r.t. the equality of the target field,
constants can be proven different from zero automatically.</p><p>The tactic must be loaded by <span style="font-family:monospace">Require Import Field</span>. New field
structures can be declared to the system with the <span style="font-family:monospace">Add Field</span>
command (see below). The field of real numbers is defined in module
<span style="font-family:monospace">RealField</span> (in textttplugins/setoid_ring). It is exported
by module <span style="font-family:monospace">Rbase</span>, so that requiring <span style="font-family:monospace">Rbase</span> or
<span style="font-family:monospace">Reals</span> is enough to use the field tactics on real
numbers. Rational numbers in canonical form are also declared as a
field in module <span style="font-family:monospace">Qcanon</span>.</p><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import Reals.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">[Loading ML file r_syntax_plugin.cmxs ... done]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">[Loading ML file ring_plugin.cmxs ... done]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">[Loading ML file field_plugin.cmxs ... done]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">[Loading ML file fourier_plugin.cmxs ... done]</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Open Scope R_scope.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall x,  x </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 0 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">    (1 - 1/x) * x - x + 1 = 0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   forall x : R, x </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> (1 - 1 / x) * x - x + 1 = 0</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros; field; auto.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall x y, y </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 0 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> y = x -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> x/y = 1.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   forall x y : R, y </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> y = x -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> x / y = 1</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros x y H H1; field [H1]; auto.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">field [</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">]</span> decides the equality of two
terms modulo field operations and rewriting of the equalities
defined by <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>. Each of <span style="font-style:oblique">term</span><sub>1</sub>
… <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> has to be a proof of some equality <span style="font-style:italic">m</span> = <span style="font-style:italic">p</span>,
where <span style="font-style:italic">m</span> is a monomial (after “abstraction”),
<span style="font-style:italic">p</span> a polynomial and = the corresponding equality of the field structure.
Beware that rewriting works with the equality <span style="font-style:italic">m</span>=<span style="font-style:italic">p</span> only if <span style="font-style:italic">p</span> is a 
polynomial since rewriting is handled by the underlying <span style="font-family:monospace">ring</span>
tactic.
</li><li class="li-enumerate"><span style="font-family:monospace">field_simplify</span> 
performs the simplification in the conclusion of the goal, <span style="font-style:italic">F</span><sub>1</sub> = <span style="font-style:italic">F</span><sub>2</sub>
becomes <span style="font-style:italic">N</span><sub>1</sub>/<span style="font-style:italic">D</span><sub>1</sub> = <span style="font-style:italic">N</span><sub>2</sub>/<span style="font-style:italic">D</span><sub>2</sub>. A normalization step (the same as the
one for rings) is then applied to <span style="font-style:italic">N</span><sub>1</sub>, <span style="font-style:italic">D</span><sub>1</sub>, <span style="font-style:italic">N</span><sub>2</sub> and
<span style="font-style:italic">D</span><sub>2</sub>. This way, polynomials remain in factorized form during the
fraction simplifications. This yields smaller expressions when
reducing to the same denominator since common factors can be
cancelled.</li><li class="li-enumerate"><span style="font-family:monospace">field_simplify [</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">]</span>
performs the simplification in the conclusion of the goal using
the equalities
defined by <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>.</li><li class="li-enumerate"><span style="font-family:monospace">field_simplify [</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">] </span><span style="font-style:italic">t</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:italic">t</span><sub><span style="font-style:italic">m</span></sub>
performs the simplification in the terms <span style="font-style:italic">t</span><sub>1</sub> …<span style="font-style:italic">t</span><sub><span style="font-style:italic">m</span></sub>
of the conclusion of the goal using
the equalities
defined by <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>. </li><li class="li-enumerate"><span style="font-family:monospace">field_simplify in </span><span style="font-style:italic">H</span> 
performs the simplification in the assumption <span style="font-style:italic">H</span>.</li><li class="li-enumerate"><span style="font-family:monospace">field_simplify [</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">] in </span><span style="font-style:italic">H</span>
performs the simplification in the assumption <span style="font-style:italic">H</span> using
the equalities
defined by <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>. </li><li class="li-enumerate"><span style="font-family:monospace">field_simplify [</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">] </span><span style="font-style:italic">t</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:italic">t</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> in </span><span style="font-style:italic">H</span>
performs the simplification in the terms <span style="font-style:italic">t</span><sub>1</sub> …<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>
of the assumption <span style="font-style:italic">H</span> using
the equalities
defined by <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span></sub>. </li><li class="li-enumerate"><span style="font-family:monospace">field_simplify_eq</span>
performs the simplification in the conclusion of the goal removing
the denominator. <span style="font-style:italic">F</span><sub>1</sub> = <span style="font-style:italic">F</span><sub>2</sub>
becomes <span style="font-style:italic">N</span><sub>1</sub> <span style="font-style:italic">D</span><sub>2</sub> = <span style="font-style:italic">N</span><sub>2</sub> <span style="font-style:italic">D</span><sub>1</sub>.</li><li class="li-enumerate"><span style="font-family:monospace">field_simplify_eq [</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">]</span>
performs the simplification in the conclusion of the goal using
the equalities
defined by <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>. </li><li class="li-enumerate"><span style="font-family:monospace">field_simplify_eq</span> in <span style="font-style:italic">H</span>
performs the simplification in the assumption <span style="font-style:italic">H</span>.</li><li class="li-enumerate"><span style="font-family:monospace">field_simplify_eq [</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">] in </span><span style="font-style:italic">H</span>
performs the simplification in the assumption <span style="font-style:italic">H</span> using
the equalities
defined by <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>. 
</li></ol>
<h2 id="sec735" class="section">24.8  Adding a new field structure
<a id="hevea_default938"></a><a id="hevea_command358"></a></h2>
<p>Declaring a new field consists in proving that a field signature (a
carrier set, an equality, and field operations: <span style="font-family:monospace">Field_theory.field_theory</span> and <span style="font-family:monospace">Field_theory.semi_field_theory</span>)
satisfies the field axioms. Semi-fields (fields without + inverse) are
also supported. The equality can be either Leibniz equality, or any
relation declared as a setoid (see <a href="Reference-Manual029.html#setoidtactics">26.7</a>). The definition
of fields and semi-fields is:
</p><pre class="verbatim">Record field_theory : Prop := mk_field {
    F_R : ring_theory rO rI radd rmul rsub ropp req;
    F_1_neq_0 : ~ 1 == 0;
    Fdiv_def : forall p q, p / q == p * / q;
    Finv_l : forall p, ~ p == 0 -&gt;  / p * p == 1
}.

Record semi_field_theory : Prop := mk_sfield {
    SF_SR : semi_ring_theory rO rI radd rmul req;
    SF_1_neq_0 : ~ 1 == 0;
    SFdiv_def : forall p q, p / q == p * / q;
    SFinv_l : forall p, ~ p == 0 -&gt;  / p * p == 1
}.
</pre><p>The result of the normalization process is a fraction represented by
the following type:
</p><pre class="verbatim">Record linear : Type := mk_linear {
   num : PExpr C;
   denum : PExpr C;
   condition : list (PExpr C) }.
</pre><p>where <span style="font-family:monospace">num</span> and <span style="font-family:monospace">denum</span> are the numerator and denominator;
<span style="font-family:monospace">condition</span> is a list of expressions that have appeared as a
denominator during the normalization process. These expressions must
be proven different from zero for the correctness of the algorithm.</p><p>The syntax for adding a new field is <span style="font-family:monospace">Add Field </span><span style="font-style:italic">name</span><span style="font-family:monospace"> : </span><span style="font-style:italic">field</span><span style="font-family:monospace">
(</span><span style="font-style:italic">mod</span><sub>1</sub><span style="font-family:monospace">,…,</span><span style="font-style:italic">mod</span><sub>2</sub><span style="font-family:monospace">)</span>. The name is not relevent. It is just used
for error messages. <span style="font-style:italic">field</span> is a proof that the field signature
satisfies the (semi-)field axioms. The optional list of modifiers is
used to tailor the behaviour of the tactic. Since field tactics are
built upon ring tactics, all mofifiers of the <span style="font-family:monospace">Add Ring</span>
apply. There is only one specific modifier:
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">completeness </span><span style="font-style:oblique">term</span></dt><dd class="dd-description"> allows the field tactic to prove
automatically that the image of non-zero coefficients are mapped to
non-zero elements of the field. <span style="font-style:oblique">term</span>is a proof of <span style="font-family:monospace">forall x y,
[x] == [y] -&gt; x?=!y = true</span>, which is the completeness of equality
on coefficients w.r.t. the field equality.
</dd></dl>
<h2 id="sec736" class="section">24.9  Legacy implementation</h2>
<p><br>
<span style="font-weight:bold">Warning: </span>This tactic is the <span style="font-family:monospace">ring</span> tactic of previous versions of
<span style="font-variant:small-caps">Coq</span> and it should be considered as deprecated. It will probably be
removed in future releases. It has been kept only for compatibility
reasons and in order to help moving existing code to the newer
implementation described above. For more details, please refer to the
Coq Reference Manual, version 8.0.</p>
<h3 id="sec737" class="subsection">24.9.1  <span style="font-family:monospace">legacy ring </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">
</span><a id="hevea_default939"></a><a id="hevea_tactic204"></a><span style="font-family:monospace">
</span><a id="hevea_default940"></a><a id="hevea_command359"></a><span style="font-family:monospace">
</span><a id="hevea_default941"></a><a id="hevea_command360"></a></h3>
<p>This tactic, written by Samuel Boutin and Patrick Loiseleur, applies
associative commutative rewriting on every ring. The tactic must be
loaded by <span style="font-family:monospace">Require Import LegacyRing</span>. The ring must be declared in
the <span style="font-family:monospace">Add Ring</span> command. The ring of booleans (with <span style="font-family:monospace">andb</span>
as multiplication and <span style="font-family:monospace">xorb</span> as addition)
is predefined; if one wants to use the tactic on <span style="font-family:monospace">nat</span> one must
first require the module <span style="font-family:monospace">LegacyArithRing</span>; for <span style="font-family:monospace">Z</span>, do
<span style="font-family:monospace">Require Import LegacyZArithRing</span>; for <span style="font-family:monospace">N</span>, do <span style="font-family:monospace">Require
Import LegacyNArithRing</span>.</p><p>The terms <span style="font-style:oblique">term</span><sub>1</sub>, …, <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> must be subterms of the goal
conclusion. The tactic <span style="font-family:monospace">ring</span> normalizes these terms
w.r.t. associativity and commutativity and replace them by their
normal form.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">legacy ring</span> When the goal is an equality <span style="font-style:italic">t</span><sub>1</sub>=<span style="font-style:italic">t</span><sub>2</sub>, it
acts like <span style="font-family:monospace">ring_simplify</span> <span style="font-style:italic">t</span><sub>1</sub> <span style="font-style:italic">t</span><sub>2</sub> and then
solves the equality by reflexivity.</li><li class="li-enumerate"><span style="font-family:monospace">ring_nat</span> is a tactic macro for <span style="font-family:monospace">repeat rewrite
S_to_plus_one; ring</span>. The theorem <span style="font-family:monospace">S_to_plus_one</span> is a
proof that <span style="font-family:monospace">forall (n:nat), S n = plus (S O) n</span>.</li></ol><p>You can have a look at the files <span style="font-family:monospace">LegacyRing.v</span>,
<span style="font-family:monospace">ArithRing.v</span>, <span style="font-family:monospace">ZArithRing.v</span> to see examples of the
<span style="font-family:monospace">Add Ring</span> command.</p>
<h3 id="sec738" class="subsection">24.9.2  Add a ring structure</h3>
<p>It can be done in the <span style="font-variant:small-caps">Coq</span>toplevel (No ML file to edit and to link
with <span style="font-variant:small-caps">Coq</span>). First, <span style="font-family:monospace">ring</span> can handle two kinds of structure:
rings and semi-rings. Semi-rings are like rings without an opposite to
addition. Their precise specification (in <span style="font-variant:small-caps">Gallina</span>) can be found in
the file</p><blockquote class="quotation">
<pre class="verbatim">plugins/ring/Ring_theory.v
</pre></blockquote><p>The typical example of ring is <span style="font-family:monospace">Z</span>, the typical
example of semi-ring is <span style="font-family:monospace">nat</span>.</p><p>The specification of a
ring is divided in two parts: first the record of constants
(⊕, ⊗, 1, 0, ⊖) and then the theorems
(associativity, commutativity, etc.).</p><div class="flushleft"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">Section Theory_of_semi_rings.

Variable A : Type.
Variable Aplus : A -&gt; A -&gt; A.
Variable Amult : A -&gt; A -&gt; A.
Variable Aone : A.
Variable Azero : A.
(* There is also a "weakly decidable" equality on A. That means 
  that if (A_eq x y)=true then x=y but x=y can arise when 
  (A_eq x y)=false. On an abstract ring the function [x,y:A]false
  is a good choice. The proof of A_eq_prop is in this case easy. *)
Variable Aeq : A -&gt; A -&gt; bool.

Record Semi_Ring_Theory : Prop :=
{ SR_plus_sym  : (n,m:A)[| n + m == m + n |];
  SR_plus_assoc : (n,m,p:A)[| n + (m + p) == (n + m) + p |];

  SR_mult_sym : (n,m:A)[| n*m == m*n |];
  SR_mult_assoc : (n,m,p:A)[| n*(m*p) == (n*m)*p |];
  SR_plus_zero_left :(n:A)[| 0 + n == n|];
  SR_mult_one_left : (n:A)[| 1*n == n |];
  SR_mult_zero_left : (n:A)[| 0*n == 0 |];
  SR_distr_left   : (n,m,p:A) [| (n + m)*p == n*p + m*p |];
  SR_plus_reg_left : (n,m,p:A)[| n + m == n + p |] -&gt; m==p;
  SR_eq_prop : (x,y:A) (Is_true (Aeq x y)) -&gt; x==y
}.
</span></pre></div><div class="flushleft"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">Section Theory_of_rings.

Variable A : Type.

Variable Aplus : A -&gt; A -&gt; A.
Variable Amult : A -&gt; A -&gt; A.
Variable Aone : A.
Variable Azero : A.
Variable Aopp : A -&gt; A.
Variable Aeq : A -&gt; A -&gt; bool.


Record Ring_Theory : Prop :=
{ Th_plus_sym  : (n,m:A)[| n + m == m + n |];
  Th_plus_assoc : (n,m,p:A)[| n + (m + p) == (n + m) + p |];
  Th_mult_sym : (n,m:A)[| n*m == m*n |];
  Th_mult_assoc : (n,m,p:A)[| n*(m*p) == (n*m)*p |];
  Th_plus_zero_left :(n:A)[| 0 + n == n|];
  Th_mult_one_left : (n:A)[| 1*n == n |];
  Th_opp_def : (n:A) [| n + (-n) == 0 |];
  Th_distr_left   : (n,m,p:A) [| (n + m)*p == n*p + m*p |];
  Th_eq_prop : (x,y:A) (Is_true (Aeq x y)) -&gt; x==y
}.
</span></pre></div><p>To define a ring structure on A, you must provide an addition, a
multiplication, an opposite function and two unities 0 and 1.</p><p>You must then prove all theorems that make
(A,Aplus,Amult,Aone,Azero,Aeq) 
a ring structure, and pack them with the <code>Build_Ring_Theory</code> 
constructor.</p><p>Finally to register a ring the syntax is:</p><p><a id="hevea_default942"></a><a id="hevea_command361"></a>
</p><blockquote class="quotation">
<span style="font-family:monospace">Add Legacy Ring</span> <span style="font-style:italic">A Aplus Amult Aone Azero Ainv Aeq T</span>
<span style="font-family:monospace">[</span> <span style="font-style:italic">c1 …cn</span> <span style="font-family:monospace">].</span>
</blockquote><p>where <span style="font-style:italic">A</span> is a term of type <span style="font-family:monospace">Set</span>, 
<span style="font-style:italic">Aplus</span> is a term of type <span style="font-family:monospace">A-&gt;A-&gt;A</span>,
<span style="font-style:italic">Amult</span> is a term of type <span style="font-family:monospace">A-&gt;A-&gt;A</span>,
<span style="font-style:italic">Aone</span> is a term of type <span style="font-family:monospace">A</span>,
<span style="font-style:italic">Azero</span> is a term of type <span style="font-family:monospace">A</span>,
<span style="font-style:italic">Ainv</span> is a term of type <span style="font-family:monospace">A-&gt;A</span>,
<span style="font-style:italic">Aeq</span> is a term of type <span style="font-family:monospace">A-&gt;bool</span>,
<span style="font-style:italic">T</span> is a term of type 
<span style="font-family:monospace">(Ring_Theory </span><span style="font-style:italic">A Aplus Amult Aone Azero Ainv
Aeq</span><span style="font-family:monospace">)</span>.
The arguments <span style="font-style:italic">c1 …cn</span>, 
are the names of constructors which define closed terms: a
subterm will be considered as a constant if it is either one of the
terms <span style="font-style:italic">c1 …cn</span> or the application of one of these terms to
closed terms. For <span style="font-family:monospace">nat</span>, the given constructors are <span style="font-family:monospace">S</span>
and <span style="font-family:monospace">O</span>, and the closed terms are <span style="font-family:monospace">O</span>, <span style="font-family:monospace">(S O)</span>,
<span style="font-family:monospace">(S (S O))</span>, …</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Add Legacy Semi Ring</span> <span style="font-style:italic">A Aplus Amult Aone Azero Aeq T</span> 
<span style="font-family:monospace">[</span> <span style="font-style:italic">c1 … cn</span> <span style="font-family:monospace">].</span><a id="hevea_default943"></a><a id="hevea_command362"></a><p>There are two differences with the <span style="font-family:monospace">Add Ring</span> command: there
is no inverse function and the term <span style="font-style:italic">T</span> must be of type
<span style="font-family:monospace">(Semi_Ring_Theory </span><span style="font-style:italic">A Aplus Amult Aone Azero
Aeq</span><span style="font-family:monospace">)</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Add Legacy Abstract Ring</span> <span style="font-style:italic">A Aplus Amult Aone Azero Ainv 
Aeq T</span><span style="font-family:monospace">.</span><a id="hevea_default944"></a><a id="hevea_command363"></a><p>This command should be used for when the operations of rings are not
computable; for example the real numbers of
<span style="font-family:monospace">theories/REALS/</span>. Here 0+1 is not beta-reduced to 1 but
you still may want to <span style="font-style:italic">rewrite</span> it to 1 using the ring
axioms. The argument <span style="font-family:monospace">Aeq</span> is not used; a good choice for
that function is <code>[x:A]false</code>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Add Legacy Abstract Semi Ring</span> <span style="font-style:italic">A Aplus Amult Aone Azero
Aeq T</span><span style="font-family:monospace">.</span><a id="hevea_default945"></a><a id="hevea_command364"></a></li></ol><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Not a valid (semi)ring theory</span><a id="hevea_error168"></a>.<p>That happens when the typing condition does not hold.
</p></li></ol><p>Currently, the hypothesis is made than no more than one ring structure
may be declared for a given type in <span style="font-family:monospace">Set</span> or <span style="font-family:monospace">Type</span>.
This allows automatic detection of the theory used to achieve the
normalization. On popular demand, we can change that and allow several
ring structures on the same set.</p><p>The table of ring theories is compatible with the <span style="font-variant:small-caps">Coq</span> 
sectioning mechanism. If you declare a ring inside a section, the
declaration will be thrown away when closing the section.
And when you load a compiled file, all the <span style="font-family:monospace">Add Ring</span>
commands of this file that are not inside a section will be loaded.</p><p>The typical example of ring is <span style="font-family:monospace">Z</span>, and the typical example of
semi-ring is <span style="font-family:monospace">nat</span>. Another ring structure is defined on the
booleans. </p><p><br>
<span style="font-weight:bold">Warning: </span>Only the ring of booleans is loaded by default with the
<span style="font-family:monospace">Ring</span> module. To load the ring structure for <span style="font-family:monospace">nat</span>,
load the module <span style="font-family:monospace">ArithRing</span>, and for <span style="font-family:monospace">Z</span>,
load the module <span style="font-family:monospace">ZArithRing</span>.</p>
<h3 id="sec739" class="subsection">24.9.3  <span style="font-family:monospace">legacy field
</span><a id="hevea_default946"></a><a id="hevea_tactic205"></a></h3>
<p>This tactic written by David Delahaye and Micaela Mayero solves equalities
using commutative field theory. Denominators have to be non equal to zero and,
as this is not decidable in general, this tactic may generate side conditions
requiring some expressions to be non equal to zero. This tactic must be loaded
by <span style="font-family:monospace">Require Import LegacyField</span>. Field theories are declared (as for
<span style="font-family:monospace">legacy ring</span>) with
the <span style="font-family:monospace">Add Legacy Field</span> command.</p>
<h3 id="sec740" class="subsection">24.9.4  <span style="font-family:monospace">Add Legacy Field
</span><a id="hevea_default947"></a><a id="hevea_command365"></a></h3>
<p>This vernacular command adds a commutative field theory to the database for the
tactic <span style="font-family:monospace">field</span>. You must provide this theory as follows:
</p><div class="flushleft">
<span style="font-family:monospace">Add Legacy Field </span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Aplus</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Amult</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Aone</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Azero</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Aopp</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Aeq</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Ainv</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Rth</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Tinvl</span></span>
</div><p>
where <span style="font-family:monospace"><span style="font-style:italic">A</span></span> is a term of type <span style="font-family:monospace">Type</span>, <span style="font-family:monospace"><span style="font-style:italic">Aplus</span></span> is
a term of type <span style="font-family:monospace">A-&gt;A-&gt;A</span>, <span style="font-family:monospace"><span style="font-style:italic">Amult</span></span> is a term of type <span style="font-family:monospace">A-&gt;A-&gt;A</span>, <span style="font-family:monospace"><span style="font-style:italic">Aone</span></span> is a term of type <span style="font-family:monospace">A</span>, <span style="font-family:monospace"><span style="font-style:italic">Azero</span></span> is a term of type <span style="font-family:monospace">A</span>, <span style="font-family:monospace"><span style="font-style:italic">Aopp</span></span> is a term of
type <span style="font-family:monospace">A-&gt;A</span>, <span style="font-family:monospace"><span style="font-style:italic">Aeq</span></span> is a term of type <span style="font-family:monospace">A-&gt;bool</span>, <span style="font-family:monospace"><span style="font-style:italic">Ainv</span></span> is a term of type <span style="font-family:monospace">A-&gt;A</span>, <span style="font-family:monospace"><span style="font-style:italic">Rth</span></span> is a term
of type <span style="font-family:monospace">(Ring_Theory </span><span style="font-family:monospace"><span style="font-style:italic">A Aplus Amult Aone Azero Ainv Aeq</span></span><span style="font-family:monospace">)</span>,
and <span style="font-family:monospace"><span style="font-style:italic">Tinvl</span></span> is a term of type <span style="font-family:monospace">forall n:</span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace">,
</span><span style="font-family:monospace">~</span><span style="font-family:monospace">(n=</span><span style="font-family:monospace"><span style="font-style:italic">Azero</span></span><span style="font-family:monospace">)-&gt;(</span><span style="font-family:monospace"><span style="font-style:italic">Amult</span></span><span style="font-family:monospace"> (</span><span style="font-family:monospace"><span style="font-style:italic">Ainv</span></span><span style="font-family:monospace"> n) n)=</span><span style="font-family:monospace"><span style="font-style:italic">Aone</span></span>.
To build a ring theory, refer to Chapter <a href="#ring">24</a> for more details.</p><p>This command adds also an entry in the ring theory table if this theory is not
already declared. So, it is useless to keep, for a given type, the <span style="font-family:monospace">Add
Ring</span> command if you declare a theory with <span style="font-family:monospace">Add Field</span>, except if you plan
to use specific features of <span style="font-family:monospace">ring</span> (see Chapter <a href="#ring">24</a>). However, the
module <span style="font-family:monospace">ring</span> is not loaded by <span style="font-family:monospace">Add Field</span> and you have to make a <span style="font-family:monospace">Require Import Ring</span> if you want to call the <span style="font-family:monospace">ring</span> tactic.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Add Legacy Field </span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Aplus</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Amult</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Aone</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Azero</span></span><span style="font-family:monospace">
</span><span style="font-family:monospace"><span style="font-style:italic">Aopp</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Aeq</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Ainv</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Rth</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Tinvl</span></span><br>
<span style="font-family:monospace">    with minus:=</span><span style="font-family:monospace"><span style="font-style:italic">Aminus</span></span><p>Adds also the term <span style="font-style:italic">Aminus</span> which must be a constant expressed by
means of <span style="font-style:italic">Aopp</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Add Legacy Field </span><span style="font-family:monospace"><span style="font-style:italic">A</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Aplus</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Amult</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Aone</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Azero</span></span><span style="font-family:monospace">
</span><span style="font-family:monospace"><span style="font-style:italic">Aopp</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Aeq</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Ainv</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Rth</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">Tinvl</span></span><br>
<span style="font-family:monospace">    with div:=</span><span style="font-family:monospace"><span style="font-style:italic">Adiv</span></span><p>Adds also the term <span style="font-style:italic">Adiv</span> which must be a constant expressed by
means of <span style="font-style:italic">Ainv</span>.</p></li></ol><p><br>
<span style="font-weight:bold">See also: </span>[<a href="biblio.html#DelMay01">42</a>] for more details regarding the implementation of <span style="font-family:monospace">legacy field</span>.</p>
<h2 id="sec741" class="section">24.10  History of <span style="font-family:monospace">ring</span></h2>
<p>First Samuel Boutin designed the tactic <span style="font-family:monospace">ACDSimpl</span>. 
This tactic did lot of rewriting. But the proofs
terms generated by rewriting were too big for <span style="font-variant:small-caps">Coq</span>’s type-checker.
Let us see why:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall x y z:Z, x + 3 + y + y * z = x + 3 + y + z * y.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   forall x y z : Z, x + 3 + y + y * z = x + 3 + y + z * y</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros; rewrite (Z.mul_comm y z); reflexivity.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Save toto.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print  toto.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">toto = </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun x y z : Z =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">eq_ind_r (fun z0 : Z =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> x + 3 + y + z0 = x + 3 + y + z * y) eq_refl</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  (Z.mul_comm y z)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall x y z : Z, x + 3 + y + y * z = x + 3 + y + z * y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument scopes are [Z_scope Z_scope Z_scope]</span></span></span><span style="font-size:small"><br>
</span></div><p>At each step of rewriting, the whole context is duplicated in the proof
term. Then, a tactic that does hundreds of rewriting generates huge proof
terms. Since <span style="font-family:monospace">ACDSimpl</span> was too slow, Samuel Boutin rewrote it
using reflection (see his article in TACS’97 [<a href="biblio.html#Bou97">18</a>]). Later, the
stuff was rewritten by Patrick
Loiseleur: the new tactic does not any more require <span style="font-family:monospace">ACDSimpl</span>
to compile and it makes use of βδι-reduction 
not only to replace the rewriting steps, but also to achieve the
interleaving of computation and 
reasoning (see <a href="#DiscussReflection">24.11</a>). He also wrote a
few ML code for the <span style="font-family:monospace">Add Ring</span> command, that allow to register
new rings dynamically.</p><p>Proofs terms generated by <span style="font-family:monospace">ring</span> are quite small, they are
linear in the number of ⊕ and ⊗ operations in the
normalized terms. Type-checking those terms requires some time because it
makes a large use of the conversion rule, but
memory requirements are much smaller. </p>
<h2 id="sec742" class="section">24.11  Discussion</h2>
<p>
<a id="DiscussReflection"></a></p><p>Efficiency is not the only motivation to use reflection
here. <span style="font-family:monospace">ring</span> also deals with constants, it rewrites for example the
expression 34 + 2*<span style="font-style:italic">x</span> −<span style="font-style:italic">x</span> + 12 to the expected result <span style="font-style:italic">x</span> + 46. For the
tactic <span style="font-family:monospace">ACDSimpl</span>, the only constants were 0 and 1. So the
expression 34 + 2*(<span style="font-style:italic">x</span> − 1) + 12 is interpreted as 
<span style="font-style:italic">V</span><sub>0</sub> ⊕ <span style="font-style:italic">V</span><sub>1</sub> ⊗ (<span style="font-style:italic">V</span><sub>2</sub> ⊖ 1) ⊕ <span style="font-style:italic">V</span><sub>3</sub>, 
with the variables mapping 
{<span style="font-style:italic">V</span><sub>0</sub> ↦ 34; <span style="font-style:italic">V</span><sub>1</sub> ↦ 2; <span style="font-style:italic">V</span><sub>2</sub> ↦ <span style="font-style:italic">x</span>; <span style="font-style:italic">V</span><sub>3</sub> ↦ 12 }. Then it is
rewritten to 34 − <span style="font-style:italic">x</span> + 2*<span style="font-style:italic">x</span> + 12, very far from the expected
result. Here rewriting is not sufficient: you have to do some kind of
reduction (some kind of <span style="font-style:italic">computation</span>) to achieve the
normalization.</p><p>The tactic <span style="font-family:monospace">ring</span> is not only faster than a classical one:
using reflection, we get for free integration of computation and
reasoning that would be very complex to implement in the classic fashion.</p><p>Is it the ultimate way to write tactics? The answer is: yes and
no. The <span style="font-family:monospace">ring</span> tactic uses intensively the conversion rule of
p<span style="font-variant:small-caps">Cic</span>, that is replaces proof by computation the most as it is
possible. It can be useful in all situations where a classical tactic
generates huge proof terms. Symbolic Processing and Tautologies are in
that case. But there are also tactics like <span style="font-family:monospace">auto</span> or
<span style="font-family:monospace">linear</span> that do many complex computations, using side-effects
and backtracking, and generate a small proof term. Clearly, it would
be significantly less efficient to replace them by tactics using
reflection.</p><p>Another idea suggested by Benjamin Werner: reflection could be used to
couple an external tool (a rewriting program or a model checker) with
<span style="font-variant:small-caps">Coq</span>. We define (in <span style="font-variant:small-caps">Coq</span>) a type of terms, a type of <em>traces</em>,
and prove a correction theorem that states that <em>replaying
traces</em> is safe w.r.t some interpretation. Then we let the external
tool do every computation (using side-effects, backtracking,
exception, or others features that are not available in pure lambda
calculus) to produce the trace: now we can check in Coq that the
trace has the expected semantic by applying the correction lemma.</p>
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note33" href="#text33">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">based on previous work from
Patrick Loiseleur and Samuel Boutin</div>
</dd></dl>

<div id="sidebarWrapper">
  <div id="sidebar">
    <div class="block">
      <h2 class="title">Navigation</h2>
      <div class="content">
        <ul class="menu">
          <li class="leaf"><a href="index.html">Cover</a></li>
          <li class="leaf"><a href="toc.html">Table of contents</a></li>
          <li class="leaf">Index
            <ul class="menu">
              <li><a href="general-index.html">General</a></li>
              <li><a href="command-index.html">Commands</a></li>
              <li><a href="tactic-index.html">Tactics</a></li>
              <li><a href="error-index.html">Errors</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</body>
</html>
