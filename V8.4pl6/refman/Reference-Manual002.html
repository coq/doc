<!DOCTYPE html>
<html>
<head>


<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/coqdoc.css" /><title>Credits</title>
</head>
<body >

<div id="container">

<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="/" class="active">Home</a></li>
    <li><a href="/about-coq" title="More about coq">About Coq</a></li>
    <li><a href="/download">Get Coq</a></li>
    <li><a href="/documentation">Documentation</a></li>
    <li><a href="/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">
<div id="logoWrapper">
  <div id="logo"><a href="/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
  </div>
  <div id="siteName"><a href="/" title="Home">The Coq Proof Assistant</a>
  </div>
</div>
</div>

<div id="content">

<h1 id="sec4" class="chapter">Credits</h1>
<ul>
<li><a href="Reference-Manual002.html#sec5">Credits: addendum for version 6.1</a>
</li><li><a href="Reference-Manual002.html#sec6">Credits: addendum for version 6.2</a>
</li><li><a href="Reference-Manual002.html#sec7">Credits: addendum for version 6.3</a>
</li><li><a href="Reference-Manual002.html#sec8">Credits: versions 7</a>
</li><li><a href="Reference-Manual002.html#sec9">Credits: version 8.0</a>
</li><li><a href="Reference-Manual002.html#sec10">Credits: version 8.1</a>
</li><li><a href="Reference-Manual002.html#sec11">Credits: version 8.2</a>
</li><li><a href="Reference-Manual002.html#sec12">Credits: version 8.3</a>
</li><li><a href="Reference-Manual002.html#sec13">Credits: version 8.4</a>
</li></ul>
<p><span style="font-variant:small-caps">Coq</span>  is a proof assistant for higher-order logic, allowing the
development of computer programs consistent with their formal
specification. It is the result of about ten years of research of the
Coq project. We shall briefly survey here three main aspects: the
<em>logical language</em> in which we write our axiomatizations and
specifications, the <em>proof assistant</em> which allows the development
of verified mathematical proofs, and the <em>program extractor</em> which
synthesizes computer programs obeying their formal specifications,
written as logical assertions in the language.</p><p>The logical language used by <span style="font-variant:small-caps">Coq</span> is a variety of type theory,
called the <em>Calculus of Inductive Constructions</em>. Without going
back to Leibniz and Boole, we can date the creation of what is now
called mathematical logic to the work of Frege and Peano at the turn
of the century. The discovery of antinomies in the free use of
predicates or comprehension principles prompted Russell to restrict
predicate calculus with a stratification of <em>types</em>. This effort
culminated with <em>Principia Mathematica</em>, the first systematic
attempt at a formal foundation of mathematics. A simplification of
this system along the lines of simply typed λ-calculus
occurred with Church’s <em>Simple Theory of Types</em>. The
λ-calculus notation, originally used for expressing
functionality, could also be used as an encoding of natural deduction
proofs. This Curry-Howard isomorphism was used by N. de Bruijn in the
<em>Automath</em> project, the first full-scale attempt to develop and
mechanically verify mathematical proofs. This effort culminated with
Jutting’s verification of Landau’s <em>Grundlagen</em> in the 1970’s.
Exploiting this Curry-Howard isomorphism, notable achievements in
proof theory saw the emergence of two type-theoretic frameworks; the
first one, Martin-Löf’s <em>Intuitionistic Theory of Types</em>,
attempts a new foundation of mathematics on constructive principles.
The second one, Girard’s polymorphic λ-calculus <span style="font-style:italic">F</span><sub>ω</sub>, is
a very strong functional system in which we may represent higher-order
logic proof structures. Combining both systems in a higher-order
extension of the Automath languages, T. Coquand presented in 1985 the
first version of the <em>Calculus of Constructions</em>, CoC. This strong
logical system allowed powerful axiomatizations, but direct inductive
definitions were not possible, and inductive notions had to be defined
indirectly through functional encodings, which introduced
inefficiencies and awkwardness. The formalism was extended in 1989 by
T. Coquand and C. Paulin with primitive inductive definitions, leading
to the current <em>Calculus of Inductive Constructions</em>. This
extended formalism is not rigorously defined here. Rather, numerous
concrete examples are discussed. We refer the interested reader to
relevant research papers for more information about the formalism, its
meta-theoretic properties, and semantics. However, it should not be
necessary to understand this theoretical material in order to write
specifications. It is possible to understand the Calculus of Inductive
Constructions at a higher level, as a mixture of predicate calculus,
inductive predicate definitions presented as typed PROLOG, and
recursive function definitions close to the language ML.</p><p>Automated theorem-proving was pioneered in the 1960’s by Davis and
Putnam in propositional calculus. A complete mechanization (in the
sense of a semi-decision procedure) of classical first-order logic was
proposed in 1965 by J.A. Robinson, with a single uniform inference
rule called <em>resolution</em>. Resolution relies on solving equations
in free algebras (i.e. term structures), using the <em>unification
algorithm</em>. Many refinements of resolution were studied in the
1970’s, but few convincing implementations were realized, except of
course that PROLOG is in some sense issued from this effort. A less
ambitious approach to proof development is computer-aided
proof-checking. The most notable proof-checkers developed in the
1970’s were LCF, designed by R. Milner and his colleagues at U.
Edinburgh, specialized in proving properties about denotational
semantics recursion equations, and the Boyer and Moore theorem-prover,
an automation of primitive recursion over inductive data types. While
the Boyer-Moore theorem-prover attempted to synthesize proofs by a
combination of automated methods, LCF constructed its proofs through
the programming of <em>tactics</em>, written in a high-level functional
meta-language, ML.</p><p>The salient feature which clearly distinguishes our proof assistant
from say LCF or Boyer and Moore’s, is its possibility to extract
programs from the constructive contents of proofs. This computational
interpretation of proof objects, in the tradition of Bishop’s
constructive mathematics, is based on a realizability interpretation,
in the sense of Kleene, due to C. Paulin. The user must just mark his
intention by separating in the logical statements the assertions
stating the existence of a computational object from the logical
assertions which specify its properties, but which may be considered
as just comments in the corresponding program. Given this information,
the system automatically extracts a functional term from a consistency
proof of its specifications. This functional term may be in turn
compiled into an actual computer program. This methodology of
extracting programs from proofs is a revolutionary paradigm for
software engineering. Program synthesis has long been a theme of
research in artificial intelligence, pioneered by R. Waldinger. The
Tablog system of Z. Manna and R. Waldinger allows the deductive
synthesis of functional programs from proofs in tableau form of their
specifications, written in a variety of first-order logic. Development
of a systematic <em>programming logic</em>, based on extensions of
Martin-Löf’s type theory, was undertaken at Cornell U. by the Nuprl
team, headed by R. Constable. The first actual program extractor, PX,
was designed and implemented around 1985 by S. Hayashi from Kyoto
University. It allows the extraction of a LISP program from a proof
in a logical system inspired by the logical formalisms of S. Feferman.
Interest in this methodology is growing in the theoretical computer
science community. We can foresee the day when actual computer systems
used in applications will contain certified modules, automatically
generated from a consistency proof of their formal specifications. We
are however still far from being able to use this methodology in a
smooth interaction with the standard tools from software engineering,
i.e. compilers, linkers, run-time systems taking advantage of special
hardware, debuggers, and the like. We hope that <span style="font-variant:small-caps">Coq</span> can be of use
to researchers interested in experimenting with this new methodology.</p><p>A first implementation of CoC was started in 1984 by G. Huet and T.
Coquand. Its implementation language was CAML, a functional
programming language from the ML family designed at INRIA in
Rocquencourt. The core of this system was a proof-checker for CoC seen
as a typed λ-calculus, called the <em>Constructive Engine</em>.
This engine was operated through a high-level notation permitting the
declaration of axioms and parameters, the definition of mathematical
types and objects, and the explicit construction of proof objects
encoded as λ-terms. A section mechanism, designed and
implemented by G. Dowek, allowed hierarchical developments of
mathematical theories. This high-level language was called the
<em>Mathematical Vernacular</em>. Furthermore, an interactive
<em>Theorem Prover</em> permitted the incremental construction of proof
trees in a top-down manner, subgoaling recursively and backtracking
from dead-alleys. The theorem prover executed tactics written in CAML,
in the LCF fashion. A basic set of tactics was predefined, which the
user could extend by his own specific tactics. This system (Version
4.10) was released in 1989. Then, the system was extended to deal
with the new calculus with inductive types by C. Paulin, with
corresponding new tactics for proofs by induction. A new standard set
of tactics was streamlined, and the vernacular extended for tactics
execution. A package to compile programs extracted from proofs to
actual computer programs in CAML or some other functional language was
designed and implemented by B. Werner. A new user-interface, relying
on a CAML-X interface by D. de Rauglaudre, was designed and
implemented by A. Felty. It allowed operation of the theorem-prover
through the manipulation of windows, menus, mouse-sensitive buttons,
and other widgets. This system (Version 5.6) was released in 1991.</p><p><span style="font-variant:small-caps">Coq</span> was ported to the new implementation Caml-light of X. Leroy and
D. Doligez by D. de Rauglaudre (Version 5.7) in 1992. A new version
of <span style="font-variant:small-caps">Coq</span> was then coordinated by C. Murthy, with new tools designed
by C. Parent to prove properties of ML programs (this methodology is
dual to program extraction) and a new user-interaction loop. This
system (Version 5.8) was released in May 1993. A Centaur interface
<span style="font-variant:small-caps">CTCoq</span> was then developed by Y. Bertot from the Croap project
from INRIA-Sophia-Antipolis.</p><p>In parallel, G. Dowek and H. Herbelin developed a new proof engine,
allowing the general manipulation of existential variables
consistently with dependent types in an experimental version of <span style="font-variant:small-caps">Coq</span>
(V5.9).</p><p>The version V5.10 of <span style="font-variant:small-caps">Coq</span> is based on a generic system for
manipulating terms with binding operators due to Chet Murthy. A new
proof engine allows the parallel development of partial proofs for
independent subgoals. The structure of these proof trees is a mixed
representation of derivation trees for the Calculus of Inductive
Constructions with abstract syntax trees for the tactics scripts,
allowing the navigation in a proof at various levels of details. The
proof engine allows generic environment items managed in an
object-oriented way. This new architecture, due to C. Murthy,
supports several new facilities which make the system easier to extend
and to scale up:</p><ul class="itemize"><li class="li-itemize">
User-programmable tactics are allowed
</li><li class="li-itemize">It is possible to separately verify development modules, and to
load their compiled images without verifying them again - a quick
relocation process allows their fast loading
</li><li class="li-itemize">A generic parsing scheme allows user-definable notations, with a
symmetric table-driven pretty-printer
</li><li class="li-itemize">Syntactic definitions allow convenient abbreviations
</li><li class="li-itemize">A limited facility of meta-variables allows the automatic
synthesis of certain type expressions, allowing generic notations
for e.g. equality, pairing, and existential quantification.
</li></ul><p>In the Fall of 1994, C. Paulin-Mohring replaced the structure of
inductively defined types and families by a new structure, allowing
the mutually recursive definitions. P. Manoury implemented a
translation of recursive definitions into the primitive recursive
style imposed by the internal recursion operators, in the style of the
ProPre system. C. Muñoz implemented a decision procedure for
intuitionistic propositional logic, based on results of R. Dyckhoff.
J.C. Filliâtre implemented a decision procedure for first-order
logic without contraction, based on results of J. Ketonen and R.
Weyhrauch. Finally C. Murthy implemented a library of inversion
tactics, relieving the user from tedious definitions of “inversion
predicates”.</p><div class="flushright">
Rocquencourt, Feb. 1st 1995<br>
Gérard Huet
</div><h2 id="sec5" class="section">Credits: addendum for version 6.1</h2>
<p>The present version 6.1 of <span style="font-variant:small-caps">Coq</span> is based on the V5.10 architecture. It
was ported to the new language Objective Caml by Bruno Barras. The
underlying framework has slightly changed and allows more conversions
between sorts. </p><p>The new version provides powerful tools for easier developments. </p><p>Cristina Cornes designed an extension of the <span style="font-variant:small-caps">Coq</span> syntax to allow
definition of terms using a powerful pattern-matching analysis in the
style of ML programs.</p><p>Amokrane Saïbi wrote a mechanism to simulate
inheritance between types families extending a proposal by Peter
Aczel. He also developed a mechanism to automatically compute which
arguments of a constant may be inferred by the system and consequently
do not need to be explicitly written. </p><p>Yann Coscoy designed a command which explains a proof term using
natural language. Pierre Crégut built a new tactic which solves
problems in quantifier-free Presburger Arithmetic. Both
functionalities have been integrated to the <span style="font-variant:small-caps">Coq</span> system by Hugo
Herbelin.</p><p>Samuel Boutin designed a tactic for simplification of commutative
rings using a canonical set of rewriting rules and equality modulo
associativity and commutativity. </p><p>Finally the organisation of the <span style="font-variant:small-caps">Coq</span> distribution has been supervised
by Jean-Christophe Filliâtre with the help of Judicaël Courant
and Bruno Barras.</p><div class="flushright">
Lyon, Nov. 18th 1996<br>
Christine Paulin
</div><h2 id="sec6" class="section">Credits: addendum for version 6.2</h2>
<p>In version 6.2 of <span style="font-variant:small-caps">Coq</span>, the parsing is done using camlp4, a
preprocessor and pretty-printer for CAML designed by Daniel de
Rauglaudre at INRIA. Daniel de Rauglaudre made the first adaptation
of <span style="font-variant:small-caps">Coq</span> for camlp4, this work was continued by Bruno Barras who also
changed the structure of <span style="font-variant:small-caps">Coq</span> abstract syntax trees and the primitives
to manipulate them. The result of
these changes is a faster parsing procedure with greatly improved
syntax-error messages. The user-interface to introduce grammar or
pretty-printing rules has also changed.</p><p>Eduardo Giménez redesigned the internal
tactic libraries, giving uniform names 
to Caml functions corresponding to <span style="font-variant:small-caps">Coq</span> tactic names. </p><p>Bruno Barras wrote new more efficient reductions functions.</p><p>Hugo Herbelin introduced more uniform notations in the <span style="font-variant:small-caps">Coq</span>
specification language: the definitions by fixpoints and
pattern-matching have a more readable syntax. Patrick Loiseleur
introduced user-friendly notations for arithmetic expressions.</p><p>New tactics were introduced: Eduardo Giménez improved a mechanism to
introduce macros for tactics, and designed special tactics for
(co)inductive definitions; Patrick Loiseleur designed a tactic to
simplify polynomial expressions in an arbitrary commutative ring which
generalizes the previous tactic implemented by Samuel Boutin.
Jean-Christophe Filliâtre introduced a tactic for refining a goal,
using a proof term with holes as a proof scheme.</p><p>David Delahaye designed the <span style="font-family:sans-serif">SearchIsos</span> tool to search an
object in the library given its type (up to isomorphism).</p><p>Henri Laulhère produced the <span style="font-variant:small-caps">Coq</span> distribution for the Windows environment.</p><p>Finally, Hugo Herbelin was the main coordinator of the <span style="font-variant:small-caps">Coq</span>
documentation with principal contributions by Bruno Barras, David Delahaye, 
Jean-Christophe Filliâtre, Eduardo
Giménez, Hugo Herbelin and Patrick Loiseleur.</p><div class="flushright">
Orsay, May 4th 1998<br>
Christine Paulin
</div><h2 id="sec7" class="section">Credits: addendum for version 6.3</h2>
<p>
The main changes in version V6.3 was the introduction of a few new tactics
and the extension of the guard condition for fixpoint definitions.</p><p>B. Barras extended the unification algorithm to complete partial terms
and solved various tricky bugs related to universes.<br>
D. Delahaye developed the <span style="font-family:monospace">AutoRewrite</span> tactic. He also designed the new
behavior of <span style="font-family:monospace">Intro</span> and provided the tacticals <span style="font-family:monospace">First</span> and
<span style="font-family:monospace">Solve</span>.<br>
J.-C. Filliâtre developed the <span style="font-family:monospace">Correctness</span> tactic.<br>
E. Giménez extended the guard condition in fixpoints.<br>
H. Herbelin designed the new syntax for definitions and extended the
<span style="font-family:monospace">Induction</span> tactic.<br>
P. Loiseleur developed the <span style="font-family:monospace">Quote</span> tactic and 
the new design of the <span style="font-family:monospace">Auto</span>
tactic, he also introduced the index of
errors in the documentation.<br>
C. Paulin wrote the <span style="font-family:monospace">Focus</span> command and introduced 
the reduction functions in definitions, this last feature 
was proposed by J.-F. Monin from CNET Lannion. </p><div class="flushright">
Orsay, Dec. 1999<br>
Christine Paulin
</div><h2 id="sec8" class="section">Credits: versions 7</h2>
<p>The version V7 is a new implementation started in September 1999 by
Jean-Christophe Filliâtre. This is a major revision with respect to
the internal architecture of the system. The <span style="font-variant:small-caps">Coq</span> version 7.0 was
distributed in March 2001, version 7.1 in September 2001, version
7.2 in January 2002, version 7.3 in May 2002 and version 7.4 in
February 2003.</p><p>Jean-Christophe Filliâtre designed the architecture of the new system, he
introduced a new representation for environments and wrote a new kernel
for type-checking terms. His approach was to use functional
data-structures in order to get more sharing, to prepare the addition
of modules and also to get closer to a certified kernel.</p><p>Hugo Herbelin introduced a new structure of terms with local
definitions. He introduced “qualified” names, wrote a new
pattern-matching compilation algorithm and designed a more compact
algorithm for checking the logical consistency of universes. He
contributed to the simplification of <span style="font-variant:small-caps">Coq</span> internal structures and the
optimisation of the system. He added basic tactics for forward
reasoning and coercions in patterns.</p><p>David Delahaye introduced a new language for tactics. General tactics
using pattern-matching on goals and context can directly be written
from the <span style="font-variant:small-caps">Coq</span> toplevel. He also provided primitives for the design
of user-defined tactics in <span style="font-variant:small-caps">Caml</span>.</p><p>Micaela Mayero contributed the library on real numbers.
Olivier Desmettre extended this library with axiomatic
trigonometric functions, square, square roots, finite sums, Chasles
property and basic plane geometry.</p><p>Jean-Christophe Filliâtre and Pierre Letouzey redesigned a new
extraction procedure from <span style="font-variant:small-caps">Coq</span> terms to <span style="font-variant:small-caps">Caml</span> or
<span style="font-variant:small-caps">Haskell</span> programs. This new 
extraction procedure, unlike the one implemented in previous version
of <span style="font-variant:small-caps">Coq</span> is able to handle all terms in the Calculus of Inductive
Constructions, even involving universes and strong elimination. P.
Letouzey adapted user contributions to extract ML programs when it was
sensible.
Jean-Christophe Filliâtre wrote <code>coqdoc</code>, a documentation
tool for <span style="font-variant:small-caps">Coq</span> libraries usable from version 7.2.</p><p>Bruno Barras improved the reduction algorithms efficiency and
the confidence level in the correctness of <span style="font-variant:small-caps">Coq</span> critical type-checking
algorithm.</p><p>Yves Bertot designed the <span style="font-family:monospace">SearchPattern</span> and
<span style="font-family:monospace">SearchRewrite</span> tools and the support for the <span style="font-variant:small-caps">pcoq</span> interface 
(<a href="http://www-sop.inria.fr/lemme/pcoq/"><span style="font-family:monospace">http://www-sop.inria.fr/lemme/pcoq/</span></a>).</p><p>Micaela Mayero and David Delahaye introduced <span style="font-family:monospace">Field</span>, a decision tactic for commutative fields.</p><p>Christine Paulin changed the elimination rules for empty and singleton
propositional inductive types.</p><p>Loïc Pottier developed <span style="font-family:monospace">Fourier</span>, a tactic solving linear inequalities on real numbers.</p><p>Pierre Crégut developed a new version based on reflexion of the <span style="font-family:monospace">Omega</span>
decision tactic.</p><p>Claudio Sacerdoti Coen designed an XML output for the <span style="font-variant:small-caps">Coq</span>
modules to be used in the Hypertextual Electronic Library of
Mathematics (HELM cf <a href="http://www.cs.unibo.it/helm"><span style="font-family:monospace">http://www.cs.unibo.it/helm</span></a>).</p><p>A library for efficient representation of finite maps using binary trees
contributed by Jean Goubault was integrated in the basic theories.</p><p>Pierre Courtieu developed a command and a tactic to reason on the
inductive structure of recursively defined functions.</p><p>Jacek Chrzaszcz designed and implemented the module system of
<span style="font-variant:small-caps">Coq</span> whose foundations are in Judicaël Courant’s PhD thesis.</p><p><br>
<br>
</p><p>The development was coordinated by C. Paulin.</p><p>Many discussions within the Démons team and the LogiCal project
influenced significantly the design of <span style="font-variant:small-caps">Coq</span> especially with 
J. Courant, J. Duprat, J. Goubault, A. Miquel,
C. Marché, B. Monate and B. Werner.</p><p>Intensive users suggested improvements of the system : 
Y. Bertot, L. Pottier, L. Théry, P. Zimmerman from INRIA,
C. Alvarado, P. Crégut, J.-F. Monin from France Telecom R &amp; D.
</p><div class="flushright">
Orsay, May. 2002<br>
Hugo Herbelin &amp; Christine Paulin
</div><h2 id="sec9" class="section">Credits: version 8.0</h2>
<p><span style="font-variant:small-caps">Coq</span> version 8 is a major revision of the <span style="font-variant:small-caps">Coq</span> proof assistant.
First, the underlying logic is slightly different. The so-called <em>impredicativity</em> of the sort <span style="font-family:monospace">Set</span> has been dropped. The main
reason is that it is inconsistent with the principle of description
which is quite a useful principle for formalizing mathematics within classical logic. Moreover, even in an constructive
setting, the impredicativity of <span style="font-family:monospace">Set</span> does not add so much in
practice and is even subject of criticism from a large part of the
intuitionistic mathematician community. Nevertheless, the
impredicativity of <span style="font-family:monospace">Set</span> remains optional for users interested in
investigating mathematical developments which rely on it.</p><p>Secondly, the concrete syntax of terms has been completely
revised. The main motivations were</p><ul class="itemize"><li class="li-itemize">
a more uniform, purified style: all constructions are now lowercase, 
with a functional programming perfume (e.g. abstraction is now
written <span style="font-family:monospace">fun</span>), and more directly accessible to the novice
(e.g. dependent product is now written <span style="font-family:monospace">forall</span> and allows
omission of types). Also, parentheses and are no longer mandatory
for function application.
</li><li class="li-itemize">extensibility: some standard notations (e.g. “&lt;” and “&gt;”) were
incompatible with the previous syntax. Now all standard arithmetic
notations (=, +, *, /, &lt;, &lt;=, ... and more) are directly part of the
syntax.
</li></ul><p>Together with the revision of the concrete syntax, a new mechanism of
<em>interpretation scopes</em> permits to reuse the same symbols
(typically +, -, *, /, &lt;, &lt;=) in various mathematical theories without
any ambiguities for <span style="font-variant:small-caps">Coq</span>, leading to a largely improved readability of
<span style="font-variant:small-caps">Coq</span> scripts. New commands to easily add new symbols are also
provided.</p><p>Coming with the new syntax of terms, a slight reform of the tactic
language and of the language of commands has been carried out. The
purpose here is a better uniformity making the tactics and commands
easier to use and to remember.</p><p>Thirdly, a restructuration and uniformisation of the standard library
of <span style="font-variant:small-caps">Coq</span> has been performed. There is now just one Leibniz’ equality
usable for all the different kinds of <span style="font-variant:small-caps">Coq</span> objects. Also, the set of
real numbers now lies at the same level as the sets of natural and
integer numbers. Finally, the names of the standard properties of
numbers now follow a standard pattern and the symbolic
notations for the standard definitions as well.</p><p>The fourth point is the release of <span style="font-variant:small-caps">CoqIDE</span>, a new graphical
gtk2-based interface fully integrated to <span style="font-variant:small-caps">Coq</span>. Close in style from
the Proof General Emacs interface, it is faster and its integration
with <span style="font-variant:small-caps">Coq</span> makes interactive developments more friendly. All
mathematical Unicode symbols are usable within <span style="font-variant:small-caps">CoqIDE</span>.</p><p>Finally, the module system of <span style="font-variant:small-caps">Coq</span> completes the picture of <span style="font-variant:small-caps">Coq</span>
version 8.0. Though released with an experimental status in the previous
version 7.4, it should be considered as a salient feature of the new
version.</p><p>Besides, <span style="font-variant:small-caps">Coq</span> comes with its load of novelties and improvements: new
or improved tactics (including a new tactic for solving first-order
statements), new management commands, extended libraries.</p><p><br>
<br>
</p><p>Bruno Barras and Hugo Herbelin have been the main contributors of the 
reflexion and the implementation of the new syntax. The smart
automatic translator from old to new syntax released with <span style="font-variant:small-caps">Coq</span> is also
their work with contributions by Olivier Desmettre.</p><p>Hugo Herbelin is the main designer and implementor of the notion of
interpretation scopes and of the commands for easily adding new notations.</p><p>Hugo Herbelin is the main implementor of the restructuration of the
standard library.</p><p>Pierre Corbineau is the main designer and implementor of the new
tactic for solving first-order statements in presence of inductive
types. He is also the maintainer of the non-domain specific automation
tactics.</p><p>Benjamin Monate is the developer of the <span style="font-variant:small-caps">CoqIDE</span> graphical
interface with contributions by Jean-Christophe Filliâtre, Pierre
Letouzey, Claude Marché and Bruno Barras.</p><p>Claude Marché coordinated the edition of the Reference Manual for
<span style="font-variant:small-caps">Coq</span> V8.0.</p><p>Pierre Letouzey and Jacek Chrzaszcz respectively maintained the
extraction tool and module system of <span style="font-variant:small-caps">Coq</span>.</p><p>Jean-Christophe Filliâtre, Pierre Letouzey, Hugo Herbelin and
contributors from Sophia-Antipolis and Nijmegen participated to the
extension of the library.</p><p>Julien Narboux built a NSIS-based automatic <span style="font-variant:small-caps">Coq</span> installation tool for
the Windows platform.</p><p>Hugo Herbelin and Christine Paulin coordinated the development which
was under the responsability of Christine Paulin.</p><div class="flushright">
Palaiseau &amp; Orsay, Apr. 2004<br>
Hugo Herbelin &amp; Christine Paulin<br>
(updated Apr. 2006)
</div><h2 id="sec10" class="section">Credits: version 8.1</h2>
<p><span style="font-variant:small-caps">Coq</span> version 8.1 adds various new functionalities.</p><p>Benjamin Grégoire implemented an alternative algorithm to check the
convertibility of terms in the <span style="font-variant:small-caps">Coq</span> type-checker. This alternative
algorithm works by compilation to an efficient bytecode that is
interpreted in an abstract machine similar to Xavier Leroy’s ZINC
machine. Convertibility is performed by comparing the normal
forms. This alternative algorithm is specifically interesting for
proofs by reflection. More generally, it is convenient in case of
intensive computations.</p><p>Christine Paulin implemented an extension of inductive types allowing
recursively non uniform parameters. Hugo Herbelin implemented
sort-polymorphism for inductive types.</p><p>Claudio Sacerdoti Coen improved the tactics for rewriting on arbitrary
compatible equivalence relations. He also generalized rewriting to
arbitrary transition systems.</p><p>Claudio Sacerdoti Coen added new features to the module system. </p><p>Benjamin Grégoire, Assia Mahboubi and Bruno Barras developed a new
more efficient and more general simplification algorithm on rings and
semi-rings.</p><p>Laurent Théry and Bruno Barras developed a new significantly more efficient
simplification algorithm on fields.</p><p>Hugo Herbelin, Pierre Letouzey, Julien Forest, Julien Narboux and
Claudio Sacerdoti Coen added new tactic features.</p><p>Hugo Herbelin implemented matching on disjunctive patterns.</p><p>New mechanisms made easier the communication between <span style="font-variant:small-caps">Coq</span> and external
provers. Nicolas Ayache and Jean-Christophe Filliâtre implemented
connections with the provers <span style="font-variant:small-caps">cvcl</span>, <span style="font-variant:small-caps">Simplify</span> and <span style="font-variant:small-caps">zenon</span>. Hugo Herbelin implemented an experimental protocol for calling
external tools from the tactic language.</p><p>Matthieu Sozeau developed <span style="font-variant:small-caps">Russell</span>, an experimental language
to specify the behavior of programs with subtypes.</p><p>A mechanism to automatically use some specific tactic to solve
unresolved implicit has been implemented by Hugo Herbelin.</p><p>Laurent Théry’s contribution on strings and Pierre Letouzey and
Jean-Christophe Filliâtre’s contribution on finite maps have been
integrated to the <span style="font-variant:small-caps">Coq</span> standard library. Pierre Letouzey developed a
library about finite sets “à la Objective Caml”. With Jean-Marc
Notin, he extended the library on lists. Pierre Letouzey’s
contribution on rational numbers has been integrated and extended..</p><p>Pierre Corbineau extended his tactic for solving first-order
statements. He wrote a reflection-based intuitionistic tautology
solver.</p><p>Pierre Courtieu, Julien Forest and Yves Bertot added extra support to
reason on the inductive structure of recursively defined functions.</p><p>Jean-Marc Notin significantly contributed to the general maintenance
of the system. He also took care of <span style="font-family:sans-serif">coqdoc</span>.</p><p>Pierre Castéran contributed to the documentation of (co-)inductive
types and suggested improvements to the libraries.</p><p>Pierre Corbineau implemented a declarative mathematical proof
language, usable in combination with the tactic-based style of proof.</p><p>Finally, many users suggested improvements of the system through the
Coq-Club mailing list and bug-tracker systems, especially user groups
from INRIA Rocquencourt, Radbout University, University of
Pennsylvania and Yale University.</p><div class="flushright">
Palaiseau, July 2006<br>
Hugo Herbelin
</div><h2 id="sec11" class="section">Credits: version 8.2</h2>
<p><span style="font-variant:small-caps">Coq</span> version 8.2 adds new features, new libraries and 
improves on many various aspects.</p><p>Regarding the language of Coq, the main novelty is the introduction by
Matthieu Sozeau of a package of commands providing Haskell-style
type classes. Type classes, that come with a few convenient features
such as type-based resolution of implicit arguments, plays a new role
of landmark in the architecture of Coq with respect to automatization.
For instance, thanks to type classes support, Matthieu Sozeau could
implement a new resolution-based version of the tactics dedicated to
rewriting on arbitrary transitive relations.</p><p>Another major improvement of Coq 8.2 is the evolution of the
arithmetic libraries and of the tools associated to them. Benjamin
Grégoire and Laurent Théry contributed a modular library for building
arbitrarily large integers from bounded integers while Evgeny Makarov
contributed a modular library of abstract natural and integer
arithmetics together with a few convenient tactics. On his side,
Pierre Letouzey made numerous extensions to the arithmetic libraries on
ℤ and ℚ, including extra support for
automatization in presence of various number-theory concepts.</p><p>Frédéric Besson contributed a reflexive tactic based on
Krivine-Stengle Positivstellensatz (the easy way) for validating
provability of systems of inequalities. The platform is flexible enough
to support the validation of any algorithm able to produce a
“certificate” for the Positivstellensatz and this covers the case of
Fourier-Motzkin (for linear systems in ℚ and ℝ),
Fourier-Motzkin with cutting planes (for linear systems in
ℤ) and sum-of-squares (for non-linear systems). Evgeny
Makarov made the platform generic over arbitrary ordered rings.</p><p>Arnaud Spiwack developed a library of 31-bits machine integers and,
relying on Benjamin Grégoire and Laurent Théry’s library, delivered a
library of unbounded integers in base 2<sup>31</sup>. As importantly, he
developed a notion of “retro-knowledge” so as to safely extend the
kernel-located bytecode-based efficient evaluation algorithm of Coq
version 8.1 to use 31-bits machine arithmetics for efficiently
computing with the library of integers he developed.</p><p>Beside the libraries, various improvements contributed to provide a
more comfortable end-user language and more expressive tactic
language. Hugo Herbelin and Matthieu Sozeau improved the
pattern-matching compilation algorithm (detection of impossible
clauses in pattern-matching, automatic inference of the return
type). Hugo Herbelin, Pierre Letouzey and Matthieu Sozeau contributed
various new convenient syntactic constructs and new tactics or tactic
features: more inference of redundant information, better unification,
better support for proof or definition by fixpoint, more expressive
rewriting tactics, better support for meta-variables, more convenient
notations, ...</p><p>Élie Soubiran improved the module system, adding new features (such as
an “include” command) and making it more flexible and more
general. He and Pierre Letouzey improved the support for modules in
the extraction mechanism.</p><p>Matthieu Sozeau extended the <span style="font-variant:small-caps">Russell</span> language, ending in an
convenient way to write programs of given specifications, Pierre
Corbineau extended the Mathematical Proof Language and the
automatization tools that accompany it, Pierre Letouzey supervised and
extended various parts the standard library, Stéphane Glondu
contributed a few tactics and improvements, Jean-Marc Notin provided
help in debugging, general maintenance and <span style="font-family:monospace">coqdoc</span> support,
Vincent Siles contributed extensions of the <span style="font-family:monospace">Scheme</span> command and
of <span style="font-family:monospace">injection</span>.</p><p>Bruno Barras implemented the <span style="font-family:monospace">coqchk</span> tool: this is a stand-alone
type-checker that can be used to certify <span style="font-family:monospace">.vo</span> files. Especially,
as this verifier runs in a separate process, it is granted not to be
“hijacked” by virtually malicious extensions added to <span style="font-variant:small-caps">Coq</span>.</p><p>Yves Bertot, Jean-Christophe Filliâtre, Pierre Courtieu and
Julien Forest acted as maintainers of features they implemented in
previous versions of Coq.</p><p>Julien Narboux contributed to <span style="font-variant:small-caps">CoqIDE</span>.
Nicolas Tabareau made the adaptation of the interface of the old
“setoid rewrite” tactic to the new version. Lionel Mamane worked on
the interaction between Coq and its external interfaces. With Samuel
Mimram, he also helped making Coq compatible with recent software
tools. Russell O’Connor, Cezary Kaliscyk, Milad Niqui contributed to
improved the libraries of integers, rational, and real numbers. We
also thank many users and partners for suggestions and feedback, in
particular Pierre Castéran and Arthur Charguéraud, the INRIA Marelle
team, Georges Gonthier and the INRIA-Microsoft Mathematical Components team, 
the Foundations group at Radbout university in Nijmegen, reporters of bugs
and participants to the Coq-Club mailing list.</p><div class="flushright">
Palaiseau, June 2008<br>
Hugo Herbelin<br>
</div><h2 id="sec12" class="section">Credits: version 8.3</h2>
<p><span style="font-variant:small-caps">Coq</span> version 8.3 is before all a transition version with refinements
or extensions of the existing features and libraries and a new tactic
<span style="font-family:monospace">nsatz</span> based on Hilbert’s Nullstellensatz for deciding systems of
equations over rings.</p><p>With respect to libraries, the main evolutions are due to Pierre
Letouzey with a rewriting of the library of finite sets <span style="font-family:monospace">FSets</span>
and a new round of evolutions in the modular development of arithmetic
(library <span style="font-family:monospace">Numbers</span>). The reason for making <span style="font-family:monospace">FSets</span> evolve is
that the computational and logical contents were quite intertwined in
the original implementation, leading in some cases to longer
computations than expected and this problem is solved in the new <span style="font-family:monospace">MSets</span> implementation. As for the modular arithmetic library, it was
only dealing with the basic arithmetic operators in the former version
and its current extension adds the standard theory of the division,
min and max functions, all made available for free to any
implementation of ℕ, ℤ or
ℤ/<span style="font-style:italic">n</span>ℤ. </p><p>The main other evolutions of the library are due to Hugo Herbelin who
made a revision of the sorting library (includingh a certified
merge-sort) and to Guillaume Melquiond who slightly revised and
cleaned up the library of reals.</p><p>The module system evolved significantly. Besides the resolution of
some efficiency issues and a more flexible construction of module
types, Élie Soubiran brought a new model of name equivalence, the
Δ-equivalence, which respects as much as possible the names
given by the users. He also designed with Pierre Letouzey a new
convenient operator <code>&lt;+</code> for nesting functor application, what
provides a light notation for inheriting the properties of cascading
modules.</p><p>The new tactic <span style="font-family:monospace">nsatz</span> is due to Loïc Pottier. It works by
computing Gröbner bases. Regarding the existing tactics, various
improvements have been done by Matthieu Sozeau, Hugo Herbelin and
Pierre Letouzey.</p><p>Matthieu Sozeau extended and refined the type classes and <span style="font-family:monospace">Program</span> features (the <span style="font-variant:small-caps">Russell</span> language). Pierre Letouzey
maintained and improved the extraction mechanism. Bruno Barras and
Élie Soubiran maintained the Coq checker, Julien Forest maintained
the <span style="font-family:monospace">Function</span> mechanism for reasoning over recursively defined
functions. Matthieu Sozeau, Hugo Herbelin and Jean-Marc Notin
maintained <span style="font-family:monospace">coqdoc</span>. Frédéric Besson maintained the <span style="font-variant:small-caps">Micromega</span> plateform for deciding systems of inequalities. Pierre
Courtieu maintained the support for the Proof General Emacs
interface. Claude Marché maintained the plugin for calling external
provers (<span style="font-family:monospace">dp</span>). Yves Bertot made some improvements to the
libraries of lists and integers. Matthias Puech improved the search
functions. Guillaume Melquiond usefully contributed here and
there. Yann Régis-Gianas grounded the support for Unicode on a more
standard and more robust basis.</p><p>Though invisible from outside, Arnaud Spiwack improved the general
process of management of existential variables. Pierre Letouzey and
Stéphane Glondu improved the compilation scheme of the Coq archive.
Vincent Gross provided support to <span style="font-variant:small-caps">CoqIDE</span>. Jean-Marc Notin provided
support for benchmarking and archiving.</p><p>Many users helped by reporting problems, providing patches, suggesting
improvements or making useful comments, either on the bug tracker or
on the Coq-club mailing list. This includes but not exhaustively
Cédric Auger, Arthur Charguéraud, François Garillot, Georges Gonthier,
Robin Green, Stéphane Lescuyer, Eelis van der Weegen, ...</p><p>Though not directly related to the implementation, special thanks are
going to Yves Bertot, Pierre Castéran, Adam Chlipala, and Benjamin
Pierce for the excellent teaching materials they provided.</p><div class="flushright">
Paris, April 2010<br>
Hugo Herbelin<br>
</div><h2 id="sec13" class="section">Credits: version 8.4</h2>
<p><span style="font-variant:small-caps">Coq</span> version 8.4 contains the result of three long-term projects: a
new modular library of arithmetic by Pierre Letouzey, a new proof
engine by Arnaud Spiwack and a new communication protocol for <span style="font-variant:small-caps">CoqIDE</span>
by Vincent Gross.</p><p>The new modular library of arithmetic extends, generalizes and
unifies the existing libraries on Peano arithmetic (types <span style="font-family:monospace">nat</span>,
<span style="font-family:monospace">N</span> and <span style="font-family:monospace">BigN</span>), positive arithmetic (type <span style="font-family:monospace">positive</span>),
integer arithmetic (<span style="font-family:monospace">Z</span> and <span style="font-family:monospace">BigZ</span>) and machine word
arithmetic (type <span style="font-family:monospace">Int31</span>). It provides with unified notations
(e.g. systematic use of <span style="font-family:monospace">add</span> and <span style="font-family:monospace">mul</span> for denoting the
addition and multiplication operators), systematic and generic
development of operators and properties of these operators for all the
types mentioned above, including gcd, pcm, power, square root, base 2
logarithm, division, modulo, bitwise operations, logical shifts,
comparisons, iterators, ...</p><p>The most visible feature of the new proof engine is the support for
structured scripts (bullets and proof brackets) but, even if yet not
user-available, the new engine also provides the basis for refining
existential variables using tactics, for applying tactics to several
goals simultaneously, for reordering goals, all features which are
planned for the next release. The new proof engine forced to
reimplement <span style="font-family:monospace">info</span> and <span style="font-family:monospace">Show Script</span> differently, what was
done by Pierre Letouzey.</p><p>Before version 8.4, <span style="font-variant:small-caps">CoqIDE</span> was linked to <span style="font-variant:small-caps">Coq</span> with the graphical
interface living in a separate thread. From version 8.4, <span style="font-variant:small-caps">CoqIDE</span> is a
separate process communicating with <span style="font-variant:small-caps">Coq</span> through a textual
channel. This allows for a more robust interfacing, the ability to
interrupt <span style="font-variant:small-caps">Coq</span> without interrupting the interface, and the ability to
manage several sessions in parallel. Relying on the infrastructure
work made by Vincent Gross, Pierre Letouzey, Pierre Boutillier and
Pierre-Marie Pédrot contributed many various refinements of <span style="font-variant:small-caps">CoqIDE</span>.</p><p><span style="font-variant:small-caps">Coq</span> 8.4 also comes with a bunch of many various smaller-scale changes
and improvements regarding the different components of the system.</p><p>The underlying logic has been extended with η-conversion thanks
to Hugo Herbelin, Stéphane Glondu and Benjamin Grégoire. The
addition of η-conversion is justified by the confidence that the
formulation of the Calculus of Inductive Constructions based on typed
equality (such as the one considered in Lee and Werner to build a
set-theoretic model of CIC [<a href="biblio.html#LeeWerner11">91</a>]) is applicable to the
concrete implementation of <span style="font-variant:small-caps">Coq</span>.</p><p>The underlying logic benefited also from a refinement of the guard
condition for fixpoints by Pierre Boutillier, the point being that it
is safe to propagate the information about structurally smaller
arguments through β-redexes that are blocked by the
“match” construction (blocked commutative cuts).</p><p>Relying on the added permissiveness of the guard condition, Hugo
Herbelin could extend the pattern-matching compilation algorithm
so that matching over a sequence of terms involving
dependencies of a term or of the indices of the type of a term in the
type of other terms is systematically supported.</p><p>Regarding the high-level specification language, Pierre Boutillier
introduced the ability to give implicit arguments to anonymous
functions, Hugo Herbelin introduced the ability to define notations
with several binders (e.g. <code>exists x y z, P</code>), Matthieu Sozeau
made the type classes inference mechanism more robust and predictable,
Enrico Tassi introduced a command <span style="font-family:monospace">Arguments</span> that generalizes
<span style="font-family:monospace">Implicit Arguments</span> and <span style="font-family:monospace">Arguments Scope</span> for assigning
various properties to arguments of constants. Various improvements in
the type inference algorithm were provided by Matthieu Sozeau and Hugo
Herbelin with contributions from Enrico Tassi.</p><p>Regarding tactics, Hugo Herbelin introduced support for referring to
expressions occurring in the goal by pattern in tactics such as <span style="font-family:monospace">set</span> or <span style="font-family:monospace">destruct</span>. Hugo Herbelin also relied on ideas from
Chung-Kil Hur’s <span style="font-family:monospace">Heq</span> plugin to introduce automatic computation of
occurrences to generalize when using <span style="font-family:monospace">destruct</span> and <span style="font-family:monospace">induction</span> on types with indices. Stéphane Glondu introduced new
tactics <span style="font-family:monospace">constr_eq</span>, <span style="font-family:monospace">is_evar</span> and <span style="font-family:monospace">has_evar</span> to be
used when writing complex tactics. Enrico Tassi added support to
fine-tuning the behavior of <span style="font-family:monospace">simpl</span>. Enrico Tassi added the
ability to specify over which variables of a section a lemma has
to be exactly generalized. Pierre Letouzey added a tactic <span style="font-family:monospace">timeout</span> and the interruptibility of <span style="font-family:monospace">vm_compute</span>. Bug fixes
and miscellaneous improvements of the tactic language came from Hugo
Herbelin, Pierre Letouzey and Matthieu Sozeau.</p><p>Regarding decision tactics, Loïc Pottier maintained <span style="font-family:monospace">Nsatz</span>,
moving in particular to a type-class based reification of goals while
Frédéric Besson maintained <span style="font-family:monospace">Micromega</span>, adding in particular
support for division.</p><p>Regarding vernacular commands, Stéphane Glondu provided new commands
to analyze the structure of type universes.</p><p>Regarding libraries, a new library about lists of a given length
(called vectors) has been provided by Pierre Boutillier. A new
instance of finite sets based on Red-Black trees and provided by
Andrew Appel has been adapted for the standard library by Pierre
Letouzey. In the library of real analysis, Yves Bertot changed the
definition of π and provided a proof of the long-standing fact yet
remaining unproved in this library, namely that <span style="font-style:italic">sin</span> π/2 =
1.</p><p>Pierre Corbineau maintained the Mathematical Proof Language (C-zar).</p><p>Bruno Barras and Benjamin Grégoire maintained the call-by-value
reduction machines.</p><p>The extraction mechanism benefited from several improvements provided by
Pierre Letouzey.</p><p>Pierre Letouzey maintained the module system, with contributions from
Élie Soubiran.</p><p>Julien Forest maintained the <span style="font-family:monospace">Function</span> command.</p><p>Matthieu Sozeau maintained the setoid rewriting mechanism.</p><p><span style="font-variant:small-caps">Coq</span> related tools have been upgraded too. In particular, <span style="font-family:monospace">coq_makefile</span> has been largely revised by Pierre Boutillier. Also,
patches from Adam Chlipala for <span style="font-family:monospace">coqdoc</span> have been integrated by
Pierre Boutillier.</p><p>Bruno Barras and Pierre Letouzey maintained the <span style="font-family:monospace">coqchk</span> checker.</p><p>Pierre Courtieu and Arnaud Spiwack contributed new features for using
<span style="font-variant:small-caps">Coq</span> through Proof General.</p><p>The <span style="font-family:monospace">Dp</span> plugin has been removed. Use the plugin provided with
<span style="font-family:monospace">Why 3</span> instead (<a href="http://why3.lri.fr"><span style="font-family:monospace">http://why3.lri.fr</span></a>).</p><p>Under the hood, the <span style="font-variant:small-caps">Coq</span> architecture benefited from improvements in
terms of efficiency and robustness, especially regarding universes
management and existential variables management, thanks to Pierre
Letouzey and Yann Régis-Gianas with contributions from Stéphane
Glondu and Matthias Puech. The build system is maintained by Pierre
Letouzey with contributions from Stéphane Glondu and Pierre
Boutillier.</p><p>A new backtracking mechanism simplifying the task of external
interfaces has been designed by Pierre Letouzey.</p><p>The general maintenance was done by Pierre Letouzey, Hugo Herbelin,
Pierre Boutillier, Matthieu Sozeau and Stéphane Glondu with also
specific contributions from Guillaume Melquiond, Julien Narboux and
Pierre-Marie Pédrot.</p><p>Packaging tools were provided by Pierre Letouzey (Windows), Pierre
Boutillier (MacOS), Stéphane Glondu (Debian). Releasing, testing and
benchmarking support was provided by Jean-Marc Notin.</p><p>Many suggestions for improvements were motivated by feedback from
users, on either the bug tracker or the coq-club mailing list. Special
thanks are going to the users who contributed patches, starting with
Tom Prince. Other patch contributors include Cédric Auger, David
Baelde, Dan Grayson, Paolo Herms, Robbert Krebbers, Marc Lasson,
Hendrik Tews and Eelis van der Weegen.</p><div class="flushright">
Paris, December 2011<br>
Hugo Herbelin<br>
</div>

<div id="sidebarWrapper">
  <div id="sidebar">
    <div class="block">
      <h2 class="title">Navigation</h2>
      <div class="content">
        <ul class="menu">
          <li class="leaf"><a href="index.html">Cover</a></li>
          <li class="leaf"><a href="toc.html">Table of contents</a></li>
          <li class="leaf">Index
            <ul class="menu">
              <li><a href="general-index.html">General</a></li>
              <li><a href="command-index.html">Commands</a></li>
              <li><a href="tactic-index.html">Tactics</a></li>
              <li><a href="error-index.html">Errors</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</body>
</html>
