<!DOCTYPE html>
<html>
<head>


<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/coqdoc.css" /><title>Chapter 4  Calculus of Inductive Constructions</title>
</head>
<body >

<div id="container">

<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="/" class="active">Home</a></li>
    <li><a href="/about-coq" title="More about coq">About Coq</a></li>
    <li><a href="/download">Get Coq</a></li>
    <li><a href="/documentation">Documentation</a></li>
    <li><a href="/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">
<div id="logoWrapper">
  <div id="logo"><a href="/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
  </div>
  <div id="siteName"><a href="/" title="Home">The Coq Proof Assistant</a>
  </div>
</div>
</div>

<div id="content">

<h1 id="sec158" class="chapter">Chapter 4  Calculus of Inductive Constructions

<a id="hevea_default319"></a>
<a id="hevea_default320"></a>
<a id="hevea_default321"></a></h1>
<ul>
<li><a href="Reference-Manual006.html#sec159">4.1  The terms</a>
</li><li><a href="Reference-Manual006.html#sec167">4.2  Typed terms</a>
</li><li><a href="Reference-Manual006.html#sec171">4.3  Conversion rules</a>
</li><li><a href="Reference-Manual006.html#sec179">4.4  Derived rules for environments</a>
</li><li><a href="Reference-Manual006.html#sec186">4.5  Inductive Definitions</a>
</li><li><a href="Reference-Manual006.html#sec219">4.6  Co-inductive types</a>
</li><li><a href="Reference-Manual006.html#sec220">4.7  <span style="font-variant:small-caps">Cic</span>: the Calculus of Inductive Construction with
impredicative <span style="font-family:sans-serif">Set</span></a>
</li></ul>
<p>The underlying formal language of <span style="font-variant:small-caps">Coq</span> is a <em>Calculus of
Constructions</em> with <em>Inductive Definitions</em>. It is presented in
this chapter. 
For <span style="font-variant:small-caps">Coq</span> version V7, this Calculus was known as the
<em>Calculus of (Co)Inductive Constructions</em><a id="hevea_default322"></a> (<span style="font-variant:small-caps">Cic</span> in short).
The underlying calculus of <span style="font-variant:small-caps">Coq</span> version V8.0 and up is a weaker
calculus where the sort <span style="font-family:sans-serif">Set</span> satisfies predicative rules. 
We call this calculus the 
<em>Predicative Calculus of (Co)Inductive
Constructions</em><a id="hevea_default323"></a> (p<span style="font-variant:small-caps">Cic</span> in short).
In Section <a href="#sec220">4.7</a> we give the extra-rules for <span style="font-variant:small-caps">Cic</span>. A
compiling option of <span style="font-variant:small-caps">Coq</span> allows to type-check theories in this
extended system.</p><p>In p<span style="font-variant:small-caps">Cic</span>  all objects have a <em>type</em>. There are types for functions (or
programs), there are atomic types (especially datatypes)... but also
types for proofs and types for the types themselves.
Especially, any object handled in the formalism must belong to a
type. For instance, the statement <span style="font-style:italic">“for all x, P”</span> is not
allowed in type theory; you must say instead: <span style="font-style:italic">“for all x
belonging to T, P”</span>. The expression <span style="font-style:italic">“x belonging to T”</span> is
written <span style="font-style:italic">“x:T”</span>. One also says: <span style="font-style:italic">“x has type T”</span>.
The terms of p<span style="font-variant:small-caps">Cic</span> are detailed in Section <a href="#sec159">4.1</a>.</p><p>In p<span style="font-variant:small-caps">Cic</span>  there is an internal reduction mechanism. In particular, it
allows to decide if two programs are <em>intentionally</em> equal (one
says <em>convertible</em>). Convertibility is presented in section 
<a href="#sec177">4.3</a>.</p><p>The remaining sections are concerned with the type-checking of terms.
The beginner can skip them.</p><p>The reader seeking a background on the Calculus of Inductive
Constructions may read several papers. Giménez and Castéran [<a href="biblio.html#GimCas05">68</a>]
provide
an introduction to inductive and co-inductive definitions in Coq. In
their book [<a href="biblio.html#CoqArt">14</a>], Bertot and Castéran give a precise
description of the p<span style="font-variant:small-caps">Cic</span> based on numerous practical examples.
Barras [<a href="biblio.html#Bar99">9</a>], Werner [<a href="biblio.html#Wer94">137</a>] and
Paulin-Mohring [<a href="biblio.html#Moh97">119</a>] are the most recent theses dealing with
Inductive Definitions. Coquand-Huet [<a href="biblio.html#CoHu85a">29</a>, <a href="biblio.html#CoHu85b">30</a>, <a href="biblio.html#CoHu86">31</a>]
introduces the Calculus of Constructions. Coquand-Paulin [<a href="biblio.html#CoPa89">32</a>]
extended this calculus to inductive definitions. The p<span style="font-variant:small-caps">Cic</span> is a
formulation of type theory including the possibility of inductive
constructions, Barendregt [<a href="biblio.html#Bar91">6</a>] studies the modern form of type
theory.</p><h2 id="sec159" class="section">4.1  The terms</h2>
<p>In most type theories, one usually makes a syntactic distinction
between types and terms. This is not the case for p<span style="font-variant:small-caps">Cic</span> which defines
both types and terms in the same syntactical structure. This is
because the type-theory itself forces terms and types to be defined in
a mutual recursive way and also because similar constructions can be
applied to both terms and types and consequently can share the same
syntactic structure.</p><p>Consider for instance the → constructor and assume <span style="font-family:sans-serif">nat</span> is the
type of natural numbers. Then → is used both to denote
<span style="font-family:sans-serif">nat</span>→<span style="font-family:sans-serif">nat</span> which is the type of functions from <span style="font-family:sans-serif">nat</span> to <span style="font-family:sans-serif">nat</span>, and
to denote <span style="font-family:sans-serif">nat</span> → <span style="font-family:sans-serif">Prop</span> which is the type of unary predicates over
the natural numbers. Consider abstraction which builds functions. It
serves to build “ordinary” functions as <span style="font-family:sans-serif">fun</span> <span style="font-style:italic">x</span>:<span style="font-family:sans-serif">nat</span> ⇒ (<span style="font-family:monospace"><span style="font-style:italic">mult</span></span>  <span style="font-style:italic">x</span> <span style="font-style:italic">x</span>) (assuming <span style="font-family:monospace">mult</span> is already defined) but may build also 
predicates over the natural numbers. For instance <span style="font-family:sans-serif">fun</span> <span style="font-style:italic">x</span>:<span style="font-family:sans-serif">nat</span> ⇒
(<span style="font-style:italic">x</span>=<span style="font-style:italic">x</span>) will
represent a predicate <span style="font-style:italic">P</span>, informally written in mathematics
<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)≡ <span style="font-style:italic">x</span>=<span style="font-style:italic">x</span>. If <span style="font-style:italic">P</span> has type <span style="font-family:sans-serif">nat</span> → <span style="font-family:sans-serif">Prop</span>, (<span style="font-style:italic">P</span> <span style="font-style:italic">x</span>) is a
proposition, furthermore <span style="font-family:sans-serif">forall</span> <span style="font-style:italic">x</span>:<span style="font-family:sans-serif">nat</span>,(<span style="font-style:italic">P</span> <span style="font-style:italic">x</span>) will represent the type of
functions which associate to each natural number <span style="font-style:italic">n</span> an object of
type (<span style="font-style:italic">P</span> <span style="font-style:italic">n</span>) and consequently represent proofs of the formula
“∀ <span style="font-style:italic">x</span>.<span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>)”.</p><h3 id="sec160" class="subsection">4.1.1  Sorts
<a id="hevea_default324"></a></h3>
<p>
When manipulated as terms, types have themselves a type which is called a sort.</p><p>There is an infinite well-founded typing hierarchy of sorts whose base
sorts are <span style="font-family:sans-serif">Prop</span> and <span style="font-family:sans-serif">Set</span>.</p><p>The sort <span style="font-family:sans-serif">Prop</span> intends to be the type of logical propositions. If
<span style="font-style:italic">M</span> is a logical proposition then it denotes the class of terms
representing proofs of <span style="font-style:italic">M</span>. An object <span style="font-style:italic">m</span> belonging to <span style="font-style:italic">M</span> witnesses
the fact that <span style="font-style:italic">M</span> is provable. An object of type <span style="font-family:sans-serif">Prop</span> is called a
proposition.</p><p>The sort <span style="font-family:sans-serif">Set</span> intends to be the type of small sets. This includes data
types such as booleans and naturals, but also products, subsets, and
function types over these data types.</p><p><span style="font-family:sans-serif">Prop</span> and <span style="font-family:sans-serif">Set</span> themselves can be manipulated as ordinary
terms. Consequently they also have a type. Because assuming simply
that <span style="font-family:sans-serif">Set</span> has type <span style="font-family:sans-serif">Set</span> leads to an inconsistent theory, the
language of p<span style="font-variant:small-caps">Cic</span> has infinitely many sorts. There are, in addition
to <span style="font-family:sans-serif">Set</span> and <span style="font-family:sans-serif">Prop</span> a hierarchy of universes <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>) for any
integer <span style="font-style:italic">i</span>.</p><p>Like <span style="font-family:sans-serif">Set</span>, all of the sorts <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>) contain small sets such as
booleans, natural numbers, as well as products, subsets and function
types over small sets. But, unlike <span style="font-family:sans-serif">Set</span>, they also contain large
sets, namely the sorts <span style="font-family:sans-serif">Set</span> and <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">j</span>) for <span style="font-style:italic">j</span>&lt;<span style="font-style:italic">i</span>, and all
products, subsets and function types over these sorts.</p><p>Formally, we call <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">S</span></span> the set of sorts which is defined by:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">S</span></span> ≡ {<span style="font-family:sans-serif">Prop</span>,<span style="font-family:sans-serif">Set</span>,<span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>)| <span style="font-style:italic">i</span> ∈ ℕ} </td></tr>
</table><p>
<a id="hevea_default325"></a>
<a id="hevea_default326"></a>
<a id="hevea_default327"></a></p><p>The sorts enjoy the following properties<sup><a id="text11" href="#note11">1</a></sup>: <span style="font-family:sans-serif">Prop</span>:<span style="font-family:sans-serif">Type</span>(1), <span style="font-family:sans-serif">Set</span>:<span style="font-family:sans-serif">Type</span>(1) and
<span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>):<span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>+1).</p><p>The user will never mention explicitly the index <span style="font-style:italic">i</span> when referring to
the universe <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>). One only writes <span style="font-family:sans-serif">Type</span>. The
system itself generates for each instance of <span style="font-family:sans-serif">Type</span> a new
index for the universe and checks that the constraints between these
indexes can be solved. From the user point of view we consequently
have <span style="font-family:sans-serif">Type :Type</span>.</p><p>We shall make precise in the typing rules the constraints between the
indexes. </p>
<h5 id="sec161" class="paragraph">Implementation issues</h5>
<p>
In practice, the <span style="font-family:sans-serif">Type</span> hierarchy is implemented using algebraic
universes. An algebraic universe <span style="font-style:italic">u</span> is either a variable (a qualified
identifier with a number) or a successor of an algebraic universe (an
expression <span style="font-style:italic">u</span>+1), or an upper bound of algebraic universes (an
expression <span style="font-style:italic">max</span>(<span style="font-style:italic">u</span><sub>1</sub>,...,<span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>)), or the base universe (the expression
0) which corresponds, in the arity of sort-polymorphic inductive
types, to the predicative sort <span style="font-family:sans-serif">Set</span>. A graph of constraints between
the universe variables is maintained globally. To ensure the existence
of a mapping of the universes to the positive integers, the graph of
constraints must remain acyclic. Typing expressions that violate the
acyclicity of the graph of constraints results in a <span style="font-family:monospace">Universe
inconsistency</span><a id="hevea_error26"></a> error (see also Section <a href="Reference-Manual004.html#sec131">2.10</a>).</p>
<h3 id="sec162" class="subsection">4.1.2  Constants</h3>
<p>
Besides the sorts, the language also contains constants denoting
objects in the environment. These constants may denote previously
defined objects but also objects related to inductive definitions
(either the type itself or one of its constructors or destructors).</p><p><br>
<span style="font-weight:bold">Remark. </span> In other presentations of p<span style="font-variant:small-caps">Cic</span>, 
the inductive objects are not seen as
external declarations but as first-class terms. Usually the
definitions are also completely ignored. This is a nice theoretical
point of view but not so practical. An inductive definition is
specified by a possibly huge set of declarations, clearly we want to
share this specification among the various inductive objects and not
to duplicate it. So the specification should exist somewhere and the
various objects should refer to it. We choose one more level of
indirection where the objects are just represented as constants and
the environment gives the information on the kind of object the
constant refers to.</p><p><br>
Our inductive objects will be manipulated as constants declared in the
environment. This roughly corresponds to the way they are actually
implemented in the <span style="font-variant:small-caps">Coq</span> system. It is simple to map this presentation
in a theory where inductive objects are represented by terms.</p>
<h3 id="sec163" class="subsection">4.1.3  Terms</h3>
<p>Terms are built from variables, global names, constructors,
abstraction, application, local declarations bindings (“let-in”
expressions) and product.</p><p>From a syntactic point of view, types cannot be distinguished from terms,
except that they cannot start by an abstraction, and that if a term is
a sort or a product, it should be a type.</p><p>More precisely the language of the <em>Calculus of Inductive
Constructions</em> is built from the following rules:</p><ol class="enumerate" type=1><li class="li-enumerate">
the sorts <span style="font-family:sans-serif">Set, Prop, Type</span> are terms.
</li><li class="li-enumerate">names for global constants of the environment are terms.
</li><li class="li-enumerate">variables are terms.
</li><li class="li-enumerate">if <span style="font-style:italic">x</span> is a variable and <span style="font-style:italic">T</span>, <span style="font-style:italic">U</span> are terms then ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span>
(<span style="font-family:sans-serif">forall</span> <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span> in <span style="font-variant:small-caps">Coq</span> concrete syntax) is a term. If <span style="font-style:italic">x</span>
occurs in <span style="font-style:italic">U</span>, ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span> reads as <span style="font-style:italic">“for all x of type T,
U”</span>. As <span style="font-style:italic">U</span> depends on <span style="font-style:italic">x</span>, one says that ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span> is a
<em>dependent product</em>. If <span style="font-style:italic">x</span> doesn’t occurs in <span style="font-style:italic">U</span> then
∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span> reads as <span style="font-style:italic">“if T then U”</span>. A non dependent
product can be written: <span style="font-style:italic">T</span> → <span style="font-style:italic">U</span>.
</li><li class="li-enumerate">if <span style="font-style:italic">x</span> is a variable and <span style="font-style:italic">T</span>, <span style="font-style:italic">U</span> are terms then λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span> .  <span style="font-style:italic">U</span>
(<span style="font-family:sans-serif">fun</span> <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>⇒ <span style="font-style:italic">U</span> in <span style="font-variant:small-caps">Coq</span> concrete syntax) is a term. This is a
notation for the λ-abstraction of
λ-calculus<a id="hevea_default328"></a>
[<a href="biblio.html#Bar81">8</a>]. The term λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span> .  <span style="font-style:italic">U</span> is a function which maps
elements of <span style="font-style:italic">T</span> to <span style="font-style:italic">U</span>.
</li><li class="li-enumerate">if <span style="font-style:italic">T</span> and <span style="font-style:italic">U</span> are terms then (<span style="font-style:italic">T</span> <span style="font-style:italic">U</span>) is a term 
(<span style="font-style:italic">T</span> <span style="font-style:italic">U</span> in <span style="font-variant:small-caps">Coq</span> concrete syntax). The term (<span style="font-style:italic">T</span> 
<span style="font-style:italic">U</span>) reads as <span style="font-style:italic">“T applied to U”</span>.
</li><li class="li-enumerate">if <span style="font-style:italic">x</span> is a variable, and <span style="font-style:italic">T</span>, <span style="font-style:italic">U</span> are terms then
<span style="font-family:sans-serif">let</span> <span style="font-style:italic">x</span>:=<span style="font-style:italic">T</span> <span style="font-family:sans-serif">in</span> <span style="font-style:italic">U</span> is a
term which denotes the term <span style="font-style:italic">U</span> where the variable <span style="font-style:italic">x</span> is locally
bound to <span style="font-style:italic">T</span>. This stands for the common “let-in” construction of
functional programs such as ML or Scheme.
</li></ol>
<h5 id="sec164" class="paragraph">Notations.</h5>
<p> Application associates to the left such that
(<span style="font-style:italic">t</span> <span style="font-style:italic">t</span><sub>1</sub>… <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>) represents (… (<span style="font-style:italic">t</span> <span style="font-style:italic">t</span><sub>1</sub>)… <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>). The
products and arrows associate to the right such that ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>→ <span style="font-style:italic">C</span>→
<span style="font-style:italic">D</span> represents ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>,(<span style="font-style:italic">B</span>→ (<span style="font-style:italic">C</span>→ <span style="font-style:italic">D</span>)). One uses sometimes
∀ <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>:<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span> or
λ <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>:<span style="font-style:italic">A</span>.  <span style="font-style:italic">B</span> to denote the abstraction or product of several variables
of the same type. The equivalent formulation is ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>, ∀ <span style="font-style:italic">y</span>:<span style="font-style:italic">A</span>,<span style="font-style:italic">B</span> or
λ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span> .  λ <span style="font-style:italic">y</span>:<span style="font-style:italic">A</span> .  <span style="font-style:italic">B</span></p>
<h5 id="sec165" class="paragraph">Free variables.</h5>
<p>
The notion of free variables is defined as usual. In the expressions
λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">U</span> and ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>, <span style="font-style:italic">U</span> the occurrences of <span style="font-style:italic">x</span> in <span style="font-style:italic">U</span>
are bound. They are represented by de Bruijn indexes in the internal
structure of terms.</p><h5 id="sec166" class="paragraph">Substitution.<a id="hevea_default329"></a></h5>
<p>
The notion of substituting a term <span style="font-style:italic">t</span> to free occurrences of a
variable <span style="font-style:italic">x</span> in a term <span style="font-style:italic">u</span> is defined as usual. The resulting term
is written <span style="font-style:italic">u</span>{<span style="font-style:italic">x</span>/<span style="font-style:italic">t</span>}.</p><h2 id="sec167" class="section">4.2  Typed terms</h2>
<p>As objects of type theory, terms are subjected to <em>type
discipline</em>. The well typing of a term depends on an environment which
consists in a global environment (see below) and a local context.</p>
<h5 id="sec168" class="paragraph">Local context.</h5>
<p>
A <em>local context</em> (or shortly context) is an ordered list of
declarations of variables. The declaration of some variable <span style="font-style:italic">x</span> is
either an assumption, written <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span> (<span style="font-style:italic">T</span> is a type) or a definition,
written <span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>. We use brackets to write contexts. A
typical example is [<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>;<span style="font-style:italic">y</span>:=<span style="font-style:italic">u</span>:<span style="font-style:italic">U</span>;<span style="font-style:italic">z</span>:<span style="font-style:italic">V</span>]. Notice that the variables
declared in a context must be distinct. If Γ declares some <span style="font-style:italic">x</span>,
we write <span style="font-style:italic">x</span> ∈ Γ. By writing (<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>) ∈ Γ we mean that
either <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span> is an assumption in Γ or that there exists some <span style="font-style:italic">t</span> such
that <span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span> is a definition in Γ. If Γ defines some
<span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>, we also write (<span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>) ∈ Γ. Contexts must be
themselves <em>well formed</em>. For the rest of the chapter, the
notation Γ::(<span style="font-style:italic">y</span>:<span style="font-style:italic">T</span>) (resp. Γ::(<span style="font-style:italic">y</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>)) denotes the context
Γ enriched with the declaration <span style="font-style:italic">y</span>:<span style="font-style:italic">T</span> (resp. <span style="font-style:italic">y</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>). The
notation [] denotes the empty context. <a id="hevea_default330"></a></p><p>We define the inclusion of two contexts Γ and Δ (written
as Γ ⊂ Δ) as the property, for all variable <span style="font-style:italic">x</span>,
type <span style="font-style:italic">T</span> and term <span style="font-style:italic">t</span>, if (<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>) ∈ Γ then (<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>) ∈ Δ
and if (<span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>) ∈ Γ then (<span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>) ∈ Δ. 
</p><p>A variable <span style="font-style:italic">x</span> is said to be free in Γ if Γ contains a
declaration <span style="font-style:italic">y</span>:<span style="font-style:italic">T</span> such that <span style="font-style:italic">x</span> is free in <span style="font-style:italic">T</span>.</p><h5 id="sec169" class="paragraph">Environment.<a id="hevea_default331"></a></h5>
<p>
Because we are manipulating global declarations (constants and global
assumptions), we also need to consider a global environment <span style="font-style:italic">E</span>.</p><p>An environment is an ordered list of declarations of global
names. Declarations are either assumptions or “standard”
definitions, that is abbreviations for well-formed terms
but also definitions of inductive objects. In the latter
case, an object in the environment will define one or more constants
(that is types and constructors, see Section <a href="#sec186">4.5</a>).</p><p>An assumption will be represented in the environment as
<span style="font-family:sans-serif">Assum</span>(Γ)(<span style="font-style:italic">c</span>:<span style="font-style:italic">T</span>) which means that <span style="font-style:italic">c</span> is assumed of some type <span style="font-style:italic">T</span>
well-defined in some context Γ. An (ordinary) definition will
be represented in the environment as <span style="font-family:sans-serif">Def</span>(Γ)(<span style="font-style:italic">c</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>) which means
that <span style="font-style:italic">c</span> is a constant which is valid in some context Γ whose
value is <span style="font-style:italic">t</span> and type is <span style="font-style:italic">T</span>.</p><p>The rules for inductive definitions (see section
<a href="#sec186">4.5</a>) have to be considered as assumption
rules to which the following definitions apply: if the name <span style="font-style:italic">c</span> is
declared in <span style="font-style:italic">E</span>, we write <span style="font-style:italic">c</span> ∈ <span style="font-style:italic">E</span> and if <span style="font-style:italic">c</span>:<span style="font-style:italic">T</span> or <span style="font-style:italic">c</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span> is
declared in <span style="font-style:italic">E</span>, we write (<span style="font-style:italic">c</span> : <span style="font-style:italic">T</span>) ∈ <span style="font-style:italic">E</span>.</p><h5 id="sec170" class="paragraph">Typing rules.<a id="hevea_default332"></a></h5>
<p>
In the following, we assume <span style="font-style:italic">E</span> is a valid environment w.r.t.
inductive definitions. We define simultaneously two
judgments. The first one <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> : <span style="font-style:italic">T</span> means the term <span style="font-style:italic">t</span> is well-typed
and has type <span style="font-style:italic">T</span> in the environment <span style="font-style:italic">E</span> and context Γ. The
second judgment <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>)[Γ] means that the environment <span style="font-style:italic">E</span> is
well-formed and the context Γ is a valid context in this
environment. It also means a third property which makes sure that any
constant in <span style="font-style:italic">E</span> was defined in an environment which is included in
Γ
<sup><a id="text12" href="#note12">2</a></sup>.</p><p>A term <span style="font-style:italic">t</span> is well typed in an environment <span style="font-style:italic">E</span> iff there exists a
context Γ and a term <span style="font-style:italic">T</span> such that the judgment <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> : <span style="font-style:italic">T</span> can
be derived from the following rules.
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">W-E</span></dt><dd class="dd-description"> <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>([])[[]]</td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold">W-S</span></dt><dd class="dd-description"> <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">T</span> : <span style="font-style:italic">s</span>    <span style="font-style:italic">s</span> ∈ <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">S</span></span>    <span style="font-style:italic">x</span> ∉Γ           </td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>)[Γ::(<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>)]</td></tr>
</table></td><td class="dcell">     
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> : <span style="font-style:italic">T</span>    <span style="font-style:italic">x</span> ∉Γ           </td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>)[Γ::(<span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>)]</td></tr>
</table></td></tr>
</table></td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold">Def</span></dt><dd class="dd-description"> <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> : <span style="font-style:italic">T</span>   <span style="font-style:italic">c</span> ∉ <span style="font-style:italic">E</span> ⋃ Γ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>;<span style="font-family:sans-serif">Def</span>(Γ)(<span style="font-style:italic">c</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>))[Γ]</td></tr>
</table></td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold">Assum</span></dt><dd class="dd-description"> <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">T</span> : <span style="font-style:italic">s</span>    <span style="font-style:italic">s</span> ∈ <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">S</span></span>    <span style="font-style:italic">c</span> ∉ <span style="font-style:italic">E</span> ⋃ Γ</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>;<span style="font-family:sans-serif">Assum</span>(Γ)(<span style="font-style:italic">c</span>:<span style="font-style:italic">T</span>))[Γ]</td></tr>
</table></td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold">Ax</span></dt><dd class="dd-description"> <a id="hevea_default333"></a>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>)[Γ]</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:sans-serif">Prop</span> : <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">p</span>)</td></tr>
</table></td><td class="dcell">     
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>)[Γ]</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:sans-serif">Set</span> : <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">q</span>)</td></tr>
</table></td></tr>
</table></td></tr>
</table>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>)[Γ]    <span style="font-style:italic">i</span>&lt;<span style="font-style:italic">j</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>) : <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">j</span>)</td></tr>
</table></td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold">Var</span></dt><dd class="dd-description"><a id="hevea_default334"></a>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"> <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>)[Γ]     (<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>) ∈ Γ  or  (<span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>) ∈ Γ for some <span style="font-style:italic">t</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">x</span> : <span style="font-style:italic">T</span></td></tr>
</table></td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold">Const</span></dt><dd class="dd-description"> <a id="hevea_default335"></a>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>)[Γ]    (<span style="font-style:italic">c</span>:<span style="font-style:italic">T</span>) ∈ <span style="font-style:italic">E</span>  or  (<span style="font-style:italic">c</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>) ∈ <span style="font-style:italic">E</span> for some <span style="font-style:italic">t</span> </td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">c</span> : <span style="font-style:italic">T</span></td></tr>
</table></td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold">Prod</span></dt><dd class="dd-description"> <a id="hevea_default336"></a>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">T</span> : <span style="font-style:italic">s</span>    <span style="font-style:italic">s</span> ∈ <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">S</span></span>   
<span style="font-style:italic">E</span>[Γ::(<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>)] ⊢ <span style="font-style:italic">U</span> : <span style="font-family:sans-serif">Prop</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"> <span style="font-style:italic">E</span>[Γ] ⊢ ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span> : <span style="font-family:sans-serif">Prop</span></td></tr>
</table></td></tr>
</table> 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">T</span> : <span style="font-style:italic">s</span>    <span style="font-style:italic">s</span> ∈{<span style="font-family:sans-serif">Prop</span>, <span style="font-family:sans-serif">Set</span>}      
<span style="font-style:italic">E</span>[Γ::(<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>)] ⊢ <span style="font-style:italic">U</span> : <span style="font-family:sans-serif">Set</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"> <span style="font-style:italic">E</span>[Γ] ⊢ ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span> : <span style="font-family:sans-serif">Set</span></td></tr>
</table></td></tr>
</table> 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">T</span> : <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>)    <span style="font-style:italic">i</span>≤ <span style="font-style:italic">k</span>   
<span style="font-style:italic">E</span>[Γ::(<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>)] ⊢ <span style="font-style:italic">U</span> : <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">j</span>)   <span style="font-style:italic">j</span> ≤ <span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span> : <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">k</span>)</td></tr>
</table></td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold">Lam</span></dt><dd class="dd-description"><a id="hevea_default337"></a> 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span> : <span style="font-style:italic">s</span>     <span style="font-style:italic">E</span>[Γ::(<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>)] ⊢ <span style="font-style:italic">t</span> : <span style="font-style:italic">U</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">t</span> : ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>, <span style="font-style:italic">U</span></td></tr>
</table></td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold">App</span></dt><dd class="dd-description"><a id="hevea_default338"></a>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> : ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">U</span>,<span style="font-style:italic">T</span>    <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">u</span> : <span style="font-style:italic">U</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ (<span style="font-style:italic">t</span> <span style="font-style:italic">u</span>) : <span style="font-style:italic">T</span>{<span style="font-style:italic">x</span>/<span style="font-style:italic">u</span>}</td></tr>
</table></td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold">Let</span></dt><dd class="dd-description"><a id="hevea_default339"></a> 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> : <span style="font-style:italic">T</span>     <span style="font-style:italic">E</span>[Γ::(<span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>)] ⊢ <span style="font-style:italic">u</span> : <span style="font-style:italic">U</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:sans-serif">let</span> <span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span> <span style="font-family:sans-serif">in</span> <span style="font-style:italic">u</span> : <span style="font-style:italic">U</span>{<span style="font-style:italic">x</span>/<span style="font-style:italic">t</span>}</td></tr>
</table></td></tr>
</table>
</dd></dl><p><br>
<span style="font-weight:bold">Remark: </span>We may have <span style="font-family:sans-serif">let</span> <span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span> <span style="font-family:sans-serif">in</span> <span style="font-style:italic">u</span>
well-typed without having ((λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">u</span>) <span style="font-style:italic">t</span>) well-typed (where
<span style="font-style:italic">T</span> is a type of <span style="font-style:italic">t</span>). This is because the value <span style="font-style:italic">t</span> associated to <span style="font-style:italic">x</span>
may be used in a conversion rule (see Section <a href="#sec171">4.3</a>).</p><h2 id="sec171" class="section">4.3  Conversion rules<a id="hevea_default340"></a>
</h2>
<h5 id="sec172" class="paragraph">β-reduction.<a id="hevea_default341"></a></h5>
<p>We want to be able to identify some terms as we can identify the
application of a function to a given argument with its result. For
instance the identity function over a given type <span style="font-style:italic">T</span> can be written
λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">x</span>. In any environment <span style="font-style:italic">E</span> and context Γ, we want to identify any object <span style="font-style:italic">a</span> (of type <span style="font-style:italic">T</span>) with the
application ((λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">x</span>) <span style="font-style:italic">a</span>). We define for this a <em>reduction</em> (or a
<em>conversion</em>) rule we call β:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">E</span>[Γ] ⊢ ((λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>. 
<span style="font-style:italic">t</span>) <span style="font-style:italic">u</span>) ▷<sub>β</sub> <span style="font-style:italic">t</span>{<span style="font-style:italic">x</span>/<span style="font-style:italic">u</span>} </td></tr>
</table><p> 
We say that <span style="font-style:italic">t</span>{<span style="font-style:italic">x</span>/<span style="font-style:italic">u</span>} is the β<em>-contraction</em> of
((λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">t</span>) <span style="font-style:italic">u</span>) and, conversely, that ((λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">t</span>) <span style="font-style:italic">u</span>)
is the β<em>-expansion</em> of <span style="font-style:italic">t</span>{<span style="font-style:italic">x</span>/<span style="font-style:italic">u</span>}.</p><p>According to β-reduction, terms of the <em>Calculus of
Inductive Constructions</em> enjoy some fundamental properties such as
confluence, strong normalization, subject reduction. These results are
theoretically of great importance but we will not detail them here and
refer the interested reader to [<a href="biblio.html#Coq85">23</a>].</p><h5 id="sec173" class="paragraph">ι-reduction.<a id="hevea_default342"></a></h5>
<p>
A specific conversion rule is associated to the inductive objects in
the environment. We shall give later on (see Section <a href="#sec214">4.5.4</a>) the
precise rules but it just says that a destructor applied to an object
built from a constructor behaves as expected. This reduction is
called ι-reduction and is more precisely studied in
[<a href="biblio.html#Moh93">118</a>, <a href="biblio.html#Wer94">137</a>].</p><h5 id="sec174" class="paragraph">δ-reduction.<a id="hevea_default343"></a></h5>
<p>We may have defined variables in contexts or constants in the global
environment. It is legal to identify such a reference with its value,
that is to expand (or unfold) it into its value. This
reduction is called δ-reduction and shows as follows.</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">x</span> ▷<sub>δ</sub> <span style="font-style:italic">t</span>     if (<span style="font-style:italic">x</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>) ∈ Γ         <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">c</span> ▷<sub>δ</sub> <span style="font-style:italic">t</span>     if (<span style="font-style:italic">c</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>) ∈ <span style="font-style:italic">E</span></td></tr>
</table><h5 id="sec175" class="paragraph">ζ-reduction.<a id="hevea_default344"></a></h5>
<p><span style="font-variant:small-caps">Coq</span> allows also to remove local definitions occurring in terms by
replacing the defined variable by its value. The declaration being
destroyed, this reduction differs from δ-reduction. It is
called ζ-reduction and shows as follows.</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:sans-serif">let</span> <span style="font-style:italic">x</span>:=<span style="font-style:italic">u</span> <span style="font-family:sans-serif">in</span> <span style="font-style:italic">t</span> ▷<sub>ζ</sub> <span style="font-style:italic">t</span>{<span style="font-style:italic">x</span>/<span style="font-style:italic">u</span>}</td></tr>
</table>
<h5 id="sec176" class="paragraph">η-conversion.

<a id="hevea_default345"></a>
</h5>
<p>
An other important concept is η-conversion. It is to identify any
term <span style="font-style:italic">t</span> of functional type ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>, <span style="font-style:italic">U</span> with its so-called
η-expansion λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  (<span style="font-style:italic">t</span> <span style="font-style:italic">x</span>) for <span style="font-style:italic">x</span> an arbitrary variable
name fresh in <span style="font-style:italic">t</span>.</p><p>The notion of η-reduction λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  (<span style="font-style:italic">t</span> <span style="font-style:italic">x</span>)▷<span style="font-style:italic">t</span>
(for <span style="font-style:italic">x</span> not occurring in <span style="font-style:italic">t</span>) is not type-sound because of subtyping
(think about λ <span style="font-style:italic">x</span>:<span style="font-family:sans-serif">Type</span>(1).  (<span style="font-style:italic">f</span> <span style="font-style:italic">x</span>) of type ∀
<span style="font-style:italic">x</span>:<span style="font-family:sans-serif">Type</span>(1), <span style="font-family:sans-serif">Type</span>(1) for <span style="font-style:italic">f</span> of type ∀ <span style="font-style:italic">x</span>:<span style="font-family:sans-serif">Type</span>(2),
<span style="font-family:sans-serif">Type</span>(1)). On the other side, η-expansion requires to know <span style="font-style:italic">T</span>
and hence requires types. Hence, neither η-expansion nor
η-reduction can be type-safely considered on terms we do not know
the type. However, η can be used as a conversion rule.</p><h5 id="sec177" class="paragraph">Convertibility.
<a id="hevea_default346"></a><a id="hevea_default347"></a><a id="hevea_default348"></a><a id="hevea_default349"></a></h5>
<p>Let us write <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> ▷ <span style="font-style:italic">u</span> for the contextual closure of the relation <span style="font-style:italic">t</span> reduces to <span style="font-style:italic">u</span> in the environment <span style="font-style:italic">E</span> and context Γ with one of the previous reduction β, ι, δ or ζ.</p><p>We say that two terms <span style="font-style:italic">t</span><sub>1</sub> and <span style="font-style:italic">t</span><sub>2</sub> are βιδζη<em>-convertible</em>, or simply <em>convertible</em>, or <em>equivalent</em>, in the environment <span style="font-style:italic">E</span> and
context Γ iff there exist terms <span style="font-style:italic">u</span><sub>1</sub> and <span style="font-style:italic">u</span><sub>2</sub> such that
<span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span><sub>1</sub> ▷ … ▷ <span style="font-style:italic">u</span><sub>1</sub> and
<span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span><sub>2</sub> ▷ … ▷ <span style="font-style:italic">u</span><sub>2</sub> and either
<span style="font-style:italic">u</span><sub>1</sub> and <span style="font-style:italic">u</span><sub>2</sub> are identical, or they are convertible up to
η-expansion, i.e. <span style="font-style:italic">u</span><sub>1</sub> is λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">u</span>′<sub>1</sub> and <span style="font-style:italic">u</span><sub>2</sub> <span style="font-style:italic">x</span> is
recursively convertible to <span style="font-style:italic">u</span>′<sub>1</sub>, or, symmetrically, <span style="font-style:italic">u</span><sub>2</sub> is λ
<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">u</span>′<sub>2</sub> and <span style="font-style:italic">u</span><sub>1</sub> <span style="font-style:italic">x</span> is recursively convertible to <span style="font-style:italic">u</span>′<sub>2</sub>. We
then write <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span><sub>1</sub> =<sub>βδιζη</sub> <span style="font-style:italic">t</span><sub>2</sub>.</p><p>The convertibility relation allows to introduce a new typing rule
which says that two convertible well-formed types have the same
inhabitants.</p><p>At the moment, we did not take into account one rule between universes
which says that any term in a universe of index <span style="font-style:italic">i</span> is also a term in
the universe of index <span style="font-style:italic">i</span>+1 (this is the <em>cumulativity</em> rule of
p<span style="font-variant:small-caps">Cic</span>). This property is included into the
conversion rule by extending the equivalence relation of
convertibility into a <em>subtyping</em> relation inductively defined by:
</p><ol class="enumerate" type=1><li class="li-enumerate">
if <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> =<sub>βδιζη</sub> <span style="font-style:italic">u</span> then <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> ≤<sub>βδιζη</sub> <span style="font-style:italic">u</span>,
</li><li class="li-enumerate">if <span style="font-style:italic">i</span> ≤ <span style="font-style:italic">j</span> then <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>) ≤<sub>βδιζη</sub> <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">j</span>),
</li><li class="li-enumerate">for any <span style="font-style:italic">i</span>, <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:sans-serif">Set</span> ≤<sub>βδιζη</sub> <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>),
</li><li class="li-enumerate"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:sans-serif">Prop</span> ≤<sub>βδιζη</sub> <span style="font-family:sans-serif">Set</span>, hence, by transitivity,
<span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:sans-serif">Prop</span> ≤<sub>βδιζη</sub> <span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>), for any <span style="font-style:italic">i</span>
</li><li class="li-enumerate">if <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">T</span> =<sub>βδιζη</sub> <span style="font-style:italic">U</span> and <span style="font-style:italic">E</span>[Γ::(<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>)] ⊢ <span style="font-style:italic">T</span>′ ≤<sub>βδιζη</sub> <span style="font-style:italic">U</span>′ then <span style="font-style:italic">E</span>[Γ] ⊢ ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>, <span style="font-style:italic">T</span>′ ≤<sub>βδιζη</sub> ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">U</span>, <span style="font-style:italic">U</span>′.
</li></ol><p>The conversion rule is now exactly:</p><dl class="description"><dt class="dt-description"><a id="Conv"></a>
<span style="font-weight:bold">Conv</span></dt><dd class="dd-description"><a id="hevea_default350"></a>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">U</span> : <span style="font-style:italic">s</span>    <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> : <span style="font-style:italic">T</span>    <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">T</span> ≤<sub>βδιζη</sub> <span style="font-style:italic">U</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> : <span style="font-style:italic">U</span></td></tr>
</table></td></tr>
</table></td></tr>
</table>
</dd></dl><h5 id="sec178" class="paragraph">Normal form.<a id="hevea_default351"></a><a id="hevea_default352"></a></h5>
<p>
A term which cannot be any more reduced is said to be in <em>normal
form</em>. There are several ways (or strategies) to apply the reduction
rule. Among them, we have to mention the <em>head reduction</em> which
will play an important role (see Chapter <a href="Reference-Manual010.html#sec340">8</a>). Any term can
be written as λ <span style="font-style:italic">x</span><sub>1</sub>:<span style="font-style:italic">T</span><sub>1</sub>.  … λ <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>:<span style="font-style:italic">T</span><sub><span style="font-style:italic">k</span></sub> . 
(<span style="font-style:italic">t</span><sub>0</sub> <span style="font-style:italic">t</span><sub>1</sub>… <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>) where
<span style="font-style:italic">t</span><sub>0</sub> is not an application. We say then that <span style="font-style:italic">t</span><sub>0</sub> is the <em>head
of </em><span style="font-style:italic">t</span>. If we assume that <span style="font-style:italic">t</span><sub>0</sub> is λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">u</span><sub>0</sub> then one step of
β-head reduction of <span style="font-style:italic">t</span> is:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">λ <span style="font-style:italic">x</span><sub>1</sub>:<span style="font-style:italic">T</span><sub>1</sub>.  … λ <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>:<span style="font-style:italic">T</span><sub><span style="font-style:italic">k</span></sub>.  (λ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>.  <span style="font-style:italic">u</span><sub>0</sub> <span style="font-style:italic">t</span><sub>1</sub>… <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>)
 ▷   λ (<span style="font-style:italic">x</span><sub>1</sub>:<span style="font-style:italic">T</span><sub>1</sub>)…(<span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>:<span style="font-style:italic">T</span><sub><span style="font-style:italic">k</span></sub>). 
(<span style="font-style:italic">u</span><sub>0</sub>{<span style="font-style:italic">x</span>/<span style="font-style:italic">t</span><sub>1</sub>} <span style="font-style:italic">t</span><sub>2</sub> … <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table><p>
Iterating the process of head reduction until the head of the reduced
term is no more an abstraction leads to the β<em>-head normal
form</em> of <span style="font-style:italic">t</span>:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">t</span> ▷ … ▷
λ <span style="font-style:italic">x</span><sub>1</sub>:<span style="font-style:italic">T</span><sub>1</sub>.  …λ <span style="font-style:italic">x</span><sub><span style="font-style:italic">k</span></sub>:<span style="font-style:italic">T</span><sub><span style="font-style:italic">k</span></sub>.  (<span style="font-style:italic">v</span> <span style="font-style:italic">u</span><sub>1</sub>
… <span style="font-style:italic">u</span><sub><span style="font-style:italic">m</span></sub>)</td></tr>
</table><p>
where <span style="font-style:italic">v</span> is not an abstraction (nor an application). Note that the
head normal form must not be confused with the normal form since some
<span style="font-style:italic">u</span><sub><span style="font-style:italic">i</span></sub> can be reducible.</p><p>Similar notions of head-normal forms involving δ, ι and ζ
reductions or any combination of those can also be defined.</p>
<h2 id="sec179" class="section">4.4  Derived rules for environments</h2>
<p>From the original rules of the type system, one can derive new rules
which change the context of definition of objects in the environment.
Because these rules correspond to elementary operations in the <span style="font-variant:small-caps">Coq</span> 
engine used in the discharge mechanism at the end of a section, we
state them explicitly.</p>
<h5 id="sec180" class="paragraph">Mechanism of substitution.</h5>
<p>One rule which can be proved valid, is to replace a term <span style="font-style:italic">c</span> by its
value in the environment. As we defined the substitution of a term for
a variable in a term, one can define the substitution of a term for a
constant. One easily extends this substitution to contexts and
environments.</p>
<h5 id="sec181" class="paragraph">Substitution Property:</h5>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>;<span style="font-family:sans-serif">Def</span>(Γ)(<span style="font-style:italic">c</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>); <span style="font-style:italic">F</span>)[Δ]</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>; <span style="font-style:italic">F</span>{<span style="font-style:italic">c</span>/<span style="font-style:italic">t</span>})[Δ{<span style="font-style:italic">c</span>/<span style="font-style:italic">t</span>}]</td></tr>
</table></td></tr>
</table>
<h5 id="sec182" class="paragraph">Abstraction.</h5>
<p>One can modify the context of definition of a constant <span style="font-style:italic">c</span> by
abstracting a constant with respect to the last variable <span style="font-style:italic">x</span> of its
defining context. For doing that, we need to check that the constants
appearing in the body of the declaration do not depend on <span style="font-style:italic">x</span>, we need
also to modify the reference to the constant <span style="font-style:italic">c</span> in the environment
and context by explicitly applying this constant to the variable <span style="font-style:italic">x</span>.
Because of the rules for building environments and terms we know the
variable <span style="font-style:italic">x</span> is available at each stage where <span style="font-style:italic">c</span> is mentioned.</p>
<h5 id="sec183" class="paragraph">Abstracting property:</h5>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>; <span style="font-family:sans-serif">Def</span>(Γ::(<span style="font-style:italic">x</span>:<span style="font-style:italic">U</span>))(<span style="font-style:italic">c</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>);
<span style="font-style:italic">F</span>)[Δ]    <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>)[Γ]</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>;<span style="font-family:sans-serif">Def</span>(Γ)(<span style="font-style:italic">c</span>:=λ <span style="font-style:italic">x</span>:<span style="font-style:italic">U</span>.  <span style="font-style:italic">t</span>:∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">U</span>,<span style="font-style:italic">T</span>);
<span style="font-style:italic">F</span>{<span style="font-style:italic">c</span>/(<span style="font-style:italic">c</span> <span style="font-style:italic">x</span>)})[Δ{<span style="font-style:italic">c</span>/(<span style="font-style:italic">c</span> <span style="font-style:italic">x</span>)}]</td></tr>
</table></td></tr>
</table>
<h5 id="sec184" class="paragraph">Pruning the context.</h5>
<p> 
We said the judgment <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>)[Γ] means that the defining contexts of
constants in <span style="font-style:italic">E</span> are included in Γ. If one abstracts or
substitutes the constants with the above rules then it may happen
that the context Γ is now bigger than the one needed for
defining the constants in <span style="font-style:italic">E</span>. Because defining contexts are growing
in <span style="font-style:italic">E</span>, the minimum context needed for defining the constants in <span style="font-style:italic">E</span>
is the same as the one for the last constant. One can consequently
derive the following property.</p>
<h5 id="sec185" class="paragraph">Pruning property:</h5>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>; <span style="font-family:sans-serif">Def</span>(Δ)(<span style="font-style:italic">c</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>))[Γ]</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>;<span style="font-family:sans-serif">Def</span>(Δ)(<span style="font-style:italic">c</span>:=<span style="font-style:italic">t</span>:<span style="font-style:italic">T</span>))[Δ]</td></tr>
</table></td></tr>
</table><h2 id="sec186" class="section">4.5  Inductive Definitions</h2>
<p>A (possibly mutual) inductive definition is specified by giving the
names and the type of the inductive sets or families to be
defined and the names and types of the constructors of the inductive
predicates. An inductive declaration in the environment can
consequently be represented with two contexts (one for inductive
definitions, one for constructors).</p><p>Stating the rules for inductive definitions in their general form
needs quite tedious definitions. We shall try to give a concrete
understanding of the rules by precising them on running examples. We
take as examples the type of natural numbers, the type of
parameterized lists over a type <span style="font-style:italic">A</span>, the relation which states that
a list has some given length and the mutual inductive definition of trees and
forests. </p>
<h3 id="sec187" class="subsection">4.5.1  Representing an inductive definition</h3>
<h4 id="sec188" class="subsubsection">Inductive definitions without parameters</h4>
<p>
As for constants, inductive definitions can be defined in a non-empty
context. <br>
We write <span style="font-family:sans-serif">Ind</span>(Γ)(Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) an inductive
definition valid in a context Γ, a
context of definitions Γ<sub><span style="font-style:italic">I</span></sub> and a context of constructors
Γ<sub><span style="font-style:italic">C</span></sub>.
</p>
<h5 id="sec189" class="paragraph">Examples.</h5>
<p>
The inductive declaration for the type of natural numbers will be:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">Ind</span>()(<span style="font-family:sans-serif">nat</span>:<span style="font-family:sans-serif">Set</span>:=<span style="font-family:sans-serif">O</span>:<span style="font-family:sans-serif">nat</span>,<span style="font-family:sans-serif">S</span>:<span style="font-family:sans-serif">nat</span>→<span style="font-family:sans-serif">nat</span> )</td></tr>
</table><p>
In a context with a variable <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, the lists of elements in <span style="font-style:italic">A</span> are
represented by:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">Ind</span>(<span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>)(<span style="font-family:sans-serif">List</span>:<span style="font-family:sans-serif">Set</span>:=<span style="font-family:sans-serif">nil</span>:<span style="font-family:sans-serif">List</span>,<span style="font-family:sans-serif">cons</span> : <span style="font-style:italic">A</span> → <span style="font-family:sans-serif">List</span> →
<span style="font-family:sans-serif">List</span> )</td></tr>
</table><p>
Assuming 
Γ<sub><span style="font-style:italic">I</span></sub> is [<span style="font-style:italic">I</span><sub>1</sub>:<span style="font-style:italic">A</span><sub>1</sub>;…;<span style="font-style:italic">I</span><sub><span style="font-style:italic">k</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>], and Γ<sub><span style="font-style:italic">C</span></sub> is
[<span style="font-style:italic">c</span><sub>1</sub>:<span style="font-style:italic">C</span><sub>1</sub>;…;<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">C</span><sub><span style="font-style:italic">n</span></sub>], the general typing rules are, 
for 1≤ <span style="font-style:italic">j</span>≤ <span style="font-style:italic">k</span> and 1≤ <span style="font-style:italic">i</span>≤ <span style="font-style:italic">n</span>:</p><p><br>
<br>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-family:sans-serif">Ind</span>(Γ)(Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) ∈ <span style="font-style:italic">E</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">I</span><sub><span style="font-style:italic">j</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>) ∈ <span style="font-style:italic">E</span></td></tr>
</table></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-family:sans-serif">Ind</span>(Γ)(Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) ∈ <span style="font-style:italic">E</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub>:<span style="font-style:italic">C</span><sub><span style="font-style:italic">i</span></sub>) ∈ <span style="font-style:italic">E</span></td></tr>
</table></td></tr>
</table>
<h4 id="sec190" class="subsubsection">Inductive definitions with parameters</h4>
<p>We have to slightly complicate the representation above in order to handle
the delicate problem of parameters. 
Let us explain that on the example of <span style="font-family:sans-serif">List</span>. With the above definition,
the type <span style="font-family:sans-serif">List</span> can only be used in an environment where we
have a variable <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>. Generally one want to consider lists of
elements in different types. For constants this is easily done by abstracting
the value over the parameter. In the case of inductive definitions we
have to handle the abstraction over several objects.</p><p>One possible way to do that would be to define the type <span style="font-family:sans-serif">List</span>
inductively as being an inductive family of type <span style="font-family:sans-serif">Set</span>→<span style="font-family:sans-serif">Set</span>:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">Ind</span>()(<span style="font-family:sans-serif">List</span>:<span style="font-family:sans-serif">Set</span>→<span style="font-family:sans-serif">Set</span>:=<span style="font-family:sans-serif">nil</span>:(∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>,<span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>),
<span style="font-family:sans-serif">cons</span> : (∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, <span style="font-style:italic">A</span> → <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span> → <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>) )</td></tr>
</table><p>
There are drawbacks to this point of view. The
information which says that for any <span style="font-style:italic">A</span>, (<span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>) is an inductively defined
<span style="font-family:sans-serif">Set</span> has been lost.
So we introduce two important definitions.</p>
<h5 id="sec191" class="paragraph">Inductive parameters, real arguments.</h5>
<p>
An inductive definition <span style="font-family:sans-serif">Ind</span>(Γ)(Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) admits 
<span style="font-style:italic">r</span> inductive parameters if each type of constructors (<span style="font-style:italic">c</span>:<span style="font-style:italic">C</span>) in
Γ<sub><span style="font-style:italic">C</span></sub> is such that 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">C</span>≡ ∀
<span style="font-style:italic">p</span><sub>1</sub>:<span style="font-style:italic">P</span><sub>1</sub>,…,∀ <span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub>:<span style="font-style:italic">P</span><sub><span style="font-style:italic">r</span></sub>,∀ <span style="font-style:italic">a</span><sub>1</sub>:<span style="font-style:italic">A</span><sub>1</sub>, … ∀ <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>,
(<span style="font-style:italic">I</span> <span style="font-style:italic">p</span><sub>1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub> <span style="font-style:italic">t</span><sub>1</sub>… <span style="font-style:italic">t</span><sub><span style="font-style:italic">q</span></sub>)</td></tr>
</table><p>
with <span style="font-style:italic">I</span> one of the inductive definitions in Γ<sub><span style="font-style:italic">I</span></sub>. 
We say that <span style="font-style:italic">q</span> is the number of real arguments of the constructor
<span style="font-style:italic">c</span>. 
</p>
<h5 id="sec192" class="paragraph">Context of parameters.</h5>
<p>
If an inductive definition <span style="font-family:sans-serif">Ind</span>(Γ)(Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) admits 
<span style="font-style:italic">r</span> inductive parameters, then there exists a context Γ<sub><span style="font-style:italic">P</span></sub> of
size <span style="font-style:italic">r</span>, such that Γ<sub><span style="font-style:italic">P</span></sub>=[<span style="font-style:italic">p</span><sub>1</sub>:<span style="font-style:italic">P</span><sub>1</sub>;…;<span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub>:<span style="font-style:italic">P</span><sub><span style="font-style:italic">r</span></sub>] and 
if (<span style="font-style:italic">t</span>:<span style="font-style:italic">A</span>) ∈ Γ<sub><span style="font-style:italic">I</span></sub>,Γ<sub><span style="font-style:italic">C</span></sub> then <span style="font-style:italic">A</span> can be written as 
∀ <span style="font-style:italic">p</span><sub>1</sub>:<span style="font-style:italic">P</span><sub>1</sub>,… ∀ <span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub>:<span style="font-style:italic">P</span><sub><span style="font-style:italic">r</span></sub>,<span style="font-style:italic">A</span>′. 
We call Γ<sub><span style="font-style:italic">P</span></sub> the context of parameters of the inductive
definition and use the notation ∀ Γ<sub><span style="font-style:italic">P</span></sub>,<span style="font-style:italic">A</span>′ for the term <span style="font-style:italic">A</span>.
</p>
<h5 id="sec193" class="paragraph">Remark.</h5>
<p>
If we have a term <span style="font-style:italic">t</span> in an instance of an
inductive definition <span style="font-style:italic">I</span> which starts with a constructor <span style="font-style:italic">c</span>, then the
<span style="font-style:italic">r</span> first arguments of <span style="font-style:italic">c</span> (the parameters) can be deduced from the
type <span style="font-style:italic">T</span> of <span style="font-style:italic">t</span>: these are exactly the <span style="font-style:italic">r</span> first arguments of <span style="font-style:italic">I</span> in
the head normal form of <span style="font-style:italic">T</span>.
</p>
<h5 id="sec194" class="paragraph">Examples.</h5>
<p>
The <span style="font-family:sans-serif">List</span> definition has 1 parameter:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">Ind</span>()(<span style="font-family:sans-serif">List</span>:<span style="font-family:sans-serif">Set</span>→<span style="font-family:sans-serif">Set</span>:=<span style="font-family:sans-serif">nil</span>:(∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>),
<span style="font-family:sans-serif">cons</span> : (∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, <span style="font-style:italic">A</span> → <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span> → <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>) )</td></tr>
</table><p>
This is also the case for this more complex definition where there is
a recursive argument on a different instance of <span style="font-family:sans-serif">List</span>: 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">Ind</span>()(<span style="font-family:sans-serif">List</span>:<span style="font-family:sans-serif">Set</span>→<span style="font-family:sans-serif">Set</span>:=<span style="font-family:sans-serif">nil</span>:(∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>),
<span style="font-family:sans-serif">cons</span> : (∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, <span style="font-style:italic">A</span> → <span style="font-family:sans-serif">List</span> (<span style="font-style:italic">A</span> → <span style="font-style:italic">A</span>) → <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>) )</td></tr>
</table><p>
But the following definition has 0 parameters:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">Ind</span>()(<span style="font-family:sans-serif">List</span>:<span style="font-family:sans-serif">Set</span>→<span style="font-family:sans-serif">Set</span>:=<span style="font-family:sans-serif">nil</span>:(∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>),
<span style="font-family:sans-serif">cons</span> : (∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, <span style="font-style:italic">A</span> → <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span> → <span style="font-family:sans-serif">List</span> (<span style="font-style:italic">A</span>*<span style="font-style:italic">A</span>)) )</td></tr>
</table>
<h5 id="sec195" class="paragraph">Concrete syntax.</h5>
<p>
In the Coq system, the context of parameters is given explicitly
after the name of the inductive definitions and is shared between the
arities and the type of constructors.
We keep track in the syntax of the number of
parameters. </p><p>Formally the representation of an inductive declaration
will be 
<span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) for an inductive
definition valid in a context Γ with <span style="font-style:italic">p</span> parameters, a
context of definitions Γ<sub><span style="font-style:italic">I</span></sub> and a context of constructors
Γ<sub><span style="font-style:italic">C</span></sub>.</p><p>The definition <span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) will be
well-formed exactly when <span style="font-family:sans-serif">Ind</span>(Γ)(Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) is and 
when <span style="font-style:italic">p</span> is (less or equal than) the number of parameters in
<span style="font-family:sans-serif">Ind</span>(Γ)(Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ). </p>
<h5 id="sec196" class="paragraph">Examples</h5>
<p>
The declaration for parameterized lists is:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">Ind</span>()[1](<span style="font-family:sans-serif">List</span>:<span style="font-family:sans-serif">Set</span>→<span style="font-family:sans-serif">Set</span>:=<span style="font-family:sans-serif">nil</span>:(∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>,<span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>),<span style="font-family:sans-serif">cons</span> :
(∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, <span style="font-style:italic">A</span> → <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span> → <span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>) )</td></tr>
</table><p>The declaration for the length of lists is:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">Ind</span>()[1](<span style="font-family:sans-serif">Length</span>:∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, (<span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>)→ <span style="font-family:sans-serif">nat</span>→<span style="font-family:sans-serif">Prop</span>:=<span style="font-family:sans-serif">Lnil</span>:∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, <span style="font-family:sans-serif">Length</span> <span style="font-style:italic">A</span> (<span style="font-family:sans-serif">nil</span> <span style="font-style:italic">A</span>) <span style="font-family:sans-serif">O</span>,<br>
 <span style="font-family:sans-serif">Lcons</span> :∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>,∀ <span style="font-style:italic">a</span>:<span style="font-style:italic">A</span>, ∀ <span style="font-style:italic">l</span>:(<span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>),∀ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>, (<span style="font-family:sans-serif">Length</span> <span style="font-style:italic">A</span> <span style="font-style:italic">l</span> <span style="font-style:italic">n</span>)→ (<span style="font-family:sans-serif">Length</span> <span style="font-style:italic">A</span> (<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span>) (<span style="font-family:sans-serif">S</span> <span style="font-style:italic">n</span>)) )</td></tr>
</table><p>The declaration for a mutual inductive definition of forests and trees is:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">Ind</span>()(<span style="font-family:sans-serif">tree</span>:<span style="font-family:sans-serif">Set</span>,<span style="font-family:sans-serif">forest</span>:<span style="font-family:sans-serif">Set</span>:=<br>
  <span style="font-family:sans-serif">node</span>:<span style="font-family:sans-serif">forest</span> → <span style="font-family:sans-serif">tree</span>,
<span style="font-family:sans-serif">emptyf</span>:<span style="font-family:sans-serif">forest</span>,<span style="font-family:sans-serif">consf</span>:<span style="font-family:sans-serif">tree</span> → <span style="font-family:sans-serif">forest</span> → <span style="font-family:sans-serif">forest</span> )</td></tr>
</table><p>These representations are the ones obtained as the result of the <span style="font-variant:small-caps">Coq</span> 
declaration:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive nat : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | O : nat</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | S : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> nat.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list (A:Set) : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | nil : list A</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | cons : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list A.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive Length (A:Set) : list A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | Lnil : Length A (nil A) O</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | Lcons :</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">       forall (a:A) (l:list A) (n:nat),</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">         Length A l n -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Length A (cons A a l) (S n).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive tree : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">     node : forest -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> tree</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> with forest : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | emptyf : forest</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | consf : tree -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
The <span style="font-variant:small-caps">Coq</span> type-checker verifies that all
parameters are applied in the correct manner in the conclusion of the
type of each constructors :</p><p>In particular, the following definition will not be accepted because 
there is an occurrence of <span style="font-family:sans-serif">List</span> which is not applied to the parameter
variable in the conclusion of the type of <span style="font-family:monospace">cons’</span>:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list’ (A:Set) : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | nil’ : list’ A</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | cons’ : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list’ A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list’ (A*A).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Error: Last occurrence of "list’" must have "A" as 1st argument in </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> "A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> list’ A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> list’ (A * A)%type".</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
Since <span style="font-variant:small-caps">Coq</span> version 8.1, there is no restriction about parameters in
the types of arguments of constructors. The following definition is
valid:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list’ (A:Set) : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | nil’ : list’ A</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | cons’ : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list’ (A-</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">A) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list’ A.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list’ is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list’_rect is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list’_ind is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list’_rec is defined</span></span></span><span style="font-size:small"><br>
</span></div>
<h3 id="sec197" class="subsection">4.5.2  Types of inductive objects</h3>
<p>
We have to give the type of constants in an environment <span style="font-style:italic">E</span> which
contains an inductive declaration.</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">Ind-Const</span></dt><dd class="dd-description"> Assuming 
Γ<sub><span style="font-style:italic">I</span></sub> is [<span style="font-style:italic">I</span><sub>1</sub>:<span style="font-style:italic">A</span><sub>1</sub>;…;<span style="font-style:italic">I</span><sub><span style="font-style:italic">k</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>], and Γ<sub><span style="font-style:italic">C</span></sub> is
[<span style="font-style:italic">c</span><sub>1</sub>:<span style="font-style:italic">C</span><sub>1</sub>;…;<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">C</span><sub><span style="font-style:italic">n</span></sub>],<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) ∈ <span style="font-style:italic">E</span>
  <span style="font-style:italic">j</span>=1… <span style="font-style:italic">k</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">I</span><sub><span style="font-style:italic">j</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>) ∈ <span style="font-style:italic">E</span></td></tr>
</table></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) ∈ <span style="font-style:italic">E</span>
    <span style="font-style:italic">i</span>=1.. <span style="font-style:italic">n</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub>:<span style="font-style:italic">C</span><sub><span style="font-style:italic">i</span></sub>) ∈ <span style="font-style:italic">E</span></td></tr>
</table></td></tr>
</table></dd></dl>
<h5 id="sec198" class="paragraph">Example.</h5>
<p>
We have (<span style="font-family:sans-serif">List</span>:<span style="font-family:sans-serif">Set</span> → <span style="font-family:sans-serif">Set</span>), (<span style="font-family:sans-serif">cons</span>:∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>,<span style="font-style:italic">A</span>→(<span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>)→
(<span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>)), <br>
(<span style="font-family:sans-serif">Length</span>:∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>, (<span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>)→<span style="font-family:sans-serif">nat</span>→<span style="font-family:sans-serif">Prop</span>), <span style="font-family:sans-serif">tree</span>:<span style="font-family:sans-serif">Set</span> and <span style="font-family:sans-serif">forest</span>:<span style="font-family:sans-serif">Set</span>.</p><p>From now on, we write <span style="font-family:sans-serif">List_A</span> instead of (<span style="font-family:sans-serif">List</span> <span style="font-style:italic">A</span>) and <span style="font-family:sans-serif">Length_A</span>
for (<span style="font-family:sans-serif">Length</span> <span style="font-style:italic">A</span>).</p>
<h3 id="sec199" class="subsection">4.5.3  Well-formed inductive definitions</h3>
<p>
We cannot accept any inductive declaration because some of them lead
to inconsistent systems. We restrict ourselves to definitions which
satisfy a syntactic criterion of positivity. Before giving the formal
rules, we need a few definitions:</p><h5 id="sec200" class="paragraph">Definitions<a id="hevea_default353"></a></h5>
<p>A type <span style="font-style:italic">T</span> is an <em>arity of sort </em><span style="font-style:italic">s</span><a id="hevea_default354"></a> if it converts
to the sort <span style="font-style:italic">s</span> or to a product ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span> with <span style="font-style:italic">U</span> an arity
of sort <span style="font-style:italic">s</span>. (For instance <span style="font-style:italic">A</span>→ <span style="font-family:sans-serif">Set</span> or ∀ <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Prop</span>,<span style="font-style:italic">A</span>→
<span style="font-family:sans-serif">Prop</span> are arities of sort respectively <span style="font-family:sans-serif">Set</span> and <span style="font-family:sans-serif">Prop</span>). A <em>type
of constructor of </em><span style="font-style:italic">I</span><a id="hevea_default355"></a> is either a term
(<span style="font-style:italic">I</span> <span style="font-style:italic">t</span><sub>1</sub>…  <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>) or ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">C</span> with <span style="font-style:italic">C</span> recursively 
a <em>type of constructor of </em><span style="font-style:italic">I</span>.</p><p><br>
</p><p>The type of constructor <span style="font-style:italic">T</span> will be said to <em>satisfy the positivity
condition</em> for a constant <span style="font-style:italic">X</span> in the following cases:</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">T</span>=(<span style="font-style:italic">X</span> <span style="font-style:italic">t</span><sub>1</sub>…  <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>) and <span style="font-style:italic">X</span> does not occur free in
any <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>
</li><li class="li-itemize"><span style="font-style:italic">T</span>=∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">U</span>,<span style="font-style:italic">V</span> and <span style="font-style:italic">X</span> occurs only strictly positively in <span style="font-style:italic">U</span> and
the type <span style="font-style:italic">V</span> satisfies the positivity condition for <span style="font-style:italic">X</span>
</li></ul><p>The constant <span style="font-style:italic">X</span> <em>occurs strictly positively</em> in <span style="font-style:italic">T</span> in the
following cases:</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">X</span> does not occur in <span style="font-style:italic">T</span>
</li><li class="li-itemize"><span style="font-style:italic">T</span> converts to (<span style="font-style:italic">X</span> <span style="font-style:italic">t</span><sub>1</sub> …  <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>) and <span style="font-style:italic">X</span> does not occur in
any of <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>
</li><li class="li-itemize"><span style="font-style:italic">T</span> converts to ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">U</span>,<span style="font-style:italic">V</span> and <span style="font-style:italic">X</span> does not occur in
type <span style="font-style:italic">U</span> but occurs strictly positively in type <span style="font-style:italic">V</span>
</li><li class="li-itemize"><span style="font-style:italic">T</span> converts to (<span style="font-style:italic">I</span> <span style="font-style:italic">a</span><sub>1</sub> …  <span style="font-style:italic">a</span><sub><span style="font-style:italic">m</span></sub>   <span style="font-style:italic">t</span><sub>1</sub> …  <span style="font-style:italic">t</span><sub><span style="font-style:italic">p</span></sub>) where
<span style="font-style:italic">I</span> is the name of an inductive declaration of the form
<span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">m</span>](<span style="font-style:italic">I</span>:<span style="font-style:italic">A</span>:=<span style="font-style:italic">c</span><sub>1</sub>:∀ <span style="font-style:italic">p</span><sub>1</sub>:<span style="font-style:italic">P</span><sub>1</sub>,… ∀
<span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub>:<span style="font-style:italic">P</span><sub><span style="font-style:italic">m</span></sub>,<span style="font-style:italic">C</span><sub>1</sub>;…;<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>:∀ <span style="font-style:italic">p</span><sub>1</sub>:<span style="font-style:italic">P</span><sub>1</sub>,… ∀
<span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub>:<span style="font-style:italic">P</span><sub><span style="font-style:italic">m</span></sub>,<span style="font-style:italic">C</span><sub><span style="font-style:italic">n</span></sub> ) 
(in particular, it is not mutually defined and it has <span style="font-style:italic">m</span>
parameters) and <span style="font-style:italic">X</span> does not occur in any of the <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>, and the
(instantiated) types of constructor <span style="font-style:italic">C</span><sub><span style="font-style:italic">i</span></sub>{<span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>/<span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub>}<sub><span style="font-style:italic">j</span>=1… <span style="font-style:italic">m</span></sub>
of <span style="font-style:italic">I</span> satisfy 
the nested positivity condition for <span style="font-style:italic">X</span>
</li></ul><p>The type of constructor <span style="font-style:italic">T</span> of <span style="font-style:italic">I</span> <em>satisfies the nested
positivity condition</em> for a constant <span style="font-style:italic">X</span> in the following
cases:</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">T</span>=(<span style="font-style:italic">I</span> <span style="font-style:italic">b</span><sub>1</sub>… <span style="font-style:italic">b</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:italic">u</span><sub>1</sub>…  <span style="font-style:italic">u</span><sub><span style="font-style:italic">p</span></sub>), <span style="font-style:italic">I</span> is an inductive
definition with <span style="font-style:italic">m</span> parameters and <span style="font-style:italic">X</span> does not occur in
any <span style="font-style:italic">u</span><sub><span style="font-style:italic">i</span></sub>
</li><li class="li-itemize"><span style="font-style:italic">T</span>=∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">U</span>,<span style="font-style:italic">V</span> and <span style="font-style:italic">X</span> occurs only strictly positively in <span style="font-style:italic">U</span> and
the type <span style="font-style:italic">V</span> satisfies the nested positivity condition for <span style="font-style:italic">X</span>
</li></ul>
<h5 id="sec201" class="paragraph">Example</h5>
<p><span style="font-style:italic">X</span> occurs strictly positively in <span style="font-style:italic">A</span>→ <span style="font-style:italic">X</span> or <span style="font-style:italic">X</span>*<span style="font-style:italic">A</span> or (<span style="font-family:monospace"><span style="font-style:italic">list</span></span> 
<span style="font-style:italic">X</span>) but not in <span style="font-style:italic">X</span> → <span style="font-style:italic">A</span> or (<span style="font-style:italic">X</span> → <span style="font-style:italic">A</span>)→ <span style="font-style:italic">A</span> nor (<span style="font-family:monospace"><span style="font-style:italic">neg</span></span> <span style="font-style:italic">X</span>)
assuming the notion of product and lists were already defined and <span style="font-family:monospace">neg</span> is an inductive definition with declaration <span style="font-family:sans-serif">Ind</span>()[<span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span>](<span style="font-family:monospace"><span style="font-style:italic">neg</span></span>:<span style="font-family:sans-serif">Set</span>:=<span style="font-family:monospace"><span style="font-style:italic">neg</span></span>:(<span style="font-style:italic">A</span>→<span style="font-family:monospace"><span style="font-style:italic">False</span></span>) → <span style="font-family:monospace"><span style="font-style:italic">neg</span></span> ). Assuming
<span style="font-style:italic">X</span> has arity <span style="font-family:monospace"><span style="font-style:italic">nat</span></span><span style="font-family:monospace"> → </span><span style="font-family:monospace"><span style="font-style:italic">Prop</span></span> and <span style="font-family:monospace">ex</span> is the inductively
defined existential quantifier, the occurrence of <span style="font-style:italic">X</span> in <span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">ex</span></span><span style="font-family:monospace"> 
</span><span style="font-family:monospace"><span style="font-style:italic">nat</span></span><span style="font-family:monospace">  λ </span><span style="font-family:monospace"><span style="font-style:italic">n</span></span><span style="font-family:monospace">:</span><span style="font-family:monospace"><span style="font-style:italic">nat</span></span><span style="font-family:monospace">.  (</span><span style="font-family:monospace"><span style="font-style:italic">X</span></span><span style="font-family:monospace">  </span><span style="font-family:monospace"><span style="font-style:italic">n</span></span><span style="font-family:monospace">))</span> is also strictly positive.</p>
<h5 id="sec202" class="paragraph">Correctness rules.</h5>
<p>
We shall now describe the rules allowing the introduction of a new
inductive definition.</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">W-Ind</span></dt><dd class="dd-description"> Let <span style="font-style:italic">E</span> be an environment and
Γ,Γ<sub><span style="font-style:italic">P</span></sub>,Γ<sub><span style="font-style:italic">I</span></sub>,Γ<sub><span style="font-style:italic">C</span></sub> are contexts such that
Γ<sub><span style="font-style:italic">I</span></sub> is [<span style="font-style:italic">I</span><sub>1</sub>:∀ Γ<sub><span style="font-style:italic">P</span></sub>,<span style="font-style:italic">A</span><sub>1</sub>;…;<span style="font-style:italic">I</span><sub><span style="font-style:italic">k</span></sub>:∀
Γ<sub><span style="font-style:italic">P</span></sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>] and Γ<sub><span style="font-style:italic">C</span></sub> is 
[<span style="font-style:italic">c</span><sub>1</sub>:∀ Γ<sub><span style="font-style:italic">P</span></sub>,<span style="font-style:italic">C</span><sub>1</sub>;…;<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>:∀ Γ<sub><span style="font-style:italic">P</span></sub>,<span style="font-style:italic">C</span><sub><span style="font-style:italic">n</span></sub>]. 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">
(<span style="font-style:italic">E</span>[Γ;Γ<sub><span style="font-style:italic">P</span></sub>] ⊢ <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub> : <span style="font-style:italic">s</span>′<sub><span style="font-style:italic">j</span></sub>)<sub><span style="font-style:italic">j</span>=1…  <span style="font-style:italic">k</span></sub>
   (<span style="font-style:italic">E</span>[Γ;Γ<sub><span style="font-style:italic">I</span></sub>;Γ<sub><span style="font-style:italic">P</span></sub>] ⊢ <span style="font-style:italic">C</span><sub><span style="font-style:italic">i</span></sub> : <span style="font-style:italic">s</span><sub><span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub></sub>)<sub><span style="font-style:italic">i</span>=1…  <span style="font-style:italic">n</span></sub>
</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="color:red"> </span><span style="color:red"><span style="font-style:italic">W</span></span><span style="color:red"><span style="font-style:italic">F</span></span>(<span style="font-style:italic">E</span>;<span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ))[Γ]</td></tr>
</table></td></tr>
</table></td></tr>
</table>
provided that the following side conditions hold:
<ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">k</span>&gt;0 and all of <span style="font-style:italic">I</span><sub><span style="font-style:italic">j</span></sub> and <span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> are distinct names for <span style="font-style:italic">j</span>=1… <span style="font-style:italic">k</span> and <span style="font-style:italic">i</span>=1… <span style="font-style:italic">n</span>,
</li><li class="li-itemize"><span style="font-style:italic">p</span> is the number of parameters of <span style="font-family:sans-serif">Ind</span>(Γ)(Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> )
and Γ<sub><span style="font-style:italic">P</span></sub> is the context of parameters, 
</li><li class="li-itemize">for <span style="font-style:italic">j</span>=1… <span style="font-style:italic">k</span> we have that <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub> is an arity of sort <span style="font-style:italic">s</span><sub><span style="font-style:italic">j</span></sub> and <span style="font-style:italic">I</span><sub><span style="font-style:italic">j</span></sub>
∉ Γ ∪ <span style="font-style:italic">E</span>,
</li><li class="li-itemize">for <span style="font-style:italic">i</span>=1… <span style="font-style:italic">n</span> we have that <span style="font-style:italic">C</span><sub><span style="font-style:italic">i</span></sub> is a type of constructor of
<span style="font-style:italic">I</span><sub><span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub></sub> which satisfies the positivity condition for <span style="font-style:italic">I</span><sub>1</sub> … <span style="font-style:italic">I</span><sub><span style="font-style:italic">k</span></sub>
and <span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> ∉ Γ ∪ <span style="font-style:italic">E</span>.
</li></ul>
</dd></dl><p>
One can remark that there is a constraint between the sort of the
arity of the inductive type and the sort of the type of its
constructors which will always be satisfied for the impredicative sort
(<span style="font-family:sans-serif">Prop</span>) but may fail to define inductive definition 
on sort <span style="font-family:sans-serif">Set</span> and generate constraints between universes for
inductive definitions in the <span style="font-family:sans-serif">Type</span> hierarchy.</p>
<h5 id="sec203" class="paragraph">Examples.</h5>
<p>
It is well known that existential quantifier can be encoded as an
inductive definition.
The following declaration introduces the second-order existential
quantifier ∃ <span style="font-style:italic">X</span>.<span style="font-style:italic">P</span>(<span style="font-style:italic">X</span>).
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive exProp (P:Prop-</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">Prop) : Prop </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   := exP_intro : forall X:Prop, P X -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> exProp P.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
The same definition on <span style="font-family:sans-serif">Set</span> is not allowed and fails :
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive exSet (P:Set-</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">Prop) : Set </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   := exS_intro : forall X:Set, P X -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> exSet P.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Error: Large non-propositional inductive types must be in Type.</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
It is possible to declare the same inductive definition in the
universe <span style="font-family:sans-serif">Type</span>. 
The <span style="font-family:monospace">exType</span> inductive definition has type (<span style="font-family:sans-serif">Type</span><sub><span style="font-style:italic">i</span></sub> →<span style="font-family:sans-serif">Prop</span>)→
<span style="font-family:sans-serif">Type</span><sub><span style="font-style:italic">j</span></sub> with the constraint that the parameter <span style="font-family:monospace">X</span> of <span style="font-family:monospace">exT_intro</span> has type <span style="font-family:sans-serif">Type</span><sub><span style="font-style:italic">k</span></sub> with <span style="font-style:italic">k</span>&lt;<span style="font-style:italic">j</span> and <span style="font-style:italic">k</span>≤ <span style="font-style:italic">i</span>.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive exType (P:Type-</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">Prop) : Type</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   := exT_intro : forall X:Type, P X -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> exType P.</span></span><span style="font-size:small"><br>
</span></div><h5 id="sec204" class="paragraph">Sort-polymorphism of inductive families.<a id="hevea_default356"></a></h5>
<p>From <span style="font-variant:small-caps">Coq</span> version 8.1, inductive families declared in <span style="font-family:sans-serif">Type</span> are
polymorphic over their arguments in <span style="font-family:sans-serif">Type</span>.</p><p>If <span style="font-style:italic">A</span> is an arity and <span style="font-style:italic">s</span> a sort, we write <span style="font-style:italic">A</span><sub>/<span style="font-style:italic">s</span></sub> for the arity
obtained from <span style="font-style:italic">A</span> by replacing its sort with <span style="font-style:italic">s</span>. Especially, if <span style="font-style:italic">A</span>
is well-typed in some environment and context, then <span style="font-style:italic">A</span><sub>/<span style="font-style:italic">s</span></sub> is typable
by typability of all products in the Calculus of Inductive Constructions.
The following typing rule is added to the theory.</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">Ind-Family</span></dt><dd class="dd-description"> Let <span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) be an
inductive definition. Let Γ<sub><span style="font-style:italic">P</span></sub> = [<span style="font-style:italic">p</span><sub>1</sub>:<span style="font-style:italic">P</span><sub>1</sub>;…;<span style="font-style:italic">p</span><sub><span style="font-style:italic">p</span></sub>:<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span></sub>]
be its context of parameters, Γ<sub><span style="font-style:italic">I</span></sub> = [<span style="font-style:italic">I</span><sub>1</sub>:∀
Γ<sub><span style="font-style:italic">P</span></sub>,<span style="font-style:italic">A</span><sub>1</sub>;…;<span style="font-style:italic">I</span><sub><span style="font-style:italic">k</span></sub>:∀ Γ<sub><span style="font-style:italic">P</span></sub>,<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>] its context of
definitions and Γ<sub><span style="font-style:italic">C</span></sub> = [<span style="font-style:italic">c</span><sub>1</sub>:∀
Γ<sub><span style="font-style:italic">P</span></sub>,<span style="font-style:italic">C</span><sub>1</sub>;…;<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>:∀ Γ<sub><span style="font-style:italic">P</span></sub>,<span style="font-style:italic">C</span><sub><span style="font-style:italic">n</span></sub>] its context of
constructors, with <span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> a constructor of <span style="font-style:italic">I</span><sub><span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub></sub>.<p>Let <span style="font-style:italic">m</span> ≤ <span style="font-style:italic">p</span> be the length of the longest prefix of parameters
such that the <span style="font-style:italic">m</span> first arguments of all occurrences of all <span style="font-style:italic">I</span><sub><span style="font-style:italic">j</span></sub> in
all <span style="font-style:italic">C</span><sub><span style="font-style:italic">k</span></sub> (even the occurrences in the hypotheses of <span style="font-style:italic">C</span><sub><span style="font-style:italic">k</span></sub>) are
exactly applied to <span style="font-style:italic">p</span><sub>1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> (<span style="font-style:italic">m</span> is the number of <em>recursively uniform parameters</em> and the <span style="font-style:italic">p</span>−<span style="font-style:italic">m</span> remaining parameters
are the <em>recursively non-uniform parameters</em>). Let <span style="font-style:italic">q</span><sub>1</sub>,
…, <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub>, with 0≤ <span style="font-style:italic">r</span>≤ <span style="font-style:italic">m</span>, be a (possibly) partial
instantiation of the recursively uniform parameters of
Γ<sub><span style="font-style:italic">P</span></sub>. We have:</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎧<br>
⎪<br>
⎨<br>
⎪<br>
⎩</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) ∈ <span style="font-style:italic">E</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">q</span><sub><span style="font-style:italic">l</span></sub> : <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">l</span></sub>)<sub><span style="font-style:italic">l</span>=1… <span style="font-style:italic">r</span></sub></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">l</span></sub> ≤<sub>βδιζη</sub> <span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub>{<span style="font-style:italic">p</span><sub><span style="font-style:italic">u</span></sub>/<span style="font-style:italic">q</span><sub><span style="font-style:italic">u</span></sub>}<sub><span style="font-style:italic">u</span>=1… <span style="font-style:italic">l</span>−1</sub>)<sub><span style="font-style:italic">l</span>=1… <span style="font-style:italic">r</span></sub></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >1 ≤ <span style="font-style:italic">j</span> ≤ <span style="font-style:italic">k</span>
</td></tr>
</table></td><td class="dcell">
</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ (<span style="font-style:italic">I</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">q</span><sub>1</sub> … <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub>:∀ [<span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span>+1</sub>:<span style="font-style:italic">P</span><sub><span style="font-style:italic">r</span>+1</sub>;…;<span style="font-style:italic">p</span><sub><span style="font-style:italic">p</span></sub>:<span style="font-style:italic">P</span><sub><span style="font-style:italic">p</span></sub>], (<span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub>)<sub>/<span style="font-style:italic">s</span><sub><span style="font-style:italic">j</span></sub></sub>)</td></tr>
</table></td></tr>
</table><p>provided that the following side conditions hold:</p><ul class="itemize"><li class="li-itemize">
Γ<sub><span style="font-style:italic">P</span>′</sub> is the context obtained from Γ<sub><span style="font-style:italic">P</span></sub> by
replacing each <span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub> that is an arity with <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">l</span></sub> for 1≤ <span style="font-style:italic">l</span> ≤ <span style="font-style:italic">r</span> (notice that
<span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub> arity implies <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">l</span></sub> arity since <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">P</span>′<sub><span style="font-style:italic">l</span></sub> ≤<sub>βδιζη</sub>  <span style="font-style:italic">P</span><sub><span style="font-style:italic">l</span></sub>{<span style="font-style:italic">p</span><sub><span style="font-style:italic">u</span></sub>/<span style="font-style:italic">q</span><sub><span style="font-style:italic">u</span></sub>}<sub><span style="font-style:italic">u</span>=1… <span style="font-style:italic">l</span>−1</sub>);
</li><li class="li-itemize">there are sorts <span style="font-style:italic">s</span><sub><span style="font-style:italic">i</span></sub>, for 1 ≤ <span style="font-style:italic">i</span> ≤ <span style="font-style:italic">k</span> such that, for
Γ<sub><span style="font-style:italic">I</span>′</sub> = [<span style="font-style:italic">I</span><sub>1</sub>:∀
Γ<sub><span style="font-style:italic">P</span>′</sub>,(<span style="font-style:italic">A</span><sub>1</sub>)<sub>/<span style="font-style:italic">s</span><sub>1</sub></sub>;…;<span style="font-style:italic">I</span><sub><span style="font-style:italic">k</span></sub>:∀ Γ<sub><span style="font-style:italic">P</span>′</sub>,(<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>)<sub>/<span style="font-style:italic">s</span><sub><span style="font-style:italic">k</span></sub></sub>]
we have (<span style="font-style:italic">E</span>[Γ;Γ<sub><span style="font-style:italic">I</span>′</sub>;Γ<sub><span style="font-style:italic">P</span>′</sub>] ⊢ <span style="font-style:italic">C</span><sub><span style="font-style:italic">i</span></sub> : <span style="font-style:italic">s</span><sub><span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub></sub>)<sub><span style="font-style:italic">i</span>=1… <span style="font-style:italic">n</span></sub>;
</li><li class="li-itemize">the sorts are such that all eliminations, to <span style="font-family:sans-serif">Prop</span>, <span style="font-family:sans-serif">Set</span> and
<span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">j</span>), are allowed (see section <a href="#elimdep">4.5.4</a>).
</li></ul></dd></dl><p>Notice that if <span style="font-style:italic">I</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">q</span><sub>1</sub> … <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub> is typable using the rules <span style="font-weight:bold">Ind-Const</span> and <span style="font-weight:bold">App</span>, then it is typable using the rule <span style="font-weight:bold">Ind-Family</span>. Conversely, the extended theory is not stronger than the
theory without <span style="font-weight:bold">Ind-Family</span>. We get an equiconsistency result by
mapping each <span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) occurring into a
given derivation into as many different inductive types and constructors
as the number of different (partial) replacements of sorts, needed for
this derivation, in the parameters that are arities (this is possible
because <span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) well-formed implies
that <span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span>′</sub>:=Γ<sub><span style="font-style:italic">C</span>′</sub> ) is well-formed and
has the same allowed eliminations, where
Γ<sub><span style="font-style:italic">I</span>′</sub> is defined as above and Γ<sub><span style="font-style:italic">C</span>′</sub> = [<span style="font-style:italic">c</span><sub>1</sub>:∀
Γ<sub><span style="font-style:italic">P</span>′</sub>,<span style="font-style:italic">C</span><sub>1</sub>;…;<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>:∀ Γ<sub><span style="font-style:italic">P</span>′</sub>,<span style="font-style:italic">C</span><sub><span style="font-style:italic">n</span></sub>]). That is,
the changes in the types of each partial instance
<span style="font-style:italic">q</span><sub>1</sub> … <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub> can be characterized by the ordered sets of arity
sorts among the types of parameters, and to each signature is
associated a new inductive definition with fresh names. Conversion is
preserved as any (partial) instance <span style="font-style:italic">I</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">q</span><sub>1</sub> … <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub> or
<span style="font-style:italic">C</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">q</span><sub>1</sub> … <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub> is mapped to the names chosen in the specific
instance of <span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">p</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ).</p><p>In practice, the rule <span style="font-weight:bold">Ind-Family</span> is used by <span style="font-variant:small-caps">Coq</span> only when all the
inductive types of the inductive definition are declared with an arity whose 
sort is in the <span style="font-family:sans-serif">Type</span>
hierarchy. Then, the polymorphism is over the parameters whose
type is an arity of sort in the <span style="font-family:sans-serif">Type</span> hierarchy. 
The sort <span style="font-style:italic">s</span><sub><span style="font-style:italic">j</span></sub> are
chosen canonically so that each <span style="font-style:italic">s</span><sub><span style="font-style:italic">j</span></sub> is minimal with respect to the
hierarchy <span style="font-family:sans-serif">Prop</span>⊂<span style="font-family:sans-serif">Set</span><sub><span style="font-style:italic">p</span></sub>⊂<span style="font-family:sans-serif">Type</span> where <span style="font-family:sans-serif">Set</span><sub><span style="font-style:italic">p</span></sub> is
predicative <span style="font-family:sans-serif">Set</span>.
More precisely, an empty or small singleton inductive definition
(i.e. an inductive definition of which all inductive types are
singleton – see paragraph <a href="#sec209">4.5.4</a>) is set in
<span style="font-family:sans-serif">Prop</span>, a small non-singleton inductive family is set in <span style="font-family:sans-serif">Set</span> (even
in case <span style="font-family:sans-serif">Set</span> is impredicative – see Section <a href="#sec220">4.7</a>),
and otherwise in the <span style="font-family:sans-serif">Type</span> hierarchy.
</p><p>Note that the side-condition about allowed elimination sorts in the
rule <span style="font-weight:bold">Ind-Family</span> is just to avoid to recompute the allowed
elimination sorts at each instance of a pattern-matching (see
section <a href="#elimdep">4.5.4</a>).</p><p>As an example, let us consider the following definition:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive option (A:Type) : Type := </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> | None : option A </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> | Some : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> option A.</span></span><span style="font-size:small"><br>
</span></div><p>As the definition is set in the <span style="font-family:sans-serif">Type</span> hierarchy, it is used
polymorphically over its parameters whose types are arities of a sort
in the <span style="font-family:sans-serif">Type</span> hierarchy. Here, the parameter <span style="font-style:italic">A</span> has this property,
hence, if <span style="font-family:monospace">option</span> is applied to a type in <span style="font-family:sans-serif">Set</span>, the result is
in <span style="font-family:sans-serif">Set</span>. Note that if <span style="font-family:monospace">option</span> is applied to a type in <span style="font-family:sans-serif">Prop</span>,
then, the result is not set in <span style="font-family:monospace">Prop</span> but in <span style="font-family:monospace">Set</span>
still. This is because <span style="font-family:monospace">option</span> is not a singleton type (see
section <a href="#sec209">4.5.4</a>) and it would loose the elimination to <span style="font-family:sans-serif">Set</span> and
<span style="font-family:sans-serif">Type</span> if set in <span style="font-family:sans-serif">Prop</span>.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun A:Set =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> option A).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun A : Set =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> option A</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Set -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun A:Prop =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> option A).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun A : Prop =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> option A</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Prop -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set</span></span></span><span style="font-size:small"><br>
</span></div><p>Here is another example.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive prod (A B:Type) : Type := pair : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> prod A B.</span></span><span style="font-size:small"><br>
</span></div><p>As <span style="font-family:monospace">prod</span> is a singleton type, it will be in <span style="font-family:sans-serif">Prop</span> if applied
twice to propositions, in <span style="font-family:sans-serif">Set</span> if applied twice to at least one type
in <span style="font-family:sans-serif">Set</span> and none in <span style="font-family:sans-serif">Type</span>, and in <span style="font-family:sans-serif">Type</span> otherwise. In all cases,
the three kind of eliminations schemes are allowed.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun A:Set =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> prod A).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun A : Set =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> prod A</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Set -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Type -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Type</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun A:Prop =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> prod A A).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun A : Prop =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> prod A A</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Prop -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun (A:Prop) (B:Set) =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> prod A B).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun (A : Prop) (B : Set) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> prod A B</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Prop -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun (A:Type) (B:Prop) =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> prod A B).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun (A : Type) (B : Prop) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> prod A B</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Type -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Type</span></span></span><span style="font-size:small"><br>
</span></div>
<h3 id="sec205" class="subsection">4.5.4  Destructors</h3>
<p>
The specification of inductive definitions with arities and
constructors is quite natural. But we still have to say how to use an
object in an inductive type.</p><p>This problem is rather delicate. There are actually several different
ways to do that. Some of them are logically equivalent but not always
equivalent from the computational point of view or from the user point
of view.</p><p>From the computational point of view, we want to be able to define a
function whose domain is an inductively defined type by using a
combination of case analysis over the possible constructors of the
object and recursion.</p><p>Because we need to keep a consistent theory and also we prefer to keep
a strongly normalizing reduction, we cannot accept any sort of
recursion (even terminating). So the basic idea is to restrict
ourselves to primitive recursive functions and functionals.</p><p>For instance, assuming a parameter <span style="font-style:italic">A</span>:<span style="font-family:sans-serif">Set</span> exists in the context, we
want to build a function <span style="font-family:sans-serif">length</span> of type <span style="font-family:sans-serif">List_A</span>→ <span style="font-family:sans-serif">nat</span> which
computes the length of the list, so such that (<span style="font-family:sans-serif">length</span> (<span style="font-family:sans-serif">nil</span> <span style="font-style:italic">A</span>)) = <span style="font-family:sans-serif">O</span>
and (<span style="font-family:sans-serif">length</span> (<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span>)) = (<span style="font-family:sans-serif">S</span> (<span style="font-family:sans-serif">length</span> <span style="font-style:italic">l</span>)). We want these
equalities to be recognized implicitly and taken into account in the
conversion rule.</p><p>From the logical point of view, we have built a type family by giving
a set of constructors. We want to capture the fact that we do not
have any other way to build an object in this type. So when trying to
prove a property (<span style="font-style:italic">P</span> <span style="font-style:italic">m</span>) for <span style="font-style:italic">m</span> in an inductive definition it is
enough to enumerate all the cases where <span style="font-style:italic">m</span> starts with a different
constructor.</p><p>In case the inductive definition is effectively a recursive one, we
want to capture the extra property that we have built the smallest
fixed point of this recursive equation. This says that we are only
manipulating finite objects. This analysis provides induction
principles.</p><p>For instance, in order to prove ∀ <span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>,(<span style="font-family:sans-serif">Length_A</span> <span style="font-style:italic">l</span> (<span style="font-family:sans-serif">length</span> <span style="font-style:italic">l</span>))
it is enough to prove:</p><p>(<span style="font-family:sans-serif">Length_A</span> (<span style="font-family:sans-serif">nil</span> <span style="font-style:italic">A</span>) (<span style="font-family:sans-serif">length</span> (<span style="font-family:sans-serif">nil</span> <span style="font-style:italic">A</span>))) and</p><p><br>
∀ <span style="font-style:italic">a</span>:<span style="font-style:italic">A</span>, ∀ <span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>, (<span style="font-family:sans-serif">Length_A</span> <span style="font-style:italic">l</span> (<span style="font-family:sans-serif">length</span> <span style="font-style:italic">l</span>)) →
(<span style="font-family:sans-serif">Length_A</span> (<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span>) (<span style="font-family:sans-serif">length</span> (<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span>))).
<br>
</p><p>which given the conversion equalities satisfied by <span style="font-family:sans-serif">length</span> is the
same as proving:
(<span style="font-family:sans-serif">Length_A</span> (<span style="font-family:sans-serif">nil</span> <span style="font-style:italic">A</span>) <span style="font-family:sans-serif">O</span>) and ∀ <span style="font-style:italic">a</span>:<span style="font-style:italic">A</span>, ∀ <span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>, 
(<span style="font-family:sans-serif">Length_A</span> <span style="font-style:italic">l</span> (<span style="font-family:sans-serif">length</span> <span style="font-style:italic">l</span>)) →
(<span style="font-family:sans-serif">Length_A</span> (<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span>) (<span style="font-family:sans-serif">S</span> (<span style="font-family:sans-serif">length</span> <span style="font-style:italic">l</span>))).</p><p>One conceptually simple way to do that, following the basic scheme
proposed by Martin-Löf in his Intuitionistic Type Theory, is to
introduce for each inductive definition an elimination operator. At
the logical level it is a proof of the usual induction principle and
at the computational level it implements a generic operator for doing
primitive recursion over the structure.</p><p>But this operator is rather tedious to implement and use. We choose in
this version of Coq to factorize the operator for primitive recursion
into two more primitive operations as was first suggested by Th. Coquand
in [<a href="biblio.html#Coq92">27</a>]. One is the definition by pattern-matching. The second one is a definition by guarded fixpoints. </p><h4 id="sec206" class="subsubsection">The <span style="font-family:monospace">match…with …end</span> construction.
<a id="hevea_default357"></a></h4>
<p>The basic idea of this destructor operation is that we have an object
<span style="font-style:italic">m</span> in an inductive type <span style="font-style:italic">I</span> and we want to prove a property (<span style="font-style:italic">P</span> <span style="font-style:italic">m</span>)
which in general depends on <span style="font-style:italic">m</span>. For this, it is enough to prove the
property for <span style="font-style:italic">m</span> = (<span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">u</span><sub>1</sub>… <span style="font-style:italic">u</span><sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub></sub>) for each constructor of <span style="font-style:italic">I</span>.</p><p>The <span style="font-variant:small-caps">Coq</span> term for this proof will be written :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">match</span> <span style="font-style:italic">m</span> <span style="font-family:sans-serif">with</span>  (<span style="font-style:italic">c</span><sub>1</sub> <span style="font-style:italic">x</span><sub>11</sub> ... <span style="font-style:italic">x</span><sub>1<span style="font-style:italic">p</span><sub>1</sub></sub>) ⇒ <span style="font-style:italic">f</span><sub>1</sub>  | … | 
(<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>1</sub>...<span style="font-style:italic">x</span><sub><span style="font-style:italic">np</span><sub><span style="font-style:italic">n</span></sub></sub>) ⇒ <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>  <span style="font-family:sans-serif">end</span></td></tr>
</table><p>
In this expression, if
<span style="font-style:italic">m</span> is a term built from a constructor (<span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">u</span><sub>1</sub>… <span style="font-style:italic">u</span><sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub></sub>) then
the expression will behave as it is specified with <span style="font-style:italic">i</span>-th branch and
will reduce to <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> where the <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span>1</sub>…<span style="font-style:italic">x</span><sub><span style="font-style:italic">ip</span><sub><span style="font-style:italic">i</span></sub></sub> are replaced
by the <span style="font-style:italic">u</span><sub>1</sub>… <span style="font-style:italic">u</span><sub><span style="font-style:italic">p</span></sub> according to the ι-reduction.</p><p>Actually, for type-checking a <span style="font-family:sans-serif">match…with…end</span>
expression we also need to know the predicate <span style="font-style:italic">P</span> to be proved by case
analysis. In the general case where <span style="font-style:italic">I</span> is an inductively defined
<span style="font-style:italic">n</span>-ary relation, <span style="font-style:italic">P</span> is a <span style="font-style:italic">n</span>+1-ary relation: the <span style="font-style:italic">n</span> first arguments
correspond to the arguments of <span style="font-style:italic">I</span> (parameters excluded), and the last
one corresponds to object <span style="font-style:italic">m</span>. <span style="font-variant:small-caps">Coq</span> can sometimes infer this
predicate but sometimes not. The concrete syntax for describing this
predicate uses the <span style="font-family:sans-serif">as…in…return</span> construction. For
instance, let us assume that <span style="font-style:italic">I</span> is an unary predicate with one
parameter. The predicate is made explicit using the syntax :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">match</span> <span style="font-style:italic">m</span> <span style="font-family:sans-serif">as</span>  <span style="font-style:italic">x</span>  <span style="font-family:sans-serif">in</span>  <span style="font-style:italic">I</span> <code>_</code> <span style="font-style:italic">a</span>  <span style="font-family:sans-serif">return</span>  (<span style="font-style:italic">P</span>  <span style="font-style:italic">x</span>)
 <span style="font-family:sans-serif">with</span>  (<span style="font-style:italic">c</span><sub>1</sub> <span style="font-style:italic">x</span><sub>11</sub> ... <span style="font-style:italic">x</span><sub>1<span style="font-style:italic">p</span><sub>1</sub></sub>) ⇒ <span style="font-style:italic">f</span><sub>1</sub>  | … | 
(<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>1</sub>...<span style="font-style:italic">x</span><sub><span style="font-style:italic">np</span><sub><span style="font-style:italic">n</span></sub></sub>) ⇒ <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:sans-serif">end</span></td></tr>
</table><p>
The <span style="font-family:sans-serif">as</span> part can be omitted if either the result type does not
depend on <span style="font-style:italic">m</span> (non-dependent elimination) or <span style="font-style:italic">m</span> is a variable (in
this case, the result type can depend on <span style="font-style:italic">m</span>). The <span style="font-family:sans-serif">in</span> part can be
omitted if the result type does not depend on the arguments of
<span style="font-style:italic">I</span>. Note that the arguments of <span style="font-style:italic">I</span> corresponding to parameters
<em>must</em> be <code>_</code>, because the result type is not generalized to
all possible values of the parameters. The expression after <span style="font-family:sans-serif">in</span>
must be seen as an <em>inductive type pattern</em>. As a final remark,
expansion of implicit arguments and notations apply to this pattern.</p><p>For the purpose of presenting the inference rules, we use a more
compact notation :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">case</span>(<span style="font-style:italic">m</span>,(λ <span style="font-style:italic">a</span> <span style="font-style:italic">x</span> .  <span style="font-style:italic">P</span>), λ <span style="font-style:italic">x</span><sub>11</sub> ... <span style="font-style:italic">x</span><sub>1<span style="font-style:italic">p</span><sub>1</sub></sub> .  <span style="font-style:italic">f</span><sub>1</sub>  | … | 
λ <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span>1</sub>...<span style="font-style:italic">x</span><sub><span style="font-style:italic">np</span><sub><span style="font-style:italic">n</span></sub></sub> .  <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table><h5 id="sec207" class="paragraph">Allowed elimination sorts.<a id="hevea_default358"></a></h5>
<p>An important question for building the typing rule for <span style="font-family:sans-serif">match</span> is
what can be the type of <span style="font-style:italic">P</span> with respect to the type of the inductive
definitions.</p><p>We define now a relation [<span style="font-style:italic">I</span>:<span style="font-style:italic">A</span>|<span style="font-style:italic">B</span>] between an inductive
definition <span style="font-style:italic">I</span> of type <span style="font-style:italic">A</span> and an arity <span style="font-style:italic">B</span>. This relation states that
an object in the inductive definition <span style="font-style:italic">I</span> can be eliminated for
proving a property <span style="font-style:italic">P</span> of type <span style="font-style:italic">B</span>.</p><p>The case of inductive definitions in sorts <span style="font-family:sans-serif">Set</span> or <span style="font-family:sans-serif">Type</span> is simple.
There is no restriction on the sort of the predicate to be
eliminated. </p>
<h5 id="sec208" class="paragraph">Notations.</h5>
<p>
The [<span style="font-style:italic">I</span>:<span style="font-style:italic">A</span>|<span style="font-style:italic">B</span>] is defined as the smallest relation satisfying the
following rules:
We write [<span style="font-style:italic">I</span>|<span style="font-style:italic">B</span>] for [<span style="font-style:italic">I</span>:<span style="font-style:italic">A</span>|<span style="font-style:italic">B</span>] where <span style="font-style:italic">A</span> is the type of
<span style="font-style:italic">I</span>.</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">Prod</span></dt><dd class="dd-description"> <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">[(<span style="font-style:italic">I</span> <span style="font-style:italic">x</span>):<span style="font-style:italic">A</span>′|<span style="font-style:italic">B</span>′]</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">[<span style="font-style:italic">I</span>:∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>, <span style="font-style:italic">A</span>′|∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>, <span style="font-style:italic">B</span>′]</td></tr>
</table></td></tr>
</table>
</dd><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:sans-serif">Set</span></span><span style="font-weight:bold"> &amp; </span><span style="font-weight:bold"><span style="font-family:sans-serif">Type</span></span></dt><dd class="dd-description"> <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">
<span style="font-style:italic">s</span><sub>1</sub> ∈ {<span style="font-family:sans-serif">Set</span>,<span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">j</span>)}, 
<span style="font-style:italic">s</span><sub>2</sub> ∈ <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">S</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">[<span style="font-style:italic">I</span>:<span style="font-style:italic">s</span><sub>1</sub>|<span style="font-style:italic">I</span>→ <span style="font-style:italic">s</span><sub>2</sub>]</td></tr>
</table></td></tr>
</table>
</dd></dl><p>The case of Inductive definitions of sort <span style="font-family:sans-serif">Prop</span> is a bit more
complicated, because of our interpretation of this sort. The only
harmless allowed elimination, is the one when predicate <span style="font-style:italic">P</span> is also of
sort <span style="font-family:sans-serif">Prop</span>.
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold"><span style="font-family:sans-serif">Prop</span></span></dt><dd class="dd-description"> <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">[<span style="font-style:italic">I</span>:<span style="font-family:sans-serif">Prop</span>|<span style="font-style:italic">I</span>→<span style="font-family:sans-serif">Prop</span>]</td></tr>
</table>
</dd></dl><p>
<span style="font-family:sans-serif">Prop</span> is the type of logical propositions, the proofs of properties
<span style="font-style:italic">P</span> in <span style="font-family:sans-serif">Prop</span> could not be used for computation and are consequently
ignored by the extraction mechanism.
Assume <span style="font-style:italic">A</span> and <span style="font-style:italic">B</span> are two propositions, and the logical disjunction
<span style="font-style:italic">A</span>∨ <span style="font-style:italic">B</span> is defined inductively by :
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive or (A B:Prop) : Prop :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   lintro : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> or A B | rintro : B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> or A B.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
The following definition which computes a boolean value by case over
the proof of <span style="font-family:monospace">or A B</span> is not accepted :
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition choice (A B: Prop) (x:or A B) := </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">    match x with lintro a =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> true | rintro b =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> false end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Error:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Incorrect elimination of "x" in the inductive type "or":</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">the return type has sort "Set" while it should be "Prop".</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Elimination of an inductive object of sort Prop</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">is not allowed on a predicate in sort Set</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">because proofs can be eliminated only to build proofs.</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
From the computational point of view, the structure of the proof of
<span style="font-family:monospace">(or A B)</span> in this term is needed for computing the boolean
value.</p><p>In general, if <span style="font-style:italic">I</span> has type <span style="font-family:sans-serif">Prop</span> then <span style="font-style:italic">P</span> cannot have type <span style="font-style:italic">I</span>→
<span style="font-family:sans-serif">Set</span>, because it will mean to build an informative proof of type
(<span style="font-style:italic">P</span> <span style="font-style:italic">m</span>) doing a case analysis over a non-computational object that
will disappear in the extracted program. But the other way is safe
with respect to our interpretation we can have <span style="font-style:italic">I</span> a computational
object and <span style="font-style:italic">P</span> a non-computational one, it just corresponds to proving
a logical property of a computational object.</p><p>In the same spirit, elimination on <span style="font-style:italic">P</span> of type <span style="font-style:italic">I</span>→
<span style="font-family:sans-serif">Type</span> cannot be allowed because it trivially implies the elimination
on <span style="font-style:italic">P</span> of type <span style="font-style:italic">I</span>→ <span style="font-family:sans-serif">Set</span> by cumulativity. It also implies that there
is two proofs of the same property which are provably different,
contradicting the proof-irrelevance property which is sometimes a
useful axiom :
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Axiom proof_irrelevance : forall (P : Prop) (x y : P), x=y.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">proof_irrelevance is assumed</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
The elimination of an inductive definition of type <span style="font-family:sans-serif">Prop</span> on a
predicate <span style="font-style:italic">P</span> of type <span style="font-style:italic">I</span>→ <span style="font-family:sans-serif">Type</span> leads to a paradox when applied to 
impredicative inductive definition like the second-order existential
quantifier <span style="font-family:monospace">exProp</span> defined above, because it give access to
the two projections on this type.</p><h5 id="sec209" class="paragraph">Empty and singleton elimination
<a id="hevea_default359"></a>
<a id="hevea_default360"></a></h5>
<p>There are special inductive definitions in <span style="font-family:sans-serif">Prop</span> for which more
eliminations are allowed. 
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold"><span style="font-family:sans-serif">Prop</span></span><span style="font-weight:bold">-extended</span></dt><dd class="dd-description"> 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">I</span>  is an empty or singleton
definition   <span style="font-style:italic">s</span> ∈ <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">S</span></span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">[<span style="font-style:italic">I</span>:<span style="font-family:sans-serif">Prop</span>|<span style="font-style:italic">I</span>→ <span style="font-style:italic">s</span>]</td></tr>
</table></td></tr>
</table></td></tr>
</table>
</dd></dl><p>A <em>singleton
definition</em> has only one constructor and all the arguments of this
constructor have type <span style="font-family:sans-serif">Prop</span>. In that case, there is a canonical
way to interpret the informative extraction on an object in that type,
such that the elimination on any sort <span style="font-style:italic">s</span> is legal. Typical examples are
the conjunction of non-informative propositions and the equality. 
If there is an hypothesis <span style="font-style:italic">h</span>:<span style="font-style:italic">a</span>=<span style="font-style:italic">b</span> in the context, it can be used for
rewriting not only in logical propositions but also in any type.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print eq_rec.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">eq_rec = </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun (A : Type) (x : A) (P : A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> eq_rect x P</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall (A : Type) (x : A) (P : A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set),</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       P x -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> forall y : A, x = y -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument A is implicit</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument scopes are [type_scope _ _ _ _ _]</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Extraction eq_rec.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">(** val eq_rec : ’a1 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> ’a2 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> ’a1 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> ’a2 **)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">let eq_rec x f y =</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  f</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
An empty definition has no constructors, in that case also,
elimination on any sort is allowed.</p>
<h5 id="sec210" class="paragraph">Type of branches.</h5>
<p>
Let <span style="font-style:italic">c</span> be a term of type <span style="font-style:italic">C</span>, we assume <span style="font-style:italic">C</span> is a type of constructor
for an inductive definition <span style="font-style:italic">I</span>. Let <span style="font-style:italic">P</span> be a term that represents the
property to be proved.
We assume <span style="font-style:italic">r</span> is the number of parameters.</p><p>We define a new type {<span style="font-style:italic">c</span>:<span style="font-style:italic">C</span>}<sup><span style="font-style:italic">P</span></sup> which represents the type of the
branch corresponding to the <span style="font-style:italic">c</span>:<span style="font-style:italic">C</span> constructor.
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >{<span style="font-style:italic">c</span>:(<span style="font-style:italic">I</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sub>1</sub>… <span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub> <span style="font-style:italic">t</span><sub>1</sub> … <span style="font-style:italic">t</span><sub><span style="font-style:italic">p</span></sub>)}<sup><span style="font-style:italic">P</span></sup></td><td style="text-align:left;white-space:nowrap" >≡ (<span style="font-style:italic">P</span> <span style="font-style:italic">t</span><sub>1</sub>…  <span style="font-style:italic">t</span><sub><span style="font-style:italic">p</span></sub> <span style="font-style:italic">c</span>) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >{<span style="font-style:italic">c</span>:∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">C</span>}<sup><span style="font-style:italic">P</span></sup></td><td style="text-align:left;white-space:nowrap" >≡ ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,{(<span style="font-style:italic">c</span> <span style="font-style:italic">x</span>):<span style="font-style:italic">C</span>}<sup><span style="font-style:italic">P</span></sup> 
</td></tr>
</table></td></tr>
</table><p>
We write {<span style="font-style:italic">c</span>}<sup><span style="font-style:italic">P</span></sup> for {<span style="font-style:italic">c</span>:<span style="font-style:italic">C</span>}<sup><span style="font-style:italic">P</span></sup> with <span style="font-style:italic">C</span> the type of <span style="font-style:italic">c</span>.</p>
<h5 id="sec211" class="paragraph">Examples.</h5>
<p>
For <span style="font-family:sans-serif">List_A</span> the type of <span style="font-style:italic">P</span> will be <span style="font-family:sans-serif">List_A</span>→ <span style="font-style:italic">s</span> for <span style="font-style:italic">s</span> ∈ <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">S</span></span>. <br>
 {(<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span>)}<sup><span style="font-style:italic">P</span></sup> ≡
∀ <span style="font-style:italic">a</span>:<span style="font-style:italic">A</span>, ∀ <span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>,(<span style="font-style:italic">P</span> (<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span>)).</p><p>For <span style="font-family:sans-serif">Length_A</span>, the type of <span style="font-style:italic">P</span> will be
∀ <span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>,∀ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>, (<span style="font-family:sans-serif">Length_A</span> <span style="font-style:italic">l</span> <span style="font-style:italic">n</span>)→ <span style="font-family:sans-serif">Prop</span> and the expression
{(<span style="font-family:sans-serif">Lcons</span> <span style="font-style:italic">A</span>)}<sup><span style="font-style:italic">P</span></sup> is defined as:<br>
∀ <span style="font-style:italic">a</span>:<span style="font-style:italic">A</span>, ∀ <span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>, ∀ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>, ∀
<span style="font-style:italic">h</span>:(<span style="font-family:sans-serif">Length_A</span> <span style="font-style:italic">l</span> <span style="font-style:italic">n</span>), (<span style="font-style:italic">P</span> (<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span>) (<span style="font-family:sans-serif">S</span> <span style="font-style:italic">n</span>) (<span style="font-family:sans-serif">Lcons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span> <span style="font-style:italic">n</span> <span style="font-style:italic">l</span>)).<br>
If <span style="font-style:italic">P</span> does not depend on its third argument, we find the more natural
expression:<br>
∀ <span style="font-style:italic">a</span>:<span style="font-style:italic">A</span>, ∀ <span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>, ∀ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>,
(<span style="font-family:sans-serif">Length_A</span> <span style="font-style:italic">l</span> <span style="font-style:italic">n</span>)→(<span style="font-style:italic">P</span> (<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span>) (<span style="font-family:sans-serif">S</span> <span style="font-style:italic">n</span>)).</p>
<h5 id="sec212" class="paragraph">Typing rule.</h5>
<p>Our very general destructor for inductive definition enjoys the
following typing rule
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">match</span></dt><dd class="dd-description"> <a id="elimdep"></a> <a id="hevea_default361"></a>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">c</span> : (<span style="font-style:italic">I</span> <span style="font-style:italic">q</span><sub>1</sub>…  <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub> <span style="font-style:italic">t</span><sub>1</sub>…  <span style="font-style:italic">t</span><sub><span style="font-style:italic">s</span></sub>)  
<span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">P</span> : <span style="font-style:italic">B</span>  [(<span style="font-style:italic">I</span> <span style="font-style:italic">q</span><sub>1</sub>… <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub>)|<span style="font-style:italic">B</span>]
  
(<span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> : {(<span style="font-style:italic">c</span><sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub></sub> <span style="font-style:italic">q</span><sub>1</sub>… <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub>)}<sup><span style="font-style:italic">P</span></sup>)<sub><span style="font-style:italic">i</span>=1…  <span style="font-style:italic">l</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:sans-serif">case</span>(<span style="font-style:italic">c</span>,<span style="font-style:italic">P</span>,<span style="font-style:italic">f</span><sub>1</sub>|… |<span style="font-style:italic">f</span><sub><span style="font-style:italic">l</span></sub>) : (<span style="font-style:italic">P</span> <span style="font-style:italic">t</span><sub>1</sub>…  <span style="font-style:italic">t</span><sub><span style="font-style:italic">s</span></sub> <span style="font-style:italic">c</span>)</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>provided <span style="font-style:italic">I</span> is an inductive type in a declaration
<span style="font-family:sans-serif">Ind</span>(Δ)[<span style="font-style:italic">r</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ) with 
Γ<sub><span style="font-style:italic">C</span></sub> = [<span style="font-style:italic">c</span><sub>1</sub>:<span style="font-style:italic">C</span><sub>1</sub>;…;<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">C</span><sub><span style="font-style:italic">n</span></sub>] and <span style="font-style:italic">c</span><sub><span style="font-style:italic">p</span><sub>1</sub></sub>… <span style="font-style:italic">c</span><sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">l</span></sub></sub> are the
only constructors of <span style="font-style:italic">I</span>.
</p></dd></dl>
<h5 id="sec213" class="paragraph">Example.</h5>
<p>
For <span style="font-family:sans-serif">List</span> and <span style="font-family:sans-serif">Length</span> the typing rules for the <span style="font-family:monospace">match</span> expression
are (writing just <span style="font-style:italic">t</span>:<span style="font-style:italic">M</span> instead of <span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">t</span> : <span style="font-style:italic">M</span>, the environment and
context being the same in all the judgments).</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>  <span style="font-style:italic">P</span>:<span style="font-family:sans-serif">List_A</span>→ <span style="font-style:italic">s</span>   <span style="font-style:italic">f</span><sub>1</sub>:(<span style="font-style:italic">P</span> (<span style="font-family:sans-serif">nil</span> <span style="font-style:italic">A</span>))  
<span style="font-style:italic">f</span><sub>2</sub>:∀ <span style="font-style:italic">a</span>:<span style="font-style:italic">A</span>, ∀ <span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>, (<span style="font-style:italic">P</span> (<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span>))</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-family:sans-serif">case</span>(<span style="font-style:italic">l</span>,<span style="font-style:italic">P</span>,<span style="font-style:italic">f</span><sub>1</sub> | <span style="font-style:italic">f</span><sub>2</sub>):(<span style="font-style:italic">P</span> <span style="font-style:italic">l</span>)</td></tr>
</table></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span>:(<span style="font-family:sans-serif">Length_A</span> <span style="font-style:italic">L</span> <span style="font-style:italic">N</span>) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">P</span>:∀ <span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>, ∀ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>, (<span style="font-family:sans-serif">Length_A</span> <span style="font-style:italic">l</span> <span style="font-style:italic">n</span>)→
<span style="font-family:sans-serif">Prop</span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">f</span><sub>1</sub>:(<span style="font-style:italic">P</span> (<span style="font-family:sans-serif">nil</span> <span style="font-style:italic">A</span>) <span style="font-family:sans-serif">O</span> <span style="font-family:sans-serif">Lnil</span>) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >   <span style="font-style:italic">f</span><sub>2</sub>:∀ <span style="font-style:italic">a</span>:<span style="font-style:italic">A</span>, ∀ <span style="font-style:italic">l</span>:<span style="font-family:sans-serif">List_A</span>, ∀ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>, ∀
<span style="font-style:italic">h</span>:(<span style="font-family:sans-serif">Length_A</span> <span style="font-style:italic">l</span> <span style="font-style:italic">n</span>), (<span style="font-style:italic">P</span> (<span style="font-family:sans-serif">cons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">n</span>) (<span style="font-family:sans-serif">S</span> <span style="font-style:italic">n</span>) (<span style="font-family:sans-serif">Lcons</span> <span style="font-style:italic">A</span> <span style="font-style:italic">a</span> <span style="font-style:italic">l</span> <span style="font-style:italic">n</span> <span style="font-style:italic">h</span>)) 
</td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-family:sans-serif">case</span>(<span style="font-style:italic">H</span>,<span style="font-style:italic">P</span>,<span style="font-style:italic">f</span><sub>1</sub> | <span style="font-style:italic">f</span><sub>2</sub>):(<span style="font-style:italic">P</span> <span style="font-style:italic">L</span> <span style="font-style:italic">N</span> <span style="font-style:italic">H</span>)</td></tr>
</table></td></tr>
</table><h5 id="sec214" class="paragraph">Definition of ι-reduction.
<a id="hevea_default362"></a></h5>
<p>
We still have to define the ι-reduction in the general case.</p><p>A ι-redex is a term of the following form:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">case</span>((<span style="font-style:italic">c</span><sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub></sub> <span style="font-style:italic">q</span><sub>1</sub>… <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub> <span style="font-style:italic">a</span><sub>1</sub>… <span style="font-style:italic">a</span><sub><span style="font-style:italic">m</span></sub>),<span style="font-style:italic">P</span>,<span style="font-style:italic">f</span><sub>1</sub>|… |
<span style="font-style:italic">f</span><sub><span style="font-style:italic">l</span></sub>)</td></tr>
</table><p>
with <span style="font-style:italic">c</span><sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub></sub> the <span style="font-style:italic">i</span>-th constructor of the inductive type <span style="font-style:italic">I</span> with <span style="font-style:italic">r</span>
parameters.</p><p>The ι-contraction of this term is (<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">a</span><sub>1</sub>… <span style="font-style:italic">a</span><sub><span style="font-style:italic">m</span></sub>) leading
to the general reduction rule:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">case</span>((<span style="font-style:italic">c</span><sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub></sub> <span style="font-style:italic">q</span><sub>1</sub>… <span style="font-style:italic">q</span><sub><span style="font-style:italic">r</span></sub> <span style="font-style:italic">a</span><sub>1</sub>… <span style="font-style:italic">a</span><sub><span style="font-style:italic">m</span></sub>),<span style="font-style:italic">P</span>,<span style="font-style:italic">f</span><sub>1</sub>|… |
<span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>) ▷<sub>ι</sub> (<span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">a</span><sub>1</sub>… <span style="font-style:italic">a</span><sub><span style="font-style:italic">m</span></sub>) </td></tr>
</table><h3 id="sec215" class="subsection">4.5.5  Fixpoint definitions <a id="hevea_default363"></a></h3>
<p>
The second operator for elimination is fixpoint definition. 
This fixpoint may involve several mutually recursive definitions.
The basic concrete syntax for a recursive set of mutually recursive 
declarations is (with Γ<sub><span style="font-style:italic">i</span></sub> contexts) : 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">fix</span> <span style="font-style:italic">f</span><sub>1</sub> (Γ<sub>1</sub>) :<span style="font-style:italic">A</span><sub>1</sub>:=<span style="font-style:italic">t</span><sub>1</sub> <span style="font-family:sans-serif">with</span> … <span style="font-family:sans-serif">with</span>  <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>
(Γ<sub><span style="font-style:italic">n</span></sub>) :<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>:=<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table><p>
The terms are obtained by projections from this set of declarations
and are written 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:sans-serif">fix</span> <span style="font-style:italic">f</span><sub>1</sub> (Γ<sub>1</sub>) :<span style="font-style:italic">A</span><sub>1</sub>:=<span style="font-style:italic">t</span><sub>1</sub> <span style="font-family:sans-serif">with</span> … <span style="font-family:sans-serif">with</span>  <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>
(Γ<sub><span style="font-style:italic">n</span></sub>) :<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>:=<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:sans-serif">for</span> <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table><p>
In the inference rules, we represent such a
term by 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:monospace">Fix</span> <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>{<span style="font-style:italic">f</span><sub>1</sub>:<span style="font-style:italic">A</span><sub>1</sub>′:=<span style="font-style:italic">t</span><sub>1</sub>′ … <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>′:=<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>′}</td></tr>
</table><p>
with <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>′ (resp. <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub>′) representing the term <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub> abstracted
(resp. generalized) with
respect to the bindings in the context Γ<sub><span style="font-style:italic">i</span></sub>, namely
<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>′=λ Γ<sub><span style="font-style:italic">i</span></sub> .  <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub> and <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub>′=∀ Γ<sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub>.</p>
<h4 id="sec216" class="subsubsection">Typing rule</h4>
<p>
The typing rule is the expected one for a fixpoint.</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">Fix</span></dt><dd class="dd-description"> <a id="hevea_default364"></a>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub> : <span style="font-style:italic">s</span><sub><span style="font-style:italic">i</span></sub>)<sub><span style="font-style:italic">i</span>=1… <span style="font-style:italic">n</span></sub>    
(<span style="font-style:italic">E</span>[Γ,<span style="font-style:italic">f</span><sub>1</sub>:<span style="font-style:italic">A</span><sub>1</sub>,…,<span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>] ⊢ <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub> : <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub>)<sub><span style="font-style:italic">i</span>=1… <span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-family:monospace">Fix</span> <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>{<span style="font-style:italic">f</span><sub>1</sub>:<span style="font-style:italic">A</span><sub>1</sub>:=<span style="font-style:italic">t</span><sub>1</sub> … <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>:=<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>} : <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub></td></tr>
</table></td></tr>
</table>
</dd></dl><p>Any fixpoint definition cannot be accepted because non-normalizing terms
will lead to proofs of absurdity.</p><p>The basic scheme of recursion that should be allowed is the one needed for 
defining primitive
recursive functionals. In that case the fixpoint enjoys a special
syntactic restriction, namely one of the arguments belongs to an
inductive type, the function starts with a case analysis and recursive
calls are done on variables coming from patterns and representing subterms.</p><p>For instance in the case of natural numbers, a proof of the induction
principle of type 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">∀ <span style="font-style:italic">P</span>:<span style="font-family:sans-serif">nat</span>→<span style="font-family:sans-serif">Prop</span>, (<span style="font-style:italic">P</span> <span style="font-family:sans-serif">O</span>)→(∀ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>, (<span style="font-style:italic">P</span> <span style="font-style:italic">n</span>)→(<span style="font-style:italic">P</span> (<span style="font-family:sans-serif">S</span> <span style="font-style:italic">n</span>)))→
∀ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>, (<span style="font-style:italic">P</span> <span style="font-style:italic">n</span>)</td></tr>
</table><p>
can be represented by the term:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">P</span>:<span style="font-family:sans-serif">nat</span>→<span style="font-family:sans-serif">Prop</span>. λ <span style="font-style:italic">f</span>:(<span style="font-style:italic">P</span> <span style="font-family:sans-serif">O</span>).  λ <span style="font-style:italic">g</span>:(∀ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>,
(<span style="font-style:italic">P</span> <span style="font-style:italic">n</span>)→(<span style="font-style:italic">P</span> (<span style="font-family:sans-serif">S</span> <span style="font-style:italic">n</span>))) . </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Fix</span> <span style="font-style:italic">h</span>{<span style="font-style:italic">h</span>:∀ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>, (<span style="font-style:italic">P</span> <span style="font-style:italic">n</span>):=λ <span style="font-style:italic">n</span>:<span style="font-family:sans-serif">nat</span>.  <span style="font-family:sans-serif">case</span>(<span style="font-style:italic">n</span>,<span style="font-style:italic">P</span>,<span style="font-style:italic">f</span> | λ
<span style="font-style:italic">p</span>:<span style="font-family:sans-serif">nat</span>.  (<span style="font-style:italic">g</span> <span style="font-style:italic">p</span> (<span style="font-style:italic">h</span> <span style="font-style:italic">p</span>)))}
</td></tr>
</table></td></tr>
</table><p>Before accepting a fixpoint definition as being correctly typed, we
check that the definition is “guarded”. A precise analysis of this
notion can be found in [<a href="biblio.html#Gim94">65</a>].</p><p>The first stage is to precise on which argument the fixpoint will be
decreasing. The type of this argument should be an inductive
definition.</p><p>For doing this the syntax of fixpoints is extended and becomes 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:monospace">Fix</span> <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>{<span style="font-style:italic">f</span><sub>1</sub>/<span style="font-style:italic">k</span><sub>1</sub>:<span style="font-style:italic">A</span><sub>1</sub>:=<span style="font-style:italic">t</span><sub>1</sub> … <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">k</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>:=<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>}</td></tr>
</table><p>
where <span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub> are positive integers.
Each <span style="font-style:italic">A</span><sub><span style="font-style:italic">i</span></sub> should be a type (reducible to a term) starting with at least
<span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub> products ∀ <span style="font-style:italic">y</span><sub>1</sub>:<span style="font-style:italic">B</span><sub>1</sub>,… ∀ <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub></sub>:<span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub></sub>, <span style="font-style:italic">A</span>′<sub><span style="font-style:italic">i</span></sub> 
and <span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub></sub>
being an instance of an inductive definition.</p><p>Now in the definition <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>, if <span style="font-style:italic">f</span><sub><span style="font-style:italic">j</span></sub> occurs then it should be applied
to at least <span style="font-style:italic">k</span><sub><span style="font-style:italic">j</span></sub> arguments and the <span style="font-style:italic">k</span><sub><span style="font-style:italic">j</span></sub>-th argument should be
syntactically recognized as structurally smaller than <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub></sub></p><p>The definition of being structurally smaller is a bit technical.
One needs first to define the notion of 
<em>recursive arguments of a constructor</em><a id="hevea_default365"></a>.
For an inductive definition <span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">r</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> ),
the type of a constructor <span style="font-style:italic">c</span> has the form
∀ <span style="font-style:italic">p</span><sub>1</sub>:<span style="font-style:italic">P</span><sub>1</sub>,… ∀ <span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub>:<span style="font-style:italic">P</span><sub><span style="font-style:italic">r</span></sub>, 
∀ <span style="font-style:italic">x</span><sub>1</sub>:<span style="font-style:italic">T</span><sub>1</sub>, … ∀ <span style="font-style:italic">x</span><sub><span style="font-style:italic">r</span></sub>:<span style="font-style:italic">T</span><sub><span style="font-style:italic">r</span></sub>, (<span style="font-style:italic">I</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">p</span><sub>1</sub>… 
<span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub> <span style="font-style:italic">t</span><sub>1</sub>… <span style="font-style:italic">t</span><sub><span style="font-style:italic">s</span></sub>) the recursive arguments will correspond to <span style="font-style:italic">T</span><sub><span style="font-style:italic">i</span></sub> in
which one of the <span style="font-style:italic">I</span><sub><span style="font-style:italic">l</span></sub> occurs.</p><p>The main rules for being structurally smaller are the following:<br>
Given a variable <span style="font-style:italic">y</span> of type an inductive
definition in a declaration 
<span style="font-family:sans-serif">Ind</span>(Γ)[<span style="font-style:italic">r</span>](Γ<sub><span style="font-style:italic">I</span></sub>:=Γ<sub><span style="font-style:italic">C</span></sub> )
where Γ<sub><span style="font-style:italic">I</span></sub> is [<span style="font-style:italic">I</span><sub>1</sub>:<span style="font-style:italic">A</span><sub>1</sub>;…;<span style="font-style:italic">I</span><sub><span style="font-style:italic">k</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">k</span></sub>], and Γ<sub><span style="font-style:italic">C</span></sub> is
[<span style="font-style:italic">c</span><sub>1</sub>:<span style="font-style:italic">C</span><sub>1</sub>;…;<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">C</span><sub><span style="font-style:italic">n</span></sub>].
The terms structurally smaller than <span style="font-style:italic">y</span> are:
</p><ul class="itemize"><li class="li-itemize">
(<span style="font-style:italic">t</span> <span style="font-style:italic">u</span>), λ <span style="font-style:italic">x</span>:<span style="font-style:italic">u</span> .  <span style="font-style:italic">t</span> when <span style="font-style:italic">t</span> is structurally smaller than <span style="font-style:italic">y</span> .
</li><li class="li-itemize"><span style="font-family:sans-serif">case</span>(<span style="font-style:italic">c</span>,<span style="font-style:italic">P</span>,<span style="font-style:italic">f</span><sub>1</sub>… <span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>) when each <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> is structurally
smaller than <span style="font-style:italic">y</span>. <br>
 If <span style="font-style:italic">c</span> is <span style="font-style:italic">y</span> or is structurally smaller than <span style="font-style:italic">y</span>, its type is an inductive
definition <span style="font-style:italic">I</span><sub><span style="font-style:italic">p</span></sub> part of the inductive
declaration corresponding to <span style="font-style:italic">y</span>. 
Each <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub> corresponds to a type of constructor <span style="font-style:italic">C</span><sub><span style="font-style:italic">q</span></sub> ≡
∀ <span style="font-style:italic">p</span><sub>1</sub>:<span style="font-style:italic">P</span><sub>1</sub>,…,∀ <span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub>:<span style="font-style:italic">P</span><sub><span style="font-style:italic">r</span></sub>, ∀ <span style="font-style:italic">y</span><sub>1</sub>:<span style="font-style:italic">B</span><sub>1</sub>, … ∀ <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>:<span style="font-style:italic">B</span><sub><span style="font-style:italic">k</span></sub>, (<span style="font-style:italic">I</span> <span style="font-style:italic">a</span><sub>1</sub>… <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span></sub>) 
and can consequently be
written λ <span style="font-style:italic">y</span><sub>1</sub>:<span style="font-style:italic">B</span>′<sub>1</sub>.  … λ <span style="font-style:italic">y</span><sub><span style="font-style:italic">k</span></sub>:<span style="font-style:italic">B</span>′<sub><span style="font-style:italic">k</span></sub>.  <span style="font-style:italic">g</span><sub><span style="font-style:italic">i</span></sub>.
(<span style="font-style:italic">B</span>′<sub><span style="font-style:italic">i</span></sub> is obtained from <span style="font-style:italic">B</span><sub><span style="font-style:italic">i</span></sub> by substituting parameters variables)
the variables <span style="font-style:italic">y</span><sub><span style="font-style:italic">j</span></sub> occurring
in <span style="font-style:italic">g</span><sub><span style="font-style:italic">i</span></sub> corresponding to recursive arguments <span style="font-style:italic">B</span><sub><span style="font-style:italic">i</span></sub> (the ones in
which one of the <span style="font-style:italic">I</span><sub><span style="font-style:italic">l</span></sub> occurs) are structurally smaller than <span style="font-style:italic">y</span>.
</li></ul><p>
The following definitions are correct, we enter them using the
<span style="font-family:monospace">Fixpoint</span> command as described in Section <a href="Reference-Manual003.html#Fixpoint">1.3.4</a> and show
the internal representation.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint plus (n m:nat) {struct n} : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   match n with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | O =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> m</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | S p =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (plus p m)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">plus is recursively defined (decreasing on 1st argument)</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print plus.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">plus = </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fix plus (n m : nat) {struct n} : nat :=</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  match n with</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  | O =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> m</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  | S p =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> S (plus p m)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  end</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint lgth (A:Set) (l:list A) {struct l} : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   match l with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | nil =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> O</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | cons a l’ =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (lgth A l’)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">lgth is recursively defined (decreasing on 2nd argument)</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print lgth.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">lgth = </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fix lgth (A : Set) (l : list A) {struct l} : nat :=</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  match l with</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  | nil =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> O</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  | cons _ l’ =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> S (lgth A l’)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  end</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall A : Set, list A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument scopes are [type_scope _]</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint sizet (t:tree) : nat := let (f) := t in S (sizef f)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">  with sizef (f:forest) : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   match f with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | emptyf =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> O</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | consf t f =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> plus (sizet t) (sizef f)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">sizet, sizef are recursively defined (decreasing respectively on 1st,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1st arguments)</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print sizet.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">sizet = </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fix sizet (t : tree) : nat :=</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  let (f) := t in S (sizef f)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">with sizef (f : forest) : nat :=</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  match f with</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  | emptyf =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> O</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  | consf t f0 =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> plus (sizet t) (sizef f0)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  end</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">for sizet</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : tree -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat</span></span></span><span style="font-size:small"><br>
</span></div><h4 id="sec217" class="subsubsection">Reduction rule<a id="hevea_default366"></a></h4>
<p>
Let <span style="font-style:italic">F</span> be the set of declarations: <span style="font-style:italic">f</span><sub>1</sub>/<span style="font-style:italic">k</span><sub>1</sub>:<span style="font-style:italic">A</span><sub>1</sub>:=<span style="font-style:italic">t</span><sub>1</sub> …
<span style="font-style:italic">f</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">k</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>:=<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>.
The reduction for fixpoints is:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-family:monospace">Fix</span> <span style="font-style:italic">f</span><sub><span style="font-style:italic">i</span></sub>{<span style="font-style:italic">F</span>} <span style="font-style:italic">a</span><sub>1</sub>…
<span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub></sub>) ▷<sub>ι</sub> <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub>{(<span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub>/<span style="font-family:monospace">Fix</span> <span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub>{<span style="font-style:italic">F</span>})<sub><span style="font-style:italic">k</span>=1… <span style="font-style:italic">n</span></sub>}
 <span style="font-style:italic">a</span><sub>1</sub>… <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub></sub></td></tr>
</table><p>
when <span style="font-style:italic">a</span><sub><span style="font-style:italic">k</span><sub><span style="font-style:italic">i</span></sub></sub> starts with a constructor.
This last restriction is needed in order to keep strong normalization
and corresponds to the reduction for primitive recursive operators.</p><p>We can illustrate this behavior on examples.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall n m:nat, plus (S n) m = S (plus n m).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   forall n m : nat, plus (S n) m = S (plus n m)</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> reflexivity.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Abort.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Current goal aborted</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall f:forest, sizet (node f) = S (sizef f).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   forall f : forest, sizet (node f) = S (sizef f)</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> reflexivity.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Abort.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Current goal aborted</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
But assuming the definition of a son function from <span style="font-family:sans-serif">tree</span> to <span style="font-family:sans-serif">forest</span>:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition sont (t:tree) : forest </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">    := let (f) := t in f.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">sont is defined</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
The following is not a conversion but can be proved after a case analysis.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall t:tree, sizet t = S (sizef (sont t)).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   forall t : tree, sizet t = S (sizef (sont t))</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> reflexivity. (** this one fails **)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Toplevel input, characters 0-11:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> reflexivity.</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Error: Impossible to unify "S (sizef (sont t))" with "sizet t".</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> destruct t.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  f : forest</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   sizet (node f) = S (sizef (sont (node f)))</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> reflexivity.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div>
<h4 id="sec218" class="subsubsection">Mutual induction</h4>
<p>The principles of mutual induction can be automatically generated 
using the <span style="font-family:monospace">Scheme</span> command described in Section <a href="Reference-Manual015.html#Scheme">13.1</a>.</p>
<h2 id="sec219" class="section">4.6  Co-inductive types</h2>
<p>
The implementation contains also co-inductive definitions, which are
types inhabited by infinite objects. 
More information on co-inductive definitions can be found
in [<a href="biblio.html#Gimenez95b">66</a>, <a href="biblio.html#Gim98">67</a>, <a href="biblio.html#GimCas05">68</a>].
</p><h2 id="sec220" class="section">4.7  <span style="font-variant:small-caps">Cic</span>: the Calculus of Inductive Construction with
impredicative <span style="font-family:sans-serif">Set</span></h2>
<p><span style="font-variant:small-caps">Coq</span> can be used as a type-checker for <span style="font-variant:small-caps">Cic</span>, the original 
Calculus of Inductive Constructions with an impredicative sort <span style="font-family:sans-serif">Set</span>
by using the compiler option <span style="font-family:monospace">-impredicative-set</span>.</p><p>For example, using the ordinary <span style="font-family:monospace">coqtop</span> command, the following
is rejected.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition id: Set := forall X:Set,X-</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">X.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Coq </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Toplevel input, characters 185-202:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Definition id: Set := forall X:Set,X-</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">X.</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">                       </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">^</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Error: The term "forall X : Set, X -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> X" has type "Type"</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> while it is expected to have type "Set".</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
while it will type-check, if one use instead the <span style="font-family:monospace">coqtop
-impredicative-set</span> command.</p><p>The major change in the theory concerns the rule for product formation
in the sort <span style="font-family:sans-serif">Set</span>, which is extended to a domain in any sort :
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">Prod</span></dt><dd class="dd-description"> <a id="hevea_default367"></a>
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">E</span>[Γ] ⊢ <span style="font-style:italic">T</span> : <span style="font-style:italic">s</span>    <span style="font-style:italic">s</span> ∈ <span style="color:red"> </span><span style="color:red"><span style="font-style:italic">S</span></span>      
<span style="font-style:italic">E</span>[Γ::(<span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>)] ⊢ <span style="font-style:italic">U</span> : <span style="font-family:sans-serif">Set</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"> <span style="font-style:italic">E</span>[Γ] ⊢ ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>,<span style="font-style:italic">U</span> : <span style="font-family:sans-serif">Set</span></td></tr>
</table></td></tr>
</table> 
</dd></dl><p>
This extension has consequences on the inductive definitions which are
allowed. 
In the impredicative system, one can build so-called <em>large inductive
definitions</em> like the example of second-order existential
quantifier (<span style="font-family:monospace">exSet</span>).</p><p>There should be restrictions on the eliminations which can be
performed on such definitions. The eliminations rules in the
impredicative system for sort <span style="font-family:sans-serif">Set</span> become :
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold"><span style="font-family:sans-serif">Set</span></span></dt><dd class="dd-description"> <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">s</span> ∈
{<span style="font-family:sans-serif">Prop</span>, <span style="font-family:sans-serif">Set</span>}</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">[<span style="font-style:italic">I</span>:<span style="font-family:sans-serif">Set</span>|<span style="font-style:italic">I</span>→ <span style="font-style:italic">s</span>]</td></tr>
</table></td><td class="dcell">
    </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">I</span>  is a small inductive definition    <span style="font-style:italic">s</span> ∈
{<span style="font-family:sans-serif">Type</span>(<span style="font-style:italic">i</span>)}</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">[<span style="font-style:italic">I</span>:<span style="font-family:sans-serif">Set</span>|<span style="font-style:italic">I</span>→ <span style="font-style:italic">s</span>]</td></tr>
</table></td></tr>
</table></td></tr>
</table>
</dd></dl><hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note11" href="#text11">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">In the Reference
Manual of versions of Coq prior to 8.4, the level of <span style="font-family:sans-serif">Type</span> typing
<span style="font-family:sans-serif">Prop</span> and <span style="font-family:sans-serif">Set</span> was numbered 0. From Coq 8.4, it started to be
numbered 1 so as to be able to leave room for re-interpreting
<span style="font-family:sans-serif">Set</span> in the hierarchy as <span style="font-family:sans-serif">Type</span>(0). This change also put the
reference manual in accordance with the internal conventions adopted
in the implementation.</div>
</dd><dt class="dt-thefootnotes"><a id="note12" href="#text12">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">This requirement could be relaxed if we instead introduced
an explicit mechanism for instantiating constants. At the external
level, the Coq engine works accordingly to this view that all the
definitions in the environment were built in a sub-context of the
current context.</div>
</dd></dl>

<div id="sidebarWrapper">
  <div id="sidebar">
    <div class="block">
      <h2 class="title">Navigation</h2>
      <div class="content">
        <ul class="menu">
          <li class="leaf"><a href="index.html">Cover</a></li>
          <li class="leaf"><a href="toc.html">Table of contents</a></li>
          <li class="leaf">Index
            <ul class="menu">
              <li><a href="general-index.html">General</a></li>
              <li><a href="command-index.html">Commands</a></li>
              <li><a href="tactic-index.html">Tactics</a></li>
              <li><a href="error-index.html">Errors</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</body>
</html>
