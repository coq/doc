<!DOCTYPE html>
<html>
<head>


<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/coqdoc.css" /><title>Chapter 13  Proof schemes</title>
</head>
<body >

<div id="container">

<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="/" class="active">Home</a></li>
    <li><a href="/about-coq" title="More about coq">About Coq</a></li>
    <li><a href="/download">Get Coq</a></li>
    <li><a href="/documentation">Documentation</a></li>
    <li><a href="/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">
<div id="logoWrapper">
  <div id="logo"><a href="/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
  </div>
  <div id="siteName"><a href="/" title="Home">The Coq Proof Assistant</a>
  </div>
</div>
</div>

<div id="content">

<h1 id="sec559" class="chapter">Chapter 13  Proof schemes</h1>
<ul>
<li><a href="Reference-Manual015.html#sec560">13.1  Generation of induction principles with <span style="font-family:monospace">Scheme</span></a>
</li><li><a href="Reference-Manual015.html#sec563">13.2  Generation of induction principles with <span style="font-family:monospace">Functional Scheme</span></a>
</li><li><a href="Reference-Manual015.html#sec564">13.3  Generation of inversion principles with <span style="font-family:monospace">Derive Inversion</span></a>
</li></ul>
<h2 id="sec560" class="section">13.1  Generation of induction principles with <span style="font-family:monospace">Scheme</span></h2>
<p>
<a id="Scheme"></a>
<a id="hevea_default807"></a>
<a id="hevea_default808"></a><a id="hevea_command277"></a></p><p>The <span style="font-family:monospace">Scheme</span> command is a high-level tool for generating
automatically (possibly mutual) induction principles for given types
and sorts. Its syntax follows the schema:
</p><blockquote class="quote">
<span style="font-family:monospace">Scheme </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> := Induction for </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">’</span><sub>1</sub><span style="font-family:monospace"> Sort </span><span style="font-style:oblique">sort</span><sub>1</sub><span style="font-family:monospace"> <br>
 with<br>
  …<br>
 with </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> := Induction for </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">’</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> Sort
</span><span style="font-style:oblique">sort</span><sub><span style="font-style:italic">m</span></sub>
</blockquote><p>
where <span style="font-style:oblique">ident</span>’<sub>1</sub> … <span style="font-style:oblique">ident</span>’<sub><span style="font-style:italic">m</span></sub> are different inductive type
identifiers belonging to the same package of mutual inductive
definitions. This command generates <span style="font-style:oblique">ident</span><sub>1</sub>… <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub>
to be mutually recursive definitions. Each term <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub> proves a
general principle of mutual induction for objects in type <span style="font-style:oblique">term</span><sub><span style="font-style:italic">i</span></sub>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Scheme </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> := Minimality for </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">’</span><sub>1</sub><span style="font-family:monospace"> Sort </span><span style="font-style:oblique">sort</span><sub>1</sub><span style="font-family:monospace"> <br>
 with<br>
  … <br>
 with </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> := Minimality for </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">’</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> Sort
</span><span style="font-style:oblique">sort</span><sub><span style="font-style:italic">m</span></sub><p>Same as before but defines a non-dependent elimination principle more
natural in case of inductively defined relations.</p></li><li class="li-enumerate"><span style="font-family:monospace">Scheme Equality for </span><span style="font-style:oblique">ident</span><sub>1</sub><a id="hevea_default809"></a><a id="hevea_command278"></a><p>Tries to generate a Boolean equality and a proof of the
decidability of the usual equality. If <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub> involves
some other inductive types, their equality has to be defined first.</p></li><li class="li-enumerate"><span style="font-family:monospace">Scheme Induction for </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> Sort </span><span style="font-style:oblique">sort</span><sub>1</sub><span style="font-family:monospace"> <br>
 with<br>
  …<br>
 with Induction for </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> Sort
</span><span style="font-style:oblique">sort</span><sub><span style="font-style:italic">m</span></sub><p>If you do not provide the name of the schemes, they will be automatically
computed from the sorts involved (works also with Minimality).</p></li></ol><p>
<a id="Scheme-examples"></a></p><p>
<br>
<span style="font-weight:bold">Example 1: </span><span style="font-style:italic">Induction scheme for </span><span style="font-style:italic"><span style="font-family:monospace">tree</span></span><span style="font-style:italic"> and </span><span style="font-style:italic"><span style="font-family:monospace">forest</span></span>
</p><p>The definition of principle of mutual induction for <span style="font-family:monospace">tree</span> and
<span style="font-family:monospace">forest</span> over the sort <span style="font-family:monospace">Set</span> is defined by the command:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive tree : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">     node : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> tree</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> with forest : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | leaf : B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | cons : tree -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Scheme tree_forest_rec := Induction for tree Sort Set</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   with forest_tree_rec := Induction for forest Sort Set.</span></span><span style="font-size:small"><br>
</span></div><p>You may now look at the type of <span style="font-family:monospace">tree_forest_rec</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check tree_forest_rec.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tree_forest_rec</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall (P : tree -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set) (P0 : forest -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set),</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall (a : A) (f : forest), P0 f -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (node a f)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall b : B, P0 (leaf b)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall t : tree, P t -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> forall f1 : forest, P0 f1 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P0 (cons t f1)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       forall t : tree, P t</span></span></span><span style="font-size:small"><br>
</span></div><p>This principle involves two different predicates for <span style="font-family:monospace">trees</span> and
<span style="font-family:monospace">forests</span>; it also has three premises each one corresponding to a
constructor of one of the inductive definitions.</p><p>The principle <span style="font-family:monospace">forest_tree_rec</span> shares exactly the same
premises, only the conclusion now refers to the property of forests.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check forest_tree_rec.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">forest_tree_rec</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall (P : tree -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set) (P0 : forest -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set),</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall (a : A) (f : forest), P0 f -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (node a f)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall b : B, P0 (leaf b)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall t : tree, P t -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> forall f1 : forest, P0 f1 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P0 (cons t f1)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       forall f2 : forest, P0 f2</span></span></span><span style="font-size:small"><br>
</span></div><p>
<br>
<span style="font-weight:bold">Example 2: </span><span style="font-style:italic">Predicates </span><span style="font-style:italic"><span style="font-family:monospace">odd</span></span><span style="font-style:italic"> and </span><span style="font-style:italic"><span style="font-family:monospace">even</span></span><span style="font-style:italic"> on naturals</span>
</p><p>Let <span style="font-family:monospace">odd</span> and <span style="font-family:monospace">even</span> be inductively defined as:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive odd : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">     oddS : forall n:nat, even n -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> odd (S n)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> with even : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | evenO : even 0</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | evenS : forall n:nat, odd n -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> even (S n).</span></span><span style="font-size:small"><br>
</span></div><p>The following command generates a powerful elimination
principle:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Scheme odd_even := Minimality for   odd Sort Prop</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   with even_odd := Minimality for even Sort Prop.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">even_odd is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">odd_even is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">odd_even, even_odd are recursively defined</span></span></span><span style="font-size:small"><br>
</span></div><p>The type of <span style="font-family:monospace">odd_even</span> for instance will be:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check odd_even.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">odd_even</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall P P0 : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall n : nat, even n -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P0 n -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (S n)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       P0 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall n : nat, odd n -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P n -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P0 (S n)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       forall n : nat, odd n -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P n</span></span></span><span style="font-size:small"><br>
</span></div><p>The type of <span style="font-family:monospace">even_odd</span> shares the same premises but the
conclusion is <span style="font-family:monospace">(n:nat)(even n)-&gt;(Q n)</span>.</p>
<h3 id="sec561" class="subsection">13.1.1  Automatic declaration of schemes</h3>
<p>
<a id="hevea_default810"></a><a id="hevea_command279"></a>
<a id="hevea_default811"></a><a id="hevea_command280"></a>
<a id="hevea_default812"></a><a id="hevea_command281"></a></p><p>It is possible to deactivate the automatic declaration of the induction
principles when defining a new inductive type with the
<span style="font-family:monospace">Unset Elimination Schemes</span> command. It may be
reactivated at any time with <span style="font-family:monospace">Set Elimination Schemes</span>.
<br>

You can also activate the automatic declaration of those Boolean
equalities and their proof (see the second variant of <span style="font-family:monospace">Scheme</span>)
with respectively the commands <span style="font-family:monospace">Set Boolean Equality Schemes</span> and
<span style="font-family:monospace">Set Decidable Equality Schemes</span>. However you have to be careful
with this option since <span style="font-variant:small-caps">Coq</span>  may now reject well-defined inductive
types because it cannot compute a Boolean equality for them.</p>
<h3 id="sec562" class="subsection">13.1.2  <span style="font-family:monospace">Combined Scheme</span></h3>
<p>
<a id="CombinedScheme"></a>
<a id="hevea_default813"></a><a id="hevea_command282"></a></p><p>The <span style="font-family:monospace">Combined Scheme</span> command is a tool for combining
induction principles generated by the <span style="font-family:monospace">Scheme</span> command.
Its syntax follows the schema :
</p><blockquote class="quote">
<span style="font-family:monospace">Combined Scheme </span><span style="font-style:oblique">ident</span><sub>0</sub><span style="font-family:monospace"> from </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">, .., </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>
</blockquote><p>
where
<span style="font-style:oblique">ident</span><sub>1</sub> …<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> are different inductive principles that must belong to
the same package of mutual inductive principle definitions. This command
generates <span style="font-style:oblique">ident</span><sub>0</sub> to be the conjunction of the principles: it is
built from the common premises of the principles and concluded by the
conjunction of their conclusions.</p><p><br>
<span style="font-weight:bold">Example: </span>We can define the induction principles for trees and forests using:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Scheme tree_forest_ind := Induction for tree Sort Prop</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   with forest_tree_ind := Induction for forest Sort Prop.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">forest_tree_ind is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tree_forest_ind is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tree_forest_ind, forest_tree_ind are recursively defined</span></span></span><span style="font-size:small"><br>
</span></div><p>Then we can build the combined induction principle which gives the
conjunction of the conclusions of each individual principle:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Combined Scheme tree_forest_mutind from tree_forest_ind, forest_tree_ind.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tree_forest_mutind is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tree_forest_mutind is recursively defined</span></span></span><span style="font-size:small"><br>
</span></div><p>The type of <span style="font-family:monospace">tree_forest_mutrec</span> will be:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check tree_forest_mutind.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tree_forest_mutind</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall (P : tree -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop) (P0 : forest -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop),</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall (a : A) (f : forest), P0 f -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (node a f)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall b : B, P0 (leaf b)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall t : tree, P t -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> forall f1 : forest, P0 f1 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P0 (cons t f1)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall t : tree, P t) /</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> (forall f2 : forest, P0 f2)</span></span></span><span style="font-size:small"><br>
</span></div>
<h2 id="sec563" class="section">13.2  Generation of induction principles with <span style="font-family:monospace">Functional Scheme</span></h2>
<p>
<a id="FunScheme"></a>
<a id="hevea_default814"></a><a id="hevea_command283"></a></p><p>The <span style="font-family:monospace">Functional Scheme</span> command is a high-level experimental
tool for generating automatically induction principles
corresponding to (possibly mutually recursive) functions. Its
syntax follows the schema:
</p><blockquote class="quote">
<span style="font-family:monospace">Functional Scheme </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> := Induction for </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">’</span><sub>1</sub><span style="font-family:monospace"> Sort </span><span style="font-style:oblique">sort</span><sub>1</sub><span style="font-family:monospace"> <br>
 with<br>
  … <br>
 with </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> := Induction for </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">’</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> Sort
</span><span style="font-style:oblique">sort</span><sub><span style="font-style:italic">m</span></sub>
</blockquote><p>
where <span style="font-style:oblique">ident</span>’<sub>1</sub> … <span style="font-style:oblique">ident</span>’<sub><span style="font-style:italic">m</span></sub> are different mutually defined function
names (they must be in the same order as when they were defined).
This command generates the induction principles
<span style="font-style:oblique">ident</span><sub>1</sub>…<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub>, following the recursive structure and case
analyses of the functions <span style="font-style:oblique">ident</span>’<sub>1</sub> … <span style="font-style:oblique">ident</span>’<sub><span style="font-style:italic">m</span></sub>.</p><p><br>
<span style="font-weight:bold">Remark: </span>There is a difference between obtaining an induction scheme by using
<span style="font-family:monospace">Functional Scheme</span> on a function defined by <span style="font-family:monospace">Function</span>
or not. Indeed <span style="font-family:monospace">Function</span> generally produces smaller
principles, closer to the definition written by the user.</p><p>
<br>
<span style="font-weight:bold">Example 1: </span><span style="font-style:italic">Induction scheme for </span><span style="font-style:italic"><span style="font-family:monospace">div2</span></span>

<a id="FunScheme-examples"></a></p><p>We define the function <span style="font-family:monospace">div2</span> as follows:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import Arith.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint div2 (n:nat) : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   match n with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | O =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 0</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | S O =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 0</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | S (S n’) =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (div2 n’)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   end.</span></span><span style="font-size:small"><br>
</span></div><p>The definition of a principle of induction corresponding to the
recursive structure of <span style="font-family:monospace">div2</span> is defined by the command:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Functional Scheme div2_ind := Induction for div2 Sort Prop.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">div2_equation is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">div2_ind is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>You may now look at the type of <span style="font-family:monospace">div2_ind</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check div2_ind.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">div2_ind</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall P : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall n : nat, n = 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 0 0) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall n n0 : nat, n = S n0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n0 = 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 1 0) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall n n0 : nat,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        n = S n0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        forall n’ : nat,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        n0 = S n’ -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P n’ (div2 n’) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (S (S n’)) (S (div2 n’))) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       forall n : nat, P n (div2 n)</span></span></span><span style="font-size:small"><br>
</span></div><p>We can now prove the following lemma using this principle:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma div2_le’ : forall n:nat, div2 n </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">= n.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intro n.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">  pattern n , (div2 n).</span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> apply div2_ind; intros.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">3 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n0 : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  e : n0 = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   0 </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0 </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 3 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> S (div2 n’) </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= S (S n’)</span></span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> auto with arith.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> auto with arith.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> simpl; auto with arith.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Qed.</span></span><span style="font-size:small"><br>
</span></div><p>We can use directly the <span style="font-family:monospace">functional induction</span>
(<a href="Reference-Manual010.html#FunInduction">8.5.5</a>) tactic instead of the pattern/apply trick:
<a id="hevea_default815"></a><a id="hevea_tactic191"></a></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Reset div2_le’.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma div2_le : forall n:nat, div2 n </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">= n.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intro n.</span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> functional induction (div2 n).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">3 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   0 </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0 </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 3 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> S (div2 n’) </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= S (S n’)</span></span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> auto with arith.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> auto with arith.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> auto with arith.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Qed.</span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Remark: </span>There is a difference between obtaining an induction scheme for a
function by using <span style="font-family:monospace">Function</span> (see Section <a href="Reference-Manual004.html#Function">2.3</a>) and by
using <span style="font-family:monospace">Functional Scheme</span> after a normal definition using
<span style="font-family:monospace">Fixpoint</span> or <span style="font-family:monospace">Definition</span>. See <a href="Reference-Manual004.html#Function">2.3</a> for
details.</p><p>
<br>
<span style="font-weight:bold">Example 2: </span><span style="font-style:italic">Induction scheme for </span><span style="font-style:italic"><span style="font-family:monospace">tree_size</span></span>
</p><p>We define trees by the following mutual inductive type:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variable A : Set.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive tree : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">     node : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> tree</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> with forest : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | empty : forest</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | cons : tree -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest.</span></span><span style="font-size:small"><br>
</span></div><p>We define the function <span style="font-family:monospace">tree_size</span> that computes the size
of a tree or a forest. Note that we use <span style="font-family:monospace">Function</span> which
generally produces better principles.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Function tree_size (t:tree) : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   match t with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | node A f =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (forest_size f)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   end</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">  with forest_size (f:forest) : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   match f with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | empty =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 0</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | cons t f’ =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> (tree_size t + forest_size f’)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   end.</span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Remark: </span><span style="font-family:monospace">Function</span> generates itself non mutual induction
principles <span style="font-family:monospace">tree_size_ind</span> and <span style="font-family:monospace">forest_size_ind</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check tree_size_ind.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tree_size_ind</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall P : tree -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall (t : tree) (A : A) (f : forest),</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        t = node A f -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (node A f) (S (forest_size f))) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       forall t : tree, P t (tree_size t)</span></span></span><span style="font-size:small"><br>
</span></div><p>The definition of mutual induction principles following the recursive
structure of <span style="font-family:monospace">tree_size</span> and <span style="font-family:monospace">forest_size</span> is defined
by the command:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Functional Scheme tree_size_ind2 := Induction for tree_size Sort Prop</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> with forest_size_ind2 := Induction for forest_size Sort Prop.</span></span><span style="font-size:small"><br>
</span></div><p>You may now look at the type of <span style="font-family:monospace">tree_size_ind2</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check tree_size_ind2.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tree_size_ind2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall (P : tree -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop) (P0 : forest -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop),</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall (t : tree) (A : A) (f : forest),</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        t = node A f -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        P0 f (forest_size f) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (node A f) (S (forest_size f))) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall f0 : forest, f0 = empty -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P0 empty 0) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall (f1 : forest) (t : tree) (f’ : forest),</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        f1 = cons t f’ -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        P t (tree_size t) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        P0 f’ (forest_size f’) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        P0 (cons t f’) (tree_size t + forest_size f’)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       forall t : tree, P t (tree_size t)</span></span></span><span style="font-size:small"><br>
</span></div>
<h2 id="sec564" class="section">13.3  Generation of inversion principles with <span style="font-family:monospace">Derive Inversion</span></h2>
<p>
<a id="Derive-Inversion"></a>
<a id="hevea_default816"></a><a id="hevea_command284"></a></p><p>The syntax of <span style="font-family:monospace">Derive Inversion</span> follows the schema:
</p><blockquote class="quote">
<span style="font-family:monospace">Derive Inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> with forall
</span>(<span style="font-weight:bold"><span style="font-style:italic">x</span></span> : <span style="font-weight:bold"><span style="font-style:italic">T</span></span>)<span style="font-family:monospace">, </span><span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span><span style="font-family:monospace"> Sort </span><span style="font-style:oblique">sort</span>
</blockquote><p>This command generates an inversion principle for the
<span style="font-family:monospace">inversion … using</span> tactic.
<a id="hevea_default817"></a><a id="hevea_tactic192"></a>
Let <span style="font-style:italic">I</span> be an inductive predicate and <span style="font-weight:bold"><span style="font-style:italic">x</span></span> the variables
occurring in <span style="font-weight:bold"><span style="font-style:italic">t</span></span>. This command generates and stocks the
inversion lemma for the sort <span style="font-style:oblique">sort</span>  corresponding to the instance
∀ (<span style="font-weight:bold"><span style="font-style:italic">x</span></span>:<span style="font-weight:bold"><span style="font-style:italic">T</span></span>), <span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span> with the name <span style="font-style:oblique">ident</span> in the <span style="font-weight:bold">global</span> environment. When applied, it is equivalent to having inverted
the instance with the tactic <span style="font-family:monospace">inversion</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Derive Inversion_clear </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> with forall
</span>(<span style="font-weight:bold"><span style="font-style:italic">x</span></span>:<span style="font-weight:bold"><span style="font-style:italic">T</span></span>)<span style="font-family:monospace">, </span><span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span><span style="font-family:monospace"> Sort </span><span style="font-style:oblique">sort</span><br>
 <a id="hevea_default818"></a><a id="hevea_command285"></a>
When applied, it is equivalent to having
inverted the instance with the tactic <span style="font-family:monospace">inversion</span>
replaced by the tactic <span style="font-family:monospace">inversion_clear</span>.
</li><li class="li-enumerate"><span style="font-family:monospace">Derive Dependent Inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> with forall
</span>(<span style="font-weight:bold"><span style="font-style:italic">x</span></span>:<span style="font-weight:bold"><span style="font-style:italic">T</span></span>)<span style="font-family:monospace">, </span><span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span><span style="font-family:monospace"> Sort </span><span style="font-style:oblique">sort</span><br>
 <a id="hevea_default819"></a><a id="hevea_command286"></a>
When applied, it is equivalent to having
inverted the instance with the tactic <span style="font-family:monospace">dependent inversion</span>.
</li><li class="li-enumerate"><span style="font-family:monospace">Derive Dependent Inversion_clear </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> with forall
</span>(<span style="font-weight:bold"><span style="font-style:italic">x</span></span>:<span style="font-weight:bold"><span style="font-style:italic">T</span></span>)<span style="font-family:monospace">, </span><span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span><span style="font-family:monospace"> Sort </span><span style="font-style:oblique">sort</span><br>
 <a id="hevea_default820"></a><a id="hevea_command287"></a>
When applied, it is equivalent to having
inverted the instance with the tactic <span style="font-family:monospace">dependent inversion_clear</span>.
</li></ol><p><br>
<span style="font-weight:bold">Example: </span></p><p>Let us consider the relation <span style="font-family:monospace">Le</span> over natural numbers and the
following variable:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive Le : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | LeO : forall n:nat, Le 0 n</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   | LeS : forall n m:nat, Le n m -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Le (S n) (S m).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variable P : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop.</span></span><span style="font-size:small"><br>
</span></div><p>To generate the inversion lemma for the instance
<span style="font-family:monospace">(Le (S n) m)</span> and the sort <span style="font-family:monospace">Prop</span>, we do:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Derive Inversion_clear leminv with (forall n m:nat, Le (S n) m) Sort Prop.</span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check leminv.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">leminv</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall (n m : nat) (P : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop),</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall m0 : nat, Le n m0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P n (S m0)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Le (S n) m -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P n m</span></span></span><span style="font-size:small"><br>
</span></div><p>Then we can use the proven inversion lemma:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Show.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  m : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : Le (S n) m</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   P n m</span></span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> inversion H using leminv.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  m : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : Le (S n) m</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">   forall m0 : nat, Le n m0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P n (S m0)</span></span></span><span style="font-size:small"><br>
</span></div>

<div id="sidebarWrapper">
  <div id="sidebar">
    <div class="block">
      <h2 class="title">Navigation</h2>
      <div class="content">
        <ul class="menu">
          <li class="leaf"><a href="index.html">Cover</a></li>
          <li class="leaf"><a href="toc.html">Table of contents</a></li>
          <li class="leaf">Index
            <ul class="menu">
              <li><a href="general-index.html">General</a></li>
              <li><a href="command-index.html">Commands</a></li>
              <li><a href="tactic-index.html">Tactics</a></li>
              <li><a href="error-index.html">Errors</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</body>
</html>
