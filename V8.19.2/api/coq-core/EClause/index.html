<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>EClause (coq-core.EClause)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq-core</a> &#x00BB; EClause</nav><h1>Module <code>EClause</code></h1><nav class="toc"><ul><li><a href="#evar-based-clauses">Evar-based clauses</a></li></ul></nav></header><section><header><h6 id="evar-based-clauses"><a href="#evar-based-clauses" class="anchor"></a>Evar-based clauses</h6></header><aside><p>The following code is an adaptation of the <code>Clenv.make_clenv_*</code> functions, except that it uses evars instead of metas, and naturally fits in the new refinement monad. It should eventually replace all uses of the aforementioned functions.</p><p>A clause is constructed as follows: assume a type <code>t := forall (x1 : A1) ...
    (xn : An), T</code>, we instantiate all the <code>xi</code> with a fresh evar <code>ei</code> and return <code>T(xi := ei)</code> together with the <code>ei</code> enriched with a bit of additional data. This is the simple part done by <code>make_evar_clause</code>.</p><p>The problem lies in the fact we want to solve such holes with some <code>constr bindings</code>. This entails some subtleties, because the provided terms may only be well-typed up to a coercion, which we can only infer if we have enough typing information. The meta machinery could insert coercions through tricky instantiation delays. The only solution we have now is to delay the tentative resolution of clauses by providing the <code>solve_evar_clause</code> function, to be called at a smart enough time.</p></aside><dl><dt class="spec type" id="type-hole"><a href="#type-hole" class="anchor"></a><code><span class="keyword">type</span> hole</code><code> = </code><code>{</code><table class="record"><tr id="type-hole.hole_evar" class="anchored"><td class="def field"><a href="#type-hole.hole_evar" class="anchor"></a><code>hole_evar : <a href="../EConstr/index.html#type-constr">EConstr.constr</a>;</code></td><td class="doc"><p>The hole itself. Guaranteed to be an evar.</p></td></tr><tr id="type-hole.hole_type" class="anchored"><td class="def field"><a href="#type-hole.hole_type" class="anchor"></a><code>hole_type : <a href="../EConstr/index.html#type-types">EConstr.types</a>;</code></td><td class="doc"><p>Type of the hole in the current environment.</p></td></tr><tr id="type-hole.hole_deps" class="anchored"><td class="def field"><a href="#type-hole.hole_deps" class="anchor"></a><code>hole_deps : bool;</code></td><td class="doc"><p>Whether the remainder of the clause was dependent in the hole. Note that because let binders are substituted, it does not mean that it actually appears somewhere in the returned clause.</p></td></tr><tr id="type-hole.hole_name" class="anchored"><td class="def field"><a href="#type-hole.hole_name" class="anchor"></a><code>hole_name : <a href="../Names/Name/index.html#type-t">Names.Name.t</a>;</code></td><td class="doc"><p>Name of the hole coming from its binder.</p></td></tr></table><code>}</code></dt><dt class="spec type" id="type-clause"><a href="#type-clause" class="anchor"></a><code><span class="keyword">type</span> clause</code><code> = </code><code>{</code><table class="record"><tr id="type-clause.cl_holes" class="anchored"><td class="def field"><a href="#type-clause.cl_holes" class="anchor"></a><code>cl_holes : <span><a href="index.html#type-hole">hole</a> list</span>;</code></td></tr><tr id="type-clause.cl_concl" class="anchored"><td class="def field"><a href="#type-clause.cl_concl" class="anchor"></a><code>cl_concl : <a href="../EConstr/index.html#type-types">EConstr.types</a>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-make_evar_clause"><a href="#val-make_evar_clause" class="anchor"></a><code><span class="keyword">val</span> make_evar_clause : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-types">EConstr.types</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="index.html#type-clause">clause</a></code></dt><dd><p>An evar version of <code>make_clenv_binding</code>. Given a type <code>t</code>, <code>evar_environments env sigma ~len t bl</code> tries to eliminate at most <code>len</code> products of the type <code>t</code> by filling it with evars. It returns the resulting type together with the list of holes generated. Assumes that <code>t</code> is well-typed in the environment.</p></dd></dl><dl><dt class="spec value" id="val-solve_evar_clause"><a href="#val-solve_evar_clause" class="anchor"></a><code><span class="keyword">val</span> solve_evar_clause : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="index.html#type-clause">clause</a> <span>&#45;&gt;</span> <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <a href="../Tactypes/index.html#type-bindings">Tactypes.bindings</a></span> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></code></dt><dd><p><code>solve_evar_clause env sigma hyps cl bl</code> tries to solve the holes contained in <code>cl</code> according to the <code>bl</code> argument. Assumes that <code>bl</code> are well-typed in the environment. The boolean <code>hyps</code> is a compatibility flag that allows to consider arguments to be dependent only when they appear in hypotheses and not in the conclusion. This boolean is only used when <code>bl</code> is of the form <code>ImplicitBindings _</code>.</p></dd></dl><dl><dt class="spec value" id="val-check_bindings"><a href="#val-check_bindings" class="anchor"></a><code><span class="keyword">val</span> check_bindings : <span><span class="type-var">'a</span> <a href="../Tactypes/index.html#type-explicit_bindings">Tactypes.explicit_bindings</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-explain_no_such_bound_variable"><a href="#val-explain_no_such_bound_variable" class="anchor"></a><code><span class="keyword">val</span> explain_no_such_bound_variable : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> <span>&#45;&gt;</span> <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <a href="../CAst/index.html#type-t">CAst.t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-error_not_right_number_missing_arguments"><a href="#val-error_not_right_number_missing_arguments" class="anchor"></a><code><span class="keyword">val</span> error_not_right_number_missing_arguments : int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl></section></div></body></html>