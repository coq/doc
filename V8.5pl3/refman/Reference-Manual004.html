<!DOCTYPE html>
<html >
<head>


<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/coqdoc.css" /><title>Chapter 2  Extensions of Gallina</title>
</head>
<body >

<div id="container">

<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="/" class="active">Home</a></li>
    <li><a href="/about-coq" title="More about coq">About Coq</a></li>
    <li><a href="/download">Get Coq</a></li>
    <li><a href="/documentation">Documentation</a></li>
    <li><a href="/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">
<div id="logoWrapper">
  <div id="logo"><a href="/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
  </div>
  <div id="siteName"><a href="/" title="Home">The Coq Proof Assistant</a>
  </div>
</div>
</div>

<div id="content">

<h1 id="Gallina-extension" class="chapter">Chapter 2  Extensions of <span style="font-variant:small-caps">Gallina</span><a id="hevea_default67"></a></h1>
<ul>
<li><a href="Reference-Manual004.html#Record">2.1  Record types



</a>
</li><li><a href="Reference-Manual004.html#Extensions-of-match">2.2  Variants and extensions of <span style="font-family:monospace">match</span>

</a>
</li><li><a href="Reference-Manual004.html#sec77">2.3  Advanced recursive functions</a>
</li><li><a href="Reference-Manual004.html#Section">2.4  Section mechanism

</a>
</li><li><a href="Reference-Manual004.html#section%3AModules">2.5  Module system

</a>
</li><li><a href="Reference-Manual004.html#sec97">2.6  Libraries and qualified names</a>
</li><li><a href="Reference-Manual004.html#Implicit%20Arguments">2.7  Implicit arguments

</a>
</li><li><a href="Reference-Manual004.html#Coercions">2.8  Coercions

</a>
</li><li><a href="Reference-Manual004.html#SetPrintingAll">2.9  Printing constructions in full</a>
</li><li><a href="Reference-Manual004.html#PrintingUniverses">2.10  Printing universes</a>
</li><li><a href="Reference-Manual004.html#ExistentialVariables">2.11  Existential variables</a>
</li></ul>
<p><span style="font-variant:small-caps">Gallina</span> is the kernel language of <span style="font-variant:small-caps">Coq</span>. We describe here extensions of
the Gallina’s syntax.</p>
<h2 id="Record" class="section">2.1  Record types
<a id="hevea_default68"></a><a id="hevea_command31"></a>
<a id="hevea_default69"></a><a id="hevea_command32"></a>
<a id="hevea_default70"></a><a id="hevea_command33"></a>
</h2>
<p>The <code>Record</code> construction is a macro allowing the definition of
records as is done in many programming languages. Its syntax is
described on Figure <a href="#record-syntax">2.1</a>. In fact, the <code>Record</code>
macro is more general than the usual record types, since it allows
also for “manifest” expressions. In this sense, the <code>Record</code>
construction allows defining “signatures”.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">sentence</span></td><td style="text-align:center;white-space:nowrap" >++=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">record</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">record</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-style:oblique">record_keyword</span> <span style="font-style:oblique">ident</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">binders</span><span style="font-style:oblique">]</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">sort</span><span style="font-style:oblique">]</span> <code>:=</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >    <span style="font-style:oblique">[</span><span style="font-style:oblique">ident</span><span style="font-style:oblique">]</span>
<code>{</code> <span style="font-style:oblique">[</span><span style="font-style:oblique">field</span> <span style="font-family:monospace">;</span> … <span style="font-family:monospace">;</span> <span style="font-style:oblique">field</span><span style="font-style:oblique">]</span> <code>}</code> <code>.</code></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">record_keyword</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">Record</span> | <span style="font-family:monospace">Inductive</span> | <span style="font-family:monospace">CoInductive</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">field</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">name</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">binders</span><span style="font-style:oblique">]</span> : <span style="font-style:oblique">type</span> [ <span style="font-family:monospace">where</span> <span style="font-style:italic">notation</span> ] </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">name</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">binders</span><span style="font-style:oblique">]</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><span style="font-style:oblique">]</span> := <span style="font-style:oblique">term</span>
</td></tr>
</table>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 2.1: Syntax for the definition of <span style="font-family:monospace">Record</span></td></tr>
</table></div>
<a id="record-syntax"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>In the expression</p><p><br>
<span style="font-family:monospace">Record</span> <span style="font-style:oblique">ident</span> <span style="font-style:oblique">params</span> <span style="font-family:monospace">:</span> 
<span style="font-style:oblique">sort</span> := <span style="font-style:oblique">ident</span><sub>0</sub> <code>{</code>
<span style="font-style:oblique">ident</span><sub>1</sub> <span style="font-style:oblique">binders</span><sub>1</sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><sub>1</sub>; 
…<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:oblique">binders</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> <code>}</code>.
<br>
</p><p>the identifier <span style="font-style:oblique">ident</span> is the name of the defined record
and <span style="font-style:oblique">sort</span> is its type. The identifier <span style="font-style:oblique">ident</span><sub>0</sub> is the name of
its constructor. If <span style="font-style:oblique">ident</span><sub>0</sub> is omitted, the default name <span style="font-family:monospace">Build_</span><span style="font-style:oblique">ident</span> is used. If <span style="font-style:oblique">sort</span> is omitted, the default sort is “<span style="font-family:sans-serif">Type</span>”.
The identifiers <span style="font-style:oblique">ident</span><sub>1</sub>, ..,
<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> are the names of fields and <span style="font-family:monospace">forall</span> <span style="font-style:oblique">binders</span><sub>1</sub><span style="font-family:monospace">,</span> <span style="font-style:oblique">term</span><sub>1</sub>, ..., <span style="font-family:monospace">forall</span> <span style="font-style:oblique">binders</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">,</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>
their respective types. Remark that the type of <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub> may
depend on the previous <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">j</span></sub> (for <span style="font-style:italic">j</span>&lt;<span style="font-style:italic">i</span>). Thus the order of the
fields is important. Finally, <span style="font-style:oblique">params</span> are the parameters of the
record.</p><p>More generally, a record may have explicitly defined (a.k.a.
manifest) fields. For instance, <span style="font-family:monospace">Record</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">[</span>
<span style="font-style:oblique">params</span> <span style="font-family:monospace">]</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">sort</span> := <code>{</code> <span style="font-style:oblique">ident</span><sub>1</sub>
<span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub>1</sub> <code>;</code> <span style="font-style:oblique">ident</span><sub>2</sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>2</sub>
<code>;</code> <span style="font-style:oblique">ident</span><sub>3</sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub>3</sub> <code>}</code> in which case
the correctness of <span style="font-style:oblique">type</span><sub>3</sub> may rely on the instance <span style="font-style:oblique">term</span><sub>2</sub> of
<span style="font-style:oblique">ident</span><sub>2</sub> and <span style="font-style:oblique">term</span><sub>2</sub> in turn may depend on <span style="font-style:oblique">ident</span><sub>1</sub>.</p><p><br>
<span style="font-weight:bold">Example: </span>The set of rational numbers may be defined as:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Record Rat : Set := mkRat</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        {sign : bool;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         top : nat;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         bottom : nat;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         Rat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">bottom</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">cond : 0 </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> bottom;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         Rat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">irred</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">cond :</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          forall x y z:nat, (x * y) = top /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> (x * z) = bottom -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> x = 1}.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Rat is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">sign is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">top is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">bottom is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Rat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">bottom</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">cond is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Rat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">irred</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">cond is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>Remark here that the field
<code>Rat_cond</code> depends on the field <code>bottom</code>. </p><p>Let us now see the work done by the <span style="font-family:monospace">Record</span> macro. First the
macro generates a variant type definition with just one constructor:
</p><blockquote class="quote">
<span style="font-family:monospace">Variant </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">params</span><span style="font-family:monospace"> :</span><span style="font-style:oblique">sort</span><span style="font-family:monospace"> :=</span> <br>
    <span style="font-style:oblique">ident</span><sub>0</sub><span style="font-family:monospace"> (</span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">:</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">) .. (</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">:</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">).</span>
</blockquote><p>
To build an object of type <span style="font-style:oblique">ident</span>, one should provide the
constructor <span style="font-style:oblique">ident</span><sub>0</sub> with <span style="font-style:italic">n</span> terms filling the fields of
the record.</p><p>As an example, let us define the rational 1/2:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import Arith.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Theorem one</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">two</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">irred :</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">       forall x y z:nat, x * y = 1 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> x * z = 2 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> x = 1.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
…<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Qed.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition half := mkRat true 1 2 (O</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">S 1) one</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">two</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">irred.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">half is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check half.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">half</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Rat</span></span></span><span style="font-size:small"><br>
</span></div><p>The macro generates also, when it is possible, the projection
functions for destructuring an object of type <span style="font-style:oblique">ident</span>. These
projection functions have the same name that the corresponding
fields. If a field is named “<code>_</code>” then no projection is built
for it. In our example:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Eval compute in half.(top).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     = 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Eval compute in half.(bottom).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     = 2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Eval compute in half.(Rat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">bottom</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">cond).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     = O</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">S 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : 0 </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> bottom half</span></span></span><span style="font-size:small"><br>
</span></div><p>Records defined with the <span style="font-family:monospace">Record</span> keyword are not allowed to be
recursive (references to the record’s name in the type of its field
raises an error). To define recursive records, one can use the <span style="font-family:monospace">Inductive</span> and <span style="font-family:monospace">CoInductive</span> keywords, resulting in an inductive
or co-inductive record. A <em>caveat</em>, however, is that records
cannot appear in mutually inductive (or co-inductive) definitions.
Induction schemes are automatically generated for inductive records.
Automatic generation of induction schemes for non-recursive records
defined with the <span style="font-family:monospace">Record</span> keyword can be activated with the
<span style="font-family:monospace">Nonrecursive Elimination Schemes</span> option
(see <a href="Reference-Manual015.html#set-nonrecursive-elimination-schemes">13.1.1</a>).</p><p><br>
<span style="font-weight:bold">Warnings: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub><span style="font-family:monospace"> cannot be defined.</span><p>It can happen that the definition of a projection is impossible.
This message is followed by an explanation of this impossibility.
There may be three reasons:
</p><ol class="enumerate" type=a><li class="li-enumerate">
The name <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub> already exists in the environment (see
Section <a href="Reference-Manual003.html#Axiom">1.3.1</a>).
</li><li class="li-enumerate">The body of <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub> uses an incorrect elimination for
<span style="font-style:oblique">ident</span> (see Sections <a href="Reference-Manual003.html#Fixpoint">1.3.4</a> and <a href="Reference-Manual006.html#Caseexpr">4.5.3</a>).
</li><li class="li-enumerate">The type of the projections <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub> depends on previous
projections which themselves could not be defined.
</li></ol></li></ol><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Records declared with the keyword Record or Structure cannot be recursive.</span><a id="hevea_error11"></a><p>The record name <span style="font-style:oblique">ident</span> appears in the type of its fields, but uses
the keyword <span style="font-family:monospace">Record</span>. Use the keyword <span style="font-family:monospace">Inductive</span> or <span style="font-family:monospace">CoInductive</span> instead.
</p></li><li class="li-enumerate"><span style="font-family:monospace">Cannot handle mutually (co)inductive records.</span><a id="hevea_error12"></a><p>Records cannot be defined as part of mutually inductive (or
co-inductive) definitions, whether with records only or mixed with
standard definitions.
</p></li><li class="li-enumerate">During the definition of the one-constructor inductive
definition, all the errors of inductive definitions, as described in
Section <a href="Reference-Manual003.html#gal-Inductive-Definitions">1.3.3</a>, may also occur.</li></ol><p><br>
<span style="font-weight:bold">See also: </span>Coercions and records in Section <a href="Reference-Manual021.html#Coercions-and-records">18.9</a>
of the chapter devoted to coercions.</p><p><br>
<span style="font-weight:bold">Remark: </span><span style="font-family:monospace">Structure</span> is a synonym of the keyword <span style="font-family:monospace">Record</span>.</p><p><br>
<span style="font-weight:bold">Remark: </span>Creation of an object of record type can be done by calling <span style="font-style:oblique">ident</span><sub>0</sub>
and passing arguments in the correct order.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Record point := { x : nat; y : nat }.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">point is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">y is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition a := Build</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">point 5 3.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">a is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>The following syntax allows creating objects by using named fields. The
fields do not have to be in any particular order, nor do they have to be all
present if the missing ones can be inferred or prompted for (see
Section <a href="Reference-Manual027.html#Program">24</a>).</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition b := {| x := 5; y := 3 |}.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">b is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition c := {| y := 3; x := 5 |}.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">c is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>This syntax can be disabled globally for printing by
</p><blockquote class="quote">
<span style="font-family:monospace">Unset Printing Records.</span>
<a id="hevea_default71"></a><a id="hevea_option0"></a>
</blockquote><p>
For a given type, one can override this using either
</p><blockquote class="quote">
<span style="font-family:monospace">Add Printing Record </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">.</span>
</blockquote><p>
to get record syntax or
</p><blockquote class="quote">
<span style="font-family:monospace">Add Printing Constructor </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">.</span>
</blockquote><p>
to get constructor syntax.</p><p>This syntax can also be used for pattern matching.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Eval compute in (</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match b with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | {| y := S n |} =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> n</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 0</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     = 2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Remark: </span>An experimental syntax for projections based on a dot notation is
available. The command to activate it is
<a id="hevea_default72"></a><a id="hevea_option1"></a>
</p><blockquote class="quote">
<span style="font-family:monospace">Set Printing Projections.</span>
</blockquote><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >++=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-family:monospace">.(</span> <span style="font-style:oblique">qualid</span> <span style="font-family:monospace">)</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-family:monospace">.(</span> <span style="font-style:oblique">qualid</span> <span style="font-style:oblique">arg</span>  …  <span style="font-style:oblique">arg</span> <span style="font-family:monospace">)</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-family:monospace">.(</span> @<span style="font-style:oblique">qualid</span> <span style="font-style:oblique">term</span>  …  <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span>
</td></tr>
</table>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 2.2: Syntax of <span style="font-family:monospace">Record</span> projections</td></tr>
</table></div>
<a id="fig:projsyntax"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>The corresponding grammar rules are given Figure <a href="#fig%3Aprojsyntax">2.2</a>.
When <span style="font-style:oblique">qualid</span> denotes a projection, the syntax <span style="font-style:oblique">term</span><span style="font-family:monospace">.(</span><span style="font-style:oblique">qualid</span><span style="font-family:monospace">)</span> is equivalent to <span style="font-style:oblique">qualid</span> <span style="font-style:oblique">term</span>, the syntax
<span style="font-style:oblique">term</span><span style="font-family:monospace">.(</span><span style="font-style:oblique">qualid</span> <span style="font-style:oblique">arg</span><sub>1</sub> … <span style="font-style:oblique">arg</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span> to
<span style="font-style:oblique">qualid</span> <span style="font-style:oblique">arg</span><sub>1</sub> … <span style="font-style:oblique">arg</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:oblique">term</span>, and the syntax
<span style="font-style:oblique">term</span><span style="font-family:monospace">.(@</span><span style="font-style:oblique">qualid</span> <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span> to
@<span style="font-style:oblique">qualid</span> <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:oblique">term</span>. In each case, <span style="font-style:oblique">term</span>
is the object projected and the other arguments are the parameters of
the inductive type.</p><p>To deactivate the printing of projections, use 
<span style="font-family:monospace">Unset Printing Projections</span>.</p>
<h3 id="sec63" class="subsection">2.1.1  Primitive Projections</h3>
<p>
<a id="hevea_default73"></a><a id="hevea_option2"></a>
<a id="hevea_default74"></a><a id="hevea_option3"></a>
<a id="hevea_default75"></a><a id="hevea_option4"></a>
<a id="hevea_default76"></a>
<a id="prim-proj"></a></p><p>The option <span style="font-family:monospace">Set Primitive Projections</span> turns on the use of primitive
projections when defining subsequent records. Primitive projections
extended the Calculus of Inductive Constructions with a new binary term
constructor <span style="font-family:monospace">r.(p)</span> representing a primitive projection p applied to
a record object <span style="font-family:monospace">r</span> (i.e., primitive projections are always
applied). Even if the record type has parameters, these do not appear at
applications of the projection, considerably reducing the sizes of terms
when manipulating parameterized records and typechecking time. On the
user level, primitive projections are a transparent replacement
for the usual defined ones.</p><p>For compatibility, the parameters still appear to the user when printing terms
even though they are absent in the actual AST manipulated by the kernel. This
can be changed by unsetting the <span style="font-family:monospace">Printing Primitive Projection Parameters</span>
flag. Further compatibility printing can be deactivated thanks to the
<span style="font-family:monospace">Printing Primitive Projection Compatibility</span> option which governs the
printing of pattern-matching over primitive records.</p>
<h2 id="Extensions-of-match" class="section">2.2  Variants and extensions of <span style="font-family:monospace">match</span>

<a id="hevea_default77"></a></h2>
<h3 id="Mult-match" class="subsection">2.2.1  Multiple and nested pattern-matching
<a id="hevea_default78"></a>
</h3>
<p>The basic version of <code>match</code> allows pattern-matching on simple
patterns. As an extension, multiple nested patterns or disjunction of
patterns are allowed, as in ML-like languages.</p><p>The extension just acts as a macro that is expanded during parsing
into a sequence of <span style="font-family:monospace">match</span> on simple patterns. Especially, a
construction defined using the extended <span style="font-family:monospace">match</span> is generally
printed under its expanded form (see <span style="font-family:monospace">Set Printing Matching</span> in
section <a href="#SetPrintingMatching">2.2.4</a>).</p><p><br>
<span style="font-weight:bold">See also: </span>Chapter <a href="Reference-Manual020.html#Mult-match-full">17</a>.</p>
<h3 id="if-then-else" class="subsection">2.2.2  Pattern-matching on boolean values: the <span style="font-family:monospace">if</span> expression

<a id="hevea_default79"></a></h3>
<p>For inductive types with exactly two constructors and for
pattern-matchings expressions which do not depend on the arguments of
the constructors, it is possible to use a <span style="font-family:monospace">if ... then ... else</span>
notation. For instance, the definition</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition not (b:bool) :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match b with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | true =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> false</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | false =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> true</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">not is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>can be alternatively written</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition not (b:bool) := if b then false else true.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">not is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>More generally, for an inductive type with constructors <span style="font-family:monospace">C</span><sub>1</sub>
and <span style="font-family:monospace">C</span><sub>2</sub>, we have the following equivalence</p><p><br>
</p><p><span style="font-family:monospace">if </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">dep_ret_type</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> then </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> else </span><span style="font-style:oblique">term</span><sub>2</sub> ≡
</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">match </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">dep_ret_type</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> with</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code><span style="font-family:monospace">|</span></code><span style="font-family:monospace"> C</span><sub>1</sub><span style="font-family:monospace"> _ </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> _ </span><code><span style="font-family:monospace">=&gt;</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code><span style="font-family:monospace">|</span></code><span style="font-family:monospace"> C</span><sub>2</sub><span style="font-family:monospace"> _ </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> _ </span><code><span style="font-family:monospace">=&gt;</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>2</sub> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">end</span>
</td></tr>
</table><p>Here is an example.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun x (H:{x=0}+{x</span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">0}) =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match H with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | left </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> true</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | right </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> false</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun (x : nat) (H : {x = 0} + {x </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0}) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> if H then true else false</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall x : nat, {x = 0} + {x </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0} -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> bool</span></span></span><span style="font-size:small"><br>
</span></div><p>Notice that the printing uses the <span style="font-family:monospace">if</span> syntax because <span style="font-family:monospace">sumbool</span> is
declared as such (see Section <a href="#printing-options">2.2.4</a>).</p>
<h3 id="Letin" class="subsection">2.2.3  Irrefutable patterns: the destructuring <span style="font-family:monospace">let</span> variants 
<a id="hevea_default80"></a>
</h3>
<p>Pattern-matching on terms inhabiting inductive type having only one
constructor can be alternatively written using <span style="font-family:monospace">let ... in ...</span>
constructions. There are two variants of them.</p>
<h4 id="sec68" class="subsubsection">First destructuring <span style="font-family:monospace">let</span> syntax</h4>
<p>
The expression <span style="font-family:monospace">let
(</span> <span style="font-style:oblique">ident</span><sub>1</sub>,…,<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">) :=</span> <span style="font-style:oblique">term</span><sub>0</sub> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span><sub>1</sub> performs case analysis on a <span style="font-style:oblique">term</span><sub>0</sub> which must be in
an inductive type with one constructor having itself <span style="font-style:italic">n</span> arguments. Variables
<span style="font-style:oblique">ident</span><sub>1</sub>…<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> are bound to the <span style="font-style:italic">n</span> arguments of the
constructor in expression <span style="font-style:oblique">term</span><sub>1</sub>. For instance, the definition</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition fst (A B:Set) (H:A * B) := match H with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                                            | pair x y =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> x</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                                            end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fst is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>can be alternatively written </p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition fst (A B:Set) (p:A * B) := let (x, </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">) := p in x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fst is defined</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
Notice that reduction is different from regular <span style="font-family:monospace">let ... in ...</span>
construction since it happens only if <span style="font-style:oblique">term</span><sub>0</sub> is in constructor
form. Otherwise, the reduction is blocked.</p><p>The pretty-printing of a definition by matching on a
irrefutable pattern can either be done using <span style="font-family:monospace">match</span> or the <span style="font-family:monospace">let</span> construction (see Section <a href="#printing-options">2.2.4</a>).</p><p>If <span style="font-style:oblique">term</span> inhabits an inductive type with one constructor <span style="font-family:monospace">C</span>,
we have an equivalence between</p><p><span style="font-family:monospace">let (</span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">,…,</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">) </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">dep_ret_type</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">term</span><span style="font-family:monospace">’</span></p><p>and</p><p><span style="font-family:monospace">match </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">dep_ret_type</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> with C </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><code><span style="font-family:monospace">=&gt;</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace">’ end</span></p>
<h4 id="sec69" class="subsubsection">Second destructuring <span style="font-family:monospace">let</span> syntax<a id="hevea_default81"></a></h4>
<p>Another destructuring <span style="font-family:monospace">let</span> syntax is available for inductive types with
one constructor by giving an arbitrary pattern instead of just a tuple
for all the arguments. For example, the preceding example can be written:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition fst (A B:Set) (p:A*B) := let </span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">pair x </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> := p in x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fst is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>This is useful to match deeper inside tuples and also to use notations
for the pattern, as the syntax <span style="font-family:monospace">let ’p := t in b</span> allows arbitrary
patterns to do the deconstruction. For example:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition deep</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">tuple (A:Set) (x:(A*A)*(A*A)) : A*A*A*A :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        let </span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">((a,b), (c, d)) := x in (a,b,c,d).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">deep</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tuple is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Notation " x </span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">With</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> p " := (exist </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> x p) (at level 20).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Identifier </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">With</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> now a keyword</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition proj1</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">sig</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> (A:Set) (P:A-</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">Prop) (t:{ x:A | P x }) : A :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        let </span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">x With p := t in x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">proj1</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">sig</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>When printing definitions which are written using this construct it
takes precedence over <span style="font-family:monospace">let</span> printing directives for the datatype
under consideration (see Section <a href="#printing-options">2.2.4</a>).</p>
<h3 id="printing-options" class="subsection">2.2.4  Controlling pretty-printing of <span style="font-family:monospace">match</span> expressions
</h3>
<p>The following commands give some control over the pretty-printing of
<span style="font-family:monospace">match</span> expressions.</p>
<h4 id="SetPrintingMatching" class="subsubsection">Printing nested patterns

<a id="hevea_default82"></a><a id="hevea_option5"></a></h4>
<p>The Calculus of Inductive Constructions knows pattern-matching only
over simple patterns. It is however convenient to re-factorize nested
pattern-matching into a single pattern-matching over a nested pattern.
<span style="font-variant:small-caps">Coq</span>’s printer try to do such limited re-factorization.</p><blockquote class="quote">
<span style="font-family:monospace">Set Printing Matching.</span>
</blockquote><p>
This tells <span style="font-variant:small-caps">Coq</span> to try to use nested patterns. This is the default
behavior.</p><blockquote class="quote">
<span style="font-family:monospace">Unset Printing Matching.</span>
</blockquote><p>
This tells <span style="font-variant:small-caps">Coq</span> to print only simple pattern-matching problems in
the same way as the <span style="font-variant:small-caps">Coq</span> kernel handles them.</p><blockquote class="quote">
<span style="font-family:monospace">Test Printing Matching.</span>
</blockquote><p>
This tells if the printing matching mode is on or off. The default is
on.</p>
<h4 id="sec72" class="subsubsection">Printing of wildcard pattern
<a id="hevea_default83"></a><a id="hevea_option6"></a></h4>
<p>Some variables in a pattern may not occur in the right-hand side of
the pattern-matching clause. There are options to control the
display of these variables.</p><blockquote class="quote">
<span style="font-family:monospace">Set Printing Wildcard.</span>
</blockquote><p>
The variables having no occurrences in the right-hand side of the
pattern-matching clause are just printed using the wildcard symbol
“<span style="font-family:monospace">_</span>”.</p><blockquote class="quote">
<span style="font-family:monospace">Unset Printing Wildcard.</span>
</blockquote><p>
The variables, even useless, are printed using their usual name. But some
non dependent variables have no name. These ones are still printed
using a “<span style="font-family:monospace">_</span>”.</p><blockquote class="quote">
<span style="font-family:monospace">Test Printing Wildcard.</span>
</blockquote><p>
This tells if the wildcard printing mode is on or off. The default is
to print wildcard for useless variables.</p>
<h4 id="sec73" class="subsubsection">Printing of the elimination predicate
<a id="hevea_default84"></a><a id="hevea_option7"></a></h4>
<p>In most of the cases, the type of the result of a matched term is
mechanically synthesizable. Especially, if the result type does not
depend of the matched term.</p><blockquote class="quote">
<span style="font-family:monospace">Set Printing Synth.</span>
</blockquote><p>
The result type is not printed when <span style="font-variant:small-caps">Coq</span> knows that it can
re-synthesize it.</p><blockquote class="quote">
<span style="font-family:monospace">Unset Printing Synth.</span>
</blockquote><p>
This forces the result type to be always printed.</p><blockquote class="quote">
<span style="font-family:monospace">Test Printing Synth.</span>
</blockquote><p>
This tells if the non-printing of synthesizable types is on or off.
The default is to not print synthesizable types.</p>
<h4 id="AddPrintingLet" class="subsubsection">Printing matching on irrefutable pattern

<a id="hevea_default85"></a><a id="hevea_command34"></a>
<a id="hevea_default86"></a><a id="hevea_command35"></a>
<a id="hevea_default87"></a><a id="hevea_command36"></a>
<a id="hevea_default88"></a><a id="hevea_command37"></a></h4>
<p>If an inductive type has just one constructor,
pattern-matching can be written using the first destructuring let syntax.</p><blockquote class="quote">
<span style="font-family:monospace">Add Printing Let </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">.</span>
</blockquote><p>
This adds <span style="font-style:oblique">ident</span> to the list of inductive types for which
pattern-matching is written using a <span style="font-family:monospace">let</span> expression.</p><blockquote class="quote">
<span style="font-family:monospace">Remove Printing Let </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">.</span>
</blockquote><p>
This removes <span style="font-style:oblique">ident</span> from this list. Note that removing an inductive
type from this list has an impact only for pattern-matching written using
<span style="font-family:monospace">match</span>. Pattern-matching explicitly written using a destructuring
let are not impacted.</p><blockquote class="quote">
<span style="font-family:monospace">Test Printing Let for </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">.</span>
</blockquote><p>
This tells if <span style="font-style:oblique">ident</span> belongs to the list.</p><blockquote class="quote">
<span style="font-family:monospace">Print Table Printing Let.</span>
</blockquote><p>
This prints the list of inductive types for which pattern-matching is
written using a <span style="font-family:monospace">let</span> expression.</p><p>The list of inductive types for which pattern-matching is written
using a <span style="font-family:monospace">let</span> expression is managed synchronously. This means that
it is sensible to the command <span style="font-family:monospace">Reset</span>.</p>
<h4 id="sec75" class="subsubsection">Printing matching on booleans
<a id="hevea_default89"></a><a id="hevea_command38"></a>
<a id="hevea_default90"></a><a id="hevea_command39"></a>
<a id="hevea_default91"></a><a id="hevea_command40"></a>
<a id="hevea_default92"></a><a id="hevea_command41"></a></h4>
<p>If an inductive type is isomorphic to the boolean type,
pattern-matching can be written using <span style="font-family:monospace">if</span> ... <span style="font-family:monospace">then</span> ... <span style="font-family:monospace">else</span> ...</p><blockquote class="quote">
<span style="font-family:monospace">Add Printing If </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">.</span>
</blockquote><p>
This adds <span style="font-style:oblique">ident</span> to the list of inductive types for which
pattern-matching is written using an <span style="font-family:monospace">if</span> expression.</p><blockquote class="quote">
<span style="font-family:monospace">Remove Printing If </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">.</span>
</blockquote><p>
This removes <span style="font-style:oblique">ident</span> from this list.</p><blockquote class="quote">
<span style="font-family:monospace">Test Printing If for </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">.</span>
</blockquote><p>
This tells if <span style="font-style:oblique">ident</span> belongs to the list.</p><blockquote class="quote">
<span style="font-family:monospace">Print Table Printing If.</span>
</blockquote><p>
This prints the list of inductive types for which pattern-matching is
written using an <span style="font-family:monospace">if</span> expression.</p><p>The list of inductive types for which pattern-matching is written
using an <span style="font-family:monospace">if</span> expression is managed synchronously. This means that
it is sensible to the command <span style="font-family:monospace">Reset</span>.</p>
<h4 id="sec76" class="subsubsection">Example</h4>
<p>This example emphasizes what the printing options offer.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition snd (A B:Set) (H:A * B) := match H with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                                            | pair x y =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> y</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                                            end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">snd is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Test Printing Let for prod.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Cases on elements of prod are printed using a `let</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> form</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print snd.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">snd = </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun (A B : Set) (H : A * B) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> let (</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">, y) := H in y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall A B : Set, A * B -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> B</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument scopes are [type</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope type</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">]</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Remove Printing Let prod.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Unset Printing Synth.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Unset Printing Wildcard.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print snd.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">snd = </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun (A B : Set) (H : A * B) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> match H return B with</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">                               | (x, y) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">                               end</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall A B : Set, A * B -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> B</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument scopes are [type</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope type</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">]</span></span></span><span style="font-size:small"><br>
</span></div>
<h2 id="sec77" class="section">2.3  Advanced recursive functions</h2>
<p>The <em>experimental</em> command 
</p><div class="center">
<span style="font-family:monospace">Function </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">
{decrease_annot} : type</span><sub>0</sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><sub>0</sub>
<a id="hevea_default93"></a><a id="hevea_command42"></a>
<a id="Function"></a>
</div><p>
can be seen as a generalization of <span style="font-family:monospace">Fixpoint</span>. It is actually a
wrapper for several ways of defining a function <em>and other useful
related objects</em>, namely: an induction principle that reflects the
recursive structure of the function (see <a href="Reference-Manual010.html#FunInduction">8.5.5</a>), and its
fixpoint equality. The meaning of this
declaration is to define a function <span style="font-style:italic">ident</span>, similarly to <span style="font-family:monospace">Fixpoint</span>. Like in <span style="font-family:monospace">Fixpoint</span>, the decreasing argument must be
given (unless the function is not recursive), but it must not
necessary be <em>structurally</em> decreasing. The point of the <span style="font-family:monospace">{}</span> annotation is to name the decreasing argument <em>and</em> to
describe which kind of decreasing criteria must be used to ensure
termination of recursive calls.</p><p>The <span style="font-family:monospace">Function</span> construction enjoys also the <span style="font-family:monospace">with</span> extension
to define mutually recursive definitions. However, this feature does
not work for non structural recursive functions. </p><p>See the documentation of <span style="font-family:monospace">functional induction</span>
(see Section <a href="Reference-Manual010.html#FunInduction">8.5.5</a>) and <span style="font-family:monospace">Functional Scheme</span>
(see Section <a href="Reference-Manual015.html#FunScheme">13.2</a> and <a href="Reference-Manual015.html#FunScheme-examples">13.2</a>) for how to use the
induction principle to easily reason about the function.</p><p><span style="font-weight:bold">Remark: </span> To obtain the right principle, it is better
to put rigid parameters of the function as first arguments. For
example it is better to define plus like this:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Function plus (m n : nat) {struct n} : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match n with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | 0 =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> m</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | S p =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (plus m p)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
than like this:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Function plus (n m : nat) {struct n} : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match n with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | 0 =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> m</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | S p =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (plus p m)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end.</span></span><span style="font-size:small"><br>
</span></div><h5 id="sec:Function-limitations" class="paragraph">Limitations</h5>
<p>
<span style="font-style:oblique">term</span><sub>0</sub> must be build as a <em>pure pattern-matching tree</em>
(<span style="font-family:monospace">match...with</span>) with applications only <em>at the end</em> of
each branch. </p><p>Function does not support partial application of the function being defined. Thus, the following example cannot be accepted due to the presence of partial application of <span style="font-style:oblique">ident</span>wrong into the body of <span style="font-style:oblique">ident</span>wrong :
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail Function wrong (C:nat) : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        List.hd 0 (List.map wrong (C::nil)).</span></span><span style="font-size:small"><br>
</span></div><p>For now dependent cases are not treated for non structurally terminating functions.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">The recursive argument must be specified</span><a id="hevea_error13"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">No argument name </span><span style="font-style:oblique">ident</span><a id="hevea_error14"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">Cannot use mutual definition with well-founded
recursion or measure</span><a id="hevea_error15"></a></li><li class="li-enumerate"><span style="font-family:monospace">Cannot define graph for </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">…</span><a id="hevea_error16"></a> (warning)<p>The generation of the graph relation <span style="font-family:monospace">(R_</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">)</span> used to
compute the induction scheme of <span style="font-style:oblique">ident</span> raised a typing error. Only
the ident is defined, the induction scheme will not be generated.</p><p>This error happens generally when:</p><ul class="itemize"><li class="li-itemize">
the definition uses pattern matching on dependent types, which
<span style="font-family:monospace">Function</span> cannot deal with yet.
</li><li class="li-itemize">the definition is not a <em>pattern-matching tree</em> as
explained above.
</li></ul></li><li class="li-enumerate"><span style="font-family:monospace">Cannot define principle(s) for </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">…</span><a id="hevea_error17"></a> (warning)<p>The generation of the graph relation <span style="font-family:monospace">(R_</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">)</span> succeeded
but the induction principle could not be built. Only the ident is
defined. Please report.</p></li><li class="li-enumerate"><span style="font-family:monospace">Cannot build functional inversion principle</span><a id="hevea_error18"></a> (warning)<p><span style="font-family:monospace">functional inversion</span> will not be available for the
function.
</p></li></ol><p><br>
<span style="font-weight:bold">See also: </span><a href="Reference-Manual015.html#FunScheme">13.2</a>, <a href="Reference-Manual015.html#FunScheme-examples">13.2</a>, <a href="Reference-Manual010.html#FunInduction">8.5.5</a></p><p>Depending on the <span style="font-family:monospace">{</span>…<span style="font-family:monospace">}</span> annotation, different definition
mechanisms are used by <span style="font-family:monospace">Function</span>. More precise description
given below.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace"> Function </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">
: type</span><sub>0</sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><sub>0</sub><p>Defines the not recursive function <span style="font-style:oblique">ident</span> as if declared with
<span style="font-family:monospace">Definition</span>. Moreover the following are defined:</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:oblique">ident</span><span style="font-family:monospace">_rect</span>, <span style="font-style:oblique">ident</span><span style="font-family:monospace">_rec</span> and <span style="font-style:oblique">ident</span><span style="font-family:monospace">_ind</span>,
which reflect the pattern matching structure of <span style="font-style:oblique">term</span><sub>0</sub> (see the
documentation of <span style="font-family:monospace">Inductive</span> <a href="Reference-Manual003.html#Inductive">1.3.3</a>);
</li><li class="li-itemize">The inductive <span style="font-family:monospace">R_</span><span style="font-style:oblique">ident</span> corresponding to the graph of
<span style="font-style:oblique">ident</span> (silently);
</li><li class="li-itemize"><span style="font-style:oblique">ident</span><span style="font-family:monospace">_complete</span> and <span style="font-style:oblique">ident</span><span style="font-family:monospace">_correct</span> which are
inversion information linking the function and its graph.
</li></ul></li><li class="li-enumerate"><span style="font-family:monospace">Function </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">
</span><span style="font-family:monospace">{</span><span style="font-family:monospace">struct</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub>0</sub><span style="font-family:monospace">}</span><span style="font-family:monospace"> : type</span><sub>0</sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><sub>0</sub><p>Defines the structural recursive function <span style="font-style:oblique">ident</span> as if declared
with <span style="font-family:monospace">Fixpoint</span>. Moreover the following are defined:</p><ul class="itemize"><li class="li-itemize">
The same objects as above;
</li><li class="li-itemize">The fixpoint equation of <span style="font-style:oblique">ident</span>: <span style="font-style:oblique">ident</span><span style="font-family:monospace">_equation</span>.
</li></ul></li><li class="li-enumerate"><span style="font-family:monospace">Function </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">{</span><span style="font-family:monospace">measure </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub>0</sub><span style="font-family:monospace">}</span><span style="font-family:monospace"> : type</span><sub>0</sub><span style="font-family:monospace"> :=
</span><span style="font-style:oblique">term</span><sub>0</sub>
</li><li class="li-enumerate"><span style="font-family:monospace">Function </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">
</span><span style="font-family:monospace">{</span><span style="font-family:monospace">wf </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub>0</sub><span style="font-family:monospace">}</span><span style="font-family:monospace"> : type</span><sub>0</sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><sub>0</sub><p>Defines a recursive function by well founded recursion. <span style="font-weight:bold">The
module </span><span style="font-weight:bold"><span style="font-family:monospace">Recdef</span></span><span style="font-weight:bold"> of the standard library must be loaded for this
feature</span>. The <span style="font-family:monospace">{}</span> annotation is mandatory and must be one of
the following:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">{measure</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-style:oblique">ident</span><sub>0</sub><span style="font-family:monospace">}</span> with <span style="font-style:oblique">ident</span><sub>0</sub>
being the decreasing argument and <span style="font-style:oblique">term</span><sub>1</sub> being a function
from type of <span style="font-style:oblique">ident</span><sub>0</sub> to <span style="font-family:monospace">nat</span> for which value on the
decreasing argument decreases (for the <span style="font-family:monospace">lt</span> order on <span style="font-family:monospace">nat</span>) at each recursive call of <span style="font-style:oblique">term</span><sub>0</sub>, parameters of the
function are bound in <span style="font-style:oblique">term</span><sub>0</sub>;
</li><li class="li-itemize"><span style="font-family:monospace">{wf</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-style:oblique">ident</span><sub>0</sub><span style="font-family:monospace">}</span> with <span style="font-style:oblique">ident</span><sub>0</sub> being
the decreasing argument and <span style="font-style:oblique">term</span><sub>1</sub> an ordering relation on
the type of <span style="font-style:oblique">ident</span><sub>0</sub> (i.e. of type T<sub><span style="font-style:oblique">ident</span><sub>0</sub></sub>
→ T<sub><span style="font-style:oblique">ident</span><sub>0</sub></sub> → <span style="font-family:monospace">Prop</span>) for which
the decreasing argument decreases at each recursive call of
<span style="font-style:oblique">term</span><sub>0</sub>. The order must be well founded. parameters of the
function are bound in <span style="font-style:oblique">term</span><sub>0</sub>.
</li></ul><p>Depending on the annotation, the user is left with some proof
obligations that will be used to define the function. These proofs
are: proofs that each recursive call is actually decreasing with
respect to the given criteria, and (if the criteria is <span style="font-family:monospace">wf</span>) a
proof that the ordering relation is well founded.</p><p>Once proof obligations are discharged, the following objects are
defined:</p><ul class="itemize"><li class="li-itemize">
The same objects as with the <span style="font-family:monospace">struct</span>;
</li><li class="li-itemize">The lemma <span style="font-style:oblique">ident</span><span style="font-family:monospace">_tcc</span> which collects all proof
obligations in one property;
</li><li class="li-itemize">The lemmas <span style="font-style:oblique">ident</span><span style="font-family:monospace">_terminate</span> and <span style="font-style:oblique">ident</span><span style="font-family:monospace">_F</span>
which is needed to be inlined during extraction of <span style="font-style:oblique">ident</span>.
</li></ul><p>The way this recursive function is defined is the subject of several
papers by Yves Bertot and Antonia Balaa on the one hand, and Gilles Barthe,
Julien Forest, David Pichardie, and Vlad Rusu on the other hand.</p><p><br>
<br>
</p><p><span style="font-weight:bold">Remark: </span> Proof obligations are presented as several
subgoals belonging to a Lemma <span style="font-style:oblique">ident</span><span style="font-family:monospace">_tcc</span>. </p></li></ol>
<h2 id="Section" class="section">2.4  Section mechanism
<a id="hevea_default94"></a>
</h2>
<p>The sectioning mechanism can be used to to organize a proof in
structured sections. Then local declarations become available (see
Section <a href="Reference-Manual003.html#Basic-definitions">1.3.2</a>).</p>
<h3 id="sec80" class="subsection">2.4.1  <span style="font-family:monospace">Section </span><span style="font-style:oblique">ident</span><a id="hevea_default95"></a><a id="hevea_command43"></a></h3>
<p>This command is used to open a section named <span style="font-style:oblique">ident</span>.</p>
<h3 id="sec81" class="subsection">2.4.2  <span style="font-family:monospace">End </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">
</span><a id="hevea_default96"></a><a id="hevea_command44"></a></h3>
<p>This command closes the section named <span style="font-style:oblique">ident</span>. After closing of the
section, the local declarations (variables and local definitions) get
<em>discharged</em>, meaning that they stop being visible and that all
global objects defined in the section are generalized with respect to
the variables and local definitions they each depended on in the
section.</p><p>Here is an example :
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Section s1.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variables x y : nat.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x is assumed</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">y is assumed</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Let y</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> := y.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">y</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition x</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> := S x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition x</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> := x</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> + y</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print x</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> = S x</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End s1.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print x</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> = fun x : nat =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> S x</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument scope is [nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope]</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print x</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> = fun x y : nat =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> let y</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> := y in x</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> x + y</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument scopes are [nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope]</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
Notice the difference between the value of <span style="font-family:monospace">x’</span> and <span style="font-family:monospace">x’’</span>
inside section <span style="font-family:monospace">s1</span> and outside.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">This is not the last opened section</span><a id="hevea_error19"></a>
</li></ol><p><br>
<span style="font-weight:bold">Remarks: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
Most commands, like <span style="font-family:monospace">Hint</span>, <span style="font-family:monospace">Notation</span>, option management, ...
which appear inside a section are canceled when the
section is closed.
</li></ol>
<h2 id="section:Modules" class="section">2.5  Module system
<a id="hevea_default97"></a>
</h2>
<p>The module system provides a way of packaging related elements
together, as well as a means of massive abstraction.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:oblique">module_type</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">qualid</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">module_type</span> <span style="font-family:monospace"> with Definition </span><span style="font-style:oblique">qualid</span> := <span style="font-style:oblique">term</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">module_type</span> <span style="font-family:monospace"> with Module </span><span style="font-style:oblique">qualid</span> := <span style="font-style:oblique">qualid</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">qualid</span> <span style="font-style:oblique">qualid</span>  …  <span style="font-style:oblique">qualid</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >!<span style="font-style:oblique">qualid</span> <span style="font-style:oblique">qualid</span>  …  <span style="font-style:oblique">qualid</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">module_binding</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">( [Import|Export] </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">  </span><span style="font-family:monospace">…</span><span style="font-family:monospace">  </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">module_type</span><span style="font-family:monospace"> )</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">module_bindings</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">module_binding</span>  …  <span style="font-style:oblique">module_binding</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">module_expression</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">qualid</span>  …  <span style="font-style:oblique">qualid</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >!<span style="font-style:oblique">qualid</span>  …  <span style="font-style:oblique">qualid</span>
</td></tr>
</table>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 2.3: Syntax of modules</td></tr>
</table></div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>In the syntax of module application, the ! prefix indicates that
any <span style="font-family:monospace">Inline</span> directive in the type of the functor arguments
will be ignored (see <a href="#Inline">2.5.4</a> below).</p>
<h3 id="sec83" class="subsection">2.5.1  <span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">
</span><a id="hevea_default98"></a><a id="hevea_command45"></a></h3>
<p>This command is used to start an interactive module named <span style="font-style:oblique">ident</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><p>Starts an interactive functor with parameters given by <span style="font-style:oblique">module_bindings</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><code><span style="font-family:monospace">:</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><p>Starts an interactive module specifying its module type. </p></li><li class="li-enumerate"><span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><span style="font-family:monospace"> </span><code><span style="font-family:monospace">:</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><p>Starts an interactive functor with parameters given by
<span style="font-style:oblique">module_bindings</span>, and output module type <span style="font-style:oblique">module_type</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;:</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><sub>1</sub><span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;:</span></code><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;:</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><sub><span style="font-style:italic">n</span></sub><p>Starts an interactive module satisfying each <span style="font-style:oblique">module_type</span><sub><span style="font-style:italic">i</span></sub>. </p></li><li class="li-enumerate"><span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;:</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><sub>1</sub><span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;:</span></code><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;:</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><sub><span style="font-style:italic">n</span></sub><p>Starts an interactive functor with parameters given by
<span style="font-style:oblique">module_bindings</span>. The output module type is verified against each
module type <span style="font-style:oblique">module_type</span><sub><span style="font-style:italic">i</span></sub>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Module [Import|Export]</span><p>Behaves like <span style="font-family:monospace">Module</span>, but automatically imports or exports
the module.</p></li></ol>
<h4 id="sec84" class="subsubsection">Reserved commands inside an interactive module:
<a id="hevea_default99"></a><a id="hevea_command46"></a></h4>
<ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Include </span><span style="font-style:oblique">module</span><p>Includes the content of <span style="font-style:oblique">module</span> in the current interactive
module. Here <span style="font-style:oblique">module</span> can be a module expression or a module type
expression. If <span style="font-style:oblique">module</span> is a high-order module or module type
expression then the system tries to instantiate <span style="font-style:oblique">module</span>
by the current interactive module.</p></li><li class="li-enumerate"><span style="font-family:monospace">Include </span><span style="font-style:oblique">module</span><sub>1</sub><span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;+</span></code><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;+</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module</span><sub><span style="font-style:italic">n</span></sub> <p>is a shortcut for <span style="font-family:monospace">Include </span><span style="font-style:oblique">module</span><sub>1</sub> … <span style="font-family:monospace">Include </span><span style="font-style:oblique">module</span><sub><span style="font-style:italic">n</span></sub>
</p></li></ol>
<h3 id="sec85" class="subsection">2.5.2  <span style="font-family:monospace">End </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">
</span><a id="hevea_default100"></a><a id="hevea_command47"></a></h3>
<p>This command closes the interactive module <span style="font-style:oblique">ident</span>. If the module type
was given the content of the module is matched against it and an error
is signaled if the matching fails. If the module is basic (is not a
functor) its components (constants, inductive types, submodules etc) are
now available through the dot notation.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">No such label </span><span style="font-style:oblique">ident</span><a id="hevea_error20"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">Signature components for label </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> do not match</span><a id="hevea_error21"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">This is not the last opened module</span><a id="hevea_error22"></a>
</li></ol>
<h3 id="sec86" class="subsection">2.5.3  <span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">module_expression</span><span style="font-family:monospace">
</span><a id="hevea_default101"></a><a id="hevea_command48"></a></h3>
<p>This command defines the module identifier <span style="font-style:oblique">ident</span> to be equal to
<span style="font-style:oblique">module_expression</span>. </p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">module_expression</span><p>Defines a functor with parameters given by <span style="font-style:oblique">module_bindings</span> and body <span style="font-style:oblique">module_expression</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><span style="font-family:monospace"> </span><code><span style="font-family:monospace">:</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><span style="font-family:monospace"> :=
</span><span style="font-style:oblique">module_expression</span><p>Defines a functor with parameters given by <span style="font-style:oblique">module_bindings</span> (possibly none),
and output module type <span style="font-style:oblique">module_type</span>, with body <span style="font-style:oblique">module_expression</span>. </p></li><li class="li-enumerate"><span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;:</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><sub>1</sub><span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;:</span></code><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;:</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">:=
</span><span style="font-style:oblique">module_expression</span><p>Defines a functor with parameters given by <span style="font-style:oblique">module_bindings</span> (possibly none) 
with body <span style="font-style:oblique">module_expression</span>. The body is checked against each <span style="font-style:oblique">module_type</span><sub><span style="font-style:italic">i</span></sub>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">module_expression</span><sub>1</sub><span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;+</span></code><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;+</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_expression</span><sub><span style="font-style:italic">n</span></sub><p>is equivalent to an interactive module where each <span style="font-style:oblique">module_expression</span><sub><span style="font-style:italic">i</span></sub> are included.</p></li></ol>
<h3 id="sec87" class="subsection">2.5.4  <span style="font-family:monospace">Module Type </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">
</span><a id="hevea_default102"></a><a id="hevea_command49"></a></h3>
<p>This command is used to start an interactive module type <span style="font-style:oblique">ident</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Module Type </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><p>Starts an interactive functor type with parameters given by <span style="font-style:oblique">module_bindings</span>.</p></li></ol>
<h4 id="sec88" class="subsubsection">Reserved commands inside an interactive module type:
<a id="hevea_default103"></a><a id="hevea_command50"></a><a id="hevea_default104"></a><a id="hevea_command51"></a></h4>
<p>
<a id="Inline"></a>
</p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Include </span><span style="font-style:oblique">module</span><p>Same as <span style="font-family:monospace">Include</span> inside a module.</p></li><li class="li-enumerate"><span style="font-family:monospace">Include </span><span style="font-style:oblique">module</span><sub>1</sub><span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;+</span></code><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;+</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module</span><sub><span style="font-style:italic">n</span></sub> <p>is a shortcut for <span style="font-family:monospace">Include </span><span style="font-style:oblique">module</span><sub>1</sub> … <span style="font-family:monospace">Include </span><span style="font-style:oblique">module</span><sub><span style="font-style:italic">n</span></sub></p></li><li class="li-enumerate"><span style="font-style:oblique">assumption_keyword</span><span style="font-family:monospace"> Inline </span><span style="font-style:oblique">assums</span><span style="font-family:monospace"> </span><p>The instance of this assumption will be automatically expanded at functor
application, except when this functor application is prefixed by a ! annotation.
</p></li></ol>
<h3 id="sec89" class="subsection">2.5.5  <span style="font-family:monospace">End </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">
</span><a id="hevea_default105"></a><a id="hevea_command52"></a></h3>
<p>This command closes the interactive module type <span style="font-style:oblique">ident</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">This is not the last opened module type</span><a id="hevea_error23"></a>
</li></ol>
<h3 id="sec90" class="subsection">2.5.6  <span style="font-family:monospace">Module Type </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">module_type</span></h3>
<p>Defines a module type <span style="font-style:oblique">ident</span> equal to <span style="font-style:oblique">module_type</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Module Type </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">module_type</span><p>Defines a functor type <span style="font-style:oblique">ident</span> specifying functors taking arguments
<span style="font-style:oblique">module_bindings</span> and returning <span style="font-style:oblique">module_type</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Module Type </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">module_type</span><sub>1</sub><span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;+</span></code><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> </span><code><span style="font-family:monospace">&lt;+</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><sub><span style="font-style:italic">n</span></sub><p>is equivalent to an interactive module type were each <span style="font-style:oblique">module_type</span><sub><span style="font-style:italic">i</span></sub> are included.</p></li></ol>
<h3 id="sec91" class="subsection">2.5.7  <span style="font-family:monospace">Declare Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">module_type</span><span style="font-family:monospace">
</span><a id="hevea_default106"></a><a id="hevea_command53"></a></h3>
<p>Declares a module <span style="font-style:oblique">ident</span> of type <span style="font-style:oblique">module_type</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Declare Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">module_bindings</span><span style="font-family:monospace"> </span><code><span style="font-family:monospace">:</span></code><span style="font-family:monospace"> </span><span style="font-style:oblique">module_type</span><p>Declares a functor with parameters <span style="font-style:oblique">module_bindings</span> and output module
type <span style="font-style:oblique">module_type</span>.</p></li></ol>
<h4 id="sec92" class="subsubsection">Example</h4>
<p>Let us define a simple module.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module M.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Interactive Module M started</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Definition T := nat.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">T is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Definition x := 0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Definition y : bool.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  bool</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">     exact true.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Defined.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">exact true.</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Defined.</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">y is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End M.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module M is defined</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
Inside a module one can define constants, prove theorems and do any
other things that can be done in the toplevel. Components of a closed
module can be accessed using the dot notation:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print M.x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">M.x = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
A simple module type:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module Type SIG.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Interactive Module Type SIG started</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Parameter T : Set.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">T is assumed</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Parameter x : T.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x is assumed</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End SIG.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module Type SIG is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>Now we can create a new module from <span style="font-family:monospace">M</span>, giving it a less
precise specification: the <span style="font-family:monospace">y</span> component is dropped as well
as the body of <span style="font-family:monospace">x</span>.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module N  :  SIG with Definition T := nat  :=  M.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module N is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print N.T.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">N.T = nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Set</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print N.x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">*** [ N.x : N.T ]</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail Print N.y.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The command has indeed failed with message:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Error: N.y not a defined object.</span></span></span><span style="font-size:small"><br>
</span></div><p>The definition of <span style="font-family:monospace">N</span> using the module type expression
<span style="font-family:monospace">SIG with Definition T:=nat</span> is equivalent to the following
one:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module Type SIG</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Definition T : Set := nat.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Parameter x : T.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End SIG</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module N : SIG</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> := M.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
If we just want to be sure that the our implementation satisfies a
given module type without restricting the interface, we can use a
transparent constraint
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module P </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">: SIG := M.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module P is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print P.y.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">P.y = true</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : bool</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
Now let us create a functor, i.e. a parametric module
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module Two (X Y: SIG).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Interactive Module Two started</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Definition T := (X.T * Y.T)%type.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Definition x := (X.x, Y.x).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End Two.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module Two is defined</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
and apply it to our modules and do some computations
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module Q := Two M N.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module Q is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Eval compute in (fst Q.x + snd Q.x).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     = N.x</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
In the end, let us define a module type with two sub-modules, sharing
some of the fields and give one of its possible implementations:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module Type SIG2.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Interactive Module Type SIG2 started</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Declare Module M1 : SIG.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module M1 is declared</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Module M2 </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">: SIG.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Interactive Module M2 started</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">     Definition T := M1.T.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">T is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">     Parameter x : T.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x is assumed</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   End M2.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module M2 is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End SIG2.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module Type SIG2 is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module Mod </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">: SIG2.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Module M1.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">     Definition T := nat.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">     Definition x := 1.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   End M1.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Module M2 := M.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End Mod.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module Mod is defined</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
Notice that <span style="font-family:monospace">M</span> is a correct body for the component <span style="font-family:monospace">M2</span>
since its <span style="font-family:monospace">T</span> component is equal <span style="font-family:monospace">nat</span> and hence
<span style="font-family:monospace">M1.T</span> as specified.</p><p><br>
<span style="font-weight:bold">Remarks: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
Modules and module types can be nested components of each other.
</li><li class="li-enumerate">One can have sections inside a module or a module type, but
not a module or a module type inside a section.
</li><li class="li-enumerate">Commands like <span style="font-family:monospace">Hint</span> or <span style="font-family:monospace">Notation</span> can
also appear inside modules and module types. Note that in case of a
module definition like:<p><br>
<span style="font-family:monospace">Module N : SIG := M.</span> 
<br>
</p><p>or</p><p><br>
<span style="font-family:monospace">Module N : SIG.<br>
   …<br>
 End N.</span>
<br>
</p><p>hints and the like valid for <span style="font-family:monospace">N</span> are not those defined in
<span style="font-family:monospace">M</span> (or the module body) but the ones defined in
<span style="font-family:monospace">SIG</span>.</p></li></ol>
<h3 id="Import" class="subsection">2.5.8  <span style="font-family:monospace">Import </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace">
</span><a id="hevea_default107"></a><a id="hevea_command54"></a><span style="font-family:monospace">
</span></h3>
<p>If <span style="font-style:oblique">qualid</span> denotes a valid basic module (i.e. its module type is a
signature), makes its components available by their short names.</p><p>Example:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module Mod.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Interactive Module Mod started</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Definition T:=nat.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">T is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Check T.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">T</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Set</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End Mod.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module Mod is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check Mod.T.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Mod.T</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Set</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail Check T. (* Incorrect! *)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The command has indeed failed with message:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The reference T was not found in the current environment.</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Import Mod.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check T. (* Now correct *)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">T</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Set</span></span></span><span style="font-size:small"><br>
</span></div><p>Some features defined in modules are activated only when a module is
imported. This is for instance the case of notations (see
Section <a href="Reference-Manual014.html#Notation">12.1</a>).</p><p>Declarations made with the <span style="font-family:monospace">Local</span> flag are never imported by the
<span style="font-family:monospace">Import</span> command. Such declarations are only accessible through their
fully qualified name.</p><p>Example:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module A.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Interactive Module A started</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Module B.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Interactive Module B started</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Local Definition T := nat.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">T is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End B.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module B is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End A.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Module A is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Import A.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail Check B.T.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The command has indeed failed with message:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The reference B.T was not found in the current environment.</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Export </span><span style="font-style:oblique">qualid</span><a id="hevea_default108"></a><a id="hevea_command55"></a><p>When the module containing the command <span style="font-family:monospace">Export </span><span style="font-style:oblique">qualid</span> is
imported, <span style="font-style:oblique">qualid</span> is imported as well.
</p></li></ol><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-style:oblique">qualid</span><span style="font-family:monospace"> is not a module</span><a id="hevea_error24"></a>
</li></ol><p><br>
<span style="font-weight:bold">Warnings: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
Trying to mask the absolute name <span style="font-style:oblique">qualid</span> !
</li></ol>
<h3 id="sec94" class="subsection">2.5.9  <span style="font-family:monospace">Print Module </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">
</span><a id="hevea_default109"></a><a id="hevea_command56"></a></h3>
<p>Prints the module type and (optionally) the body of the module <span style="font-style:oblique">ident</span>.</p>
<h3 id="sec95" class="subsection">2.5.10  <span style="font-family:monospace">Print Module Type </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">
</span><a id="hevea_default110"></a><a id="hevea_command57"></a></h3>
<p>Prints the module type corresponding to <span style="font-style:oblique">ident</span>.</p>
<h3 id="sec96" class="subsection">2.5.11  <span style="font-family:monospace">Locate Module </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace">
</span><a id="hevea_default111"></a><a id="hevea_command58"></a></h3>
<p>Prints the full name of the module <span style="font-style:oblique">qualid</span>.</p>
<h2 id="sec97" class="section">2.6  Libraries and qualified names</h2>
<h3 id="Libraries" class="subsection">2.6.1  Names of libraries

<a id="hevea_default112"></a></h3>
<p>The theories developed in <span style="font-variant:small-caps">Coq</span> are stored in <em>library files</em>
which are hierarchically classified into <em>libraries</em> and <em>sublibraries</em>. To express this hierarchy, library names are
represented by qualified identifiers <span style="font-style:oblique">qualid</span>, i.e. as list of
identifiers separated by dots (see Section <a href="Reference-Manual003.html#qualid">1.2.3</a>). For
instance, the library file <span style="font-family:monospace">Mult</span> of the standard <span style="font-variant:small-caps">Coq</span> library
<span style="font-family:monospace">Arith</span> is named <span style="font-family:monospace">Coq.Arith.Mult</span>. The identifier that starts
the name of a library is called a <em>library root</em>. All library
files of the standard library of <span style="font-variant:small-caps">Coq</span> have the reserved root <span style="font-family:monospace">Coq</span>
but library file names based on other roots can be obtained by using
<span style="font-variant:small-caps">Coq</span> commands (<span style="font-family:monospace">coqc</span>, <span style="font-family:monospace">coqtop</span>, <span style="font-family:monospace">coqdep</span>, …) options
<span style="font-family:monospace">-Q</span> or <span style="font-family:monospace">-R</span> (see Section <a href="Reference-Manual016.html#coqoptions">14.3.3</a>). Also, when an
interactive <span style="font-variant:small-caps">Coq</span> session starts, a library of root <span style="font-family:monospace">Top</span> is
started, unless option <span style="font-family:monospace">-top</span> or <span style="font-family:monospace">-notop</span> is set (see
Section <a href="Reference-Manual016.html#coqoptions">14.3.3</a>).</p>
<h3 id="LongNames" class="subsection">2.6.2  Qualified names

<a id="hevea_default113"></a>
<a id="hevea_default114"></a></h3>
<p>Library files are modules which possibly contain submodules which
eventually contain constructions (axioms, parameters, definitions,
lemmas, theorems, remarks or facts). The <em>absolute name</em>, or <em>full name</em>, of a construction in some library file is a qualified
identifier starting with the logical name of the library file,
followed by the sequence of submodules names encapsulating the
construction and ended by the proper name of the construction.
Typically, the absolute name <span style="font-family:monospace">Coq.Init.Logic.eq</span> denotes Leibniz’
equality defined in the module <span style="font-family:monospace">Logic</span> in the sublibrary <span style="font-family:monospace">Init</span> of the standard library of <span style="font-variant:small-caps">Coq</span>.</p><p>The proper name that ends the name of a construction is the <span style="font-style:italic">short
name</span> (or sometimes <span style="font-style:italic">base name</span>) of the construction (for
instance, the short name of <span style="font-family:monospace">Coq.Init.Logic.eq</span> is <span style="font-family:monospace">eq</span>). Any
partial suffix of the absolute name is a <em>partially qualified name</em>
(e.g. <span style="font-family:monospace">Logic.eq</span> is a partially qualified name for <span style="font-family:monospace">Coq.Init.Logic.eq</span>). Especially, the short name of a construction is
its shortest partially qualified name.</p><p><span style="font-variant:small-caps">Coq</span> does not accept two constructions (definition, theorem, ...)
with the same absolute name but different constructions can have the
same short name (or even same partially qualified names as soon as the
full names are different).</p><p>Notice that the notion of absolute, partially qualified and
short names also applies to library file names.</p>
<h5 id="sec100" class="paragraph">Visibility</h5>
<p><span style="font-variant:small-caps">Coq</span> maintains a table called <span style="font-style:italic">name table</span> which maps partially
qualified names of constructions to absolute names. This table is
updated by the commands <span style="font-family:monospace">Require</span> (see <a href="Reference-Manual008.html#Require">6.5.1</a>), <span style="font-family:monospace">Import</span> and <span style="font-family:monospace">Export</span> (see <a href="#Import">2.5.8</a>) and also each time a new
declaration is added to the context. An absolute name is called <span style="font-style:italic">visible</span> from a given short or partially qualified name when this
latter name is enough to denote it. This means that the short or
partially qualified name is mapped to the absolute name in <span style="font-variant:small-caps">Coq</span> name
table. Definitions flagged as <span style="font-family:monospace">Local</span> are only accessible with their
fully qualified name (see <a href="Reference-Manual003.html#Definition">1.3.2</a>).</p><p>It may happen that a visible name is hidden by the short name or a
qualified name of another construction. In this case, the name that
has been hidden must be referred to using one more level of
qualification. To ensure that a construction always remains
accessible, absolute names can never be hidden.</p><p>Examples:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check 0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition nat := bool.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nat is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check 0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Datatypes.nat</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check Datatypes.nat.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Datatypes.nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Set</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Locate nat.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Constant Top.nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Inductive Coq.Init.Datatypes.nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  (shorter name to refer to it in current context is Datatypes.nat)</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">See also: </span>Command <span style="font-family:monospace">Locate</span> in Section <a href="Reference-Manual008.html#Locate">6.3.10</a> and <span style="font-family:monospace">Locate
Library</span> in Section <a href="Reference-Manual008.html#Locate%20Library">6.6.11</a>.</p>
<h3 id="loadpath" class="subsection">2.6.3  Libraries and filesystem<a id="hevea_default115"></a>
<a id="hevea_default116"></a> <a id="hevea_default117"></a></h3>
<p>Please note that the questions described here have been subject to
redesign in Coq v8.5. Former versions of Coq use the same terminology
to describe slightly different things.</p><p>Compiled files (<span style="font-family:monospace">.vo</span> and <span style="font-family:monospace">.vio</span>) store sub-libraries. In
order to refer to them inside <span style="font-variant:small-caps">Coq</span>, a translation from file-system
names to <span style="font-variant:small-caps">Coq</span> names is needed. In this translation, names in the
file system are called <em>physical</em> paths while <span style="font-variant:small-caps">Coq</span> names are
contrastingly called <em>logical</em> names.</p><p>A logical prefix <span style="font-family:monospace">Lib</span> can be associated to a physical path
<span style="font-style:oblique">path</span> using the command line option <span style="font-family:monospace">-Q</span>
<span style="font-style:oblique">path</span> <span style="font-family:monospace">Lib</span>. All subfolders of <span style="font-style:oblique">path</span> are
recursively associated to the logical path <span style="font-family:monospace">Lib</span> extended with the
corresponding suffix coming from the physical path. For instance, the
folder <span style="font-family:monospace">path/fOO/Bar</span> maps to <span style="font-family:monospace">Lib.fOO.Bar</span>. Subdirectories
corresponding to invalid <span style="font-variant:small-caps">Coq</span> identifiers are skipped, and, by
convention, subdirectories named <span style="font-family:monospace">CVS</span> or <span style="font-family:monospace">_darcs</span> are
skipped too.</p><p>Thanks to this mechanism, <span style="font-family:monospace">.vo</span> files are made available through the
logical name of the folder they are in, extended with their own basename. For
example, the name associated to the file <span style="font-family:monospace">path/fOO/Bar/File.vo</span> is
<span style="font-family:monospace">Lib.fOO.Bar.File</span>. The same caveat applies for invalid identifiers.
When compiling a source file, the <span style="font-family:monospace">.vo</span> file stores its logical name,
so that an error is issued if it is loaded with the wrong loadpath afterwards.</p><p>Some folders have a special status and are automatically put in the path.
<span style="font-variant:small-caps">Coq</span> commands associate automatically a logical path to files
in the repository trees rooted at the directory from where the command
is launched, <span style="font-style:italic">coqlib</span><span style="font-family:monospace">/user-contrib/</span>, the directories
listed in the <code>$COQPATH</code>, <code>${XDG_DATA_HOME}/coq/</code> and
<code>${XDG_DATA_DIRS}/coq/</code> environment variables (see
<a href="http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html"><span style="font-family:monospace">http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html</span></a>)
with the same physical-to-logical translation and with an empty logical prefix.</p><p>The command line option <span style="font-family:monospace">-R</span> is a variant of <span style="font-family:monospace">-Q</span> which has the
strictly same behavior regarding loadpaths, but which also makes the
corresponding <span style="font-family:monospace">.vo</span> files available through their short names in a
way not unlike the <span style="font-family:monospace">Import</span> command (see <a href="#Import">2.5.8</a>). For instance,
<span style="font-family:monospace">-R</span> <span style="font-style:oblique">path</span> <span style="font-family:monospace">Lib</span> associates to the file
<span style="font-family:monospace">path/fOO/Bar/File.vo</span> the logical name <span style="font-family:monospace">Lib.fOO.Bar.File</span>, but
allows this file to be accessed through the short names <span style="font-family:monospace">fOO.Bar.File</span>,
<span style="font-family:monospace">Bar.File</span> and <span style="font-family:monospace">File</span>. If several files with identical base name
are present in different subdirectories of a recursive loadpath, which of
these files is found first may be system-dependent and explicit
qualification is recommended. The <span style="font-family:monospace">From</span> argument of the <span style="font-family:monospace">Require</span>
command can be used to bypass the implicit shortening by providing an absolute
root to the required file (see <a href="Reference-Manual008.html#Require">6.5.1</a>).</p><p>There also exists another independent loadpath mechanism attached to <span style="font-variant:small-caps">Objective Caml</span>
object files (<span style="font-family:monospace">.cmo</span> or <span style="font-family:monospace">.cmxs</span>) rather than <span style="font-variant:small-caps">Coq</span> object files
as described above. The <span style="font-variant:small-caps">Objective Caml</span> loadpath is managed using the option
<span style="font-family:monospace">-I path</span> (in the <span style="font-variant:small-caps">Objective Caml</span> world, there is neither a notion of logical
name prefix nor a way to access files in subdirectories of <span style="font-family:monospace">path</span>).
See the command <span style="font-family:monospace">Declare ML Module</span> in Section <a href="Reference-Manual008.html#compiled">6.5</a> to
understand the need of the <span style="font-variant:small-caps">Objective Caml</span> loadpath.</p><p>See Section <a href="Reference-Manual016.html#coqoptions">14.3.3</a> for a more general view over the <span style="font-variant:small-caps">Coq</span>
command line options.</p>
<h2 id="Implicit Arguments" class="section">2.7  Implicit arguments
<a id="hevea_default118"></a>
</h2>
<p>An implicit argument of a function is an argument which can be
inferred from contextual knowledge. There are different kinds of
implicit arguments that can be considered implicit in different
ways. There are also various commands to control the setting or the
inference of implicit arguments.</p>
<h3 id="sec103" class="subsection">2.7.1  The different kinds of implicit arguments</h3>
<h4 id="sec104" class="subsubsection">Implicit arguments inferable from the knowledge of other 
arguments of a function</h4>
<p>The first kind of implicit arguments covers the arguments that are
inferable from the knowledge of the type of other arguments of the
function, or of the type of the surrounding context of the
application. Especially, such implicit arguments correspond to 
parameters dependent in the type of the function. Typical implicit
arguments are the type arguments in polymorphic functions. 
There are several kinds of such implicit arguments.</p>
<h5 id="sec105" class="paragraph">Strict Implicit Arguments.</h5>
<p> 
An implicit argument can be either strict or non strict. An implicit
argument is said <em>strict</em> if, whatever the other arguments of the
function are, it is still inferable from the type of some other
argument. Technically, an implicit argument is strict if it
corresponds to a parameter which is not applied to a variable which
itself is another parameter of the function (since this parameter
may erase its arguments), not in the body of a <span style="font-family:monospace">match</span>, and not
itself applied or matched against patterns (since the original
form of the argument can be lost by reduction).</p><p>For instance, the first argument of
</p><blockquote class="quote">
<code>cons: forall A:Set, A -&gt; list A -&gt; list A</code>
</blockquote><p>
in module <span style="font-family:monospace">List.v</span> is strict because <span style="font-family:monospace">list</span> is an inductive
type and <span style="font-family:monospace">A</span> will always be inferable from the type <span style="font-family:monospace">list A</span> of the third argument of <span style="font-family:monospace">cons</span>.
On the contrary, the second argument of a term of type 
</p><blockquote class="quote">
<code>forall P:nat-&gt;Prop, forall n:nat, P n -&gt; ex nat P</code>
</blockquote><p>
is implicit but not strict, since it can only be inferred from the
type <span style="font-family:monospace">P n</span> of the third argument and if <span style="font-family:monospace">P</span> is, e.g., <span style="font-family:monospace">fun _ =&gt; True</span>, it reduces to an expression where <span style="font-family:monospace">n</span> does not
occur any longer. The first argument <span style="font-family:monospace">P</span> is implicit but not
strict either because it can only be inferred from <span style="font-family:monospace">P n</span> and <span style="font-family:monospace">P</span> is not canonically inferable from an arbitrary <span style="font-family:monospace">n</span> and the
normal form of <span style="font-family:monospace">P n</span> (consider e.g. that <span style="font-family:monospace">n</span> is <span style="font-family:monospace">0</span> and
the third argument has type <span style="font-family:monospace">True</span>, then any <span style="font-family:monospace">P</span> of the form
<span style="font-family:monospace">fun n =&gt; match n with 0 =&gt; True | _ =&gt; </span><span style="font-family:monospace"><em>anything</em></span><span style="font-family:monospace"> end</span> would
be a solution of the inference problem).</p>
<h5 id="sec106" class="paragraph">Contextual Implicit Arguments.</h5>
<p> 
An implicit argument can be <em>contextual</em> or not. An implicit
argument is said <em>contextual</em> if it can be inferred only from the
knowledge of the type of the context of the current expression. For
instance, the only argument of
</p><blockquote class="quote">
<code>nil : forall A:Set, list A</code>
</blockquote><p>
is contextual. Similarly, both arguments of a term of type
</p><blockquote class="quote">
<code>forall P:nat-&gt;Prop, forall n:nat, P n \/ n = 0</code>
</blockquote><p>
are contextual (moreover, <span style="font-family:monospace">n</span> is strict and <span style="font-family:monospace">P</span> is not).</p>
<h5 id="sec107" class="paragraph">Reversible-Pattern Implicit Arguments.</h5>
<p>
There is another class of implicit arguments that can be reinferred
unambiguously if all the types of the remaining arguments are
known. This is the class of implicit arguments occurring in the type
of another argument in position of reversible pattern, which means it
is at the head of an application but applied only to uninstantiated
distinct variables. Such an implicit argument is called <em>reversible-pattern implicit argument</em>. A typical example is the
argument <span style="font-family:monospace">P</span> of <span style="font-family:monospace">nat_rec</span> in
</p><blockquote class="quote">
<span style="font-family:monospace">nat_rec : forall P : nat -&gt; Set,
P 0 -&gt; (forall n : nat, P n -&gt; P (S n)) -&gt; forall x : nat, P x</span>.
</blockquote><p>
(<span style="font-family:monospace">P</span> is reinferable by abstracting over <span style="font-family:monospace">n</span> in the type <span style="font-family:monospace">P n</span>).</p><p>See Section <a href="#SetReversiblePatternImplicit">2.7.9</a> for the automatic declaration
of reversible-pattern implicit arguments.</p>
<h4 id="sec108" class="subsubsection">Implicit arguments inferable by resolution</h4>
<p>This corresponds to a class of non dependent implicit arguments that
are solved based on the structure of their type only.</p>
<h3 id="sec109" class="subsection">2.7.2  Maximal or non maximal insertion of implicit arguments</h3>
<p>In case a function is partially applied, and the next argument to be
applied is an implicit argument, two disciplines are applicable. In the
first case, the function is considered to have no arguments furtherly:
one says that the implicit argument is not maximally inserted. In
the second case, the function is considered to be implicitly applied
to the implicit arguments it is waiting for: one says that the
implicit argument is maximally inserted.</p><p>Each implicit argument can be declared to have to be inserted
maximally or non maximally. This can be governed argument per argument
by the command <span style="font-family:monospace">Implicit Arguments</span> (see <a href="#ImplicitArguments">2.7.4</a>)
or globally by the command <span style="font-family:monospace">Set Maximal Implicit Insertion</span>
(see <a href="#SetMaximalImplicitInsertion">2.7.10</a>). See also
Section <a href="#PrintImplicit">2.7.13</a>.</p>
<h3 id="sec110" class="subsection">2.7.3  Casual use of implicit arguments</h3>
<p>In a given expression, if it is clear that some argument of a function
can be inferred from the type of the other arguments, the user can
force the given argument to be guessed by replacing it by “<span style="font-family:monospace">_</span>”. If
possible, the correct argument will be automatically generated.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Cannot infer a term for this placeholder</span><a id="hevea_error25"></a><p><span style="font-variant:small-caps">Coq</span> was not able to deduce an instantiation of a “<span style="font-family:monospace">_</span>”.</p></li></ol>
<h3 id="sec111" class="subsection">2.7.4  Declaration of implicit arguments
<a id="hevea_default119"></a><a id="hevea_command59"></a></h3>
<p>
<a id="ImplicitArguments"></a></p><p>In case one wants that some arguments of a given object (constant,
inductive types, constructors, assumptions, local or not) are always
inferred by Coq, one may declare once and for all which are the expected
implicit arguments of this object. There are two ways to do this,
a priori and a posteriori.</p>
<h4 id="sec112" class="subsubsection">Implicit Argument Binders</h4>
<p>In the first setting, one wants to explicitly give the implicit
arguments of a declared object as part of its definition. To do this, one has
to surround the bindings of implicit arguments by curly braces:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition id {A : Type} (x : A) : A := x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">id is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>This automatically declares the argument <span style="font-family:monospace">A</span> of <span style="font-family:monospace">id</span> as a
maximally inserted implicit argument. One can then do as-if the argument
was absent in every situation but still be able to specify it if needed:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition compose {A B C} (g : B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> C) (f : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> B) := </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        fun x =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> g (f x).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">compose is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall A, compose id id = id (A:=A).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall A : Type, compose id id = id</span></span></span><span style="font-size:small"><br>
</span></div><p>The syntax is supported in all top-level definitions: <span style="font-family:monospace">Definition</span>,
<span style="font-family:monospace">Fixpoint</span>, <span style="font-family:monospace">Lemma</span> and so on. For (co-)inductive datatype
declarations, the semantics are the following: an inductive parameter
declared as an implicit argument need not be repeated in the inductive
definition but will become implicit for the constructors of the
inductive only, not the inductive type itself. For example:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list {A : Type} : Type :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      | nil : list</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      | cons : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">rect is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ind is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">rec is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print list.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Inductive list (A : Type) : Type :=  nil : list | cons : A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> list -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> list</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">For list: Argument A is implicit and maximally inserted</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">For nil: Argument A is implicit and maximally inserted</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">For cons: Argument A is implicit and maximally inserted</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">For list: Argument scope is [type</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">For nil: Argument scope is [type</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">For cons: Argument scopes are [type</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">]</span></span></span><span style="font-size:small"><br>
</span></div><p>One can always specify the parameter if it is not uniform using the
usual implicit arguments disambiguation syntax.</p>
<h4 id="sec113" class="subsubsection">Declaring Implicit Arguments</h4>
<p>To set implicit arguments a posteriori, one can use the
command:
</p><blockquote class="quote">
<span style="font-family:monospace">Arguments </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-style:oblique">possibly_bracketed_ident</span><span style="font-family:monospace">  </span><span style="font-family:monospace">…</span><span style="font-family:monospace">  </span><span style="font-style:oblique">possibly_bracketed_ident</span><span style="font-family:monospace">
</span></blockquote><p>
where the list of <span style="font-style:oblique">possibly_bracketed_ident</span> is the list of all arguments of
<span style="font-style:oblique">qualid</span> where the ones to be declared implicit are surrounded by
square brackets and the ones to be declared as maximally inserted implicits
are surrounded by curly braces.</p><p>After the above declaration is issued, implicit arguments can just (and
have to) be skipped in any expression involving an application of
<span style="font-style:oblique">qualid</span>.</p><p>Implicit arguments can be cleared with the following syntax:</p><blockquote class="quote">
<span style="font-family:monospace">Arguments </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> : clear implicits
</span><a id="hevea_default120"></a><a id="hevea_command60"></a>
</blockquote><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Global Arguments </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-style:oblique">possibly_bracketed_ident</span><span style="font-family:monospace">  </span><span style="font-family:monospace">…</span><span style="font-family:monospace">  </span><span style="font-style:oblique">possibly_bracketed_ident</span><span style="font-family:monospace">
</span><a id="hevea_default121"></a><a id="hevea_command61"></a><p>Tell to recompute the implicit arguments of <span style="font-style:oblique">qualid</span> after ending of
the current section if any, enforcing the implicit arguments known
from inside the section to be the ones declared by the command.</p></li><li class="li-enumerate"><span style="font-family:monospace">Local Arguments </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-style:oblique">possibly_bracketed_ident</span><span style="font-family:monospace">  </span><span style="font-family:monospace">…</span><span style="font-family:monospace">  </span><span style="font-style:oblique">possibly_bracketed_ident</span><span style="font-family:monospace">
</span><a id="hevea_default122"></a><a id="hevea_command62"></a><p>When in a module, tell not to activate the implicit arguments of
<span style="font-style:oblique">qualid</span> declared by this command to contexts that require the
module.</p></li><li class="li-enumerate"><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">Global </span><span style="font-family:monospace"><span style="font-style:oblique">|</span></span><span style="font-family:monospace"> Local</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> Arguments </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">possibly_bracketed_ident</span><span style="font-family:monospace">  </span><span style="font-family:monospace">…</span><span style="font-family:monospace">  </span><span style="font-style:oblique">possibly_bracketed_ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">possibly_bracketed_ident</span><span style="font-family:monospace">  </span><span style="font-family:monospace">…</span><span style="font-family:monospace">  </span><span style="font-style:oblique">possibly_bracketed_ident</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><p>For names of constants, inductive types, constructors, lemmas which
can only be applied to a fixed number of arguments (this excludes for
instance constants whose type is polymorphic), multiple 
implicit arguments decflarations can be given. 
Depending on the number of arguments <span style="font-style:oblique">qualid</span> is applied
to in practice, the longest applicable list of implicit arguments is
used to select which implicit arguments are inserted.</p><p>For printing, the omitted arguments are the ones of the longest list
of implicit arguments of the sequence.</p></li></ol><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list (A:Type) : Type :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">       | nil : list A </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">       | cons : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list A.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (cons nat 3 (nil nat)).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">cons nat 3 (nil nat)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : list nat</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments cons [A] </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments nil [A].</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (cons 3 nil).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">cons 3 nil</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : list nat</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint map (A B:Type) (f:A-</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">B) (l:list A) : list B :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match l with nil =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> nil | cons a t =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> cons (f a) (map A B f t) end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">map is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">map is recursively defined (decreasing on 4th argument)</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint length (A:Type) (l:list A) : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match l with nil =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 0 | cons </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> m =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (length A m) end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">length is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">length is recursively defined (decreasing on 2nd argument)</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments map [A B] f l.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments length {A} l. (* A has to be maximally inserted *)</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun l:list (list nat) =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> map length l).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun l : list (list nat) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> map length l</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : list (list nat) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> list nat</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments map [A B] f l, [A] B f l, A B f l.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun l =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> map length l = map (list nat) nat length l).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">fun l : list (list nat) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> map length l = map length l</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : list (list nat) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Remark: </span>To know which are the implicit arguments of an object, use the command
<span style="font-family:monospace">Print Implicit</span> (see <a href="#PrintImplicit">2.7.13</a>).</p>
<h3 id="sec114" class="subsection">2.7.5  Automatic declaration of implicit arguments</h3>
<p><span style="font-variant:small-caps">Coq</span> can also automatically detect what are the implicit arguments
of a defined object. The command is just
</p><blockquote class="quote">
<span style="font-family:monospace">Arguments </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> : default implicits
</span><a id="hevea_default123"></a><a id="hevea_command63"></a>
</blockquote><p>
The auto-detection is governed by options telling if strict,
contextual, or reversible-pattern implicit arguments must be
considered or not (see
Sections <a href="#SetStrictImplicit">2.7.7</a>, <a href="#SetContextualImplicit">2.7.8</a>, <a href="#SetReversiblePatternImplicit">2.7.9</a>
and also <a href="#SetMaximalImplicitInsertion">2.7.10</a>).</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Global Arguments </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> : default implicits
</span><a id="hevea_default124"></a><a id="hevea_command64"></a><p>Tell to recompute the implicit arguments of <span style="font-style:oblique">qualid</span> after ending of
the current section if any.</p></li><li class="li-enumerate"><span style="font-family:monospace">Local Arguments </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> : default implicits
</span><a id="hevea_default125"></a><a id="hevea_command65"></a><p>When in a module, tell not to activate the implicit arguments of
<span style="font-style:oblique">qualid</span> computed by this declaration to contexts that requires the
module.</p></li></ol><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list (A:Set) : Set := </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | nil : list A </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | cons : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list A.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments cons : default implicits.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print Implicit cons.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">cons : forall A : Set, A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> list A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> list A</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument A is implicit</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments nil : default implicits.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print Implicit nil.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nil : forall A : Set, list A</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Set Contextual Implicit.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments nil : default implicits.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print Implicit nil.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nil : forall A : Set, list A</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument A is implicit and maximally inserted</span></span></span><span style="font-size:small"><br>
</span></div><p>The computation of implicit arguments takes account of the
unfolding of constants. For instance, the variable <span style="font-family:monospace">p</span> below has
type <span style="font-family:monospace">(Transitivity R)</span> which is reducible to <span style="font-family:monospace">forall x,y:U, R x
y -&gt; forall z:U, R y z -&gt; R x z</span>. As the variables <span style="font-family:monospace">x</span>, <span style="font-family:monospace">y</span> and
<span style="font-family:monospace">z</span> appear strictly in body of the type, they are implicit.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variable X : Type.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition Relation := X -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> X -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition Transitivity (R:Relation) :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        forall x y:X, R x y -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forall z:X, R y z -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> R x z.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variables (R : Relation) (p : Transitivity R).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments p : default implicits.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print p.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">*** [ p : Transitivity R ]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Expanded type for implicit arguments</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">p : forall x y : X, R x y -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> forall z : X, R y z -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> R x z</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Arguments x, y, z are implicit</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print Implicit p.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">p : forall x y : X, R x y -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> forall z : X, R y z -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> R x z</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Arguments x, y, z are implicit</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variables (a b c : X) (r1 : R a b) (r2 : R b c).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (p r1 r2).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">p r1 r2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : R a c</span></span></span><span style="font-size:small"><br>
</span></div>
<h3 id="Auto-implicit" class="subsection">2.7.6  Mode for automatic declaration of implicit arguments

<a id="hevea_default126"></a><a id="hevea_option8"></a></h3>
<p>In case one wants to systematically declare implicit the arguments
detectable as such, one may switch to the automatic declaration of
implicit arguments mode by using the command
</p><blockquote class="quote">
<span style="font-family:monospace">Set Implicit Arguments.
</span></blockquote><p>
Conversely, one may unset the mode by using <span style="font-family:monospace">Unset Implicit
Arguments</span>. The mode is off by default. Auto-detection of implicit
arguments is governed by options controlling whether strict and
contextual implicit arguments have to be considered or not.</p>
<h3 id="SetStrictImplicit" class="subsection">2.7.7  Controlling strict implicit arguments
<a id="hevea_default127"></a><a id="hevea_option9"></a>
</h3>
<p>When the mode for automatic declaration of implicit arguments is on,
the default is to automatically set implicit only the strict implicit
arguments plus, for historical reasons, a small subset of the non
strict implicit arguments. To relax this constraint and to
set implicit all non strict implicit arguments by default, use the command
</p><blockquote class="quote">
<span style="font-family:monospace">Unset Strict Implicit.
</span></blockquote><p>
Conversely, use the command <span style="font-family:monospace">Set Strict Implicit</span> to
restore the original mode that declares implicit only the strict implicit arguments plus a small subset of the non strict implicit arguments.</p><p>In the other way round, to capture exactly the strict implicit arguments and no more than the strict implicit arguments, use the command:
<a id="hevea_default128"></a><a id="hevea_option10"></a>
</p><blockquote class="quote">
<span style="font-family:monospace">Set Strongly Strict Implicit.
</span></blockquote><p>
Conversely, use the command <span style="font-family:monospace">Unset Strongly Strict Implicit</span> to
let the option “<span style="font-family:monospace">Strict Implicit</span>” decide what to do.</p><p><br>
<span style="font-weight:bold">Remark: </span>In versions of <span style="font-variant:small-caps">Coq</span> prior to version 8.0, the default was to
declare the strict implicit arguments as implicit.</p>
<h3 id="SetContextualImplicit" class="subsection">2.7.8  Controlling contextual implicit arguments
<a id="hevea_default129"></a><a id="hevea_option11"></a>
</h3>
<p>By default, <span style="font-variant:small-caps">Coq</span> does not automatically set implicit the contextual
implicit arguments. To tell <span style="font-variant:small-caps">Coq</span> to infer also contextual implicit
argument, use command 
</p><blockquote class="quote">
<span style="font-family:monospace">Set Contextual Implicit. 
</span></blockquote><p>
Conversely, use command <span style="font-family:monospace">Unset Contextual Implicit</span> to
unset the contextual implicit mode.</p>
<h3 id="SetReversiblePatternImplicit" class="subsection">2.7.9  Controlling reversible-pattern implicit arguments
<a id="hevea_default130"></a><a id="hevea_option12"></a>
</h3>
<p>By default, <span style="font-variant:small-caps">Coq</span> does not automatically set implicit the reversible-pattern
implicit arguments. To tell <span style="font-variant:small-caps">Coq</span> to infer also reversible-pattern implicit
argument, use command 
</p><blockquote class="quote">
<span style="font-family:monospace">Set Reversible Pattern Implicit. 
</span></blockquote><p>
Conversely, use command <span style="font-family:monospace">Unset Reversible Pattern Implicit</span> to
unset the reversible-pattern implicit mode.</p>
<h3 id="SetMaximalImplicitInsertion" class="subsection">2.7.10  Controlling the insertion of implicit arguments not followed by explicit arguments
<a id="hevea_default131"></a><a id="hevea_option13"></a>
</h3>
<p>Implicit arguments can be declared to be automatically inserted when a
function is partially applied and the next argument of the function is
an implicit one. In case the implicit arguments are automatically
declared (with the command <span style="font-family:monospace">Set Implicit Arguments</span>), the command
</p><blockquote class="quote">
<span style="font-family:monospace">Set Maximal Implicit Insertion. 
</span></blockquote><p>
is used to tell to declare the implicit arguments with a maximal
insertion status. By default, automatically declared implicit
arguments are not declared to be insertable maximally. To restore the
default mode for maximal insertion, use command <span style="font-family:monospace">Unset Maximal
Implicit Insertion</span>.</p>
<h3 id="Implicits-explicitation" class="subsection">2.7.11  Explicit applications
<a id="hevea_default132"></a>

<a id="hevea_default133"></a> <a id="hevea_default134"></a></h3>
<p>In presence of non strict or contextual argument, or in presence of
partial applications, the synthesis of implicit arguments may fail, so
one may have to give explicitly certain implicit arguments of an
application. The syntax for this is <span style="font-family:monospace">(</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">:=</span><span style="font-style:oblique">term</span><span style="font-family:monospace">)</span> where <span style="font-style:oblique">ident</span>
is the name of the implicit argument and <span style="font-style:oblique">term</span> is its corresponding
explicit term. Alternatively, one can locally deactivate the hiding of
implicit arguments of a function by using the notation
<span style="font-family:monospace">@</span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">..</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>. This syntax extension is
given Figure <a href="#fig%3Aexplicitations">2.4</a>.
</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >++=</td><td style="text-align:left;white-space:nowrap" >@ <span style="font-style:oblique">qualid</span> <span style="font-style:oblique">term</span>  …  <span style="font-style:oblique">term</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >@ <span style="font-style:oblique">qualid</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">qualid</span> <span style="font-style:oblique">argument</span>  …  <span style="font-style:oblique">argument</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">argument</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">:=</span><span style="font-style:oblique">term</span><span style="font-family:monospace">)</span></td></tr>
</table>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 2.4: Syntax for explicitly giving implicit arguments</td></tr>
</table></div>
<a id="fig:explicitations"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p><span style="font-weight:bold">Example (continued): </span>
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (p r1 (z:=c)).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">p r1 (z:=c)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : R b c -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> R a c</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (p (x:=a) (y:=b) r1 (z:=c) r2).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">p r1 r2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : R a c</span></span></span><span style="font-size:small"><br>
</span></div>
<h3 id="sec121" class="subsection">2.7.12  Renaming implicit arguments
<a id="hevea_default135"></a><a id="hevea_command66"></a>
</h3>
<p>Implicit arguments names can be redefined using the following syntax:
</p><blockquote class="quote">
<span style="font-family:monospace">Arguments </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-style:oblique">name</span><span style="font-family:monospace">  </span><span style="font-family:monospace">…</span><span style="font-family:monospace">  </span><span style="font-style:oblique">name</span><span style="font-family:monospace"> : rename</span>
</blockquote><p>Without the <span style="font-family:monospace">rename</span> flag, <span style="font-family:monospace">Arguments</span> can be used to assert
that a given object has the expected number of arguments and that
these arguments are named as expected.</p><p><span style="font-weight:bold">Example (continued): </span>
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments p [s t] </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> [u] </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">: rename.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (p r1 (u:=c)).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">p r1 (u:=c)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : R b c -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> R a c</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (p (s:=a) (t:=b) r1 (u:=c) r2).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">p r1 r2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : R a c</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail Arguments p [s t] </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> [w] </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The command has indeed failed with message:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Error: To rename arguments the "rename" flag must be specified.</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument x renamed to s.</span></span></span><span style="font-size:small"><br>
</span></div>
<h3 id="PrintImplicit" class="subsection">2.7.13  Displaying what the implicit arguments are
<a id="hevea_default136"></a><a id="hevea_command67"></a>
</h3>
<p>To display the implicit arguments associated to an object, and to know
if each of them is to be used maximally or not, use the command
</p><blockquote class="quote">
<span style="font-family:monospace">Print Implicit </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace">.
</span></blockquote>
<h3 id="sec123" class="subsection">2.7.14  Explicit displaying of implicit arguments for pretty-printing
<a id="hevea_default137"></a><a id="hevea_option14"></a>
<a id="hevea_default138"></a><a id="hevea_option15"></a></h3>
<p>By default the basic pretty-printing rules hide the inferable implicit
arguments of an application. To force printing all implicit arguments,
use command
</p><blockquote class="quote">
<span style="font-family:monospace">Set Printing Implicit.</span>
</blockquote><p>
Conversely, to restore the hiding of implicit arguments, use command
</p><blockquote class="quote">
<span style="font-family:monospace">Unset Printing Implicit.</span>
</blockquote><p>By default the basic pretty-printing rules display the implicit arguments that are not detected as strict implicit arguments. This “defensive” mode can quickly make the display cumbersome so this can be deactivated by using the command
</p><blockquote class="quote">
<span style="font-family:monospace">Unset Printing Implicit Defensive.</span>
</blockquote><p>
Conversely, to force the display of non strict arguments, use command
</p><blockquote class="quote">
<span style="font-family:monospace">Set Printing Implicit Defensive.</span>
</blockquote><p><br>
<span style="font-weight:bold">See also: </span><span style="font-family:monospace">Set Printing All</span> in Section <a href="#SetPrintingAll">2.9</a>.</p>
<h3 id="sec124" class="subsection">2.7.15  Interaction with subtyping</h3>
<p>When an implicit argument can be inferred from the type of more than
one of the other arguments, then only the type of the first of these
arguments is taken into account, and not an upper type of all of
them. As a consequence, the inference of the implicit argument of
“=” fails in
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail Check nat = Prop.</span></span><span style="font-size:small"><br>
</span></div><p>but succeeds in
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check Prop = nat.</span></span><span style="font-size:small"><br>
</span></div>
<h3 id="sec125" class="subsection">2.7.16  Deactivation of implicit arguments for parsing</h3>
<p>
<a id="hevea_default139"></a><a id="hevea_option16"></a></p><p>Use of implicit arguments can be deactivated by issuing the command:
</p><blockquote class="quote">
<span style="font-family:monospace">Set Parsing Explicit.</span>
</blockquote><p>In this case, all arguments of constants, inductive types,
constructors, etc, including the arguments declared as implicit, have
to be given as if none arguments were implicit. By symmetry, this also
affects printing. To restore parsing and normal printing of implicit
arguments, use:
</p><blockquote class="quote">
<span style="font-family:monospace">Set Parsing Explicit.</span>
</blockquote>
<h3 id="sec126" class="subsection">2.7.17  Canonical structures
<a id="hevea_default140"></a><a id="hevea_command68"></a></h3>
<p>A canonical structure is an instance of a record/structure type that
can be used to solve unification problems involving a projection
applied to an unknown structure instance (an implicit argument) and
a value. The complete documentation of canonical structures can be found
in Chapter <a href="Reference-Manual022.html#CS-full">19</a>, here only a simple example is given.</p><p>Assume that <span style="font-style:oblique">qualid</span> denotes an object (<span style="font-style:italic">Build</span>_<span style="font-style:italic">struc</span>  <span style="font-style:italic">c</span><sub>1</sub>  …  <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>) in
the
structure <em>struct</em> of which the fields are <span style="font-style:italic">x</span><sub>1</sub>, ...,
<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>. Assume that <span style="font-style:oblique">qualid</span> is declared as a canonical structure
using the command
</p><blockquote class="quote">
<span style="font-family:monospace">Canonical Structure </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace">.</span>
</blockquote><p>
Then, each time an equation of the form (<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> 
_)=<sub>βδιζ</sub><span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> has to be solved during the
type-checking process, <span style="font-style:oblique">qualid</span> is used as a solution. Otherwise
said, <span style="font-style:oblique">qualid</span> is canonically used to extend the field <span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> into a
complete structure built on <span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub>.</p><p>Canonical structures are particularly useful when mixed with
coercions and strict implicit arguments. Here is an example.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import Relations.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import EqNat.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Set Implicit Arguments.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Unset Strict Implicit.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Structure Setoid : Type := </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        {Carrier :</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Set;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         Equal : relation Carrier;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         Prf</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">equiv : equivalence Carrier Equal}.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition is</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">law (A B:Setoid) (f:A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> B) :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        forall x y:A, Equal x y -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Equal (f x) (f y).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Axiom eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">nat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">equiv : equivalence nat eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">nat.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition nat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">setoid : Setoid := Build</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">Setoid eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">nat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">equiv.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Canonical Structure nat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">setoid.</span></span><span style="font-size:small"><br>
</span></div><p>Thanks to <span style="font-family:monospace">nat_setoid</span> declared as canonical, the implicit
arguments <span style="font-family:monospace">A</span> and <span style="font-family:monospace">B</span> can be synthesized in the next statement.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma is</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">law</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">S : is</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">law S.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  is</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">law (A:=nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">setoid) (B:=nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">setoid) S</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Remark: </span>If a same field occurs in several canonical structure, then
only the structure declared first as canonical is considered.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Canonical Structure </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.</span><br>
 <span style="font-family:monospace">Canonical Structure </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span><br>
 <span style="font-family:monospace">Canonical Structure </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span><p>These are equivalent to a regular definition of <span style="font-style:oblique">ident</span> followed by
the declaration </p><p><span style="font-family:monospace">Canonical Structure </span><span style="font-style:oblique">ident</span>.
</p></li></ol><p><br>
<span style="font-weight:bold">See also: </span>more examples in user contribution <span style="font-family:monospace">category</span>
(<span style="font-family:monospace">Rocq/ALGEBRA</span>).</p>
<h4 id="sec127" class="subsubsection">Print Canonical Projections.
<a id="hevea_default141"></a><a id="hevea_command69"></a></h4>
<p>This displays the list of global names that are components of some
canonical structure. For each of them, the canonical structure of
which it is a projection is indicated. For instance, the above example 
gives the following output:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print Canonical Projections.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nat </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">- Carrier ( nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">setoid )</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">eq</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nat </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">- Equal ( nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">setoid )</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">eq</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">equiv </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">- Prf</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">equiv ( nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">setoid )</span></span></span><span style="font-size:small"><br>
</span></div>
<h3 id="sec128" class="subsection">2.7.18  Implicit types of variables</h3>
<p>
<a id="hevea_default142"></a><a id="hevea_command70"></a></p><p>It is possible to bind variable names to a given type (e.g. in a
development using arithmetic, it may be convenient to bind the names
<span style="font-family:monospace">n</span> or <span style="font-family:monospace">m</span> to the type <span style="font-family:monospace">nat</span> of natural numbers). The
command for that is
</p><blockquote class="quote">
<span style="font-family:monospace">Implicit Types </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">  </span><span style="font-family:monospace">…</span><span style="font-family:monospace">  </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">
</span></blockquote><p>
The effect of the command is to automatically set the type of bound
variables starting with <span style="font-style:oblique">ident</span> (either <span style="font-style:oblique">ident</span> itself or
<span style="font-style:oblique">ident</span> followed by one or more single quotes, underscore or digits)
to be <span style="font-style:oblique">type</span> (unless the bound variable is already declared with an
explicit type in which case, this latter type is considered).</p><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import List.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Implicit Types m n : nat.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma cons</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">inj</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">nat : forall m n l, n :: l = m :: l -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> n = m.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall (m n : nat) (l : Datatypes.list nat), n :: l = m :: l -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n = m</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros m n.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  m, n : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall l : Datatypes.list nat, n :: l = m :: l -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n = m</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma cons</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">inj</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">bool : forall (m n:bool) l, n :: l = m :: l -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> n = m.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall (m n : bool) (l : Datatypes.list bool), n :: l = m :: l -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n = m</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Implicit Type </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><br>
This is useful for declaring the implicit type of a single variable.
</li><li class="li-enumerate"><span style="font-family:monospace">Implicit Types ( </span><span style="font-style:oblique">ident</span><sub>1,1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">ident</span><sub>1,<span style="font-style:italic">k</span><sub>1</sub></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">)</span><span style="font-family:monospace"> … </span><span style="font-family:monospace">(</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span>,1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span>,<span style="font-style:italic">k</span><sub><span style="font-style:italic">n</span></sub></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">)</span><span style="font-family:monospace">.</span><br>
 Adds <span style="font-style:italic">n</span> blocks of implicit types with different specifications.
</li></ol>
<h3 id="implicit-generalization" class="subsection">2.7.19  Implicit generalization

<a id="hevea_default143"></a><a id="hevea_command71"></a></h3>
<p>Implicit generalization is an automatic elaboration of a statement with
free variables into a closed statement where these variables are
quantified explicitly. Implicit generalization is done inside binders
starting with a <span style="font-family:monospace">`</span> and terms delimited by <span style="font-family:monospace">`{ }</span> and
<span style="font-family:monospace">`( )</span>, always introducing maximally inserted implicit arguments for
the generalized variables. Inside implicit generalization
delimiters, free variables in the current context are automatically
quantified using a product or a lambda abstraction to generate a closed
term. In the following statement for example, the variables <span style="font-family:monospace">n</span>
and <span style="font-family:monospace">m</span> are automatically generalized and become explicit
arguments of the lemma as we are using <span style="font-family:monospace">`( )</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Generalizable All Variables.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma nat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">comm : `(n = n + 0).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall n : nat, n = n + 0</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
One can control the set of generalizable identifiers with the
<span style="font-family:monospace">Generalizable</span> vernacular command to avoid unexpected
generalizations when mistyping identifiers. There are three variants of
the command:</p><blockquote class="quote">
<span style="font-family:monospace">Generalizable (All|No) Variable(s)? (</span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)?.</span>
</blockquote><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Generalizable All Variables.</span> All variables are candidate for 
generalization if they appear free in the context under a
generalization delimiter. This may result in confusing errors in
case of typos. In such cases, the context will probably contain some
unexpected generalized variable.</li><li class="li-enumerate"><span style="font-family:monospace">Generalizable No Variables.</span> Disable implicit generalization 
entirely. This is the default behavior.</li><li class="li-enumerate"><span style="font-family:monospace">Generalizable Variable(s)? </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">.</span> 
Allow generalization of the given identifiers only. Calling this
command multiple times adds to the allowed identifiers.</li><li class="li-enumerate"><span style="font-family:monospace">Global Generalizable</span> Allows to export the choice of
generalizable variables.
</li></ol><p>One can also use implicit generalization for binders, in which case the
generalized variables are added as binders and set maximally implicit.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition id `(x : A) : A := x.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Print id.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">id = fun (A : Type) (x : A) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> x</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall A : Type, A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> A</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument A is implicit and maximally inserted</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument scopes are [type</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">]</span></span></span><span style="font-size:small"><br>
</span></div><p>The generalizing binders <span style="font-family:monospace">`{ }</span> and <span style="font-family:monospace">`( )</span> work similarly to
their explicit counterparts, only binding the generalized variables
implicitly, as maximally-inserted arguments. In these binders, the
binding name for the bound object is optional, whereas the type is
mandatory, dually to regular binders.</p>
<h2 id="Coercions" class="section">2.8  Coercions

<a id="hevea_default144"></a></h2>
<p>Coercions can be used to implicitly inject terms from one <em>class</em> in
which they reside into another one. A <em>class</em> is either a sort
(denoted by the keyword <span style="font-family:monospace">Sortclass</span>), a product type (denoted by the
keyword <span style="font-family:monospace">Funclass</span>), or a type constructor (denoted by its name),
e.g. an inductive type or any constant with a type of the form
<span style="font-family:monospace">forall</span> (<span style="font-style:italic">x</span><sub>1</sub>:<span style="font-style:italic">A</span><sub>1</sub>) .. (<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>:<span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>), <span style="font-style:italic">s</span> where <span style="font-style:italic">s</span> is a sort.</p><p>Then the user is able to apply an
object that is not a function, but can be coerced to a function, and
more generally to consider that a term of type A is of type B provided
that there is a declared coercion between A and B. The main command is
<a id="hevea_default145"></a><a id="hevea_command72"></a>
</p><blockquote class="quote">
<span style="font-family:monospace">Coercion </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">class</span><sub>1</sub><span style="font-family:monospace"> &gt;-&gt; </span><span style="font-style:oblique">class</span><sub>2</sub><span style="font-family:monospace">.
</span></blockquote><p>
which declares the construction denoted by <span style="font-style:oblique">qualid</span> as a
coercion between <span style="font-style:oblique">class</span><sub>1</sub> and <span style="font-style:oblique">class</span><sub>2</sub>.</p><p>More details and examples, and a description of the commands related
to coercions are provided in Chapter <a href="Reference-Manual021.html#Coercions-full">18</a>.</p><h2 id="SetPrintingAll" class="section">2.9  Printing constructions in full
<a id="hevea_default146"></a><a id="hevea_option17"></a></h2>
<p>Coercions, implicit arguments, the type of pattern-matching, but also
notations (see Chapter <a href="Reference-Manual014.html#Addoc-syntax">12</a>) can obfuscate the behavior
of some tactics (typically the tactics applying to occurrences of
subterms are sensitive to the implicit arguments). The command
</p><blockquote class="quote">
<span style="font-family:monospace">Set Printing All.</span>
</blockquote><p>
deactivates all high-level printing features such as coercions,
implicit arguments, returned type of pattern-matching, notations and
various syntactic sugar for pattern-matching or record projections.
Otherwise said, <span style="font-family:monospace">Set Printing All</span> includes the effects
of the commands <span style="font-family:monospace">Set Printing Implicit</span>, <span style="font-family:monospace">Set Printing
Coercions</span>, <span style="font-family:monospace">Set Printing Synth</span>, <span style="font-family:monospace">Unset Printing Projections</span>
and <span style="font-family:monospace">Unset Printing Notations</span>. To reactivate the high-level
printing features, use the command
</p><blockquote class="quote">
<span style="font-family:monospace">Unset Printing All.</span>
</blockquote><h2 id="PrintingUniverses" class="section">2.10  Printing universes
<a id="hevea_default147"></a><a id="hevea_option18"></a></h2>
<p>The following command:
</p><blockquote class="quote">
<span style="font-family:monospace">Set Printing Universes</span>
</blockquote><p>
activates the display of the actual level of each occurrence of
<span style="font-family:sans-serif">Type</span>. See Section <a href="Reference-Manual006.html#Sorts">4.1.1</a> for details. This wizard option, in
combination with <span style="font-family:monospace">Set Printing All</span> (see
section <a href="#SetPrintingAll">2.9</a>) can help to diagnose failures to unify
terms apparently identical but internally different in the Calculus of
Inductive Constructions. To reactivate the display of the actual level
of the occurrences of <span style="font-family:sans-serif">Type</span>, use
</p><blockquote class="quote">
<span style="font-family:monospace">Unset Printing Universes.</span>
</blockquote><p><a id="hevea_default148"></a><a id="hevea_command73"></a>
<a id="hevea_default149"></a><a id="hevea_command74"></a></p><p>The constraints on the internal level of the occurrences of <span style="font-family:sans-serif">Type</span>
(see Section <a href="Reference-Manual006.html#Sorts">4.1.1</a>) can be printed using the command
</p><blockquote class="quote">
<span style="font-family:monospace">Print </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">Sorted</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> Universes.</span>
</blockquote><p>
If the optional <span style="font-family:monospace">Sorted</span> option is given, each universe will be
made equivalent to a numbered label reflecting its level (with a
linear ordering) in the universe hierarchy.</p><p>This command also accepts an optional output filename:
</p><blockquote class="quote">
<span style="font-family:monospace">Print </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">Sorted</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> Universes </span><span style="font-style:oblique">string</span><span style="font-family:monospace">.
</span></blockquote><p>
If <span style="font-style:oblique">string</span> ends in <span style="font-family:monospace">.dot</span> or <span style="font-family:monospace">.gv</span>, the constraints are
printed in the DOT language, and can be processed by Graphviz
tools. The format is unspecified if <span style="font-style:oblique">string</span> doesn’t end in
<span style="font-family:monospace">.dot</span> or <span style="font-family:monospace">.gv</span>.</p><h2 id="ExistentialVariables" class="section">2.11  Existential variables</h2>
<p>
<a id="evars"></a></p><p>Coq terms can include existential variables which
represents unknown subterms to eventually be replaced by actual
subterms.</p><p>Existential variables are generated in place of unsolvable implicit
arguments or “<span style="font-family:monospace">_</span>” placeholders when using commands such as
<span style="font-family:monospace">Check</span> (see Section <a href="Reference-Manual008.html#Check">6.3.1</a>) or when using tactics such as
<span style="font-family:monospace">refine</span> (see Section <a href="Reference-Manual010.html#refine">8.2.3</a>), as well as in place of unsolvable
instances when using tactics such that <span style="font-family:monospace">eapply</span> (see
Section <a href="Reference-Manual010.html#eapply">8.2.4</a>). An existential variable is defined in a
context, which is the context of variables of the placeholder which
generated the existential variable, and a type, which is the expected
type of the placeholder. </p><p>As a consequence of typing constraints, existential variables can be
duplicated in such a way that they possibly appear in different
contexts than their defining context. Thus, any occurrence of a given
existential variable comes with an instance of its original context. In the
simple case, when an existential variable denotes the placeholder
which generated it, or is used in the same context as the one in which
it was generated, the context is not displayed and the existential
variable is represented by “?” followed by an identifier.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Parameter identity : forall (X:Set), X -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> X.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">identity is assumed</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check identity </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">identity ?y ?y0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : ?X@{x:=?y0}</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">where</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?y : [ |- forall x : ?T, ?X] </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?T : [ |- Set] </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?X : [x : ?T |- Set] </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?y0 : [ |- ?T] </span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check identity </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> (fun x =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">identity ?y (fun x : ?T =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> ?y0)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : ?X@{x:=fun x : ?T =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> ?y0}</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">where</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?y : [ |- forall x : forall x : ?T, ?T0, ?X] </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?X : [x : forall x : ?T, ?T0 |- Set] </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?T : [ |- Set] </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?T0 : [x : ?T |- Set] </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?y0 : [x : ?T |- ?T0] </span></span></span><span style="font-size:small"><br>
</span></div><p>In the general case, when an existential variable ?<span style="font-style:oblique">ident</span>
appears outside of its context of definition, its instance, written under
the form <code>@{id1:=term1; ...; idn:=termn}</code>, is appending to its
name, indicating how the variables of its defining context are
instantiated. The variables of the context of the existential
variables which are instantiated by themselves are not written, unless
the flag <span style="font-family:monospace">Printing Existential Instances</span> is on (see
Section <a href="#SetPrintingExistentialInstances">2.11.1</a>), and this is why an
existential variable used in the same context as its context of
definition is written with no instance.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun x y =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">) 0 1.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">(fun x y : nat =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> ?y) 0 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : ?T@{x:=0; y:=1}</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">where</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?T : [x : nat  y : nat |- Type] </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?y : [x : nat  y : nat |- ?T] </span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Set Printing Existential Instances.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check (fun x y =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">) 0 1.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">(fun x y : nat =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> ?y@{x:=x; y:=y}) 0 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : ?T@{x:=0; y:=1}</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">where</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?T : [x : nat  y : nat |- Type] </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?y : [x : nat  y : nat |- ?T@{x:=x; y:=y}] </span></span></span><span style="font-size:small"><br>
</span></div>
<h3 id="SetPrintingExistentialInstances" class="subsection">2.11.1  Explicit displaying of existential instances for pretty-printing

<a id="hevea_default150"></a><a id="hevea_option19"></a></h3>
<p>The command:
</p><blockquote class="quote">
<span style="font-family:monospace">Set Printing Existential Instances</span>
</blockquote><p>
activates the full display of how the context of an existential variable is
instantiated at each of the occurrences of the existential variable.</p><p>To deactivate the full display of the instances of existential
variables, use
</p><blockquote class="quote">
<span style="font-family:monospace">Unset Printing Existential Instances.</span>
</blockquote>
<h3 id="sec135" class="subsection">2.11.2  Solving existential variables using tactics</h3>
<p>
<a id="hevea_default151"></a></p><p>Instead of letting the unification engine try to solve an existential variable
by itself, one can also provide an explicit hole together with a tactic to solve
it. Using the syntax <span style="font-family:monospace">ltac:(</span><span style="font-style:oblique">tacexpr</span><span style="font-family:monospace">)</span>, the user can put a
tactic anywhere a term is expected. The order of resolution is not specified and
is implementation-dependent. The inner tactic may use any variable defined in
its scope, including repeated alternations between variables introduced by term
binding as well as those introduced by tactic binding. The expression <span style="font-style:oblique">tacexpr</span>
can be any tactic expression as described at section <a href="Reference-Manual011.html#TacticLanguage">9</a>.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition foo (x : nat) : nat := ltac:(exact x).</span></span><span style="font-size:small"><br>
</span></div><p>This construction is useful when one wants to define complicated terms using
highly automated tactics without resorting to writing the proof-term by means of
the interactive proof engine.</p><p>This mechanism is comparable to the <span style="font-family:monospace">Declare Implicit Tactic</span> command
defined at <a href="Reference-Manual010.html#DeclareImplicit">8.9.7</a>, except that the used tactic is local to each
hole instead of being declared globally.</p>
<div id="sidebarWrapper">
  <div id="sidebar">
    <div class="block">
      <h2 class="title">Navigation</h2>
      <div class="content">
        <ul class="menu">
          <li class="leaf"><a href="index.html">Cover</a></li>
          <li class="leaf"><a href="toc.html">Table of contents</a></li>
          <li class="leaf">Index
            <ul class="menu">
              <li><a href="general-index.html">General</a></li>
              <li><a href="command-index.html">Commands</a></li>
              <li><a href="option-index.html">Options</a></li>
              <li><a href="tactic-index.html">Tactics</a></li>
              <li><a href="error-index.html">Errors</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</body>
</html>
