<!DOCTYPE html>
<html >
<head>


<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/coqdoc.css" /><title>Chapter 1  The Gallina specification language
</title>
</head>
<body >

<div id="container">

<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="/" class="active">Home</a></li>
    <li><a href="/about-coq" title="More about coq">About Coq</a></li>
    <li><a href="/download">Get Coq</a></li>
    <li><a href="/documentation">Documentation</a></li>
    <li><a href="/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">
<div id="logoWrapper">
  <div id="logo"><a href="/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
  </div>
  <div id="siteName"><a href="/" title="Home">The Coq Proof Assistant</a>
  </div>
</div>
</div>

<div id="content">

<h1 id="Gallina" class="chapter">Chapter 1  The <span style="font-variant:small-caps">Gallina</span> specification language
<a id="hevea_default0"></a></h1>
<ul>
<li><a href="Reference-Manual003.html#lexical">1.1  Lexical conventions
</a>
</li><li><a href="Reference-Manual003.html#term">1.2  Terms </a>
</li><li><a href="Reference-Manual003.html#Vernacular">1.3  The Vernacular
</a>
</li></ul>
<p>
<a id="BNF-syntax"></a> </p><p>This chapter describes <span style="font-variant:small-caps">Gallina</span>, the specification language of <span style="font-variant:small-caps">Coq</span>.
It allows developing mathematical theories and to prove specifications
of programs. The theories are built from axioms, hypotheses,
parameters, lemmas, theorems and definitions of constants, functions,
predicates and sets. The syntax of logical objects involved in
theories is described in Section <a href="#term">1.2</a>. The language of
commands, called <em>The Vernacular</em> is described in section
<a href="#Vernacular">1.3</a>.</p><p>In <span style="font-variant:small-caps">Coq</span>, logical objects are typed to ensure their logical
correctness. The rules implemented by the typing algorithm are described in
Chapter <a href="Reference-Manual006.html#Cic">4</a>.</p><h3 id="sec17" class="subsection">About the grammars in the manual
<a id="hevea_default1"></a></h3>
<p>Grammars are presented in Backus-Naur form (BNF). Terminal symbols are
set in <span style="font-family:monospace">typewriter font</span>. In addition, there are special
notations for regular expressions.</p><p>An expression enclosed in square brackets <span style="font-style:oblique">[</span>…<span style="font-style:oblique">]</span> means at
most one occurrence of this expression (this corresponds to an
optional component).</p><p>The notation “<span style="font-style:oblique">entry</span> <span style="font-family:monospace">sep</span> … <span style="font-family:monospace">sep</span> <span style="font-style:oblique">entry</span>” stands for a non empty
sequence of expressions parsed by <span style="font-style:oblique">entry</span> and
separated by the literal “<span style="font-family:monospace">sep</span>”<sup><a id="text1" href="#note1">1</a></sup>.</p><p>Similarly, the notation “<span style="font-style:oblique">entry</span>  …  <span style="font-style:oblique">entry</span>” stands for a non
empty sequence of expressions parsed by the “<span style="font-style:oblique">entry</span>” entry,
without any separator between.</p><p>At the end, the notation “<span style="font-style:oblique">[</span><span style="font-style:oblique">entry</span> <span style="font-family:monospace">sep</span> … <span style="font-family:monospace">sep</span> <span style="font-style:oblique">entry</span><span style="font-style:oblique">]</span>” stands for a
possibly empty sequence of expressions parsed by the “<span style="font-style:oblique">entry</span>” entry,
separated by the literal “<span style="font-family:monospace">sep</span>”.</p>
<h2 id="lexical" class="section">1.1  Lexical conventions
<a id="hevea_default2"></a></h2>
<h5 id="sec19" class="paragraph">Blanks</h5>
<p>
Space, newline and horizontal tabulation are considered as blanks.
Blanks are ignored but they separate tokens.</p>
<h5 id="sec20" class="paragraph">Comments</h5>
<p>Comments in <span style="font-variant:small-caps">Coq</span> are enclosed between <span style="font-family:monospace">(*</span> and <span style="font-family:monospace">*)</span><a id="hevea_default3"></a>, and can be nested. They can contain any
character. However, string literals must be correctly closed. Comments
are treated as blanks.</p>
<h5 id="sec21" class="paragraph">Identifiers and access identifiers</h5>
<p>Identifiers, written <span style="font-style:oblique">ident</span>, are sequences of letters, digits,
<code>_</code> and <code>'</code>, that do not start with a digit or <code>'</code>.
That is, they are recognized by the following lexical class:</p><p><a id="hevea_default4"></a>
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:oblique">first_letter</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">a..z</span> ∣ <span style="font-family:monospace">A..Z</span> ∣ <span style="font-family:monospace">_</span>
∣ <span style="font-family:monospace">unicode-letter</span> 
</td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:oblique">subsequent_letter</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">a..z</span> ∣ <span style="font-family:monospace">A..Z</span> ∣ <span style="font-family:monospace">0..9</span>
∣ <span style="font-family:monospace">_</span> ∣ <span style="font-family:monospace">’</span> 
∣ <span style="font-family:monospace">unicode-letter</span> 
∣ <span style="font-family:monospace">unicode-id-part</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:oblique">ident</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">first_letter</span> [<span style="font-style:oblique">subsequent_letter</span>…<span style="font-style:oblique">subsequent_letter</span>]
</td></tr>
</table>
</div><p>
All characters are meaningful. In particular, identifiers are
case-sensitive. The entry <span style="font-family:monospace">unicode-letter</span> non-exhaustively
includes Latin, Greek, Gothic, Cyrillic, Arabic, Hebrew, Georgian,
Hangul, Hiragana and Katakana characters, CJK ideographs, mathematical
letter-like symbols, hyphens, non-breaking space, … The entry
<span style="font-family:monospace">unicode-id-part</span> non-exhaustively includes symbols for prime
letters and subscripts.</p><p>Access identifiers, written <span style="font-style:oblique">access_ident</span>, are identifiers prefixed
by <code>.</code> (dot) without blank. They are used in the syntax of qualified
identifiers.</p>
<h5 id="sec22" class="paragraph">Natural numbers and integers</h5>
<p>
Numerals are sequences of digits. Integers are numerals optionally preceded by a minus sign.</p><p><a id="hevea_default5"></a>
<a id="hevea_default6"></a>
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:oblique">digit</span></td><td style="text-align:center;white-space:nowrap" >  ::=  </td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">0..9</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:oblique">num</span></td><td style="text-align:center;white-space:nowrap" >  ::=  </td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">digit</span>…<span style="font-style:oblique">digit</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:oblique">integer</span></td><td style="text-align:center;white-space:nowrap" >  ::=  </td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">[</span><span style="font-family:monospace">-</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-style:oblique">num</span><span style="font-family:monospace"> </span></td></tr>
</table>
</div><h5 id="strings" class="paragraph">Strings
<a id="hevea_default7"></a></h5>
<p>
Strings are delimited by <code>"</code> (double quote), and enclose a
sequence of any characters different from <code>"</code> or the sequence
<code>""</code> to denote the double quote character. In grammars, the
entry for quoted strings is <span style="font-style:oblique">string</span>.</p>
<h5 id="sec24" class="paragraph">Keywords</h5>
<p>
The following identifiers are reserved keywords, and cannot be
employed otherwise:
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><code>_</code></td><td style="text-align:left;white-space:nowrap" ><code>as</code></td><td style="text-align:left;white-space:nowrap" ><code>at</code></td><td style="text-align:left;white-space:nowrap" ><code>cofix</code></td><td style="text-align:left;white-space:nowrap" ><code>else</code></td><td style="text-align:left;white-space:nowrap" ><code>end</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>exists</code></td><td style="text-align:left;white-space:nowrap" ><code>exists2</code></td><td style="text-align:left;white-space:nowrap" ><code>fix</code></td><td style="text-align:left;white-space:nowrap" ><code>for</code></td><td style="text-align:left;white-space:nowrap" ><code>forall</code></td><td style="text-align:left;white-space:nowrap" ><code>fun</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>if</code></td><td style="text-align:left;white-space:nowrap" ><code>IF</code></td><td style="text-align:left;white-space:nowrap" ><code>in</code></td><td style="text-align:left;white-space:nowrap" ><code>let</code></td><td style="text-align:left;white-space:nowrap" ><code>match</code></td><td style="text-align:left;white-space:nowrap" ><code>mod</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>Prop</code></td><td style="text-align:left;white-space:nowrap" ><code>return</code></td><td style="text-align:left;white-space:nowrap" ><code>Set</code></td><td style="text-align:left;white-space:nowrap" ><code>then</code></td><td style="text-align:left;white-space:nowrap" ><code>Type</code></td><td style="text-align:left;white-space:nowrap" ><code>using</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>where</code></td><td style="text-align:left;white-space:nowrap" ><code>with</code></td></tr>
</table>
</div>
<h5 id="sec25" class="paragraph">Special tokens</h5>
<p>
The following sequences of characters are special tokens:
</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><code>!</code></td><td style="text-align:left;white-space:nowrap" ><code>%</code></td><td style="text-align:left;white-space:nowrap" ><code>&amp;</code></td><td style="text-align:left;white-space:nowrap" ><code>&amp;&amp;</code></td><td style="text-align:left;white-space:nowrap" ><code>(</code></td><td style="text-align:left;white-space:nowrap" ><code>()</code></td><td style="text-align:left;white-space:nowrap" ><code>)</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>*</code></td><td style="text-align:left;white-space:nowrap" ><code>+</code></td><td style="text-align:left;white-space:nowrap" ><code>++</code></td><td style="text-align:left;white-space:nowrap" ><code>,</code></td><td style="text-align:left;white-space:nowrap" ><code>-</code></td><td style="text-align:left;white-space:nowrap" ><code>-&gt;</code></td><td style="text-align:left;white-space:nowrap" ><code>.</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>.(</code></td><td style="text-align:left;white-space:nowrap" ><code>..</code></td><td style="text-align:left;white-space:nowrap" ><code>/</code></td><td style="text-align:left;white-space:nowrap" ><code>/\</code></td><td style="text-align:left;white-space:nowrap" ><code>:</code></td><td style="text-align:left;white-space:nowrap" ><code>::</code></td><td style="text-align:left;white-space:nowrap" ><code>:&lt;</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>:=</code></td><td style="text-align:left;white-space:nowrap" ><code>:&gt;</code></td><td style="text-align:left;white-space:nowrap" ><code>;</code></td><td style="text-align:left;white-space:nowrap" ><code>&lt;</code></td><td style="text-align:left;white-space:nowrap" ><code>&lt;-</code></td><td style="text-align:left;white-space:nowrap" ><code>&lt;-&gt;</code></td><td style="text-align:left;white-space:nowrap" ><code>&lt;:</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>&lt;=</code></td><td style="text-align:left;white-space:nowrap" ><code>&lt;&gt;</code></td><td style="text-align:left;white-space:nowrap" ><code>=</code></td><td style="text-align:left;white-space:nowrap" ><code>=&gt;</code></td><td style="text-align:left;white-space:nowrap" ><code>=_D</code></td><td style="text-align:left;white-space:nowrap" ><code>&gt;</code></td><td style="text-align:left;white-space:nowrap" ><code>&gt;-&gt;</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>&gt;=</code></td><td style="text-align:left;white-space:nowrap" ><code>?</code></td><td style="text-align:left;white-space:nowrap" ><code>?=</code></td><td style="text-align:left;white-space:nowrap" ><code>@</code></td><td style="text-align:left;white-space:nowrap" ><code>[</code></td><td style="text-align:left;white-space:nowrap" ><code>\/</code></td><td style="text-align:left;white-space:nowrap" ><code>]</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><code>^</code></td><td style="text-align:left;white-space:nowrap" ><code>{</code></td><td style="text-align:left;white-space:nowrap" ><code>|</code></td><td style="text-align:left;white-space:nowrap" ><code>|-</code></td><td style="text-align:left;white-space:nowrap" ><code>||</code></td><td style="text-align:left;white-space:nowrap" ><code>}</code></td><td style="text-align:left;white-space:nowrap" ><code>~</code> </td></tr>
</table>
</div><p>Lexical ambiguities are resolved according to the “longest match”
rule: when a sequence of non alphanumerical characters can be decomposed
into several different ways, then the first token is the longest
possible one (among all tokens defined at this moment), and so on.</p>
<h2 id="term" class="section">1.2  Terms <a id="hevea_default8"></a></h2>
<h3 id="sec27" class="subsection">1.2.1  Syntax of terms</h3>
<p>Figures <a href="#term-syntax">1.1</a> and <a href="#term-syntax-aux">1.2</a> describe the basic syntax of
the terms of the <em>Calculus of Inductive Constructions</em> (also
called <span style="font-variant:small-caps">Cic</span>). The formal presentation of <span style="font-variant:small-caps">Cic</span> is given in Chapter
<a href="Reference-Manual006.html#Cic">4</a>. Extensions of this syntax are given in chapter
<a href="Reference-Manual004.html#Gallina-extension">2</a>. How to customize the syntax is described in Chapter
<a href="Reference-Manual014.html#Addoc-syntax">12</a>.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">forall</span> <span style="font-style:oblique">binders</span> <span style="font-family:monospace">,</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#products">1.2.8</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">fun</span> <span style="font-style:oblique">binders</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#abstractions">1.2.7</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">fix</span> <span style="font-style:oblique">fix_bodies</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#fixpoints">1.2.14</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">cofix</span> <span style="font-style:oblique">cofix_bodies</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#fixpoints">1.2.14</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">let</span> <span style="font-style:oblique">ident</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">binders</span><span style="font-style:oblique">]</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span>
<span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#let-in">1.2.12</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">let fix</span> <span style="font-style:oblique">fix_body</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#fixpoints">1.2.14</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">let cofix</span> <span style="font-style:oblique">cofix_body</span>
<span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#fixpoints">1.2.14</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">let</span> <span style="font-family:monospace">(</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">name</span> <span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> <span style="font-style:oblique">name</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">)</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">dep_ret_type</span><span style="font-style:oblique">]</span>
<span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span>
<span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#caseanalysis">1.2.13</a>, <a href="Reference-Manual004.html#Mult-match">2.2.1</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">let ’</span> <span style="font-style:oblique">pattern</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span>
<span style="font-style:oblique">[</span><span style="font-style:oblique">return_type</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#caseanalysis">1.2.13</a>, <a href="Reference-Manual004.html#Mult-match">2.2.1</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">if</span> <span style="font-style:oblique">term</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">dep_ret_type</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">then</span> <span style="font-style:oblique">term</span>
<span style="font-family:monospace">else</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#caseanalysis">1.2.13</a>, <a href="Reference-Manual004.html#Mult-match">2.2.1</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#typecast">1.2.10</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-family:monospace">&lt;:</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#typecast">1.2.10</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-family:monospace">:&gt;</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="Reference-Manual027.html#ProgramSyntax">24.1.1</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-family:monospace">-&gt;</span> <span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#products">1.2.8</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-style:oblique">arg</span>  …  <span style="font-style:oblique">arg</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#applications">1.2.9</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@</span> <span style="font-style:oblique">qualid</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">term</span>  …  <span style="font-style:oblique">term</span><span style="font-style:oblique">]</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="Reference-Manual004.html#Implicits-explicitation">2.7.11</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-family:monospace">%</span> <span style="font-style:oblique">ident</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="Reference-Manual014.html#scopechange">12.2.2</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">match</span> <span style="font-style:oblique">match_item</span> <span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> <span style="font-style:oblique">match_item</span>
<span style="font-style:oblique">[</span><span style="font-style:oblique">return_type</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">with</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >   <span style="font-style:oblique">[</span><span style="font-style:oblique">[</span><span style="font-family:monospace">|</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-style:oblique">equation</span><span style="font-family:monospace"> </span><span style="font-family:monospace">|</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">|</span><span style="font-family:monospace"> </span><span style="font-style:oblique">equation</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace">end</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#caseanalysis">1.2.13</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">qualid</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#qualid">1.2.3</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">sort</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#Gallina-sorts">1.2.5</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">num</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#numerals">1.2.4</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >_</td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#hole">1.2.11</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">arg</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="Reference-Manual004.html#Implicits-explicitation">2.7.11</a>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">binders</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">binder</span>  …  <span style="font-style:oblique">binder</span> </td><td style="text-align:center;white-space:nowrap" >   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">binder</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">name</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >(<a href="#Binders">1.2.6</a>) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(</span> <span style="font-style:oblique">name</span>  …  <span style="font-style:oblique">name</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(</span> <span style="font-style:oblique">name</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">name</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">_</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">qualid</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">qualid</span> <span style="font-style:oblique">access_ident</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">sort</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Prop</span>  |  <span style="font-family:monospace">Set</span>  |  <span style="font-family:monospace">Type</span></td><td style="text-align:center;white-space:nowrap" >   </td></tr>
</table>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 1.1: Syntax of terms</td></tr>
</table></div>
<a id="term-syntax"></a>
<a id="hevea_default9"></a>
<a id="hevea_default10"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">fix_bodies</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-style:oblique">fix_body</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">fix_body</span> <span style="font-family:monospace">with</span> <span style="font-style:oblique">fix_body</span> <span style="font-family:monospace">with</span> … <span style="font-family:monospace">with</span> <span style="font-style:oblique">fix_body</span>
<span style="font-family:monospace">for</span> <span style="font-style:oblique">ident</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">cofix_bodies</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-style:oblique">cofix_body</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">cofix_body</span> <span style="font-family:monospace">with</span> <span style="font-style:oblique">cofix_body</span> <span style="font-family:monospace">with</span> … <span style="font-family:monospace">with</span> <span style="font-style:oblique">cofix_body</span>
<span style="font-family:monospace">for</span> <span style="font-style:oblique">ident</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">fix_body</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-style:oblique">ident</span> <span style="font-style:oblique">binders</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">annotation</span><span style="font-style:oblique">]</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><span style="font-style:oblique">]</span>
<span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">cofix_body</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">binders</span><span style="font-style:oblique">]</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">annotation</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">{ struct</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">}</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">match_item</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">as</span> <span style="font-style:oblique">name</span><span style="font-style:oblique">]</span>
<span style="font-style:oblique">[</span><span style="font-family:monospace">in</span> <span style="font-style:oblique">qualid</span><span style="font-style:oblique">[</span><span style="font-style:oblique">pattern</span>  …  <span style="font-style:oblique">pattern</span><span style="font-style:oblique">]</span><span style="font-style:oblique">]</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">dep_ret_type</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">[</span><span style="font-family:monospace">as</span> <span style="font-style:oblique">name</span><span style="font-style:oblique">]</span> <span style="font-style:oblique">return_type</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">return_type</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">return</span> <span style="font-style:oblique">term</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">equation</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">mult_pattern</span> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">mult_pattern</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">mult_pattern</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">pattern</span> <span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> <span style="font-style:oblique">pattern</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">pattern</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">qualid</span> <span style="font-style:oblique">pattern</span>  …  <span style="font-style:oblique">pattern</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">@</span> <span style="font-style:oblique">qualid</span> <span style="font-style:oblique">pattern</span>  …  <span style="font-style:oblique">pattern</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">pattern</span> <span style="font-family:monospace">as</span> <span style="font-style:oblique">ident</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">pattern</span> <span style="font-family:monospace">%</span> <span style="font-style:oblique">ident</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">qualid</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">_</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">num</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(</span> <span style="font-style:oblique">or_pattern</span> <span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> <span style="font-style:oblique">or_pattern</span> <span style="font-family:monospace">)</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">or_pattern</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">pattern</span> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">pattern</span></td></tr>
</table>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 1.2: Syntax of terms (continued)</td></tr>
</table></div>
<a id="term-syntax-aux"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<h3 id="sec28" class="subsection">1.2.2  Types</h3>
<p><span style="font-variant:small-caps">Coq</span> terms are typed. <span style="font-variant:small-caps">Coq</span> types are recognized by the same
syntactic class as <span style="font-style:oblique">term</span>. We denote by <span style="font-style:oblique">type</span> the semantic subclass
of types inside the syntactic class <span style="font-style:oblique">term</span>.
<a id="hevea_default11"></a></p>
<h3 id="qualid" class="subsection">1.2.3  Qualified identifiers and simple identifiers

<a id="ident"></a></h3>
<p><em>Qualified identifiers</em> (<span style="font-style:oblique">qualid</span>) denote <em>global constants</em>
(definitions, lemmas, theorems, remarks or facts), <em>global
variables</em> (parameters or axioms), <em>inductive
types</em> or <em>constructors of inductive types</em>.
<em>Simple identifiers</em> (or shortly <span style="font-style:oblique">ident</span>) are a
syntactic subset of qualified identifiers. Identifiers may also
denote local <em>variables</em>, what qualified identifiers do not.</p>
<h3 id="numerals" class="subsection">1.2.4  Numerals
</h3>
<p>Numerals have no definite semantics in the calculus. They are mere
notations that can be bound to objects through the notation mechanism
(see Chapter <a href="Reference-Manual014.html#Addoc-syntax">12</a> for details). Initially, numerals are
bound to Peano’s representation of natural numbers
(see <a href="Reference-Manual005.html#libnats">3.1.3</a>).</p><p>Note: negative integers are not at the same level as <span style="font-style:oblique">num</span>, for this
would make precedence unnatural.</p>
<h3 id="Gallina-sorts" class="subsection">1.2.5  Sorts 
<a id="hevea_default12"></a>
<a id="hevea_default13"></a>
<a id="hevea_default14"></a>
<a id="hevea_default15"></a>
<a id="hevea_default16"></a>
</h3>
<p>There are three sorts <span style="font-family:sans-serif">Set</span>, <span style="font-family:sans-serif">Prop</span> and <span style="font-family:sans-serif">Type</span>.
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:sans-serif">Prop</span> is the universe of <em>logical propositions</em>.
The logical propositions themselves are typing the proofs.
We denote propositions by <span style="font-style:oblique">form</span>. This constitutes a semantic
subclass of the syntactic class <span style="font-style:oblique">term</span>.
<a id="hevea_default17"></a>
</li><li class="li-itemize"><span style="font-family:sans-serif">Set</span> is is the universe of <em>program
types</em> or <em>specifications</em>.
The specifications themselves are typing the programs.
We denote specifications by <span style="font-style:oblique">specif</span>. This constitutes a semantic
subclass of the syntactic class <span style="font-style:oblique">term</span>.
<a id="hevea_default18"></a>
</li><li class="li-itemize"><span style="font-family:sans-serif">Type</span> is the type of <span style="font-family:sans-serif">Set</span> and <span style="font-family:sans-serif">Prop</span>
</li></ul><p>
More on sorts can be found in Section <a href="Reference-Manual006.html#Sorts">4.1.1</a>.</p>
<h3 id="Binders" class="subsection">1.2.6  Binders

<a id="hevea_default19"></a></h3>
<p>Various constructions such as <span style="font-family:monospace">fun</span>, <span style="font-family:monospace">forall</span>, <span style="font-family:monospace">fix</span> and
<span style="font-family:monospace">cofix</span> <em>bind</em> variables. A binding is represented by an
identifier. If the binding variable is not used in the expression, the
identifier can be replaced by the symbol <span style="font-family:monospace">_</span>. When the type of a
bound variable cannot be synthesized by the system, it can be
specified with the notation <span style="font-family:monospace">(</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span> <span style="font-family:monospace">)</span>. There is also a notation for a sequence of binding variables
sharing the same type: <span style="font-family:monospace">(</span> <span style="font-style:oblique">ident</span><sub>1</sub>…<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span> <span style="font-family:monospace">)</span>.</p><p>Some constructions allow the binding of a variable to value. This is
called a “let-binder”. The entry <span style="font-style:oblique">binder</span> of the grammar accepts
either an assumption binder as defined above or a let-binder. 
The notation in the
latter case is <span style="font-family:monospace">(</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span>. In a
let-binder, only one variable can be introduced at the same
time. It is also possible to give the type of the variable as follows:
<span style="font-family:monospace">(</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span>.</p><p>Lists of <span style="font-style:oblique">binder</span> are allowed. In the case of <span style="font-family:monospace">fun</span> and <span style="font-family:monospace">forall</span>, it is intended that at least one binder of the list is an
assumption otherwise <span style="font-family:monospace">fun</span> and <span style="font-family:monospace">forall</span> gets identical. Moreover,
parentheses can be omitted in the case of a single sequence of
bindings sharing the same type (e.g.: <span style="font-family:monospace">fun (x y z : A) =&gt; t</span> can
be shortened in <span style="font-family:monospace">fun x y z : A =&gt; t</span>).</p>
<h3 id="abstractions" class="subsection">1.2.7  Abstractions

<a id="hevea_default20"></a></h3>
<p>The expression “<span style="font-family:monospace">fun</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span>”
defines the <em>abstraction</em> of the variable <span style="font-style:oblique">ident</span>, of type
<span style="font-style:oblique">type</span>, over the term <span style="font-style:oblique">term</span>. It denotes a function of the variable
<span style="font-style:oblique">ident</span> that evaluates to the expression <span style="font-style:oblique">term</span> (e.g. <span style="font-family:monospace">fun x:</span><span style="font-style:italic">A</span><span style="font-family:monospace">
=&gt; x</span> denotes the identity function on type <span style="font-style:italic">A</span>).
The keyword <span style="font-family:monospace">fun</span> can be followed by several binders as given in
Section <a href="#Binders">1.2.6</a>. Functions over several variables are
equivalent to an iteration of one-variable functions. For instance the
expression “<span style="font-family:monospace">fun</span> <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span>” denotes the same function as “<span style="font-family:monospace">fun</span> <span style="font-style:oblique">ident</span><sub>1</sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span> <span style="font-family:monospace">=&gt;</span> … <span style="font-family:monospace">fun</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span>”. If a let-binder
occurs in the list of binders, it is expanded to a let-in definition
(see Section <a href="#let-in">1.2.12</a>).</p>
<h3 id="products" class="subsection">1.2.8  Products

<a id="hevea_default21"></a></h3>
<p>The expression “<span style="font-family:monospace">forall</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><span style="font-family:monospace">,</span> <span style="font-style:oblique">term</span>” denotes the <em>product</em> of the variable <span style="font-style:oblique">ident</span> of
type <span style="font-style:oblique">type</span>, over the term <span style="font-style:oblique">term</span>. As for abstractions, <span style="font-family:monospace">forall</span>
is followed by a binder list, and products over several variables are
equivalent to an iteration of one-variable products. 
Note that <span style="font-style:oblique">term</span> is intended to be a type.</p><p>If the variable <span style="font-style:oblique">ident</span> occurs in <span style="font-style:oblique">term</span>, the product is called <em>dependent product</em>. The intention behind a dependent product <span style="font-family:monospace">forall</span> <span style="font-style:italic">x</span> <span style="font-family:monospace">:</span> <span style="font-style:italic">A</span><span style="font-family:monospace">,</span> <span style="font-style:italic">B</span> is twofold. It denotes either
the universal quantification of the variable <span style="font-style:italic">x</span> of type <span style="font-style:italic">A</span> in the
proposition <span style="font-style:italic">B</span> or the functional dependent product from <span style="font-style:italic">A</span> to <span style="font-style:italic">B</span> (a
construction usually written Π<sub><span style="font-style:italic">x</span>:<span style="font-style:italic">A</span></sub>.<span style="font-style:italic">B</span> in set theory).</p><p>Non dependent product types have a special notation: “<span style="font-style:italic">A</span> <span style="font-family:monospace">-&gt;</span>
<span style="font-style:italic">B</span>” stands for “<span style="font-family:monospace">forall _:</span><span style="font-style:italic">A</span><span style="font-family:monospace">,</span> <span style="font-style:italic">B</span>”. The <em>non dependent
product</em> is used both to denote the propositional implication and
function types.</p>
<h3 id="applications" class="subsection">1.2.9  Applications

<a id="hevea_default22"></a></h3>
<p>The expression <span style="font-style:oblique">term</span><sub>0</sub> <span style="font-style:oblique">term</span><sub>1</sub> denotes the application of
<span style="font-style:oblique">term</span><sub>0</sub> to <span style="font-style:oblique">term</span><sub>1</sub>.</p><p>The expression <span style="font-style:oblique">term</span><sub>0</sub> <span style="font-style:oblique">term</span><sub>1</sub> ... <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>
denotes the application of the term <span style="font-style:oblique">term</span><sub>0</sub> to the arguments
<span style="font-style:oblique">term</span><sub>1</sub> ... then <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>. It is equivalent to <span style="font-family:monospace">(</span> …
<span style="font-family:monospace">(</span> <span style="font-style:oblique">term</span><sub>0</sub> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">)</span> … <span style="font-family:monospace">)</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> :
associativity is to the left.</p><p>The notation <span style="font-family:monospace">(</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span> for
arguments is used for making explicit the value of implicit arguments
(see Section <a href="Reference-Manual004.html#Implicits-explicitation">2.7.11</a>).</p>
<h3 id="typecast" class="subsection">1.2.10  Type cast

<a id="hevea_default23"></a></h3>
<p>The expression “<span style="font-style:oblique">term</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span>” is a type cast
expression. It enforces the type of <span style="font-style:oblique">term</span> to be <span style="font-style:oblique">type</span>.</p><p>“<span style="font-style:oblique">term</span> <span style="font-family:monospace">&lt;:</span> <span style="font-style:oblique">type</span>” locally sets up the virtual machine for checking
that <span style="font-style:oblique">term</span> has type <span style="font-style:oblique">type</span>.</p>
<h3 id="hole" class="subsection">1.2.11  Inferable subterms

<a id="hevea_default24"></a></h3>
<p>Expressions often contain redundant pieces of information. Subterms that
can be automatically inferred by <span style="font-variant:small-caps">Coq</span> can be replaced by the
symbol “_” and <span style="font-variant:small-caps">Coq</span> will guess the missing piece of information.</p>
<h3 id="let-in" class="subsection">1.2.12  Let-in definitions

<a id="hevea_default25"></a>
<a id="hevea_default26"></a></h3>
<p><span style="font-family:monospace">let</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span><sub>2</sub> denotes
the local binding of <span style="font-style:oblique">term</span><sub>1</sub> to the variable <span style="font-style:oblique">ident</span> in
<span style="font-style:oblique">term</span><sub>2</sub>. 
There is a syntactic sugar for let-in definition of functions: <span style="font-family:monospace">let</span> <span style="font-style:oblique">ident</span> <span style="font-style:oblique">binder</span><sub>1</sub> … <span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>1</sub>
<span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span><sub>2</sub> stands for <span style="font-family:monospace">let</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:= fun</span>
<span style="font-style:oblique">binder</span><sub>1</sub> … <span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">in</span>
<span style="font-style:oblique">term</span><sub>2</sub>.</p>
<h3 id="caseanalysis" class="subsection">1.2.13  Definition by case analysis

<a id="hevea_default27"></a></h3>
<p>Objects of inductive types can be destructurated by a case-analysis
construction called <em>pattern-matching</em> expression. A
pattern-matching expression is used to analyze the structure of an
inductive objects and to apply specific treatments accordingly.</p><p>This paragraph describes the basic form of pattern-matching. See
Section <a href="Reference-Manual004.html#Mult-match">2.2.1</a> and Chapter <a href="Reference-Manual020.html#Mult-match-full">17</a> for the
description of the general form. The basic form of pattern-matching is
characterized by a single <span style="font-style:oblique">match_item</span> expression, a <span style="font-style:oblique">mult_pattern</span>
restricted to a single <span style="font-style:oblique">pattern</span> and <span style="font-style:oblique">pattern</span> restricted to the
form <span style="font-style:oblique">qualid</span> <span style="font-style:oblique">ident</span>  …  <span style="font-style:oblique">ident</span>.</p><p>The expression <span style="font-family:monospace">match</span> <span style="font-style:oblique">term</span><sub>0</sub> <span style="font-style:oblique">return_type</span> <span style="font-family:monospace">with</span>
<span style="font-style:oblique">pattern</span><sub>1</sub> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span><sub>1</sub> | … |
<span style="font-style:oblique">pattern</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">end</span>, denotes a <em>pattern-matching</em> over the term <span style="font-style:oblique">term</span><sub>0</sub> (expected to be of an
inductive type <span style="font-style:italic">I</span>). The terms <span style="font-style:oblique">term</span><sub>1</sub>…<span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> are the
<em>branches</em> of the pattern-matching expression. Each of
<span style="font-style:oblique">pattern</span><sub><span style="font-style:italic">i</span></sub> has a form <span style="font-style:oblique">qualid</span> <span style="font-style:oblique">ident</span>  …  <span style="font-style:oblique">ident</span> where <span style="font-style:oblique">qualid</span>
must denote a constructor. There should be exactly one branch for
every constructor of <span style="font-style:italic">I</span>.</p><p>The <span style="font-style:oblique">return_type</span> expresses the type returned by the whole <span style="font-family:monospace">match</span>
expression. There are several cases. In the <em>non dependent</em> case,
all branches have the same type, and the <span style="font-style:oblique">return_type</span> is the common
type of branches. In this case, <span style="font-style:oblique">return_type</span> can usually be omitted
as it can be inferred from the type of the branches<sup><a id="text2" href="#note2">2</a></sup>.</p><p>In the <em>dependent</em> case, there are three subcases. In the first
subcase, the type in each branch may depend on the exact value being
matched in the branch. In this case, the whole pattern-matching itself
depends on the term being matched. This dependency of the term being
matched in the return type is expressed with an “<span style="font-family:monospace">as </span><span style="font-style:oblique">ident</span>”
clause where <span style="font-style:oblique">ident</span> is dependent in the return type.
For instance, in the following example:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive bool : Type := true : bool | false : bool.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive eq (A:Type) (x:A) : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop := eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">refl : eq A x x.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive or (A:Prop) (B:Prop) : Prop :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      | or</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">introl : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> or A B</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      | or</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">intror : B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> or A B.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition bool</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">case (b:bool) : or (eq bool b true) (eq bool b false)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      := match b as x return or (eq bool x true) (eq bool x false) with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         | true  =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> or</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">introl (eq bool true true) (eq bool true false)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                      (eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">refl bool true)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         | false =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> or</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">intror (eq bool false true) (eq bool false false)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                      (eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">refl bool false)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         end.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
the branches have respective types <span style="font-family:monospace">or (eq bool true true) (eq
bool true false)</span> and <span style="font-family:monospace">or (eq bool false true) (eq bool false
false)</span> while the whole pattern-matching expression has type <span style="font-family:monospace">or
(eq bool b true) (eq bool b false)</span>, the identifier <span style="font-family:monospace">x</span> being used
to represent the dependency. Remark that when the term being matched
is a variable, the <span style="font-family:monospace">as</span> clause can be omitted and the term being
matched can serve itself as binding name in the return type. For
instance, the following alternative definition is accepted and has the
same meaning as the previous one.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition bool</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">case (b:bool) : or (eq bool b true) (eq bool b false)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      := match b return or (eq bool b true) (eq bool b false) with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         | true  =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> or</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">introl (eq bool true true) (eq bool true false)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                      (eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">refl bool true)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         | false =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> or</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">intror (eq bool false true) (eq bool false false)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                      (eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">refl bool false)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">         end.</span></span><span style="font-size:small"><br>
</span></div><p>The second subcase is only relevant for annotated inductive types such
as the equality predicate (see Section <a href="Reference-Manual005.html#Equality">3.1.2</a>), the order
predicate on natural numbers or the type of
lists of a given length (see Section <a href="Reference-Manual020.html#listn">17.3</a>). In this configuration,
the type of each branch can depend on the type dependencies specific
to the branch and the whole pattern-matching expression has a type
determined by the specific dependencies in the type of the term being
matched. This dependency of the return type in the annotations of the
inductive type is expressed using a 
“in I _ … _ <span style="font-style:oblique">pattern</span><sub>1</sub> … <span style="font-style:oblique">pattern</span><sub><span style="font-style:italic">n</span></sub>” clause, where
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:italic">I</span> is the inductive type of the term being matched;</li><li class="li-itemize">the _’s are matching the parameters of the inductive type:
the return type is not dependent on them.</li><li class="li-itemize">the <span style="font-style:oblique">pattern</span><sub><span style="font-style:italic">i</span></sub>’s are matching the annotations of the inductive
type: the return type is dependent on them</li><li class="li-itemize">in the basic case which we describe below, each <span style="font-style:oblique">pattern</span><sub><span style="font-style:italic">i</span></sub> is a
name <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>; see <a href="Reference-Manual020.html#match-in-patterns">17.3.2</a> for the general case</li></ul><p>For instance, in the following example:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">sym (A:Type) (x y:A) (H:eq A x y) : eq A y x :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match H in eq </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> z return eq A z x with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">refl </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">refl A x</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
the type of the branch has type <span style="font-family:monospace">eq A x x</span> because the third
argument of <span style="font-family:monospace">eq</span> is <span style="font-family:monospace">x</span> in the type of the pattern <span style="font-family:monospace">refl_equal</span>. On the contrary, the type of the whole pattern-matching
expression has type <span style="font-family:monospace">eq A y x</span> because the third argument of <span style="font-family:monospace">eq</span> is <span style="font-family:monospace">y</span> in the type of <span style="font-family:monospace">H</span>. This dependency of the case
analysis in the third argument of <span style="font-family:monospace">eq</span> is expressed by the
identifier <span style="font-family:monospace">z</span> in the return type.</p><p>Finally, the third subcase is a combination of the first and second
subcase. In particular, it only applies to pattern-matching on terms
in a type with annotations. For this third subcase, both
the clauses <span style="font-family:monospace">as</span> and <span style="font-family:monospace">in</span> are available.</p><p>There are specific notations for case analysis on types with one or
two constructors: “<span style="font-family:monospace">if </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> then </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> else </span><span style="font-family:monospace">…</span>”
and “<span style="font-family:monospace">let (</span>… <span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> …<span style="font-family:monospace">) := </span> … <span style="font-family:monospace">in</span>
…” (see Sections <a href="Reference-Manual004.html#if-then-else">2.2.2</a> and <a href="Reference-Manual004.html#Letin">2.2.3</a>).</p>
<h3 id="fixpoints" class="subsection">1.2.14  Recursive functions

<a id="hevea_default28"></a></h3>
<p>The expression “<span style="font-family:monospace">fix</span> <span style="font-style:oblique">ident</span><sub>1</sub> <span style="font-style:oblique">binder</span><sub>1</sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub>1</sub>
<span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">with</span> … <span style="font-family:monospace">with</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>
<span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">for</span>
<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>” denotes the <span style="font-style:italic">i</span><sup><span style="font-size:small">th</span></sup>component of a block of functions
defined by mutual well-founded recursion. It is the local counterpart
of the <span style="font-family:monospace">Fixpoint</span> command. See Section <a href="#Fixpoint">1.3.4</a> for more
details. When <span style="font-style:italic">n</span>=1, the “<span style="font-family:monospace">for</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>” clause is omitted.</p><p>The expression “<span style="font-family:monospace">cofix</span> <span style="font-style:oblique">ident</span><sub>1</sub> <span style="font-style:oblique">binder</span><sub>1</sub> <span style="font-family:monospace">:</span>
<span style="font-style:oblique">type</span><sub>1</sub> <span style="font-family:monospace">with</span> … <span style="font-family:monospace">with</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">for</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>” denotes the <span style="font-style:italic">i</span><sup><span style="font-size:small">th</span></sup>component of
a block of terms defined by a mutual guarded co-recursion. It is the
local counterpart of the <span style="font-family:monospace">CoFixpoint</span> command. See
Section <a href="#CoFixpoint">1.3.4</a> for more details. When <span style="font-style:italic">n</span>=1, the “<span style="font-family:monospace">for</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>” clause is omitted.</p><p>The association of a single fixpoint and a local
definition have a special syntax: “<span style="font-family:monospace">let fix</span> <span style="font-style:italic">f</span> … <span style="font-family:monospace">:=</span> … <span style="font-family:monospace">in</span> …” stands for “<span style="font-family:monospace">let</span> <span style="font-style:italic">f</span> <span style="font-family:monospace">:=
fix</span> <span style="font-style:italic">f</span> … <span style="font-family:monospace">:=</span> … <span style="font-family:monospace">in</span> …”. The same
applies for co-fixpoints.</p>
<h2 id="Vernacular" class="section">1.3  The Vernacular
</h2>
<blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">sentence</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">assumption</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">definition</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">inductive</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">fixpoint</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">assertion</span> <span style="font-style:oblique">proof</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">assumption</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">assumption_keyword</span> <span style="font-style:oblique">assums</span> <span style="font-family:monospace">.</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">assumption_keyword</span></td><td style="text-align:center;white-space:nowrap" > ::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Axiom</span> | <span style="font-family:monospace">Conjecture</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Parameter</span> | <span style="font-family:monospace">Parameters</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Variable</span> | <span style="font-family:monospace">Variables</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Hypothesis</span> | <span style="font-family:monospace">Hypotheses</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">assums</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span>  …  <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(</span> <span style="font-style:oblique">ident</span>  …  <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span>  …  <span style="font-family:monospace">(</span> <span style="font-style:oblique">ident</span>  …  <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">definition</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-style:oblique">[</span><span style="font-family:monospace">Local</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace">Definition</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace">:=</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace">.</span><span style="font-family:monospace"> </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Let</span> <span style="font-style:oblique">ident</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">binders</span><span style="font-style:oblique">]</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">.</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">inductive</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">Inductive</span> <span style="font-style:oblique">ind_body</span> <span style="font-family:monospace">with</span> … <span style="font-family:monospace">with</span> <span style="font-style:oblique">ind_body</span> <span style="font-family:monospace">.</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">CoInductive</span> <span style="font-style:oblique">ind_body</span> <span style="font-family:monospace">with</span> … <span style="font-family:monospace">with</span> <span style="font-style:oblique">ind_body</span> <span style="font-family:monospace">.</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ind_body</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-style:oblique">ident</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">binders</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">:=</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >  <span style="font-style:oblique">[</span><span style="font-style:oblique">[</span><span style="font-family:monospace">|</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:</span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace">|</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">|</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:</span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">fixpoint</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Fixpoint</span> <span style="font-style:oblique">fix_body</span> <span style="font-family:monospace">with</span> … <span style="font-family:monospace">with</span> <span style="font-style:oblique">fix_body</span> <span style="font-family:monospace">.</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">CoFixpoint</span> <span style="font-style:oblique">cofix_body</span> <span style="font-family:monospace">with</span> … <span style="font-family:monospace">with</span> <span style="font-style:oblique">cofix_body</span> <span style="font-family:monospace">.</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">assertion</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-style:oblique">assertion_keyword</span> <span style="font-style:oblique">ident</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">binders</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">.</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-style:oblique">assertion_keyword</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Theorem</span> | <span style="font-family:monospace">Lemma</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Remark</span> | <span style="font-family:monospace">Fact</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Corollary</span> | <span style="font-family:monospace">Proposition</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Definition</span> | <span style="font-family:monospace">Example</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">proof</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Proof</span> <span style="font-family:monospace">.</span> … <span style="font-family:monospace">Qed</span> <span style="font-family:monospace">.</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Proof</span> <span style="font-family:monospace">.</span> … <span style="font-family:monospace">Defined</span> <span style="font-family:monospace">.</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Proof</span> <span style="font-family:monospace">.</span> … <span style="font-family:monospace">Admitted</span> <span style="font-family:monospace">.</span></td></tr>
</table>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 1.3: Syntax of sentences</td></tr>
</table></div>
<a id="sentences-syntax"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Figure <a href="#sentences-syntax">1.3</a> describes <em>The Vernacular</em> which is the
language of commands of <span style="font-variant:small-caps">Gallina</span>. A sentence of the vernacular
language, like in many natural languages, begins with a capital letter
and ends with a dot.</p><p>The different kinds of command are described hereafter. They all suppose
that the terms occurring in the sentences are well-typed.</p>
<h3 id="Declarations" class="subsection">1.3.1  Assumptions
<a id="hevea_default29"></a>
</h3>
<p>Assumptions extend the environment<a id="hevea_default30"></a> with axioms,
parameters, hypotheses or variables. An assumption binds an <span style="font-style:oblique">ident</span>
to a <span style="font-style:oblique">type</span>. It is accepted by <span style="font-variant:small-caps">Coq</span> if and only if this <span style="font-style:oblique">type</span> is
a correct type in the environment preexisting the declaration and if
<span style="font-style:oblique">ident</span> was not previously defined in the same module. This <span style="font-style:oblique">type</span>
is considered to be the type (or specification, or statement) assumed
by <span style="font-style:oblique">ident</span> and we say that <span style="font-style:oblique">ident</span> has type <span style="font-style:oblique">type</span>.</p>
<h4 id="Axiom" class="subsubsection"><span style="font-family:monospace">Axiom </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> :</span><span style="font-style:oblique">term</span><span style="font-family:monospace"> .</span>
<a id="hevea_default31"></a><a id="hevea_command0"></a>
</h4>
<p>This command links <span style="font-style:oblique">term</span> to the name <span style="font-style:oblique">ident</span> as its specification
in the global context. The fact asserted by <span style="font-style:oblique">term</span> is thus assumed as
a postulate.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-style:oblique">ident</span><span style="font-family:monospace"> already exists</span><a id="hevea_error0"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"> 
<a id="hevea_default32"></a><a id="hevea_command1"></a><a id="hevea_default33"></a><a id="hevea_command2"></a>
<span style="font-family:monospace">Parameter </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> :</span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span> <br>
 Is equivalent to <span style="font-family:monospace">Axiom </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">term</span></li><li class="li-enumerate"><span style="font-family:monospace">Parameter </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">:</span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span><br>
 Adds <span style="font-style:italic">n</span> parameters with specification <span style="font-style:oblique">term</span></li><li class="li-enumerate"><span style="font-family:monospace">Parameter ( </span><span style="font-style:oblique">ident</span><sub>1,1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub>1,<span style="font-style:italic">k</span><sub>1</sub></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">)</span><span style="font-family:monospace"> … </span><span style="font-family:monospace">(</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span>,1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span>,<span style="font-style:italic">k</span><sub><span style="font-style:italic">n</span></sub></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">)</span><span style="font-family:monospace">.</span><br>
 Adds <span style="font-style:italic">n</span> blocks of parameters with different specifications.</li><li class="li-enumerate"><span style="font-family:monospace">Local Axiom </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span><br>
<a id="hevea_default34"></a><a id="hevea_command3"></a>
Such axioms are never made accessible through their unqualified name by
<span style="font-family:monospace">Import</span> and its variants (see <a href="Reference-Manual004.html#Import">2.5.8</a>). You have to explicitly
give their fully qualified name to refer to them.</li><li class="li-enumerate"><a id="hevea_default35"></a><a id="hevea_command4"></a>
<span style="font-family:monospace">Conjecture </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> :</span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span><br>
 Is equivalent to <span style="font-family:monospace">Axiom </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">term</span>.
</li></ol><p><span style="font-weight:bold">Remark: </span> It is possible to replace <span style="font-family:monospace">Parameter</span> by
<span style="font-family:monospace">Parameters</span>.</p>
<h4 id="Variable" class="subsubsection"><span style="font-family:monospace">Variable </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> :</span><span style="font-style:oblique">term</span>.
<a id="hevea_default36"></a><a id="hevea_command5"></a>
<a id="hevea_default37"></a><a id="hevea_command6"></a>
</h4>
<p>This command links <span style="font-style:oblique">term</span> to the name <span style="font-style:oblique">ident</span> in the context of the
current section (see Section <a href="Reference-Manual004.html#Section">2.4</a> for a description of the section
mechanism). When the current section is closed, name <span style="font-style:oblique">ident</span> will be
unknown and every object using this variable will be explicitly
parametrized (the variable is <em>discharged</em>). Using the <span style="font-family:monospace">Variable</span> command out of any section is equivalent to using <span style="font-family:monospace">Local Parameter</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-style:oblique">ident</span><span style="font-family:monospace"> already exists</span><a id="hevea_error1"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Variable </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">:</span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span><br>
 Links <span style="font-style:oblique">term</span> to names <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>.
</li><li class="li-enumerate"><span style="font-family:monospace">Variable ( </span><span style="font-style:oblique">ident</span><sub>1,1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub>1,<span style="font-style:italic">k</span><sub>1</sub></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">)</span><span style="font-family:monospace"> … </span><span style="font-family:monospace">(</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span>,1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span>,<span style="font-style:italic">k</span><sub><span style="font-style:italic">n</span></sub></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">)</span><span style="font-family:monospace">.</span><br>
 Adds <span style="font-style:italic">n</span> blocks of variables with different specifications.
</li><li class="li-enumerate"><a id="hevea_default38"></a><a id="hevea_command7"></a>
<a id="hevea_default39"></a><a id="hevea_command8"></a>
<span style="font-family:monospace">Hypothesis </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace">:</span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span> <br>
 <span style="font-family:monospace">Hypothesis</span> is a synonymous of <span style="font-family:monospace">Variable</span>
</li></ol><p><span style="font-weight:bold">Remark: </span> It is possible to replace <span style="font-family:monospace">Variable</span> by
<span style="font-family:monospace">Variables</span> and <span style="font-family:monospace">Hypothesis</span> by <span style="font-family:monospace">Hypotheses</span>.</p><p>It is advised to use the keywords <code>Axiom</code> and <code>Hypothesis</code>
for logical postulates (i.e. when the assertion <span style="font-style:oblique">term</span> is of sort
<code>Prop</code>), and to use the keywords <code>Parameter</code> and
<code>Variable</code> in other cases (corresponding to the declaration of an
abstract mathematical entity).</p>
<h3 id="Basic-definitions" class="subsection">1.3.2  Definitions
<a id="hevea_default40"></a>
</h3>
<p>Definitions extend the environment<a id="hevea_default41"></a> with
associations of names to terms. A definition can be seen as a way to
give a meaning to a name or as a way to abbreviate a term. In any
case, the name can later be replaced at any time by its definition.</p><p>The operation of unfolding a name into its definition is called
δ-conversion<a id="hevea_default42"></a> (see
Section <a href="Reference-Manual006.html#delta">4.3</a>). A definition is accepted by the system if and
only if the defined term is well-typed in the current context of the
definition and if the name is not already used. The name defined by
the definition is called a <em>constant</em><a id="hevea_default43"></a> and the term
it refers to is its <em>body</em>. A definition has a type which is the
type of its body.</p><p>A formal presentation of constants and environments is given in
Section <a href="Reference-Manual006.html#Typed-terms">4.2</a>.</p>
<h4 id="Definition" class="subsubsection"><span style="font-family:monospace">Definition </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace">.

</span><a id="hevea_default44"></a><a id="hevea_command9"></a></h4>
<p>This command binds <span style="font-style:oblique">term</span> to the name <span style="font-style:oblique">ident</span> in the
environment, provided that <span style="font-style:oblique">term</span> is well-typed.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-style:oblique">ident</span><span style="font-family:monospace"> already exists</span><a id="hevea_error2"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Definition</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">.</span><br>
 It checks that the type of <span style="font-style:oblique">term</span><sub>2</sub> is definitionally equal to
<span style="font-style:oblique">term</span><sub>1</sub>, and registers <span style="font-style:oblique">ident</span> as being of type <span style="font-style:oblique">term</span><sub>1</sub>,
and bound to value <span style="font-style:oblique">term</span><sub>2</sub>.
</li><li class="li-enumerate"><span style="font-family:monospace">Definition</span> <span style="font-style:oblique">ident</span> <span style="font-style:oblique">binder</span><sub>1</sub> … <span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub>
<span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">.</span><br>
 This is equivalent to <br>
 <span style="font-family:monospace">Definition</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">: forall</span><span style="font-style:oblique">binder</span><sub>1</sub> … <span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">,</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">:=</span> <span style="font-family:monospace">fun</span> <span style="font-style:oblique">binder</span><sub>1</sub> … <span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span><sub>2</sub> <span style="font-family:monospace">.</span></li><li class="li-enumerate"><span style="font-family:monospace">Local Definition </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span><br>
<a id="hevea_default45"></a><a id="hevea_command10"></a>
Such definitions are never made accessible through their unqualified name by
<span style="font-family:monospace">Import</span> and its variants (see <a href="Reference-Manual004.html#Import">2.5.8</a>). You have to explicitly
give their fully qualified name to refer to them.
</li><li class="li-enumerate"><span style="font-family:monospace">Example </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span><br>
<span style="font-family:monospace">Example</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">.</span><br>
<span style="font-family:monospace">Example</span> <span style="font-style:oblique">ident</span> <span style="font-style:oblique">binder</span><sub>1</sub> … <span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub>
<span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">.</span><br>
<a id="hevea_default46"></a><a id="hevea_command11"></a>
These are synonyms of the <span style="font-family:monospace">Definition</span> forms.
</li></ol><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">The term </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> has type </span><span style="font-style:oblique">type</span><span style="font-family:monospace"> while it is expected to have type </span><span style="font-style:oblique">type</span><a id="hevea_error3"></a>
</li></ol><p><br>
<span style="font-weight:bold">See also: </span>Sections <a href="Reference-Manual008.html#Opaque">6.10.1</a>, <a href="Reference-Manual008.html#Transparent">6.10.2</a>, <a href="Reference-Manual010.html#unfold">8.7.5</a>.</p>
<h4 id="sec47" class="subsubsection"><span style="font-family:monospace">Let </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace">.
</span><a id="hevea_default47"></a><a id="hevea_command12"></a></h4>
<p>This command binds the value <span style="font-style:oblique">term</span> to the name <span style="font-style:oblique">ident</span> in the
environment of the current section. The name <span style="font-style:oblique">ident</span> disappears
when the current section is eventually closed, and, all
persistent objects (such as theorems) defined within the
section and depending on <span style="font-style:oblique">ident</span> are prefixed by the let-in definition
<span style="font-family:monospace">let </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in</span>. Using the <span style="font-family:monospace">Let</span> command out of any section is equivalent to using <span style="font-family:monospace">Local Definition</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-style:oblique">ident</span><span style="font-family:monospace"> already exists</span><a id="hevea_error4"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Let </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">.</span>
</li><li class="li-enumerate"><span style="font-family:monospace">Let Fixpoint </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">fix_body</span><span style="font-family:monospace"> </span><span style="font-family:monospace">with</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">with</span><span style="font-family:monospace"> </span><span style="font-style:oblique">fix_body</span><span style="font-family:monospace"> </span><span style="font-family:monospace">.</span><span style="font-family:monospace">.</span>
</li><li class="li-enumerate"><span style="font-family:monospace">Let CoFixpoint </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">cofix_body</span><span style="font-family:monospace"> </span><span style="font-family:monospace">with</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">with</span><span style="font-family:monospace"> </span><span style="font-style:oblique">cofix_body</span><span style="font-family:monospace"> </span><span style="font-family:monospace">.</span><span style="font-family:monospace">.</span>
</li></ol><p><br>
<span style="font-weight:bold">See also: </span>Sections <a href="Reference-Manual004.html#Section">2.4</a> (section mechanism), <a href="Reference-Manual008.html#Opaque">6.10.1</a>,
<a href="Reference-Manual008.html#Transparent">6.10.2</a> (opaque/transparent constants), <a href="Reference-Manual010.html#unfold">8.7.5</a> (tactic
<span style="font-family:monospace">unfold</span>).</p>
<h3 id="gal-Inductive-Definitions" class="subsection">1.3.3  Inductive definitions
<a id="hevea_default48"></a>

<a id="hevea_default49"></a><a id="hevea_command13"></a>
<a id="Inductive"></a>
<a id="hevea_default50"></a><a id="hevea_command14"></a>
<a id="Variant"></a></h3>
<p>We gradually explain simple inductive types, simple
annotated inductive types, simple parametric inductive types, 
mutually inductive types. We explain also co-inductive types.</p>
<h4 id="sec49" class="subsubsection">Simple inductive types</h4>
<p>The definition of a simple inductive type has the following form:</p><p><br>
</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Inductive</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">sort</span> <span style="font-family:monospace">:=</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub>1</sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">:</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub>1</sub> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-family:monospace">|</span></td><td style="text-align:left;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-family:monospace">|</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">:</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span></sub> </td></tr>
</table>
</td></tr>
</table><p>
<br>
</p><p>The name <span style="font-style:oblique">ident</span> is the name of the inductively defined type and
<span style="font-style:oblique">sort</span> is the universes where it lives.
The names <span style="font-style:oblique">ident</span><sub>1</sub>, …, <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>
are the names of its constructors and <span style="font-style:oblique">type</span><sub>1</sub>, …,
<span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span></sub> their respective types. The types of the constructors have
to satisfy a <em>positivity condition</em> (see Section <a href="Reference-Manual006.html#Positivity">4.5.2</a>)
for <span style="font-style:oblique">ident</span>. This condition ensures the soundness of the inductive
definition. If this is the case, the names <span style="font-style:oblique">ident</span>,
<span style="font-style:oblique">ident</span><sub>1</sub>, …, <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> are added to the environment with
their respective types. Accordingly to the universe where
the inductive type lives (<span style="font-style:italic">e.g.</span> its type <span style="font-style:oblique">sort</span>), <span style="font-variant:small-caps">Coq</span> provides a
number of destructors for <span style="font-style:oblique">ident</span>. Destructors are named
<span style="font-style:oblique">ident</span><span style="font-family:monospace">_ind</span>, <span style="font-style:oblique">ident</span><span style="font-family:monospace">_rec</span> or <span style="font-style:oblique">ident</span><span style="font-family:monospace">_rect</span> which
respectively correspond to elimination principles on <span style="font-family:monospace">Prop</span>, <span style="font-family:monospace">Set</span> and <span style="font-family:monospace">Type</span>. The type of the destructors expresses structural
induction/recursion principles over objects of <span style="font-style:oblique">ident</span>. We give below
two examples of the use of the <span style="font-family:monospace">Inductive</span> definitions.</p><p>The set of natural numbers is defined as:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive nat : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | O : nat</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | S : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> nat.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nat is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">rect is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ind is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">rec is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>The type <span style="font-family:monospace">nat</span> is defined as the least <code>Set</code> containing <span style="font-family:monospace">O</span> and closed by the <span style="font-family:monospace">S</span> constructor. The names <span style="font-family:monospace">nat</span>,
<span style="font-family:monospace">O</span> and <span style="font-family:monospace">S</span> are added to the environment.</p><p>Now let us have a look at the elimination principles. They are three
of them:
<span style="font-family:monospace">nat_ind</span>, <span style="font-family:monospace">nat_rec</span> and <span style="font-family:monospace">nat_rect</span>. The type of <span style="font-family:monospace">nat_ind</span> is:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check nat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">ind.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nat</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ind</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall P : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       P O -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> (forall n : nat, P n -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (S n)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> forall n : nat, P n</span></span></span><span style="font-size:small"><br>
</span></div><p>This is the well known structural induction principle over natural
numbers, i.e. the second-order form of Peano’s induction principle.
It allows proving some universal property of natural numbers (<span style="font-family:monospace">forall n:nat, P n</span>) by induction on <span style="font-family:monospace">n</span>.</p><p>The types of <span style="font-family:monospace">nat_rec</span> and <span style="font-family:monospace">nat_rect</span> are similar, except
that they pertain to <span style="font-family:monospace">(P:nat-&gt;Set)</span> and <span style="font-family:monospace">(P:nat-&gt;Type)</span>
respectively . They correspond to primitive induction principles
(allowing dependent types) respectively over sorts <code>Set</code> and
<code>Type</code>. The constant <span style="font-style:oblique">ident</span><span style="font-family:monospace">_ind</span> is always provided,
whereas <span style="font-style:oblique">ident</span><span style="font-family:monospace">_rec</span> and <span style="font-style:oblique">ident</span><span style="font-family:monospace">_rect</span> can be impossible
to derive (for example, when <span style="font-style:oblique">ident</span> is a proposition).</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-size:small">
</span><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive nat : Set := O | S (</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">:nat).</span></span><span style="font-size:small"><br>
</span></div><span style="font-size:small">
</span>
In the case where inductive types have no annotations (next section
gives an example of such annotations), 
a constructor can be defined by only giving the type of
its arguments.
</li></ol>
<h4 id="sec50" class="subsubsection">Simple annotated inductive types</h4>
<p>In an annotated inductive types, the universe where the inductive
type is defined is no longer a simple sort, but what is called an
arity, which is a type whose conclusion is a sort.</p><p>As an example of annotated inductive types, let us define the
<span style="font-style:italic">even</span> predicate:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive even : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | even</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">0 : even O</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | even</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">SS : forall n:nat, even n -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> even (S (S n)).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">even is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">even</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ind is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>The type <span style="font-family:monospace">nat-&gt;Prop</span> means that <span style="font-family:monospace">even</span> is a unary predicate
(inductively defined) over natural numbers. The type of its two
constructors are the defining clauses of the predicate <span style="font-family:monospace">even</span>. The
type of <span style="font-family:monospace">even_ind</span> is:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check even</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">ind.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">even</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ind</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall P : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       P O -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall n : nat, even n -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P n -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (S (S n))) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       forall n : nat, even n -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P n</span></span></span><span style="font-size:small"><br>
</span></div><p>From a mathematical point of view it asserts that the natural numbers
satisfying the predicate <span style="font-family:monospace">even</span> are exactly in the smallest set of
naturals satisfying the clauses <span style="font-family:monospace">even_0</span> or <span style="font-family:monospace">even_SS</span>. This
is why, when we want to prove any predicate <span style="font-family:monospace">P</span> over elements of
<span style="font-family:monospace">even</span>, it is enough to prove it for <span style="font-family:monospace">O</span> and to prove that if
any natural number <span style="font-family:monospace">n</span> satisfies <span style="font-family:monospace">P</span> its double successor <span style="font-family:monospace">(S (S n))</span> satisfies also <span style="font-family:monospace">P</span>. This is indeed analogous to the
structural induction principle we got for <span style="font-family:monospace">nat</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Non strictly positive occurrence of </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">type</span><a id="hevea_error5"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">The conclusion of </span><span style="font-style:oblique">type</span><span style="font-family:monospace"> is not valid; it must be
built from </span><span style="font-style:oblique">ident</span><a id="hevea_error6"></a>
</li></ol>
<h4 id="sec51" class="subsubsection">Parametrized inductive types</h4>
<p>
In the previous example, each constructor introduces a
different instance of the predicate <span style="font-family:monospace">even</span>. In some cases, 
all the constructors introduces the same generic instance of the
inductive definition, in which case, instead of an annotation, we use
a context of parameters which are binders shared by all the
constructors of the definition.</p><p>The general scheme is:
</p><div class="center">
<span style="font-family:monospace">Inductive</span> <span style="font-style:oblique">ident</span> <span style="font-style:oblique">binder</span><sub>1</sub>…<span style="font-style:oblique">binder</span><sub><span style="font-style:italic">k</span></sub> : <span style="font-style:oblique">term</span> :=
<span style="font-style:oblique">ident</span><sub>1</sub>: <span style="font-style:oblique">term</span><sub>1</sub> | … | <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>: <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>
<span style="font-family:monospace">.</span>
</div><p>
Parameters differ from inductive type annotations in the fact that the
conclusion of each type of constructor <span style="font-style:oblique">term</span><sub><span style="font-style:italic">i</span></sub> invoke the inductive
type with the same values of parameters as its specification.</p><p>A typical example is the definition of polymorphic lists:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list (A:Set) : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | nil : list A</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | cons : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list A.</span></span><span style="font-size:small"><br>
</span></div><p>Note that in the type of <span style="font-family:monospace">nil</span> and <span style="font-family:monospace">cons</span>, we write <span style="font-family:monospace">(list A)</span> and not just <span style="font-family:monospace">list</span>.<br>
The constructors <span style="font-family:monospace">nil</span> and
<span style="font-family:monospace">cons</span> will have respectively types:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check nil.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">nil</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall A : Set, list A</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check cons.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">cons</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall A : Set, A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> list A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> list A</span></span></span><span style="font-size:small"><br>
</span></div><p>Types of destructors are also quantified with <span style="font-family:monospace">(A:Set)</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-size:small">
</span><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list (A:Set) : Set := nil | cons (</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">:A) (</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">:list A).</span></span><span style="font-size:small"><br>
</span></div><span style="font-size:small">
</span>
This is an alternative definition of lists where we specify the
arguments of the constructors rather than their full type.
</li><li class="li-enumerate"><span style="font-size:small">
</span><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variant sum (A B:Set) : Set := left : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> sum A B | right : B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> sum A B.</span></span><span style="font-size:small"><br>
</span></div><span style="font-size:small">
</span>
The <span style="font-family:monospace">Variant</span> keyword is identical to the <span style="font-family:monospace">Inductive</span> keyword,
except that it disallows recursive definition of types (in particular
lists cannot be defined with the <span style="font-family:monospace">Variant</span> keyword). No induction
scheme is generated for this variant, unless the option
<span style="font-family:monospace">Nonrecursive Elimination Schemes</span> is set
(see <a href="Reference-Manual015.html#set-nonrecursive-elimination-schemes">13.1.1</a>).
</li></ol><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">The </span><span style="font-style:oblique">num</span><span style="font-family:monospace">th argument of </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> must be </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">’</span><span style="font-family:monospace"> in
</span><span style="font-style:oblique">type</span><a id="hevea_error7"></a>
</li></ol>
<h5 id="sec52" class="paragraph">New from <span style="font-variant:small-caps">Coq</span> V8.1</h5>
<p> The condition on parameters for
inductive definitions has been relaxed since <span style="font-variant:small-caps">Coq</span> V8.1. It is now
possible in the type of a constructor, to invoke recursively the
inductive definition on an argument which is not the parameter itself.</p><p>One can define :
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list2 (A:Set) : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | nil2 : list2 A</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | cons2 : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list2 (A*A) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list2 A.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list2 is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list2</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">rect is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list2</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ind is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">list2</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">rec is defined</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
that can also be written by specifying only the type of the arguments:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list2 (A:Set) : Set := nil2 | cons2 (</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">:A) (</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">:list2 (A*A)).</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
But the following definition will give an error:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail Inductive listw (A:Set) : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | nilw : listw (A*A)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | consw : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> listw (A*A) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> listw (A*A).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The command has indeed failed with message:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Last occurrence of "listw" must have "A" as 1st argument in</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> "listw (A * A)%type".</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
Because the conclusion of the type of constructors should be <span style="font-family:monospace">listw A</span> in both cases. </p><p>A parametrized inductive definition can be defined using
annotations instead of parameters but it will sometimes give a
different (bigger) sort for the inductive definition and will produce
a less convenient rule for case elimination.</p><p><br>
<span style="font-weight:bold">See also: </span>Sections <a href="Reference-Manual006.html#Cic-inductive-definitions">4.5</a> and <a href="Reference-Manual010.html#Tac-induction">8.5.2</a>.</p>
<h4 id="Mutual-Inductive" class="subsubsection">Mutually defined inductive types
<a id="hevea_default51"></a><a id="hevea_command15"></a>
</h4>
<p>The definition of a block of mutually inductive types has the form:</p><p><br>
</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Inductive </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><sub>1</sub><span style="font-family:monospace"> := </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub>1</sub><sup>1</sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">:</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub>1</sub><sup>1</sup><span style="font-family:monospace"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace"> |</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">…</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">&nbsp;</span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace"> |</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span><sub>1</sub></sub><sup>1</sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">:</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span><sub>1</sub></sub><sup>1</sup><span style="font-family:monospace">
</span></td></tr>
</table><span style="font-family:monospace"> </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">with</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">with </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> := </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub>1</sub><sup><span style="font-style:italic">m</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">:</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub>1</sub><sup><span style="font-style:italic">m</span></sup><span style="font-family:monospace"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace"> |</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace"> |</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span><sub><span style="font-style:italic">m</span></sub></sub><sup><span style="font-style:italic">m</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">:</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span><sub><span style="font-style:italic">m</span></sub></sub><sup><span style="font-style:italic">m</span></sup><span style="font-family:monospace">.
</span></td></tr>
</table><span style="font-family:monospace">
</span></td></tr>
</table><p><span style="font-family:monospace">
</span>
<br>
</p><p>It has the same semantics as the above <span style="font-family:monospace">Inductive</span>
definition for each <span style="font-style:oblique">ident</span><sub>1</sub>, …, <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub>. All names
<span style="font-style:oblique">ident</span><sub>1</sub>, …, <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub> and <span style="font-style:oblique">ident</span><sub>1</sub><sup>1</sup>, …,
<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span><sub><span style="font-style:italic">m</span></sub></sub><sup><span style="font-style:italic">m</span></sup> are simultaneously added to the environment. Then
well-typing of constructors can be checked. Each one of the
<span style="font-style:oblique">ident</span><sub>1</sub>, …, <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub> can be used on its own.</p><p>It is also possible to parametrize these inductive definitions.
However, parameters correspond to a local
context in which the whole set of inductive declarations is done. For
this reason, the parameters must be strictly the same for each
inductive types The extended syntax is:</p><p><br>
</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Inductive</span> <span style="font-style:oblique">ident</span><sub>1</sub> <span style="font-style:oblique">params</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub>1</sub> <span style="font-family:monospace">:=</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub>1</sub><sup>1</sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">:</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub>1</sub><sup>1</sup> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-family:monospace">|</span></td><td style="text-align:left;white-space:nowrap" >…</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-family:monospace">|</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span><sub>1</sub></sub><sup>1</sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">:</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span><sub>1</sub></sub><sup>1</sup>
</td></tr>
</table> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">with</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" > … </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">with</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:oblique">params</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub><span style="font-style:italic">m</span></sub> <span style="font-family:monospace">:=</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub>1</sub><sup><span style="font-style:italic">m</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">:</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub>1</sub><sup><span style="font-style:italic">m</span></sup> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-family:monospace">|</span></td><td style="text-align:left;white-space:nowrap" >… </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-family:monospace">|</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span><sub><span style="font-style:italic">m</span></sub></sub><sup><span style="font-style:italic">m</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">:</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span><sub><span style="font-style:italic">m</span></sub></sub><sup><span style="font-style:italic">m</span></sup>.
</td></tr>
</table>
</td></tr>
</table><p>
<br>
</p><p><br>
<span style="font-weight:bold">Example: </span>The typical example of a mutual inductive data type is the one for
trees and forests. We assume given two types <span style="font-style:italic">A</span> and <span style="font-style:italic">B</span> as variables.
It can be declared the following way.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variables A B : Set.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive tree : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          node : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> tree</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      with forest : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | leaf : B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | cons : tree -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest.</span></span><span style="font-size:small"><br>
</span></div><p>This declaration generates automatically six induction
principles. They are respectively 
called <span style="font-family:monospace">tree_rec</span>, <span style="font-family:monospace">tree_ind</span>, <span style="font-family:monospace">tree_rect</span>, <span style="font-family:monospace">forest_rec</span>, <span style="font-family:monospace">forest_ind</span>, <span style="font-family:monospace">forest_rect</span>. These ones are not the most general ones but are
just the induction principles corresponding to each inductive part
seen as a single inductive definition.</p><p>To illustrate this point on our example, we give the types of <span style="font-family:monospace">tree_rec</span> and <span style="font-family:monospace">forest_rec</span>.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check tree</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">rec.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tree</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">rec</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall P : tree -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall (a : A) (f : forest), P (node a f)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> forall t : tree, P t</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check forest</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">rec.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">forest</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">rec</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall P : forest -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Set,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall b : B, P (leaf b)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall (t : tree) (f0 : forest), P f0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (cons t f0)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       forall f1 : forest, P f1</span></span></span><span style="font-size:small"><br>
</span></div><p>Assume we want to parametrize our mutual inductive definitions with
the two type variables <span style="font-style:italic">A</span> and <span style="font-style:italic">B</span>, the declaration should be done the
following way:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive tree (A B:Set) : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          node : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest A B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> tree A B</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      with forest (A B:Set) : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | leaf : B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest A B</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | cons : tree A B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest A B -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forest A B.</span></span><span style="font-size:small"><br>
</span></div><p>Assume we define an inductive definition inside a section. When the
section is closed, the variables declared in the section and occurring
free in the declaration are added as parameters to the inductive
definition. </p><p><br>
<span style="font-weight:bold">See also: </span>Section <a href="Reference-Manual004.html#Section">2.4</a>.</p>
<h4 id="CoInductiveTypes" class="subsubsection">Co-inductive types

<a id="hevea_default52"></a><a id="hevea_command16"></a></h4>
<p>The objects of an inductive type are well-founded with respect to the
constructors of the type. In other words, such objects contain only a
<span style="font-style:italic">finite</span> number of constructors. Co-inductive types arise from
relaxing this condition, and admitting types whose objects contain an
infinity of constructors. Infinite objects are introduced by a
non-ending (but effective) process of construction, defined in terms
of the constructors of the type.</p><p>An example of a co-inductive type is the type of infinite sequences of
natural numbers, usually called streams. It can be introduced in <span style="font-variant:small-caps">Coq</span>
using the <span style="font-family:monospace">CoInductive</span> command:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> CoInductive Stream : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          Seq : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Stream -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Stream.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Stream is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>The syntax of this command is the same as the command <span style="font-family:monospace">Inductive</span>
(see Section <a href="#gal-Inductive-Definitions">1.3.3</a>). Notice that no
principle of induction is derived from the definition of a
co-inductive type, since such principles only make sense for inductive
ones. For co-inductive ones, the only elimination principle is case
analysis. For example, the usual destructors on streams
<span style="font-family:monospace">hd:Stream-&gt;nat</span> and <span style="font-family:monospace">tl:Str-&gt;Str</span> can be defined as
follows:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition hd (x:Stream) := let (a,s) := x in a.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">hd is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition tl (x:Stream) := let (a,s) := x in s.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">tl is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>Definition of co-inductive predicates and blocks of mutually
co-inductive definitions are also allowed. An example of a
co-inductive predicate is the extensional equality on streams:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> CoInductive EqSt : Stream -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Stream -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          eqst :</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">            forall s1 s2:Stream,</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">              hd s1 = hd s2 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> EqSt (tl s1) (tl s2) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> EqSt s1 s2.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">EqSt is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>In order to prove the extensionally equality of two streams <span style="font-style:italic">s</span><sub>1</sub> and
<span style="font-style:italic">s</span><sub>2</sub> we have to construct an infinite proof of equality, that is,
an infinite object of type (<span style="font-family:monospace">EqSt</span> <span style="font-style:italic">s</span><sub>1</sub> <span style="font-style:italic">s</span><sub>2</sub>). We will see
how to introduce infinite objects in Section <a href="#CoFixpoint">1.3.4</a>.</p>
<h3 id="sec55" class="subsection">1.3.4  Definition of recursive functions</h3>
<h4 id="sec56" class="subsubsection">Definition of functions by recursion over inductive objects</h4>
<p>This section describes the primitive form of definition by recursion
over inductive objects. See Section <a href="Reference-Manual004.html#Function">2.3</a> for more advanced
constructions. The command:
</p><div class="center">
<span style="font-family:monospace">Fixpoint </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">params</span><span style="font-family:monospace"> </span><span style="font-family:monospace">{struct</span><span style="font-family:monospace">
</span><span style="font-style:oblique">ident</span><sub>0</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">}</span><span style="font-family:monospace"> : type</span><sub>0</sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><sub>0</sub><span style="font-family:monospace"> 
</span><a id="hevea_default53"></a><a id="hevea_command17"></a><a id="Fixpoint"></a>
</div><p>
allows defining functions by pattern-matching over inductive objects 
using a fixed point construction.
The meaning of this declaration is to define <span style="font-style:italic">ident</span> a recursive
function with arguments specified by the binders in <span style="font-style:oblique">params</span> such
that <span style="font-style:italic">ident</span> applied to arguments corresponding to these binders
has type <span style="font-style:oblique">type</span><sub>0</sub>, and is equivalent to the expression <span style="font-style:oblique">term</span><sub>0</sub>. The
type of the <span style="font-style:oblique">ident</span> is consequently <span style="font-family:monospace">forall </span><span style="font-style:oblique">params</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace">
</span><span style="font-style:oblique">type</span><sub>0</sub> and the value is equivalent to <span style="font-family:monospace">fun </span><span style="font-style:oblique">params</span><span style="font-family:monospace"> </span><span style="font-family:monospace">=&gt;</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>0</sub>.</p><p>To be accepted, a <span style="font-family:monospace">Fixpoint</span> definition has to satisfy some
syntactical constraints on a special argument called the decreasing
argument. They are needed to ensure that the <span style="font-family:monospace">Fixpoint</span> definition
always terminates. The point of the <span style="font-family:monospace">{struct </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">}</span>
annotation is to let the user tell the system which argument decreases
along the recursive calls. For instance, one can define the addition 
function as :</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint add (n m:nat) {struct n} : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match n with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | O =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> m</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | S p =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (add p m)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">add is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">add is recursively defined (decreasing on 1st argument)</span></span></span><span style="font-size:small"><br>
</span></div><p>The <span style="font-family:monospace">{struct </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">}</span> annotation may be left implicit, in
this case the system try successively arguments from left to right
until it finds one that satisfies the decreasing condition. Note that
some fixpoints may have several arguments that fit as decreasing
arguments, and this choice influences the reduction of the
fixpoint. Hence an explicit annotation must be used if the leftmost
decreasing argument is not the desired one. Writing explicit
annotations can also speed up type-checking of large mutual fixpoints.</p><p>The <span style="font-family:monospace">match</span> operator matches a value (here <code>n</code>) with the
various constructors of its (inductive) type. The remaining arguments
give the respective values to be returned, as functions of the
parameters of the corresponding constructor. Thus here when <code>n</code>
equals <code>O</code> we return <code>m</code>, and when <code>n</code> equals 
<code>(S p)</code> we return <code>(S (add p m))</code>.</p><p>The <span style="font-family:monospace">match</span> operator is formally described
in detail in Section <a href="Reference-Manual006.html#Caseexpr">4.5.3</a>. The system recognizes that in
the inductive call <span style="font-family:monospace">(add p m)</span> the first argument actually
decreases because it is a <em>pattern variable</em> coming from <span style="font-family:monospace">match
n with</span>.</p><p><br>
<span style="font-weight:bold">Example: </span>The following definition is not correct and generates an
error message:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail Fixpoint wrongplus (n m:nat) {struct n} : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match m with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | O =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> n</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | S p =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (wrongplus n p)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The command has indeed failed with message:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Recursive definition of wrongplus is ill-formed.</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">In environment</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">wrongplus : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">n : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">m : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">p : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Recursive call to wrongplus has principal argument equal to </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">"n" instead of a subterm of "n".</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Recursive definition is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">"fun n m : nat =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> match m with</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">                  | 0 =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">                  | S p =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> S (wrongplus n p)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">                  end".</span></span></span><span style="font-size:small"><br>
</span></div><p>because the declared decreasing argument <span style="font-family:monospace">n</span> actually does not
decrease in the recursive call. The function computing the addition
over the second argument should rather be written:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint plus (n m:nat) {struct m} : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match m with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | O =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> n</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | S p =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (plus n p)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end.</span></span><span style="font-size:small"><br>
</span></div><p>The ordinary match operation on natural numbers can be mimicked in the
following way.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint nat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">match </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        (C:Set) (f0:C) (fS:nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> C -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> C) (n:nat) {struct n} : C :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match n with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | O =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> f0</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | S p =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> fS p (nat</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">match C f0 fS p)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
The recursive call may not only be on direct subterms of the recursive
variable <span style="font-family:monospace">n</span> but also on a deeper subterm and we can directly
write the function <span style="font-family:monospace">mod2</span> which gives the remainder modulo 2 of a
natural number.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint mod2 (n:nat) : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match n with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | O =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> O</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | S p =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> match p with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                 | O =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S O</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                 | S q =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> mod2 q</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">                 end</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
In order to keep the strong normalization property, the fixed point
reduction will only be performed when the argument in position of the
decreasing argument (which type should be in an inductive definition)
starts with a constructor.</p><p>The <span style="font-family:monospace">Fixpoint</span> construction enjoys also the <span style="font-family:monospace">with</span> extension
to define functions over mutually defined inductive types or more
generally any mutually recursive definitions.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Fixpoint</span> <span style="font-style:oblique">ident</span><sub>1</sub> <span style="font-style:oblique">params</span><sub>1</sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub>1</sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>1</sub><br>
 <span style="font-family:monospace">with</span> … <br>
 <span style="font-family:monospace">with</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:oblique">params</span><sub><span style="font-style:italic">m</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub><span style="font-style:italic">m</span></sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span></sub><br>
 Allows to define simultaneously <span style="font-style:oblique">ident</span><sub>1</sub>, …,
<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub>.
</li></ol><p><br>
<span style="font-weight:bold">Example: </span>The size of trees and forests can be defined the following way: 
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fixpoint tree</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">size (t:tree) : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match t with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | node a f =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> S (forest</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">size f)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">       with forest</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">size (f:forest) : nat :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        match f with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | leaf b =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 1</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | cons t f</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> (tree</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">size t + forest</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">size f</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-size:small">
</span>
A generic command <span style="font-family:monospace">Scheme</span> is useful to build automatically various
mutual induction principles. It is described in Section <a href="Reference-Manual015.html#Scheme">13.1</a>.</p>
<h4 id="sec57" class="subsubsection">Definitions of recursive objects in co-inductive types</h4>
<p>The command:
</p><div class="center">
<span style="font-family:monospace">CoFixpoint </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><sub>0</sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><sub>0</sub>
<a id="hevea_default54"></a><a id="hevea_command18"></a><a id="CoFixpoint"></a>
</div><p>
introduces a method for constructing an infinite object of a
coinductive type. For example, the stream containing all natural
numbers can be introduced applying the following method to the number
<span style="font-family:monospace">O</span> (see Section <a href="#CoInductiveTypes">1.3.3</a> for the definition of
<span style="font-family:monospace">Stream</span>, <span style="font-family:monospace">hd</span> and <span style="font-family:monospace">tl</span>):
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> CoFixpoint from (n:nat) : Stream := Seq n (from (S n)).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">from is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">from is corecursively defined</span></span></span><span style="font-size:small"><br>
</span></div><p>Oppositely to recursive ones, there is no decreasing argument in a
co-recursive definition. To be admissible, a method of construction
must provide at least one extra constructor of the infinite object for
each iteration. A syntactical guard condition is imposed on
co-recursive definitions in order to ensure this: each recursive call
in the definition must be protected by at least one constructor, and
only by constructors. That is the case in the former definition, where
the single recursive call of <span style="font-family:monospace">from</span> is guarded by an
application of <span style="font-family:monospace">Seq</span>. On the contrary, the following recursive
function does not satisfy the guard condition:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail CoFixpoint filter (p:nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> bool) (s:Stream) : Stream :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        if p (hd s) then Seq (hd s) (filter p (tl s)) else filter p (tl s).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The command has indeed failed with message:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Recursive definition of filter is ill-formed.</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">In environment</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">filter : (nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> bool) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Stream -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Stream</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">p : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> bool</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">s : Stream</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Unguarded recursive call in "filter p (tl s)".</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Recursive definition is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">"fun (p : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> bool) (s : Stream) =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> if p (hd s) then Seq (hd s) (filter p (tl s)) else filter p (tl s)".</span></span></span><span style="font-size:small"><br>
</span></div><p>The elimination of co-recursive definition is done lazily, i.e. the
definition is expanded only when it occurs at the head of an
application which is the argument of a case analysis expression. In
any other context, it is considered as a canonical expression which is
completely evaluated. We can test this using the command
<span style="font-family:monospace">Eval</span>, which computes the normal forms of a term:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Eval compute in (from 0).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     = (cofix from (n : nat) : Stream := Seq n (from (S n))) 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Stream</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Eval compute in (hd (from 0)).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : nat</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Eval compute in (tl (from 0)).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     = (cofix from (n : nat) : Stream := Seq n (from (S n))) 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : Stream</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">CoFixpoint </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">params</span><span style="font-family:monospace"> :</span><span style="font-style:oblique">type</span><sub>1</sub><span style="font-family:monospace"> :=
</span><span style="font-style:oblique">term</span><sub>1</sub><br>
As for most constructions, arguments of co-fixpoints
expressions can be introduced before the <span style="font-family:monospace">:=</span> sign.
</li><li class="li-enumerate"><span style="font-family:monospace">CoFixpoint</span> <span style="font-style:oblique">ident</span><sub>1</sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub>1</sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>1</sub><br>
 <span style="font-family:monospace">with</span><br>
  … <br>
 <span style="font-family:monospace">with</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:oblique">type</span><sub><span style="font-style:italic">m</span></sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span></sub><br>
As in the <span style="font-family:monospace">Fixpoint</span> command (see Section <a href="#Fixpoint">1.3.4</a>), it
is possible to introduce a block of mutually dependent methods.
</li></ol>
<h3 id="sec58" class="subsection">1.3.5  Assertions and proofs</h3>
<p>
<a id="Assertions"></a></p><p>An assertion states a proposition (or a type) of which the proof (or
an inhabitant of the type) is interactively built using tactics. The
interactive proof mode is described in
Chapter <a href="Reference-Manual009.html#Proof-handling">7</a> and the tactics in Chapter <a href="Reference-Manual010.html#Tactics">8</a>.
The basic assertion command is:</p>
<h4 id="sec59" class="subsubsection"><span style="font-family:monospace">Theorem </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.
</span><a id="hevea_default55"></a><a id="hevea_command19"></a></h4>
<p>After the statement is asserted, <span style="font-variant:small-caps">Coq</span> needs a proof. Once a proof of
<span style="font-style:oblique">type</span> under the assumptions represented by <span style="font-style:oblique">binders</span> is given and
validated, the proof is generalized into a proof of <span style="font-family:monospace">forall
</span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace">, </span><span style="font-style:oblique">type</span> and the theorem is bound to the name
<span style="font-style:oblique">ident</span> in the environment.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">The term </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> has type </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> which should be Set,
Prop or Type</span><a id="hevea_error8"></a></li><li class="li-enumerate"><span style="font-style:oblique">ident</span><span style="font-family:monospace"> already exists</span><a id="hevea_error9"></a><p>The name you provided is already defined. You have then to choose
another name.</p></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"> 
<span style="font-family:monospace">Lemma </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.</span><a id="hevea_default56"></a><a id="hevea_command20"></a><br>
 <span style="font-family:monospace">Remark </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.</span><a id="hevea_default57"></a><a id="hevea_command21"></a><br>
 <span style="font-family:monospace">Fact </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.</span><a id="hevea_default58"></a><a id="hevea_command22"></a><br>
 <span style="font-family:monospace">Corollary </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.</span><a id="hevea_default59"></a><a id="hevea_command23"></a><br>
 <span style="font-family:monospace">Proposition </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.</span><a id="hevea_default60"></a><a id="hevea_command24"></a><p>These commands are synonyms of <span style="font-family:monospace">Theorem </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Theorem </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace">: </span><span style="font-style:oblique">type</span><span style="font-family:monospace"> </span><span style="font-family:monospace">with</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">with</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace">: </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.</span><p>This command is useful for theorems that are proved by simultaneous
induction over a mutually inductive assumption, or that assert mutually
dependent statements in some mutual co-inductive type. It is equivalent
to <span style="font-family:monospace">Fixpoint</span> or <span style="font-family:monospace">CoFixpoint</span>
(see Section <a href="#CoFixpoint">1.3.4</a>) but using tactics to build the proof of
the statements (or the body of the specification, depending on the
point of view). The inductive or co-inductive types on which the
induction or coinduction has to be done is assumed to be non ambiguous
and is guessed by the system. </p><p>Like in a <span style="font-family:monospace">Fixpoint</span> or <span style="font-family:monospace">CoFixpoint</span> definition, the induction
hypotheses have to be used on <em>structurally smaller</em> arguments
(for a <span style="font-family:monospace">Fixpoint</span>) or be <em>guarded by a constructor</em> (for a <span style="font-family:monospace">CoFixpoint</span>). The verification that recursive proof arguments are
correct is done only at the time of registering the lemma in the
environment. To know if the use of induction hypotheses is correct at
some time of the interactive development of a proof, use the command
<span style="font-family:monospace">Guarded</span> (see Section <a href="Reference-Manual009.html#Guarded">7.3.2</a>).</p><p>The command can be used also with <span style="font-family:monospace">Lemma</span>,
<span style="font-family:monospace">Remark</span>, etc. instead of <span style="font-family:monospace">Theorem</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Definition </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.</span><p>This allows defining a term of type <span style="font-style:oblique">type</span> using the proof editing mode. It
behaves as <span style="font-family:monospace">Theorem</span> but is intended to be used in conjunction with
<span style="font-family:monospace">Defined</span> (see <a href="Reference-Manual009.html#Defined">1</a>) in order to define a
constant of which the computational behavior is relevant.</p><p>The command can be used also with <span style="font-family:monospace">Example</span> instead
of <span style="font-family:monospace">Definition</span>.</p><p><br>
<span style="font-weight:bold">See also: </span>Sections <a href="Reference-Manual008.html#Opaque">6.10.1</a> and <a href="Reference-Manual008.html#Transparent">6.10.2</a> (<span style="font-family:monospace">Opaque</span>
and <span style="font-family:monospace">Transparent</span>) and <a href="Reference-Manual010.html#unfold">8.7.5</a> (tactic <span style="font-family:monospace">unfold</span>).</p></li><li class="li-enumerate"><span style="font-family:monospace">Let </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.</span><p>Like <span style="font-family:monospace">Definition </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">.</span> except
that the definition is turned into a let-in definition generalized over
the declarations depending on it after closing the current section.</p></li><li class="li-enumerate"><span style="font-family:monospace">Fixpoint </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binders</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">annotation</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:=</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace">with</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">with</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binders</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">annotation</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:=</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace">.</span>
<a id="hevea_default61"></a><a id="hevea_command25"></a><p>This generalizes the syntax of <span style="font-family:monospace">Fixpoint</span> so that one or more
bodies can be defined interactively using the proof editing mode (when
a body is omitted, its type is mandatory in the syntax). When the
block of proofs is completed, it is intended to be ended by <span style="font-family:monospace">Defined</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">CoFixpoint </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:=</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace">with</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">with</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">binders</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">:=</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace">.</span>
<a id="hevea_default62"></a><a id="hevea_command26"></a><p>This generalizes the syntax of <span style="font-family:monospace">CoFixpoint</span> so that one or more bodies
can be defined interactively using the proof editing mode.</p></li></ol>
<h4 id="sec60" class="subsubsection"><span style="font-family:monospace">Proof.</span> … <span style="font-family:monospace">Qed.</span>
<a id="hevea_default63"></a><a id="hevea_command27"></a>
<a id="hevea_default64"></a><a id="hevea_command28"></a></h4>
<p>A proof starts by the keyword <span style="font-family:monospace">Proof</span>. Then <span style="font-variant:small-caps">Coq</span> enters the
proof editing mode until the proof is completed. The proof editing
mode essentially contains tactics that are described in chapter
<a href="Reference-Manual010.html#Tactics">8</a>. Besides tactics, there are commands to manage the proof
editing mode. They are described in Chapter <a href="Reference-Manual009.html#Proof-handling">7</a>. When
the proof is completed it should be validated and put in the
environment using the keyword <span style="font-family:monospace">Qed</span>.
<br>
</p><p><br>
<span style="font-weight:bold">Error message: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-style:oblique">ident</span><span style="font-family:monospace"> already exists</span><a id="hevea_error10"></a>
</li></ol><p><br>
<span style="font-weight:bold">Remarks: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
Several statements can be simultaneously asserted.
</li><li class="li-enumerate">Not only other assertions but any vernacular command can be given
while in the process of proving a given assertion. In this case, the command is
understood as if it would have been given before the statements still to be
proved. 
</li><li class="li-enumerate"><span style="font-family:monospace">Proof</span> is recommended but can currently be omitted. On the
opposite side, <span style="font-family:monospace">Qed</span> (or <span style="font-family:monospace">Defined</span>, see below) is mandatory to
validate a proof.
</li><li class="li-enumerate">Proofs ended by <span style="font-family:monospace">Qed</span> are declared opaque. Their content
cannot be unfolded (see <a href="Reference-Manual010.html#Conversion-tactics">8.7</a>), thus realizing
some form of <em>proof-irrelevance</em>. To be able to unfold a proof,
the proof should be ended by <span style="font-family:monospace">Defined</span> (see below).
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<a id="hevea_default65"></a><a id="hevea_command29"></a>
<span style="font-family:monospace">Proof.</span> … <span style="font-family:monospace">Defined.</span><br>
 Same as <span style="font-family:monospace">Proof.</span> … <span style="font-family:monospace">Qed.</span> but the proof is
then declared transparent, which means that its
content can be explicitly used for type-checking and that it
can be unfolded in conversion tactics (see
<a href="Reference-Manual010.html#Conversion-tactics">8.7</a>, <a href="Reference-Manual008.html#Opaque">6.10.1</a>, <a href="Reference-Manual008.html#Transparent">6.10.2</a>).
</li><li class="li-enumerate"><a id="hevea_default66"></a><a id="hevea_command30"></a>
<span style="font-family:monospace">Proof.</span> … <span style="font-family:monospace">Admitted.</span><br>
 Turns the current asserted statement into an axiom and exits the
proof mode.
</li></ol><hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">This is similar to the
expression “<span style="font-style:oblique">entry</span> { <span style="font-family:monospace">sep</span> <span style="font-style:oblique">entry</span> }” in
standard BNF, or “<span style="font-style:oblique">entry</span> ( <span style="font-family:monospace">sep</span> <span style="font-style:oblique">entry</span> )*” in
the syntax of regular expressions.</div></dd><dt class="dt-thefootnotes"><a id="note2" href="#text2">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Except if
the inductive type is empty in which case there is no equation that can be 
used to infer the return type.</div></dd></dl>

<div id="sidebarWrapper">
  <div id="sidebar">
    <div class="block">
      <h2 class="title">Navigation</h2>
      <div class="content">
        <ul class="menu">
          <li class="leaf"><a href="index.html">Cover</a></li>
          <li class="leaf"><a href="toc.html">Table of contents</a></li>
          <li class="leaf">Index
            <ul class="menu">
              <li><a href="general-index.html">General</a></li>
              <li><a href="command-index.html">Commands</a></li>
              <li><a href="option-index.html">Options</a></li>
              <li><a href="tactic-index.html">Tactics</a></li>
              <li><a href="error-index.html">Errors</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</body>
</html>
