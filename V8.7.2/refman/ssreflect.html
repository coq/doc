<!DOCTYPE html>
<html >
<head>


<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/coqdoc.css" /><title>Chapter 11  The SSReflect proof language</title>
</head>
<body >

<div id="container">

<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="/" class="active">Home</a></li>
    <li><a href="/about-coq" title="More about coq">About Coq</a></li>
    <li><a href="/download">Get Coq</a></li>
    <li><a href="/documentation">Documentation</a></li>
    <li><a href="/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">
<div id="logoWrapper">
  <div id="logo"><a href="/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
  </div>
  <div id="siteName"><a href="/" title="Home">The Coq Proof Assistant</a>
  </div>
</div>
</div>

<div id="content">

<h1 id="sec520" class="chapter">Chapter 11  The SSReflect proof language</h1>
<ul>
<li><a href="ssreflect.html#sec521">11.1  Introduction</a>
</li><li><a href="ssreflect.html#sec523">11.2  Usage</a>
</li><li><a href="ssreflect.html#sec526">11.3  Gallina extensions</a>
</li><li><a href="ssreflect.html#sec532">11.4  Definitions</a>
</li><li><a href="ssreflect.html#sec538">11.5  Basic tactics</a>
</li><li><a href="ssreflect.html#sec552">11.6  Control flow</a>
</li><li><a href="ssreflect.html#sec564">11.7  Rewriting</a>
</li><li><a href="ssreflect.html#sec578">11.8  Contextual patterns</a>
</li><li><a href="ssreflect.html#sec585">11.9  Views and reflection</a>
</li><li><a href="ssreflect.html#sec599">11.10  <span style="font-variant:small-caps">SSReflect</span> searching tool</a>
</li><li><a href="ssreflect.html#sec600">11.11  Synopsis and Index</a>
</li></ul>
<p>
<span style="font-size:x-large"><span style="font-weight:bold">Georges Gonthier, Assia Mahboubi, Enrico Tassi</span></span> <br>
<br>
</p>
<h2 id="sec521" class="section">11.1  Introduction</h2>
<p><a id="sec:intro"></a></p><p>This chapter describes a set of tactics known as <span style="font-variant:small-caps">SSReflect</span>
originally designed to provide support for the so-called <em>small scale
reflection</em> proof methodology. Despite the original purpose this set of tactic
is of general interest and is available in Coq starting from version 8.7.</p><p><span style="font-variant:small-caps">SSReflect</span> was developed independently of the tactics described in
Chapter <a href="tactics.html#Tactics">8</a>. Indeed the scope of the tactics part of
<span style="font-variant:small-caps">SSReflect</span> largely overlaps with the standard set of tactics. Eventually
the overlap will be reduced in future releases of Coq.</p><p>Proofs written in <span style="font-variant:small-caps">SSReflect</span> typically look quite different from the
ones written using only tactics as per Chapter <a href="tactics.html#Tactics">8</a>.
We try to summarise here the most “visible” ones in order to
help the reader already accustomed to the tactics described in
Chapter <a href="tactics.html#Tactics">8</a> to read this chapter.</p><p>The first difference between the tactics described in this
chapter and the tactics described in Chapter <a href="tactics.html#Tactics">8</a> is the way
hypotheses are managed (we call this <em>bookkeeping</em>).
In Chapter <a href="tactics.html#Tactics">8</a> the most common
approach is to avoid moving explicitly hypotheses back and forth
between the context and the conclusion of the goal. On the contrary
in <span style="font-variant:small-caps">SSReflect</span>
all bookkeeping is performed on the conclusion of the goal, using for
that purpose a couple of syntactic constructions behaving similar to
tacticals (and often named as such in this chapter).
The <span style="font-family:monospace">:</span> tactical moves hypotheses from the context to the
conclusion, while <span style="font-family:monospace">=&gt;</span> moves hypotheses from the
conclusion to the context, and <span style="font-family:monospace">in</span> moves back
and forth an hypothesis from the context to the conclusion for the
time of applying an action to it.</p><p>While naming hypotheses is commonly done by means of an <span style="font-family:monospace">as</span>
clause in the basic model of Chapter <a href="tactics.html#Tactics">8</a>, it is here to
<span style="font-family:monospace">=&gt;</span> that this task is devoted. As tactics leave
new assumptions in the conclusion, and are often followed by
<span style="font-family:monospace">=&gt;</span> to explicitly name them.
While generalizing the goal is normally
not explicitly needed in Chapter <a href="tactics.html#Tactics">8</a>, it is an explicit
operation performed by <span style="font-family:monospace">:</span>.</p><p>Beside the difference of bookkeeping model, this chapter includes
specific tactics which have no explicit counterpart in
Chapter <a href="tactics.html#Tactics">8</a> such as tactics to mix forward steps and
generalizations as <span style="font-family:monospace">generally have</span> or <span style="font-family:monospace">without loss</span>.</p><p><span style="font-variant:small-caps">SSReflect</span> adopts the point of view that rewriting, definition
expansion and partial evaluation participate all to a same concept of
rewriting a goal in a larger sense. As such, all these functionalities are
provided by the <span style="font-family:monospace">rewrite</span> tactic.</p><p><span style="font-variant:small-caps">SSReflect</span> includes a little language of patterns to select subterms in tactics
or tacticals where it matters. Its most notable application
is in the <span style="font-family:monospace">rewrite</span> tactic, where patterns are used to specify
where the rewriting step has to take place.</p><p>Finally, <span style="font-variant:small-caps">SSReflect</span> supports so-called reflection steps, typically
allowing to switch back and forth between the computational view and
logical view of a concept.</p><p>To conclude it is worth mentioning that <span style="font-variant:small-caps">SSReflect</span> tactics
can be mixed with non <span style="font-variant:small-caps">SSReflect</span> tactics in the same proof,
or in the same Ltac expression. The few exceptions
to this statement are described in section <a href="#sec%3Acompat">11.2.2</a>.</p><h3 id="sec522" class="subsection">Acknowledgments</h3>
<p>
The authors would like to thank Frédéric Blanqui, François Pottier
and Laurence Rideau for their comments and suggestions.</p>
<h2 id="sec523" class="section">11.2  Usage</h2>
<h3 id="sec524" class="subsection">11.2.1  Getting started</h3>
<p><a id="sec:files"></a>
To be available, the tactics presented in this manual need the
following minimal set of libraries to loaded: <span style="font-family:monospace">ssreflect.v</span>, <span style="font-family:monospace">ssrfun.v</span> and <span style="font-family:monospace">ssrbool.v</span>. Moreover, these tactics come with a
methodology specific to the authors of Ssreflect and which requires a
few options to be set in a different way than in their default
way. All in all, this corresponds to working in the following context:</p><div class="lstlisting">  From Coq Require Import ssreflect ssrfun ssrbool.
  Set Implicit Arguments.
  Unset Strict Implicit.
  Unset Printing Implicit Defensive.</div>
<h3 id="sec525" class="subsection">11.2.2  Compatibility issues</h3>
<p><a id="sec:compat"></a>
Requiring the above modules creates an environment which
is mostly compatible with the rest of <span style="font-variant:small-caps">Coq</span>, up to a few discrepancies:
</p><ul class="itemize"><li class="li-itemize">
New keywords (<span style="font-family:monospace">is</span>) might clash with variable, constant,
tactic or tactical names, or with quasi-keywords in tactic or
vernacular notations.
</li><li class="li-itemize">New tactic(al)s names (<span style="font-family:monospace">last</span>, <span style="font-family:monospace">done</span>, <span style="font-family:monospace">have</span>,
<span style="font-family:monospace">suffices</span>, <span style="font-family:monospace">suff</span>,
<span style="font-family:monospace">without loss</span>, <span style="font-family:monospace">wlog</span>, <span style="font-family:monospace">congr</span>, <span style="font-family:monospace">unlock</span>) might clash
with user tactic names.
</li><li class="li-itemize">Identifiers with both leading and trailing <span style="font-family:monospace">_</span>, such as <span style="font-family:monospace">_x_</span>,
are reserved by <span style="font-variant:small-caps">SSReflect</span> and cannot appear in scripts.
</li><li class="li-itemize">The extensions to the <span style="font-family:monospace">rewrite</span> tactic are partly
incompatible with those available in current versions of <span style="font-variant:small-caps">Coq</span>;
in particular:
<span style="font-family:monospace">rewrite .. in (type of k)</span> or <br>
<span style="font-family:monospace">rewrite .. in *</span> or any other
variant of <span style="font-family:monospace">rewrite</span> will not work, and the <span style="font-variant:small-caps">SSReflect</span> syntax and semantics for occurrence selection and
rule chaining is different.<p>Use an explicit rewrite direction (<span style="font-family:monospace">rewrite &lt;-</span> … or <span style="font-family:monospace">rewrite -&gt;</span> …)
to access the <span style="font-variant:small-caps">Coq</span> <span style="font-family:monospace">rewrite</span> tactic.
</p></li><li class="li-itemize">New symbols (<span style="font-family:monospace">//, /=, //=</span>) might clash with adjacent existing
symbols (e.g., ’<span style="font-family:monospace">//</span>’) instead of ’<span style="font-family:monospace">/</span>”<span style="font-family:monospace">/</span>’). This can be avoided
by inserting white spaces.
</li><li class="li-itemize">New constant and theorem names might clash with the user
theory. This can be avoided by not importing all of <span style="font-variant:small-caps">SSReflect</span>:
<div class="lstlisting">  From Coq Require ssreflect.
  Import ssreflect.SsrSyntax.</div>Note that the full syntax of <span style="font-variant:small-caps">SSReflect</span>’s <span style="font-family:monospace">rewrite</span> and reserved identifiers are
enabled only if the <span style="font-family:monospace">ssreflect</span> module has been required and if
<span style="font-family:monospace">SsrSyntax</span> has been imported. Thus a file that requires (without importing)
<span style="font-family:monospace">ssreflect</span> and imports <span style="font-family:monospace">SsrSyntax</span>, can be
required and imported without automatically enabling <span style="font-variant:small-caps">SSReflect</span>’s
extended rewrite syntax and reserved identifiers.
</li><li class="li-itemize">Some user notations (in particular, defining an infix ’;’) might
interfere with the "open term", parenthesis free, syntax of tactics
such as <span style="font-family:monospace">have</span>, <span style="font-family:monospace">set</span> and <span style="font-family:monospace">pose</span>.
</li><li class="li-itemize">The generalization of <span style="font-family:monospace">if</span> statements to non-Boolean
conditions is turned off by <span style="font-variant:small-caps">SSReflect</span>, because it is mostly subsumed by
<span style="font-family:monospace">Coercion</span> to <span style="font-family:monospace">bool</span> of the <span style="font-family:monospace">sum</span>XXX types (declared in
<span style="font-family:monospace">ssrfun.v</span>)
and the <span style="font-family:monospace">if</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">is</span> <span style="font-style:oblique">pattern</span> <span style="font-family:monospace">then</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">else</span> <span style="font-style:oblique">term</span> construct (see
<a href="#ssec%3Apatcond">11.3.2</a>). To use the generalized form, turn off the <span style="font-variant:small-caps">SSReflect</span>
Boolean <span style="font-family:monospace">if</span> notation using the command:
<div class="lstlisting">  Close Scope boolean_if_scope.</div></li><li class="li-itemize">The following two options can be unset to disable the
incompatible <span style="font-family:monospace">rewrite</span> syntax and allow
reserved identifiers to appear in scripts.
<div class="lstlisting">  Unset SsrRewrite.
  Unset SsrIdents.</div></li></ul>
<h2 id="sec526" class="section">11.3  Gallina extensions</h2>
<p>Small-scale reflection makes an extensive use of the programming
subset of Gallina, <span style="font-variant:small-caps">Coq</span>’s logical specification language. This subset
is quite suited to the description of functions on representations,
because it closely follows the well-established design of the ML
programming language. The <span style="font-variant:small-caps">SSReflect</span> extension provides three additions
to Gallina, for pattern assignment, pattern testing, and polymorphism;
these mitigate minor but annoying discrepancies between Gallina and ML.</p>
<h3 id="sec527" class="subsection">11.3.1  Pattern assignment</h3>
<p><a id="ssec:patass"></a>
The <span style="font-variant:small-caps">SSReflect</span> extension provides the following construct for
irrefutable pattern matching, that is, destructuring assignment:</p><p><span style="font-family:monospace">let: </span> <span style="font-style:oblique">pattern</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span><sub>2</sub></p><p>Note the colon ‘<span style="font-family:monospace">:</span>’ after the <span style="font-family:monospace">let</span> keyword, which avoids any
ambiguity with a function
definition or <span style="font-variant:small-caps">Coq</span>’s basic destructuring <span style="font-family:monospace">let</span>. The <span style="font-family:monospace">let:</span>
construct differs from the latter in that
</p><ul class="itemize"><li class="li-itemize">
The pattern can be nested (deep pattern matching), in
particular, this allows expression of the form:
<div class="lstlisting"> let: exist (x, y) p_xy := Hp in ...</div></li><li class="li-itemize">The destructured constructor is explicitly given in the
pattern, and is used for type inference, e.g.,
<div class="lstlisting">  Let f u := let: (m, n) := u in m + n.</div>using a colon <span style="font-family:monospace">let:</span>, infers <span style="font-family:monospace">f : nat * nat -&gt; nat</span>, whereas
<div class="lstlisting">  Let f u := let (m, n) := u in m + n.</div>with a usual <span style="font-family:monospace">let</span>, requires an extra type annotation.
</li></ul><p>
The <span style="font-family:monospace">let:</span> construct is just (more legible) notation for the primitive Gallina expression</p><div class="center"><div class="centered">
<span style="font-family:monospace">match</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">with</span> <span style="font-style:oblique">pattern</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span><sub>2</sub> <span style="font-family:monospace">end</span>
</div></div><p>The <span style="font-variant:small-caps">SSReflect</span> destructuring assignment supports all the dependent match
annotations; the full syntax is</p><div class="center"><div class="centered">
<span style="font-family:monospace">let:</span> <span style="font-style:oblique">pattern</span><sub>1</sub> <span style="font-family:monospace">as</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">pattern</span><sub>2</sub> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">return</span> <span style="font-style:oblique">term</span><sub>2</sub> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span><sub>3</sub>
</div></div><p>where <span style="font-style:oblique">pattern</span><sub>2</sub> is a <em>type</em> pattern and <span style="font-style:oblique">term</span><sub>1</sub> and
<span style="font-style:oblique">term</span><sub>2</sub> are types.</p><p>When the <span style="font-family:monospace">as</span> and <span style="font-family:monospace">return</span> are both present, then <span style="font-style:oblique">ident</span> is bound
in both the type <span style="font-style:oblique">term</span><sub>2</sub> and the expression <span style="font-style:oblique">term</span><sub>3</sub>;
variables in the optional type pattern <span style="font-style:oblique">pattern</span><sub>2</sub> are
bound only in the type <span style="font-style:oblique">term</span><sub>2</sub>, and other variables in <span style="font-style:oblique">pattern</span><sub>1</sub> are
bound only in the expression <span style="font-style:oblique">term</span><sub>3</sub>, however.</p>
<h3 id="sec528" class="subsection">11.3.2  Pattern conditional</h3>
<p><a id="ssec:patcond"></a>
The following construct can be used for a refutable pattern matching,
that is, pattern testing:</p><div class="center"><div class="centered">
<span style="font-family:monospace">if</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">is</span> <span style="font-style:oblique">pattern</span><sub>1</sub> <span style="font-family:monospace">then</span> <span style="font-style:oblique">term</span><sub>2</sub> <span style="font-family:monospace">else</span> <span style="font-style:oblique">term</span><sub>3</sub>
</div></div><p>Although this construct is not strictly ML (it does exits in variants
such as the pattern calculus or the ρ-calculus), it turns out to be
very convenient for writing functions on representations,
because most such functions manipulate simple datatypes such as Peano
integers, options,
lists, or binary trees, and the pattern conditional above is almost
always the right construct
for analyzing such simple types. For example, the <span style="font-family:monospace">null</span> and
<span style="font-family:monospace">all</span> list function(al)s can be defined as follows:
</p><div class="lstlisting">  Variable d: Set.
  Fixpoint null (s : list d) := if s is nil then true else false.
  Variable a : d -&gt; bool.
  Fixpoint all (s : list d) : bool :=
     if s is cons x s' then a x &amp;&amp; all s' else true.</div><p>The pattern conditional also provides a notation for destructuring
assignment with a refutable pattern, adapted to the pure functional
setting of Gallina, which lacks a <br>
<span style="font-family:monospace">Match_Failure</span> exception.</p><p>Like <span style="font-family:monospace">let:</span> above, the <span style="font-family:monospace">if</span>…<span style="font-family:monospace">is</span> construct is just (more legible)
notation for the primitive Gallina expression:</p><div class="center"><div class="centered">
<span style="font-family:monospace">match</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">with</span> <span style="font-style:oblique">pattern</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span><sub>2</sub> <span style="font-family:monospace">| _ =&gt;</span> <span style="font-style:oblique">term</span><sub>2</sub> <span style="font-family:monospace">end</span>
</div></div><p>Similarly, it will always be displayed as the expansion of this form
in terms of primitive <span style="font-family:monospace">match</span> expressions (where the default
expression <span style="font-style:oblique">term</span><sub>3</sub> may be replicated).</p><p>Explicit pattern testing also largely subsumes the generalization of
the <span style="font-family:monospace">if</span> construct to all binary datatypes; compare:</p><div class="center"><div class="centered">
<span style="font-family:monospace">if</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">is inl _ then</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">l</span></sub> <span style="font-family:monospace">else</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">r</span></sub>
</div></div><p>and:</p><div class="center"><div class="centered">
<span style="font-family:monospace">if</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">then</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">l</span></sub> <span style="font-family:monospace">else</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">r</span></sub>
</div></div><p>The latter appears to be marginally shorter, but it is quite
ambiguous, and indeed often
requires an explicit annotation term : <span style="font-family:monospace">{_}+{_}</span> to type-check,
which evens the character count.</p><p>Therefore, <span style="font-variant:small-caps">SSReflect</span> restricts by default the condition of a plain <span style="font-family:monospace">if</span>
construct to the standard <span style="font-family:monospace">bool</span> type; this avoids spurious type
annotations, e.g., in:
</p><div class="lstlisting">  Definition orb b1 b2 := if b1 then true else b2.</div><p>As pointed out in section <a href="#sec%3Acompat">11.2.2</a>, this restriction can be removed with
the command:
</p><div class="lstlisting">  Close Scope boolean_if_scope.</div><p>Like <span style="font-family:monospace">let:</span> above, the <span style="font-family:monospace">if</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">is</span> <span style="font-style:oblique">pattern</span>
<span style="font-family:monospace">else</span> <span style="font-style:oblique">term</span> construct
supports the dependent <span style="font-family:monospace">match</span> annotations:</p><div class="center"><div class="centered">
<span style="font-family:monospace">if</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">is</span> <span style="font-style:oblique">pattern</span><sub>1</sub> <span style="font-family:monospace">as</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">pattern</span><sub>2</sub> <span style="font-family:monospace">return</span> <span style="font-style:oblique">term</span><sub>2</sub> <span style="font-family:monospace">then</span> <span style="font-style:oblique">term</span><sub>3</sub> <span style="font-family:monospace">else</span> <span style="font-style:oblique">term</span><sub>4</sub>
</div></div><p>As in <span style="font-family:monospace">let:</span> the variable <span style="font-style:oblique">ident</span> (and those in
the type pattern <span style="font-style:oblique">pattern</span><sub>2</sub>) are bound in <span style="font-style:oblique">term</span><sub>2</sub>; <span style="font-style:oblique">ident</span> is
also bound in <span style="font-style:oblique">term</span><sub>3</sub> (but not in <span style="font-style:oblique">term</span><sub>4</sub>), while the
variables in <span style="font-style:oblique">pattern</span><sub>1</sub> are bound only in <span style="font-style:oblique">term</span><sub>3</sub>.</p><p>Another variant allows to treat the else case first:</p><div class="center"><div class="centered">
<span style="font-family:monospace">if</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">isn’t</span> <span style="font-style:oblique">pattern</span><sub>1</sub> <span style="font-family:monospace">then</span> <span style="font-style:oblique">term</span><sub>2</sub> <span style="font-family:monospace">else</span> <span style="font-style:oblique">term</span><sub>3</sub>
</div></div><p>Note that <span style="font-style:oblique">pattern</span><sub>1</sub> eventually binds variables in <span style="font-style:oblique">term</span><sub>3</sub>
and not <span style="font-style:oblique">term</span><sub>2</sub>.</p>
<h3 id="sec529" class="subsection">11.3.3  Parametric polymorphism</h3>
<p><a id="ssec:parampoly"></a></p><p>Unlike ML, polymorphism in core Gallina is explicit: the type
parameters of polymorphic functions must be declared explicitly, and
supplied at each point of use. However, <span style="font-variant:small-caps">Coq</span> provides two features
to suppress redundant parameters:
</p><ul class="itemize"><li class="li-itemize">
Sections are used to provide (possibly implicit) parameters for
a set of definitions.
</li><li class="li-itemize">Implicit arguments declarations are used to tell <span style="font-variant:small-caps">Coq</span> to use
type inference to deduce some parameters from the context at each
point of call.
</li></ul><p>
The combination of these features provides a fairly good emulation of ML-style
polymorphism, but unfortunately this emulation breaks down for
higher-order programming. Implicit arguments are indeed not inferred
at all points of use, but only at
points of call, leading to expressions such as
</p><div class="lstlisting">  Definition all_null (s : list T) := all (@null T) s.</div><p>Unfortunately, such higher-order expressions are quite frequent in
representation functions, especially those which use <span style="font-variant:small-caps">Coq</span>’s
<span style="font-family:monospace">Structure</span>s to emulate Haskell type classes.</p><p>Therefore, <span style="font-variant:small-caps">SSReflect</span> provides a variant of <span style="font-variant:small-caps">Coq</span>’s implicit argument
declaration, which causes <span style="font-variant:small-caps">Coq</span> to fill in some implicit parameters
at each point of use, e.g., the above definition can be written:
</p><div class="lstlisting">  Definition all_null (s : list d) := all null s.</div><p>Better yet, it can be omitted entirely, since <span style="font-family:monospace">all_null s</span> isn’t
much of an improvement over <span style="font-family:monospace">all null s</span>.</p><p>The syntax of the new declaration is</p><div class="center"><div class="centered">
<span style="font-family:monospace">Prenex Implicits</span> <span style="font-style:oblique">ident</span><sup>+</sup>.
</div></div><p>Let us denote <sub>1</sub> … <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub> the list of identifiers given to a
<span style="font-family:monospace">Prenex Implicits</span> command.
The command checks that each <span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> is the name of a functional
constant, whose implicit arguments are prenex, i.e., the first <span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub> &gt;
0 arguments of <span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> are implicit; then it assigns
<span style="font-family:monospace">Maximal Implicit</span> status to these arguments.</p><p>As these prenex implicit arguments are ubiquitous and have often large
display strings, it is strongly recommended to change the default
display settings of <span style="font-variant:small-caps">Coq</span> so that they are not printed (except after a
<span style="font-family:monospace">Set Printing All</span> command).
All <span style="font-variant:small-caps">SSReflect</span> library files thus start with the incantation
</p><div class="lstlisting">  Set Implicit Arguments.
  Unset Strict Implicit.
  Unset Printing Implicit Defensive.</div>
<h3 id="sec530" class="subsection">11.3.4  Anonymous arguments</h3>
<p>When in a definition, the type of a certain argument is mandatory, but
not its name, one usually use “arrow” abstractions for prenex
arguments, or the <span style="font-family:monospace">(_ : </span><span style="font-style:oblique">term</span><span style="font-family:monospace">)</span> syntax for inner arguments.
In <span style="font-variant:small-caps">SSReflect</span>, the latter can be replaced by the open syntax ‘<span style="font-family:monospace">of </span><span style="font-style:oblique">term</span>’
or (equivalently) ‘<span style="font-style:oblique">term</span>’, which are both syntactically
equivalent to a <span style="font-family:monospace">(_ : </span><span style="font-style:oblique">term</span><span style="font-family:monospace">)</span> expression.</p><p>For instance, the usual two-contrsuctor polymorphic type <span style="font-family:monospace">list</span>,
i.e. the one of the
standard <span style="font-family:monospace">List</span> library, can be defined by the following
declaration:
</p><div class="lstlisting">  Inductive list (A : Type) : Type := nil | cons of A &amp; list A.</div>
<h3 id="sec531" class="subsection">11.3.5  Wildcards</h3>
<p><a id="ssec:wild"></a></p><p>The terms passed as arguments
to <span style="font-variant:small-caps">SSReflect</span> tactics can contain <em>holes</em>, materialized by wildcards
<span style="font-family:monospace">_</span>.
Since <span style="font-variant:small-caps">SSReflect</span> allows a more powerful form of type inference for these
arguments, it enhances the possibilities of using such wildcards.
These holes are in particular used as a convenient shorthand for
abstractions, especially in local definitions or type expressions.</p><p>Wildcards may be interpreted as abstractions (see for example sections
<a href="#ssec%3Apose">11.4.1</a> and <a href="#ssec%3Astruct">11.6.6</a>), or their content can be
inferred from the whole
context of the goal (see for example section <a href="#ssec%3Aset">11.4.2</a>).
</p>
<h2 id="sec532" class="section">11.4  Definitions</h2>
<h3 id="sec533" class="subsection">11.4.1  Definitions</h3>
<p><a id="ssec:pose"></a>
<a id="hevea_default910"></a><a id="hevea_tactic237"></a>
<a id="hevea_default911"></a><a id="hevea_tactic238"></a>
<a id="hevea_default912"></a><a id="hevea_tactic239"></a></p><p>The <span style="font-family:monospace">pose</span> tactic allows to add a defined constant to a
proof context. <span style="font-variant:small-caps">SSReflect</span> generalizes this tactic in several ways.
In particular, the <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">pose</span> tactic supports <em>open syntax</em>:
the body of
the definition does not need surrounding parentheses. For instance:
</p><div class="lstlisting">  pose t := x + y.</div><p>is a valid tactic expression.</p><p>The <span style="font-family:monospace">pose</span> tactic is also improved for the
local definition of higher order terms.
Local definitions of functions can use the same syntax as
global ones. The tactic:
</p><div class="lstlisting">  pose f x y := x + y.</div><p>adds to the context the defined constant:
</p><div class="lstlisting">  f := fun x y : nat =&gt; x + y : nat -&gt; nat -&gt; nat</div><p>The <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">pose</span> tactic also supports (co)fixpoints,
by providing the local counterpart of the
<span style="font-family:monospace">Fixpoint f := </span>…<span style="font-family:monospace"> </span> and <span style="font-family:monospace">CoFixpoint f := </span>…<span style="font-family:monospace"> </span> constructs.
For instance, the following tactic:
</p><div class="lstlisting">  pose fix f (x y : nat) {struct x} : nat :=
      if x is S p then S (f p y) else 0.</div><p>defines a local fixpoint <span style="font-family:monospace">f</span>, which mimics the standard <span style="font-family:monospace">plus</span>
operation on natural numbers.</p><p>Similarly, local cofixpoints can be defined by a tactic of the form:
</p><div class="lstlisting">  pose cofix f (arg : T) ...</div><p>The possibility to include wildcards in the body of the definitions
offers a smooth
way of defining local abstractions. The type of “holes” is
guessed by type inference, and the holes are abstracted.
For instance the tactic:
</p><div class="lstlisting">  pose f := _ + 1.</div><p>is shorthand for:
</p><div class="lstlisting">  pose f n := n + 1.</div><p>When the local definition of a function involves both arguments and
holes, hole abstractions appear first. For instance, the
tactic:
</p><div class="lstlisting">  pose f x := x + _.</div><p>is shorthand for:
</p><div class="lstlisting">  pose f n x := x + n.</div><p>The interaction of the <span style="font-family:monospace">pose</span> tactic with the interpretation of
implicit arguments results in a powerful and concise syntax for local
definitions involving dependent types.
For instance, the tactic:
</p><div class="lstlisting">  pose f x y := (x, y).</div><p>adds to the context the local definition:
</p><div class="lstlisting">  pose f (Tx Ty : Type) (x : Tx) (y : Ty) := (x, y).</div><p>The generalization of wildcards makes the use of the <span style="font-family:monospace">pose</span> tactic
resemble ML-like definitions of polymorphic functions.</p>
<h3 id="sec534" class="subsection">11.4.2  Abbreviations</h3>
<p><a id="ssec:set"></a>
<a id="hevea_default913"></a><a id="hevea_tactic240"></a></p><p>The <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">set</span> tactic performs abbreviations: it introduces a
defined constant for a subterm appearing in the goal and/or in the
context.</p><p><span style="font-variant:small-caps">SSReflect</span> extends the <span style="font-family:monospace">set</span> tactic by supplying:
</p><ul class="itemize"><li class="li-itemize">
an open syntax, similarly to the <span style="font-family:monospace">pose</span> tactic;
</li><li class="li-itemize">a more aggressive matching algorithm;
</li><li class="li-itemize">an improved interpretation of wildcards, taking advantage of the
matching algorithm;
</li><li class="li-itemize">an improved occurrence selection mechanism allowing to abstract only
selected occurrences of a term.
</li></ul><p>The general syntax of this tactic is
</p><div class="center"><div class="centered">
<span style="font-family:monospace">set</span> <span style="font-style:oblique">ident</span> <span style="font-style:italic">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><sub>1</sub><span style="font-style:italic">]</span> <span style="font-family:monospace">:=</span> <span style="font-style:italic">[</span><span style="font-style:oblique">occ-switch</span><span style="font-style:italic">]</span> <span style="font-style:oblique">term</span><sub>2</sub>
</div></div><div class="center"><div class="centered">
<span style="font-style:oblique">occ-switch</span> ::= <span style="font-family:monospace">{</span>[<span style="font-family:monospace">+</span>|<span style="font-family:monospace">-</span>] <span style="font-style:oblique">natural</span><sup>*</sup> <span style="font-family:monospace">}</span>
</div></div><p>where:</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:oblique">ident</span> is a fresh identifier chosen by the user.
</li><li class="li-itemize"><span style="font-style:oblique">term</span><sub>1</sub> is
an optional type annotation. The type annotation <span style="font-style:oblique">term</span><sub>1</sub> can be
given in open syntax (no surrounding parentheses). If no <span style="font-style:oblique">occ-switch</span>
(described hereafter) is present, it is also
the case for <span style="font-style:oblique">term</span><sub>2</sub>.
On the other hand, in presence of <span style="font-style:oblique">occ-switch</span>, parentheses
surrounding <span style="font-style:oblique">term</span><sub>2</sub> are mandatory.
</li><li class="li-itemize">In the occurrence switch <span style="font-style:oblique">occ-switch</span>, if the first element
of the list is a <span style="font-style:oblique">natural</span>, this element should be a number, and not
an Ltac variable. The empty list <span style="font-family:monospace">{}</span> is not interpreted as a
valid occurrence switch.
</li></ul><p>The tactic:
</p><div class="lstlisting">  set t := f _.</div><p>transforms the goal <span style="font-family:monospace">f x + f x = f x</span> into <span style="font-family:monospace">t + t = t</span>, adding
<span style="font-family:monospace">t := f x</span> to the context, and the tactic:
</p><div class="lstlisting">  set t := {2}(f _).</div><p>transforms it into <span style="font-family:monospace">f x + t = f x</span>, adding <span style="font-family:monospace">t := f x</span> to the context.</p><p>The type annotation <span style="font-style:oblique">term</span><sub>1</sub> may
contain wildcards, which will be filled with the appropriate value by
the matching process.</p><p>The tactic first tries to find a subterm of the goal matching
<span style="font-style:oblique">term</span><sub>2</sub> (and its type <span style="font-style:oblique">term</span><sub>1</sub>),
and stops at the first subterm it finds. Then the occurrences
of this subterm selected by the optional <span style="font-style:oblique">occ-switch</span> are replaced
by <span style="font-style:oblique">ident</span> and a definition <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span> is added to
the context. If no <span style="font-style:oblique">occ-switch</span> is present, then all the
occurrences are abstracted.</p><h4 id="sec535" class="subsubsection">Matching</h4>
<p>The matching algorithm compares a pattern <span style="font-style:italic">term</span>
with a subterm of the goal by comparing their heads
and then pairwise unifying their arguments (modulo conversion). Head
symbols match under the following conditions:</p><ul class="itemize"><li class="li-itemize">
If the head of <span style="font-style:italic">term</span> is a constant, then it
should be syntactically equal to the head symbol of the subterm.
</li><li class="li-itemize">If this head is a projection of a canonical structure,
then canonical structure equations are used for the matching.
</li><li class="li-itemize">If the head of <span style="font-style:italic">term</span> is <em>not</em> a constant, the
subterm should have the same structure (λ abstraction,
<span style="font-family:monospace">let</span>…<span style="font-family:monospace">in</span> structure …).
</li><li class="li-itemize">If the head of <span style="font-style:italic">term</span> is a hole, the subterm should have
at least as many arguments as <span style="font-style:italic">term</span>. For instance the tactic:
<div class="lstlisting">  set t := _ x.</div>transforms the goal <code>x</code><code> + </code><code>y</code><code> = </code><code>z</code> into <span style="font-family:monospace">t y = z</span> and adds
<span style="font-family:monospace">t := plus x : nat -&gt; nat</span> to the context.</li><li class="li-itemize">In the special case where <span style="font-style:italic">term</span> is of the form
<span style="font-family:monospace">(let f := </span><span style="font-style:italic">t</span><sub>0</sub> <span style="font-family:monospace">in f) </span><span style="font-style:italic">t</span><sub>1</sub>… <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>,
then the pattern <span style="font-style:italic">term</span> is treated
as <span style="font-family:monospace">(_ </span><span style="font-style:italic">t</span><sub>1</sub>… <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span>. For each subterm in
the goal having the form (<span style="font-style:italic">A</span>  <span style="font-style:italic">u</span><sub>1</sub>… <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span>′</sub>) with <span style="font-style:italic">n</span>′ ≥ <span style="font-style:italic">n</span>, the
matching algorithm successively tries to find the largest
partial application (<span style="font-style:italic">A</span> <span style="font-style:italic">u</span><sub>1</sub>… <span style="font-style:italic">u</span><sub><span style="font-style:italic">i</span>′</sub>) convertible to the head
<span style="font-style:italic">t</span><sub>0</sub> of <span style="font-style:italic">term</span>. For instance the following tactic:
<div class="lstlisting">  set t := (let g y z := y.+1 + z in g) 2.</div>transforms the goal
<div class="lstlisting">  (let f x y z := x + y + z in f 1) 2 3 = 6.</div>into <span style="font-family:monospace">t 3 = 6</span> and adds the local definition of <span style="font-family:monospace">t</span> to the
context.
</li></ul><p>Moreover:
</p><ul class="itemize"><li class="li-itemize">
Multiple holes in <span style="font-style:italic">term</span> are treated as independent
placeholders. For instance, the tactic:
<div class="lstlisting">  set t := _ + _.</div>transforms the goal <span style="font-family:monospace">x + y = z</span> into <span style="font-family:monospace">t = z</span> and pushes
<span style="font-family:monospace">t := x + y : nat</span> in the context.
</li><li class="li-itemize">The type of the subterm matched should fit the type
(possibly casted by some type annotations) of the pattern
<span style="font-style:italic">term</span>.
</li><li class="li-itemize">The replacement of the subterm found by the instantiated pattern
should not capture variables, hence the following script:
<div class="lstlisting">  Goal forall x : nat, x + 1 = 0.
  set u := _ + 1.</div>raises an error message, since <span style="font-family:monospace">x</span> is bound in the goal.
</li><li class="li-itemize">Typeclass inference should fill in any residual hole, but
matching should never assign a value to a global existential variable.</li></ul><h4 id="sec536" class="subsubsection">Occurrence selection</h4>
<p><a id="sssec:occselect"></a></p><p><span style="font-variant:small-caps">SSReflect</span> provides a generic syntax for the selection of occurrences by
their position indexes. These <em>occurrence switches</em> are shared by
all
<span style="font-variant:small-caps">SSReflect</span> tactics which require control on subterm selection like rewriting,
generalization, …</p><p>An <em>occurrence switch</em> can be:
</p><ul class="itemize"><li class="li-itemize">
A list <span style="font-family:monospace">{</span> <span style="font-style:oblique">natural</span><sup>*</sup> <span style="font-family:monospace">}</span> of occurrences affected by the
tactic.
For instance, the tactic:
<div class="lstlisting">  set x := {1 3}(f 2).</div>transforms the goal <span style="font-family:monospace">f 2 + f 8 = f 2 + f 2</span> into
<span style="font-family:monospace">x + f 8 = f 2 + x</span>, and adds the abbreviation
<span style="font-family:monospace">x := f 2</span> in the
context. Notice that some occurrences of a
given term may be hidden to the user, for example because of a
notation. The vernacular <span style="font-family:monospace"><span style="color:#9900CC">Set </span></span><span style="font-family:monospace">
Printing All</span> command displays all
these hidden occurrences and should be used to find the correct
coding of the occurrences to be selected<sup><a id="text16" href="#note16">1</a></sup>. For instance, the
following script:
<div class="lstlisting">  Notation "a &lt; b":= (le (S a) b).
  Goal forall x y, x &lt; y -&gt; S x &lt; S y.
  intros x y; set t := S x.</div>generates the goal
<span style="font-family:monospace">t &lt;= y -&gt; t &lt; S y</span> since <span style="font-family:monospace">x &lt; y</span> is now a notation for
<span style="font-family:monospace">S x &lt;= y</span>.
</li><li class="li-itemize">A list <span style="font-family:monospace">{</span><span style="font-style:oblique">natural</span><sup>+</sup><span style="font-family:monospace">}</span>. This is equivalent to
<span style="font-family:monospace">{</span> <span style="font-style:oblique">natural</span><sup>+</sup> <span style="font-family:monospace">}</span> but the list should start with a number, and
not with an Ltac variable.
</li><li class="li-itemize">A list <span style="font-family:monospace">{</span><span style="font-style:oblique">natural</span><sup>*</sup><span style="font-family:monospace">}</span> of occurrences <em>not</em> to be
affected by the tactic. For instance, the tactic:
<div class="lstlisting">  set x := {-2}(f 2).</div>behaves like
<div class="lstlisting">  set x := {1 3}(f 2).</div>on the goal <code>f</code><code> 2 + </code><code>f</code><code> 8 = </code><code>f</code><code> 2 + </code><code>f</code><code> 2</code> which has three occurrences of
the the term <span style="font-family:monospace">f 2</span>
</li><li class="li-itemize">In particular, the switch <span style="font-family:monospace">{+}</span> selects <em>all</em> the
occurrences. This switch is useful to turn
off the default behavior of a tactic which automatically clears
some assumptions (see section <a href="#ssec%3Adischarge">11.5.3</a> for instance).
</li><li class="li-itemize">The switch <span style="font-family:monospace">{-}</span> imposes that <em>no</em> occurrences of the
term should be affected by the tactic. The tactic:
<div class="lstlisting">  set x := {-}(f 2).</div>leaves the goal unchanged and adds the definition <span style="font-family:monospace">x := f 2</span> to the
context. This kind of tactic may be used to take advantage of the
power of the matching algorithm in a local definition, instead of
copying large terms by hand.
</li></ul><p>It is important to remember that matching <em>precedes</em> occurrence
selection, hence the tactic:
</p><div class="lstlisting">  set a := {2}(_ + _).</div><p>transforms the goal <span style="font-family:monospace">x + y = x + y + z</span> into <span style="font-family:monospace">x + y = a + z</span>
and fails on the goal <br>
<span style="font-family:monospace">(x + y) + (z + z) = z + z</span> with the error message:
</p><div class="lstlisting">  User error: only 1 &lt; 2 occurrence of (x + y + (z + z))</div>
<h3 id="sec537" class="subsection">11.4.3  Localization</h3>
<p><a id="ssec:loc"></a></p><p>It is possible to define an abbreviation for a term appearing in the
context of a goal thanks to the <span style="font-family:monospace">in</span> tactical.</p><p>A tactic of the form:</p><div class="center"><div class="centered">
<span style="font-family:monospace">set x :=</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">fact</span><sub>1</sub><span style="font-family:monospace">...</span><span style="font-style:oblique">fact</span><sub><span style="font-style:italic">n</span></sub>.
</div></div><p>introduces a defined constant called <span style="font-family:monospace">x</span> in the context, and folds
it in the facts <span style="font-style:italic">fact</span><sub>1</sub> …<span style="font-style:italic"> fact</span><sub><span style="font-style:italic">n</span></sub>
The body of <span style="font-family:monospace">x</span> is the first subterm matching <span style="font-style:italic">term</span> in
<span style="font-style:italic">fact</span><sub>1</sub> …<span style="font-style:italic"> fact</span><sub><span style="font-style:italic">n</span></sub>.</p><p>A tactic of the form:</p><div class="center"><div class="centered">
<span style="font-family:monospace">set x :=</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">fact</span><sub>1</sub><span style="font-family:monospace">...</span><span style="font-style:oblique">fact</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">*.</span>
</div></div><p>matches <span style="font-style:oblique">term</span> and then folds <span style="font-family:monospace">x</span> similarly in
<span style="font-style:italic">fact</span><sub>1</sub> …<span style="font-style:italic"> fact</span><sub><span style="font-style:italic">n</span></sub>, but also folds <span style="font-family:monospace">x</span> in the goal.</p><p>A goal <code>x</code><code> + </code><code>t</code><code> = 4</code>, whose context contains <span style="font-family:monospace">Hx : x = 3</span>, is left
unchanged by the tactic:
</p><div class="lstlisting">  set z := 3 in Hx.</div><p>but the context is extended with the definition <span style="font-family:monospace">z := 3</span> and <span style="font-family:monospace">Hx</span> becomes
<span style="font-family:monospace">Hx : x = z</span>.
On the same goal and context, the tactic:
</p><div class="lstlisting">  set z := 3 in Hx *.</div><p>will moreover change the goal into <code>x</code><code> + </code><code>t</code><code> = </code><code>S</code><code> </code><code>z</code>. Indeed, remember
that <span style="font-family:monospace">4</span> is just a notation for <span style="font-family:monospace">(S 3)</span>.</p><p>The use of the <span style="font-family:monospace">in</span> tactical is not limited to the localization of
abbreviations: for a complete description of the <span style="font-family:monospace">in</span> tactical, see
section <a href="#ssec%3Aprofstack">11.5.1</a>.
</p>
<h2 id="sec538" class="section">11.5  Basic tactics</h2>
<p><a id="sec:book"></a></p><p>A sizable fraction of proof scripts consists of steps that do not
"prove" anything new, but instead perform menial bookkeeping tasks
such as selecting the names of constants and assumptions or splitting
conjuncts. Although they are logically trivial, bookkeeping steps are
extremely important because they define the structure of the data-flow
of a proof script. This is especially true for reflection-based
proofs, which often involve large numbers of constants and
assumptions. Good bookkeeping consists in always explicitly declaring
(i.e., naming) all new constants and assumptions in the script, and
systematically pruning irrelevant constants and assumptions in the
context. This is essential in the context of an interactive
development environment (IDE), because it facilitates navigating the
proof, allowing to instantly "jump back" to the point at which a
questionable assumption was added, and to find relevant assumptions by
browsing the pruned context. While novice or casual <span style="font-variant:small-caps">Coq</span> users may
find the automatic name selection feature convenient, the usage of
such a feature severely undermines the readability and maintainability
of proof scripts, much like automatic variable declaration in programming
languages. The <span style="font-variant:small-caps">SSReflect</span> tactics are therefore designed to support
precise bookkeeping and to eliminate name generation heuristics.
The bookkeeping features of <span style="font-variant:small-caps">SSReflect</span> are implemented as tacticals (or
pseudo-tacticals), shared across most <span style="font-variant:small-caps">SSReflect</span> tactics, and thus form
the foundation of the <span style="font-variant:small-caps">SSReflect</span> proof language.</p>
<h3 id="sec539" class="subsection">11.5.1  Bookkeeping</h3>
<p><a id="ssec:profstack"></a>
<a id="hevea_default914"></a><a id="hevea_tactic241"></a>
<a id="hevea_default915"></a><a id="hevea_tactic242"></a>
<a id="hevea_default916"></a><a id="hevea_tactic243"></a>
<a id="hevea_default917"></a><a id="hevea_tactic244"></a></p><p>During the course of a proof <span style="font-variant:small-caps">Coq</span> always present the user with
a <em>sequent</em> whose general form is
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:italic">T</span><sub><span style="font-style:italic">i</span></sub> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >…</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">d</span><sub><span style="font-style:italic">j</span></sub> <span style="font-family:monospace">:=</span> <span style="font-style:italic">e</span><sub><span style="font-style:italic">j</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:italic">T</span><sub><span style="font-style:italic">j</span></sub> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >…</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">F</span><sub><span style="font-style:italic">k</span></sub> <span style="font-family:monospace">:</span> <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >… </td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">forall</span> <span style="font-family:monospace">(</span><span style="font-style:italic">x</span><sub>ℓ</sub> <span style="font-family:monospace">:</span> <span style="font-style:italic">T</span><sub>ℓ</sub><span style="font-family:monospace">)</span> …,</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">let</span> <span style="font-style:italic">y</span><sub><span style="font-style:italic">m</span></sub> <span style="font-family:monospace">:=</span> <span style="font-style:italic">b</span><sub><span style="font-style:italic">m</span></sub> <span style="font-family:monospace">in</span> … <span style="font-family:monospace">in</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">-&gt;</span> … <span style="font-family:monospace">-&gt;</span> <span style="font-style:italic">C</span>
</td></tr>
</table></td></tr>
</table><p>
The <em>goal</em> to be proved appears below the double line; above the line is
the <em>context</em> of the sequent, a set of declarations of
<em>constants</em> <span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub>, <em>defined constants</em> <span style="font-style:italic">d</span><sub><span style="font-style:italic">i</span></sub>, and
<em>facts</em> <span style="font-style:italic">F</span><sub><span style="font-style:italic">k</span></sub> that can be used to prove the goal (usually, <span style="font-style:italic">T</span><sub><span style="font-style:italic">i</span></sub>,
<span style="font-style:italic">T</span><sub><span style="font-style:italic">j</span></sub> : <span style="font-family:monospace">Type</span> and <span style="font-style:italic">P</span><sub><span style="font-style:italic">k</span></sub> : <span style="font-family:monospace">Prop</span>). The various kinds of
declarations can come in any order. The top part of the context
consists of declarations produced by the <span style="font-family:monospace">Section</span> commands
<span style="font-family:monospace">Variable</span>, <span style="font-family:monospace">Let</span>, and <span style="font-family:monospace">Hypothesis</span>. This <em>section context</em>
is never affected by the <span style="font-variant:small-caps">SSReflect</span> tactics: they only operate on
the lower part — the <em>proof context</em>.
As in the figure above, the goal often decomposes into a series of
(universally) quantified <em>variables</em>
<span style="font-family:monospace">(</span><span style="font-style:italic">x</span><sub>ℓ</sub> <span style="font-family:monospace">:</span> <span style="font-style:italic">T</span><sub>ℓ</sub><span style="font-family:monospace">)</span>, local <em>definitions</em>
<span style="font-family:monospace">let</span> <span style="font-style:italic">y</span><sub><span style="font-style:italic">m</span></sub> <span style="font-family:monospace">:=</span> <span style="font-style:italic">b</span><sub><span style="font-style:italic">m</span></sub> <span style="font-family:monospace">in</span>, and <em>assumptions</em>
<span style="font-style:italic">P</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">-&gt;</span>, and a <em>conclusion</em> <span style="font-style:italic">C</span> (as in the context, variables,
definitions, and assumptions can appear in any order). The conclusion
is what actually needs to be proved — the rest of the goal can be
seen as a part of the proof context that happens to be “below the line”.</p><p>However, although they are logically equivalent, there are fundamental
differences between constants and facts on the one hand, and variables
and assumptions on the others. Constants and facts are
<em>unordered</em>, but <em>named</em> explicitly in the proof text;
variables and assumptions are <em>ordered</em>, but <em>unnamed</em>: the
display names of variables may change at any time because of
α-conversion.</p><p>Similarly, basic deductive steps such as <span style="font-family:monospace">apply</span> can only operate on
the goal because the Gallina terms that control their action (e.g.,
the type of the lemma used by <span style="font-family:monospace">apply</span>) only provide unnamed bound
variables.<sup><a id="text17" href="#note17">2</a></sup> Since the proof
script can only refer directly to the context, it must constantly
shift declarations from the goal to the context and conversely in
between deductive steps.</p><p>In <span style="font-variant:small-caps">SSReflect</span> these moves are performed by two <em>tacticals</em> ‘<span style="font-family:monospace">=&gt;</span>’
and ‘<span style="font-family:monospace">:</span>’, so that the bookkeeping required by a deductive step can
be directly associated to that step, and that tactics in an <span style="font-variant:small-caps">SSReflect</span>
script correspond to actual logical steps in the proof rather than
merely shuffle facts. Still, some isolated bookkeeping is unavoidable,
such as naming variables and assumptions at the beginning of a proof.
<span style="font-variant:small-caps">SSReflect</span> provides a specific <span style="font-family:monospace">move</span> tactic for this purpose.</p><p>Now <span style="font-family:monospace">move</span> does essentially nothing: it is mostly a placeholder for
‘<span style="font-family:monospace">=&gt;</span>’ and ‘<span style="font-family:monospace">:</span>’. The ‘<span style="font-family:monospace">=&gt;</span>’ tactical moves variables, local
definitions, and assumptions to the context, while the ‘<span style="font-family:monospace">:</span>’
tactical moves facts and constants to the goal. For example, the proof
of<sup><a id="text18" href="#note18">3</a></sup>
</p><div class="lstlisting">  Lemma subnK : forall m n, n &lt;= m -&gt; m - n + n = m.</div><p>might start with
</p><div class="lstlisting">  move=&gt; m n le_n_m.</div><p>where <span style="font-family:monospace">move</span> does nothing, but <code>=&gt; </code><code>m</code><code> </code><code>n</code><code> </code><code>le_m_n</code> changes the
variables and assumption of the goal in the constants <span style="font-family:monospace">m n : nat</span>
and the fact <code>le_n_m</code><code> : </code><code>n</code><code> &lt;= </code><code>m</code>, thus exposing the conclusion<br>
 <span style="font-family:monospace">m - n + n = m</span>. </p><p>The ‘<span style="font-family:monospace">:</span>’ tactical is the converse of ‘<span style="font-family:monospace">=&gt;</span>’: it removes facts
and constants from the context by turning them into variables and assumptions.
Thus
</p><div class="lstlisting">  move: m le_n_m.</div><p>turns back <span style="font-family:monospace">m</span> and <code>le_m_n</code> into a variable and an assumption, removing
them from the proof context, and changing the goal to
</p><div class="lstlisting">  forall m, n &lt;= m -&gt; m - n + n = m.</div><p>which can be proved by induction on <span style="font-family:monospace">n</span> using <span style="font-family:monospace">elim: n</span>.</p><p>Because they are tacticals, ‘<span style="font-family:monospace">:</span>’ and ‘<span style="font-family:monospace">=&gt;</span>’ can be combined, as in
</p><div class="lstlisting">  move: m le_n_m =&gt; p le_n_p.</div><p>simultaneously renames <code>m</code> and <code>le_m_n</code> into <code>p</code> and <code>le_n_p</code>,
respectively, by first turning them into unnamed variables, then
turning these variables back into constants and facts.</p><p>Furthermore, <span style="font-variant:small-caps">SSReflect</span> redefines the basic <span style="font-variant:small-caps">Coq</span> tactics <span style="font-family:monospace">case</span>,
<span style="font-family:monospace">elim</span>, and <span style="font-family:monospace">apply</span> so that they can take better advantage of
’<span style="font-family:monospace">:</span>’ and ‘<span style="font-family:monospace">=&gt;</span>’. In there <span style="font-variant:small-caps">SSReflect</span> variants, these tactic operate
on the first variable or constant of the goal and they do not use or
change the proof context. The ‘<span style="font-family:monospace">:</span>’ tactical is used to operate on
an element in the context. For instance the proof of <span style="font-family:monospace">subnK</span> could
continue with
</p><div class="lstlisting">  elim: n.</div><p>instead of <span style="font-family:monospace">elim n</span>; this has the advantage of
removing <span style="font-family:monospace">n</span> from the context. Better yet, this <span style="font-family:monospace">elim</span> can be combined
with previous <span style="font-family:monospace">move</span> and with the branching version of the <span style="font-family:monospace">=&gt;</span> tactical
(described in <a href="#ssec%3Aintro">11.5.4</a>),
to encapsulate the inductive step in a single command:
</p><div class="lstlisting">  elim: n m le_n_m =&gt; [|n IHn] m =&gt; [_ | lt_n_m].</div><p>which breaks down the proof into two subgoals,
</p><div class="lstlisting">  m - 0 + 0 = m</div><p>given <span style="font-family:monospace">m : nat</span>, and
</p><div class="lstlisting">  m - S n + S n = m</div><p>given <span style="font-family:monospace">m n : nat</span>, <code>lt_n_m</code><code> : </code><code>S</code><code> </code><code>n</code><code> &lt;= </code><code>m</code>, and
</p><div class="lstlisting">  IHn : forall m, n &lt;= m -&gt; m - n + n = m.</div><p>The ’<span style="font-family:monospace">:</span>’ and ‘<span style="font-family:monospace">=&gt;</span>’ tacticals can be explained very simply
if one views the goal as a stack of variables and assumptions piled
on a conclusion:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:oblique">tactic</span> <span style="font-family:monospace">:</span> <span style="font-style:italic">a</span> <span style="font-style:italic">b</span> <span style="font-style:italic">c</span> pushes the context constants <span style="font-style:italic">a</span>, <span style="font-style:italic">b</span>, <span style="font-style:italic">c</span>
as goal variables <em>before</em> performing <span style="font-style:oblique">tactic</span>.
</li><li class="li-itemize"><span style="font-style:oblique">tactic</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:italic">a</span> <span style="font-style:italic">b</span> <span style="font-style:italic">c</span> pops the top three goal variables as
context constants <span style="font-style:italic">a</span>, <span style="font-style:italic">b</span>, <span style="font-style:italic">c</span>, <em>after</em> <span style="font-style:oblique">tactic</span>
has been performed.
</li></ul><p>
These pushes and pops do not need to balance out as in the examples above,
so
</p><div class="lstlisting">  move: m le_n_m =&gt; p.</div><p>would rename <span style="font-family:monospace">m</span> into <span style="font-family:monospace">p</span>, but leave an extra assumption <span style="font-family:monospace">n &lt;= p</span>
in the goal.</p><p>Basic tactics like <span style="font-family:monospace">apply</span> and <span style="font-family:monospace">elim</span> can also be used without the
’<span style="font-family:monospace">:</span>’ tactical: for example we can directly start a proof of <span style="font-family:monospace">subnK</span>
by induction on the top variable <span style="font-family:monospace">m</span> with
</p><div class="lstlisting">  elim=&gt; [|m IHm] n le_n.</div><p>The general form of the localization tactical <span style="font-family:monospace">in</span> is also best
explained in terms of the goal stack:</p><div class="center"><div class="centered">
<span style="font-style:oblique">tactic</span> <span style="font-family:monospace">in a H1 H2 *.</span>
</div></div><p>is basically equivalent to</p><div class="center"><div class="centered">
<span style="font-family:monospace">move: a H1 H2;</span> <span style="font-style:oblique">tactic</span> <span style="font-family:monospace">=&gt; a H1 H2.</span>
</div></div><p>with two differences: the <span style="font-family:monospace">in</span> tactical will preserve the body of <span style="font-family:monospace">a</span> if
<span style="font-family:monospace">a</span> is a defined constant, and if the ‘<span style="font-family:monospace">*</span>’ is omitted it
will use a temporary abbreviation to hide the statement of the goal
from <span style="font-family:monospace">/*tactic*/</span>.</p><p>The general form of the <span style="font-family:monospace">in</span> tactical can be used directly with
the <span style="font-family:monospace">move</span>, <span style="font-family:monospace">case</span> and <span style="font-family:monospace">elim</span> tactics, so that one can write
</p><div class="lstlisting">  elim: n =&gt; [|n IHn] in m le_n_m *.</div><p>instead of
</p><div class="lstlisting">  elim: n m le_n_m =&gt; [|n IHn] m le_n_m.</div><p>This is quite useful for inductive proofs that involve many facts.</p><p>See section <a href="#ssec%3Agloc">11.6.5</a> for the general syntax and presentation
of the <span style="font-family:monospace">in</span> tactical.</p>
<h3 id="sec540" class="subsection">11.5.2  The defective tactics</h3>
<p><a id="ssec:basictac"></a></p><p>In this section we briefly present the three basic tactics performing
context manipulations and the main backward chaining tool.</p><h4 id="sec541" class="subsubsection">The <span style="font-family:monospace">move</span> tactic.</h4>
<p><a id="sssec:move"></a>
<a id="hevea_default918"></a><a id="hevea_tactic245"></a></p><p>The <span style="font-family:monospace">move</span> tactic, in its
defective form, behaves like the primitive <span style="font-family:monospace">hnf</span> <span style="font-variant:small-caps">Coq</span> tactic. For
example, such a defective:
</p><div class="lstlisting">  move.</div><p>exposes the first assumption in the goal, i.e. its changes the goal
<span style="font-family:monospace">False</span> into <span style="font-family:monospace">False -&gt; False</span>.</p><p>More precisely, the <span style="font-family:monospace">move</span> tactic inspects the goal and does nothing
(<span style="font-family:monospace">idtac</span>) if an introduction step is possible, i.e. if the
goal is a product or a <span style="font-family:monospace">let</span>…<span style="font-family:monospace">in</span>, and performs <span style="font-family:monospace">hnf</span>
otherwise.</p><p>Of course this tactic is most often used in combination with the
bookkeeping tacticals (see section <a href="#ssec%3Aintro">11.5.4</a> and
<a href="#ssec%3Adischarge">11.5.3</a>). These combinations mostly subsume the <span style="font-family:monospace">intros</span>,
<span style="font-family:monospace">generalize</span>, <span style="font-family:monospace">revert</span>, <span style="font-family:monospace">rename</span>, <span style="font-family:monospace">clear</span> and
<span style="color:#00197F"><span style="font-family:monospace">pattern</span></span> tactics.</p><h4 id="sec542" class="subsubsection">The <span style="font-family:monospace">case</span> tactic.</h4>
<p>
<a id="hevea_default919"></a><a id="hevea_tactic246"></a></p><p>The <span style="font-family:monospace">case</span> tactic performs
<em>primitive case analysis</em> on (co)inductive types; specifically,
it destructs the top variable or assumption of the goal,
exposing its constructor(s) and its arguments, as well as setting the value
of its type family indices if it belongs to a type family
(see section <a href="#ssec%3Atypefam">11.5.6</a>).</p><p>The <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">case</span> tactic has a special behavior on
equalities.
If the top assumption of the goal is an equality, the <span style="font-family:monospace">case</span> tactic
“destructs” it as a set of equalities between the constructor
arguments of its left and right hand sides, as per the
tactic <span style="font-family:monospace">injection</span>.
For example, <span style="font-family:monospace">case</span> changes the goal
</p><div class="lstlisting">  (x, y) = (1, 2) -&gt; G.</div><p>into
</p><div class="lstlisting">  x = 1 -&gt; y = 2 -&gt; G.</div><p>Note also that the case of <span style="font-variant:small-caps">SSReflect</span> performs <span style="font-family:monospace">False</span>
elimination, even if no branch is generated by this case operation.
Hence the command:
</p><div class="lstlisting">  case.</div><p>on a goal of the form <span style="font-family:monospace">False -&gt; G</span> will succeed and prove the goal.</p><h4 id="sec543" class="subsubsection">The <span style="font-family:monospace">elim</span> tactic.</h4>
<p> 
<a id="hevea_default920"></a><a id="hevea_tactic247"></a></p><p>The <span style="font-family:monospace">elim</span> tactic performs
inductive elimination on inductive types.
The defective:
</p><div class="lstlisting">  elim.</div><p>tactic performs inductive elimination on a goal whose top assumption
has an inductive type. For example on goal of the form:
</p><div class="lstlisting">  forall n : nat, m &lt;= n</div><p>in a context containing <span style="font-family:monospace">m : nat</span>, the
</p><div class="lstlisting">  elim.</div><p>tactic produces two goals,
</p><div class="lstlisting">  m &lt;=  0</div><p>on one hand and
</p><div class="lstlisting">  forall n : nat, m &lt;= n -&gt; m &lt;= S n</div><p>on the other hand.</p><h4 id="sec544" class="subsubsection">The <span style="font-family:monospace">apply</span> tactic.</h4>
<p><a id="sssec:apply"></a>
<a id="hevea_default921"></a><a id="hevea_tactic248"></a></p><p>The <span style="font-family:monospace">apply</span> tactic is the main
backward chaining tactic of the proof system. It takes as argument any
<span style="font-family:monospace">/*term*/</span> and applies it to the goal.
Assumptions in the type of <span style="font-family:monospace">/*term*/</span> that don’t directly match the
goal may generate one or more subgoals.</p><p>In fact the <span style="font-variant:small-caps">SSReflect</span> tactic:
</p><div class="lstlisting">  apply.</div><p>is a synonym for:
</p><div class="lstlisting">  intro top; first [refine top | refine (top _) |  refine (top _ _) | ...]; clear top.</div><p>where <span style="font-family:monospace">top</span> is fresh name, and the sequence of <span style="font-family:monospace">refine</span> tactics
tries to catch the appropriate number of wildcards to be inserted.
Note that this use of the <span style="font-family:monospace">refine</span> tactic implies that the tactic
tries to match the goal up to expansion of
constants and evaluation of subterms.</p><p><span style="font-variant:small-caps">SSReflect</span>’s <span style="font-family:monospace">apply</span> has a special behaviour on goals containing
existential metavariables of sort <span style="font-family:monospace">Prop</span>. Consider the
following example:
</p><div class="lstlisting">Goal (forall y, 1 &lt; y -&gt; y &lt; 2 -&gt; exists x : { n | n &lt; 3 }, proj1_sig x &gt; 0).
move=&gt; y y_gt1 y_lt2; apply: (ex_intro _ (exist _ y _)).
  by apply: gt_trans _ y_lt2.
by move=&gt; y_lt3; apply: lt_trans y_gt1.</div><p>Note that the last <span style="font-family:monospace">_</span> of the tactic <span style="font-family:monospace">apply: (ex_intro _ (exist _ y _))</span>
represents a proof that <span style="font-family:monospace">y &lt; 3</span>. Instead of generating the following
goal
</p><div class="lstlisting">   0 &lt;  (n:=3) (m:=y) ?54</div><p>the system tries to prove <span style="font-family:monospace">y &lt; 3</span> calling the <span style="font-family:monospace">trivial</span>
tactic. If it succeeds, let’s say because the context contains
<span style="font-family:monospace">H : y &lt; 3</span>, then the system generates the following goal:
</p><div class="lstlisting">   0 &lt; proj1_sig (exist (fun n =&gt; n &lt; 3) y H</div><p>Otherwise the missing proof is considered to be irrelevant, and
is thus discharged generating the following goals:
</p><div class="lstlisting">   y &lt; 3
   forall H : y &lt; 3, proj1_sig (exist (fun n =&gt; n &lt; 3) y H)</div><p>Last, the user can replace the <span style="font-family:monospace">trivial</span> tactic by defining
an Ltac expression named <span style="font-family:monospace">ssrautoprop</span>.</p>
<h3 id="sec545" class="subsection">11.5.3  Discharge</h3>
<p><a id="ssec:discharge"></a>
<a id="hevea_default922"></a><a id="hevea_tactic249"></a></p><p>The general syntax of the discharging tactical ‘<span style="font-family:monospace">:</span>’ is:
</p><div class="center"><div class="centered">
	<span style="font-style:oblique">tactic</span> <span style="font-style:italic">[</span><span style="font-style:oblique">ident</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">d-item</span><sub>1</sub> … <span style="font-style:oblique">d-item</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">[</span><span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span>
</div></div><p>
where <span style="font-style:italic">n</span> &gt; 0, and <span style="font-style:oblique">d-item</span> and <span style="font-style:oblique">clear-switch</span> are defined as



</p><blockquote class="table"><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div><div class="center"><div class="centered"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">d-item</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">[</span><span style="font-style:oblique">occ-switch</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span> <span style="font-style:oblique">term</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">clear-switch</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">{</span> <span style="font-style:oblique">ident</span><sub>1</sub>  …  <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub> <span style="font-family:monospace">}</span>
</td></tr>
</table>

</div></div><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div></blockquote><p>
with the following requirements:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:oblique">tactic</span> must be one of the four basic tactics described
in <a href="#ssec%3Abasictac">11.5.2</a>, i.e., <span style="font-family:monospace">move</span>, <span style="font-family:monospace">case</span>, <span style="font-family:monospace">elim</span> or <span style="font-family:monospace">apply</span>,
the <span style="font-family:monospace">exact</span> tactic (section <a href="#ssec%3Atermin">11.6.2</a>),
the <span style="font-family:monospace">congr</span> tactic (section <a href="#ssec%3Acongr">11.7.4</a>), or the application
of the <em>view</em> tactical ‘<span style="font-family:monospace">/</span>’ (section <a href="#ssec%3Aassumpinterp">11.9.2</a>)
to one of <span style="font-family:monospace">move</span>, <span style="font-family:monospace">case</span>, or <span style="font-family:monospace">elim</span>.
</li><li class="li-itemize">The optional <span style="font-style:oblique">ident</span> specifies <em>equation generation</em>
(section <a href="#ssec%3Aequations">11.5.5</a>), and is only allowed if <span style="font-style:oblique">tactic</span>
is <span style="font-family:monospace">move</span>, <span style="font-family:monospace">case</span> or <span style="font-family:monospace">elim</span>, or the application of the
view tactical ‘<span style="font-family:monospace">/</span>’ (section <a href="#ssec%3Aassumpinterp">11.9.2</a>)
to <span style="font-family:monospace">case</span> or <span style="font-family:monospace">elim</span>.
</li><li class="li-itemize">An <span style="font-style:oblique">occ-switch</span> selects occurrences of <span style="font-style:oblique">term</span>,
as in <a href="#sssec%3Aoccselect">11.4.2</a>; <span style="font-style:oblique">occ-switch</span> is not allowed if
<span style="font-style:oblique">tactic</span> is <span style="font-family:monospace">apply</span> or <span style="font-family:monospace">exact</span>.
</li><li class="li-itemize">A clear item <span style="font-style:oblique">clear-switch</span> specifies facts and constants to be
deleted from the proof context (as per the <span style="font-family:monospace">clear</span> tactic).
</li></ul><p>
The ‘<span style="font-family:monospace">:</span>’ tactical first <em>discharges</em> all the <span style="font-style:oblique">d-item</span>s,
right to left, and then performs <span style="font-style:oblique">tactic</span>, i.e., for each <span style="font-style:oblique">d-item</span>,
starting with <span style="font-style:oblique">d-item</span><sub><span style="font-style:italic">n</span></sub>:
</p><ol class="enumerate" type=1><li class="li-enumerate">
The <span style="font-variant:small-caps">SSReflect</span> matching algorithm described in section <a href="#ssec%3Aset">11.4.2</a>
is used to find occurrences of <span style="font-style:oblique">term</span> in the goal,
after filling any holes ‘<span style="font-family:monospace">_</span>’ in <span style="font-style:oblique">term</span>; however if <span style="font-style:oblique">tactic</span>
is <span style="font-family:monospace">apply</span> or <span style="font-family:monospace">exact</span> a different matching algorithm,
described below, is used
<sup><a id="text19" href="#note19">4</a></sup>.
</li><li class="li-enumerate"> <a id="enum:gen"></a> These occurrences are replaced by a new
variable; in particular,
if <span style="font-style:oblique">term</span> is a fact, this adds an assumption to the goal.
</li><li class="li-enumerate"> <a id="enum:clr"></a> If <span style="font-style:oblique">term</span> is <em>exactly</em> the name of a constant
or fact in the proof context, it is deleted from the context,
unless there is an <span style="font-style:oblique">occ-switch</span>.
</li></ol><p>
Finally, <span style="font-style:oblique">tactic</span> is performed just after <span style="font-style:oblique">d-item</span><sub>1</sub> has been
generalized —
that is, between steps <a href="#enum%3Agen">2</a> and <a href="#enum%3Aclr">3</a> for <span style="font-style:oblique">d-item</span><sub>1</sub>.
The names listed in the final <span style="font-style:oblique">clear-switch</span> (if it is present)
are cleared first, before <span style="font-style:oblique">d-item</span><sub><span style="font-style:italic">n</span></sub> is discharged.</p><p>Switches affect the discharging of a <span style="font-style:oblique">d-item</span> as follows:
</p><ul class="itemize"><li class="li-itemize">
An <span style="font-style:oblique">occ-switch</span> restricts generalization (step <a href="#enum%3Agen">2</a>)
to a specific subset of the occurrences of <span style="font-style:oblique">term</span>, as per
<a href="#sssec%3Aoccselect">11.4.2</a>, and prevents clearing (step <a href="#enum%3Aclr">3</a>).
</li><li class="li-itemize">All the names specified by a <span style="font-style:oblique">clear-switch</span> are deleted from the
context in step <a href="#enum%3Aclr">3</a>, possibly in addition to <span style="font-style:oblique">term</span>.
</li></ul><p>
For example, the tactic:
</p><div class="lstlisting">  move: n {2}n (refl_equal n).</div><ul class="itemize"><li class="li-itemize">
first generalizes <span style="font-family:monospace">(refl_equal n : n = n)</span>;
</li><li class="li-itemize">then generalizes the second occurrence of <span style="font-family:monospace">n</span>.
</li><li class="li-itemize">finally generalizes all the other occurrences of <span style="font-family:monospace">n</span>,
and clears <span style="font-family:monospace">n</span> from the proof context
(assuming <span style="font-family:monospace">n</span> is a proof constant).
</li></ul><p>
Therefore this tactic changes any goal <span style="font-family:monospace">G</span> into
</p><div class="lstlisting"> forall n n0 : nat, n = n0 -&gt; G.</div><p>where the name <span style="font-family:monospace">n0</span> is picked by the <span style="font-variant:small-caps">Coq</span> display function,
and assuming <span style="font-family:monospace">n</span> appeared only in <span style="font-family:monospace">G</span>.</p><p>Finally, note that a discharge operation generalizes defined constants
as variables, and not as local definitions. To override this behavior,
prefix the name of the local definition with a <span style="font-family:monospace">@</span>,
like in <span style="font-family:monospace">move: @n</span>.</p><p>This is in contrast with the behavior of the <span style="font-family:monospace">in</span> tactical (see section
<a href="#ssec%3Agloc">11.6.5</a>), which preserves local definitions by default.</p><h4 id="sec546" class="subsubsection">Clear rules</h4>
<p>The clear step will fail if <span style="font-style:oblique">term</span> is a proof constant that
appears in other facts; in that case either the facts should be
cleared explicitly with a <span style="font-style:oblique">clear-switch</span>, or the clear step should be
disabled. The latter can be done by adding an <span style="font-style:oblique">occ-switch</span> or simply by
putting parentheses around <span style="font-style:oblique">term</span>: both
</p><div class="lstlisting">  move: (n).</div><p>and
</p><div class="lstlisting">  move: {+}n.</div><p>generalize <span style="font-family:monospace">n</span> without clearing <span style="font-family:monospace">n</span> from the proof context.</p><p>The clear step will also fail if the <span style="font-style:oblique">clear-switch</span> contains a
<span style="font-style:oblique">ident</span> that is not in the <em>proof</em> context.
Note that <span style="font-variant:small-caps">SSReflect</span> never clears a section constant.</p><p>If <span style="font-style:oblique">tactic</span> is <span style="font-family:monospace">move</span> or <span style="font-family:monospace">case</span> and an equation <span style="font-style:oblique">ident</span> is given,
then clear (step <a href="#enum%3Aclr">3</a>) for <span style="font-style:oblique">d-item</span><sub>1</sub> is suppressed
(see section <a href="#ssec%3Aequations">11.5.5</a>).</p><h4 id="sec547" class="subsubsection">Matching for <span style="font-family:monospace">apply</span> and <span style="font-family:monospace">exact</span></h4>
<p><a id="sss:strongapply"></a></p><p>The matching algorithm for <span style="font-style:oblique">d-item</span>s of the <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">apply</span> and
<span style="font-family:monospace">exact</span> tactics
exploits the type of <span style="font-style:oblique">d-item</span><sub>1</sub> to interpret
wildcards in the other <span style="font-style:oblique">d-item</span> and to determine which occurrences of
these should be generalized.
Therefore, <span style="font-style:oblique">occur switch</span>es are not needed for <span style="font-family:monospace">apply</span> and <span style="font-family:monospace">exact</span>.</p><p>Indeed, the <span style="font-variant:small-caps">SSReflect</span> tactic <span style="font-family:monospace">apply: H x</span> is equivalent to
</p><div class="lstlisting">  refine (@H _ ... _ x); clear H x</div><p>with an appropriate number of wildcards between <span style="font-family:monospace">H</span> and <span style="font-family:monospace">x</span>.</p><p>Note that this means that matching for <span style="font-family:monospace">apply</span> and <span style="font-family:monospace">exact</span> has
much more context to interpret wildcards; in particular it can accommodate
the ‘<span style="font-family:monospace">_</span>’ <span style="font-style:oblique">d-item</span>, which would always be rejected after ‘<span style="font-family:monospace">move:</span>’.
For example, the tactic
</p><div class="lstlisting">  apply: trans_equal (Hfg _) _.</div><p>transforms the goal <span style="font-family:monospace">f a = g b</span>, whose context contains
<span style="font-family:monospace">(Hfg : forall x, f x = g x)</span>, into <span style="font-family:monospace">g a = g b</span>.
This tactic is equivalent (see section <a href="#ssec%3Aprofstack">11.5.1</a>) to:
</p><div class="lstlisting">  refine (trans_equal (Hfg _) _).</div><p>and this is a common idiom for applying transitivity on the left hand side
of an equation.</p><h4 id="sec548" class="subsubsection">The <span style="font-family:monospace">abstract</span> tactic</h4>
<p><a id="ssec:abstract"></a>
<a id="hevea_default923"></a><a id="hevea_tactic250"></a></p><p>The <span style="font-family:monospace">abstract</span> tactic assigns an abstract constant previously introduced with
the <span style="font-family:monospace">[: name ]</span> intro pattern (see section <a href="#ssec%3Aintro">11.5.4</a>,
page <a href="#ssec%3Aintroabstract">??</a>).
In a goal like the following:
</p><div class="lstlisting"> m : nat
 abs : &lt;hidden&gt;
 n : nat
 =============
 m &lt; 5 + n</div><p>The tactic <span style="font-family:monospace">abstract: abs n</span> first generalizes the goal with respect to
<span style="font-family:monospace">n</span> (that is not visible to the abstract constant <span style="font-family:monospace">abs</span>) and then
assigns <span style="font-family:monospace">abs</span>. The resulting goal is:
</p><div class="lstlisting"> m : nat
 n : nat
 =============
 m &lt; 5 + n</div><p>Once this subgoal is closed, all other goals having <span style="font-family:monospace">abs</span> in their context
see the type assigned to <span style="font-family:monospace">abs</span>. In this case:
</p><div class="lstlisting"> m : nat
 abs : forall n, m &lt; 5 + n</div><p>For a more detailed example the user should refer to section <a href="#sssec%3Ahave">11.6.6</a>,
page <a href="#sec%3Ahavetransparent">??</a>.</p>
<h3 id="sec549" class="subsection">11.5.4  Introduction</h3>
<p><a id="ssec:intro"></a>
<a id="hevea_default924"></a><a id="hevea_tactic251"></a></p><p>The application of a tactic to a given goal can generate
(quantified) variables, assumptions, or definitions, which the user may want to
<em>introduce</em> as new facts, constants or defined constants, respectively.
If the tactic splits the goal into several subgoals,
each of them may require the introduction of different constants and facts.
Furthermore it is very common to immediately decompose
or rewrite with an assumption instead of adding it to the context,
as the goal can often be simplified and even
proved after this.</p><p>All these operations are performed by the introduction tactical
‘<span style="font-family:monospace">=&gt;</span>’, whose general syntax is
</p><div class="center"><div class="centered">
	<span style="font-style:oblique">tactic</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">i-item</span><sub>1</sub> … <span style="font-style:oblique">i-item</span><sub><span style="font-style:italic">n</span></sub>
</div></div><p>
where <span style="font-style:oblique">tactic</span> can be any tactic, <span style="font-style:italic">n</span> &gt; 0 and



</p><blockquote class="table"><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div><div class="center"><div class="centered"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">i-item</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">i-pattern</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">s-item</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">clear-switch</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">/</span><span style="font-style:oblique">term</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">s-item</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">/=</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">//</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">//=</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">i-pattern</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">_</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">?</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">*</span> <span style="font-style:italic">|</span> <span style="font-style:italic">[</span><span style="font-style:oblique">occ-switch</span><span style="font-style:italic">]</span><span style="font-family:monospace">-&gt;</span> <span style="font-style:italic">|</span> <span style="font-style:italic">[</span><span style="font-style:oblique">occ-switch</span><span style="font-style:italic">]</span><span style="font-family:monospace">&lt;-</span> <span style="font-style:italic">|</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
	</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">[</span> <span style="font-style:oblique">i-item</span><sub>1</sub><sup>*</sup> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">i-item</span><sub><span style="font-style:italic">m</span></sub><sup>*</sup> <span style="font-family:monospace">]</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">-</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">[:</span> <span style="font-style:oblique">ident</span><sup>+</sup> <span style="font-family:monospace">]</span>
</td></tr>
</table>

</div></div><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div></blockquote><p>The ‘<span style="font-family:monospace">=&gt;</span>’ tactical first executes <span style="font-style:oblique">tactic</span>, then the
<span style="font-style:oblique">i-item</span>s, left to right, i.e., starting from <span style="font-style:oblique">i-item</span><sub>1</sub>. An
<span style="font-style:oblique">s-item</span> specifies a simplification operation; a <span style="font-style:oblique">clear
switch</span> specifies context pruning as in <a href="#ssec%3Adischarge">11.5.3</a>. The
<span style="font-style:oblique">i-pattern</span>s can be seen as a variant of <em>intro patterns</em> <a href="tactics.html#intros-pattern">8.3.2</a>:
each performs an introduction operation, i.e., pops some variables or
assumptions from the goal.</p><p>An <span style="font-style:oblique">s-item</span> can simplify the set of subgoals or the subgoal themselves:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">//</span> removes all the “trivial” subgoals that can be resolved by
the <span style="font-variant:small-caps">SSReflect</span> tactic <span style="font-family:monospace">done</span> described in <a href="#ssec%3Atermin">11.6.2</a>, i.e., it
executes <span style="font-family:monospace">try done</span>.
</li><li class="li-itemize"><span style="font-family:monospace">/=</span> simplifies the goal by performing partial evaluation, as
per the tactic <span style="font-family:monospace">simpl</span>.<sup><a id="text20" href="#note20">5</a></sup>
</li><li class="li-itemize"><span style="font-family:monospace">//=</span> combines both kinds of simplification; it is equivalent
to <span style="font-family:monospace">/= //</span>, i.e., <span style="font-family:monospace">simpl; try done</span>.
</li></ul><p>
When an <span style="font-style:oblique">s-item</span> bears a <span style="font-style:oblique">clear-switch</span>, then the <span style="font-style:oblique">clear-switch</span> is
executed <em>after</em> the <span style="font-style:oblique">s-item</span>, e.g., <code>{</code><code>IHn</code><code>}//</code> will solve
some subgoals, possibly using the fact <code>IHn</code>, and will erase <code>IHn</code>
from the context of the remaining subgoals.</p><p>The last entry in the <span style="font-style:oblique">i-item</span> grammar rule, <span style="font-family:monospace">/</span><span style="font-style:oblique">term</span>,
represents a view (see section <a href="#sec%3Aviews">11.9</a>). If <span style="font-style:oblique">i-item</span><sub><span style="font-style:italic">k</span>+1</sub>
is a view <span style="font-style:oblique">i-item</span>, the view is applied to the assumption in top
position once <span style="font-style:oblique">i-item</span><sub>1</sub> … <span style="font-style:oblique">i-item</span><sub><span style="font-style:italic">k</span></sub> have been performed.</p><p>The view is applied to the top assumption.</p><p><span style="font-variant:small-caps">SSReflect</span> supports the following <span style="font-style:oblique">i-pattern</span>s:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-style:oblique">ident</span> pops the top variable, assumption, or local definition into
a new constant, fact, or defined constant <span style="font-style:oblique">ident</span>, respectively.
Note that defined constants cannot be introduced when
δ-expansion is required to expose the top variable or assumption.
</li><li class="li-itemize"><span style="font-family:monospace">?</span> pops the top variable into an anonymous constant or fact,
whose name is picked by the tactic interpreter.
<span style="font-variant:small-caps">SSReflect</span> only generates names that
cannot appear later in the user script.<sup><a id="text21" href="#note21">6</a></sup>
</li><li class="li-itemize"><span style="font-family:monospace">_</span> pops the top variable into an anonymous constant that will be
deleted from
the proof context of all the subgoals produced by the <span style="font-family:monospace">=&gt;</span> tactical.
They should thus never be displayed, except in an error message
if the constant is still actually used in the goal or context after
the last <span style="font-style:oblique">i-item</span> has been executed (<span style="font-style:oblique">s-item</span>s can erase goals
or terms where the constant appears).
</li><li class="li-itemize"><span style="font-family:monospace">*</span> pops all the remaining apparent variables/assumptions
as anonymous constants/facts. Unlike <span style="font-family:monospace">?</span> and <span style="font-family:monospace">move</span> the <span style="font-family:monospace">*</span>
<span style="font-style:oblique">i-item</span> does not expand definitions in the goal to expose
quantifiers, so it may be useful to repeat a <span style="font-family:monospace">move=&gt; *</span> tactic,
e.g., on the goal
<div class="lstlisting">  forall a b : bool, a &lt;&gt; b</div>a first <span style="font-family:monospace">move=&gt; *</span> adds only <span style="font-family:monospace">_a_ : bool</span> and <span style="font-family:monospace">_b_ : bool</span> to
the context; it takes a second <span style="font-family:monospace">move=&gt; *</span> to add
<span style="font-family:monospace">_Hyp_ : _a_ = _b_</span>.
</li><li class="li-itemize">[<span style="font-style:oblique">occ-switch</span>]<span style="font-family:monospace">-&gt;</span> (resp. [<span style="font-style:oblique">occ-switch</span>]<span style="font-family:monospace">&lt;-</span>)
pops the top assumption
(which should be a rewritable proposition) into an anonymous fact,
rewrites (resp. rewrites right to left) the goal with this fact
(using the <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">rewrite</span> tactic described in section <a href="#sec%3Arw">11.7</a>,
and honoring the optional occurrence selector),
and finally deletes the anonymous fact from the context.
</li><li class="li-itemize"><span style="font-family:monospace">[ </span><span style="font-style:oblique">i-item</span><sub>1</sub><sup>*</sup><span style="font-family:monospace"> | </span>…<span style="font-family:monospace"> | </span><span style="font-style:oblique">i-item</span><sub><span style="font-style:italic">m</span></sub><sup>*</sup><span style="font-family:monospace"> ]</span>,
when it is the very <em>first</em> <span style="font-style:oblique">i-pattern</span> after <span style="font-style:oblique">tactic</span> <span style="font-family:monospace">=&gt;</span>
tactical <em>and</em> <span style="font-style:oblique">tactic</span> is not a <span style="font-family:monospace">move</span>, is a <em>branching</em>
<span style="font-style:oblique">i-pattern</span>. It executes
the sequence <span style="font-style:oblique">i-item</span><sub><span style="font-style:italic">i</span></sub><sup>*</sup> on the <span style="font-style:italic">i</span><sup><span style="font-style:italic">th</span></sup>
subgoal produced by <span style="font-style:oblique">tactic</span>. The execution of <span style="font-style:oblique">tactic</span>
should thus generate exactly <span style="font-style:italic">m</span>
subgoals, unless the <span style="font-family:monospace">[</span>…<span style="font-family:monospace">]</span> <span style="font-style:oblique">i-pattern</span> comes after an initial
<span style="font-family:monospace">//</span> or <span style="font-family:monospace">//=</span> <span style="font-style:oblique">s-item</span> that closes some of the goals produced by
<span style="font-style:oblique">tactic</span>, in which case exactly <span style="font-style:italic">m</span> subgoals should remain after the
<span style="font-style:oblique">s-item</span>, or we have the trivial branching <span style="font-style:oblique">i-pattern</span> <span style="font-family:monospace">[]</span>,
which always does nothing, regardless of the number of remaining subgoals.
</li><li class="li-itemize"><span style="font-family:monospace">[ </span><span style="font-style:oblique">i-item</span><sub>1</sub><sup>*</sup><span style="font-family:monospace"> | </span>…<span style="font-family:monospace"> | </span><span style="font-style:oblique">i-item</span><sub><span style="font-style:italic">m</span></sub><sup>*</sup><span style="font-family:monospace"> ]</span>, when it is
<em>not</em> the first <span style="font-style:oblique">i-pattern</span> or when <span style="font-style:oblique">tactic</span> is a
<span style="font-family:monospace">move</span>, is a <em>destructing</em> <span style="font-style:oblique">i-pattern</span>. It starts by
destructing the top variable, using the <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">case</span> tactic
described in <a href="#ssec%3Abasictac">11.5.2</a>. It then behaves as the
corresponding branching <span style="font-style:oblique">i-pattern</span>, executing the sequence
<span style="font-style:oblique">i-item</span><sub><span style="font-style:italic">i</span></sub><sup>*</sup> in the <span style="font-style:italic">i</span><sup><span style="font-style:italic">th</span></sup> subgoal generated by the case
analysis; unless we have the trivial destructing <span style="font-style:oblique">i-pattern</span>
<span style="font-family:monospace">[]</span>, the latter should generate exactly <span style="font-style:italic">m</span> subgoals, i.e., the
top variable should have an inductive type with exactly <span style="font-style:italic">m</span>
constructors.<sup><a id="text22" href="#note22">7</a></sup>
While it is good style to use the <span style="font-style:oblique">i-item</span><sub><span style="font-style:italic">i</span></sub><sup>*</sup>
to pop the variables and assumptions corresponding to each constructor,
this is not enforced by <span style="font-variant:small-caps">SSReflect</span>.
</li><li class="li-itemize"><span style="font-family:monospace">-</span> does nothing, but counts as an intro pattern. It can also
be used to force the interpretation of
<span style="font-family:monospace">[ </span><span style="font-style:oblique">i-item</span><sub>1</sub><sup>*</sup><span style="font-family:monospace"> | </span>…<span style="font-family:monospace"> | </span><span style="font-style:oblique">i-item</span><sub><span style="font-style:italic">m</span></sub><sup>*</sup><span style="font-family:monospace"> ]</span>
as a case analysis like in <span style="font-family:monospace">move=&gt; -[H1 H2]</span>. It can also be used
to indicate explicitly the link between a view and a name like in
<span style="font-family:monospace">move=&gt; /eqP-H1</span>. Last, it can serve as a separator between
views. Section <a href="#ssec%3Amultiview">11.9.9</a> explains in which respect
the tactic <span style="font-family:monospace">move=&gt; /v1/v2</span> differs from the tactic
<span style="font-family:monospace">move=&gt; /v1-/v2</span>.
</li><li class="li-itemize"><span style="font-family:monospace">[: </span><span style="font-style:oblique">ident</span><sup>+</sup><span style="font-family:monospace"> ]</span> introduces in the context an abstract constant
for each <span style="font-style:oblique">ident</span>. Its type has to be fixed later on by using
the <span style="font-family:monospace">abstract</span> tactic (see page <a href="#ssec%3Aabstract">??</a>). Before then
the type displayed is <span style="font-family:monospace">&lt;hidden&gt;</span>.<a id="ssec:introabstract"></a>
</li></ul><p>
Note that <span style="font-variant:small-caps">SSReflect</span> does not support the syntax
<span style="font-family:monospace">(</span><span style="font-style:oblique">ipat</span><span style="font-family:monospace">,</span>…<span style="font-family:monospace">,</span><span style="font-style:oblique">ipat</span><span style="font-family:monospace">)</span> for destructing
intro-patterns.</p><p>Clears are deferred until the end of the intro pattern. For
example, given the goal:
</p><div class="lstlisting">x, y : nat
==================
0 &lt; x = true -&gt; (0 &lt; x) &amp;&amp; (y &lt; 2) = true</div><p>the tactic <span style="font-family:monospace">move=&gt; {x} -&gt;</span> successfully rewrites the goal and
deletes <span style="font-family:monospace">x</span> and the anonymous equation. The goal is thus turned into:
</p><div class="lstlisting">y : nat
==================
true &amp;&amp; (y &lt; 2) = true</div><p>If the cleared names are reused in the same intro pattern, a renaming
is performed behind the scenes.</p><p>Facts mentioned in a clear switch must be valid
names in the proof context (excluding the section context).</p><p>The rules for interpreting branching and destructing <span style="font-style:oblique">i-pattern</span>
are motivated by the fact that it would be pointless to have a branching
pattern if <span style="font-style:oblique">tactic</span> is a <span style="font-family:monospace">move</span>, and in most of the remaining cases
<span style="font-style:oblique">tactic</span> is <span style="font-family:monospace">case</span> or <span style="font-family:monospace">elim</span>, which implies destruction.
The rules above imply that
</p><div class="lstlisting">  move=&gt; [a b].
  case=&gt; [a b].
  case=&gt; a b.</div><p>are all equivalent, so which one to use is a matter of style;
<span style="font-family:monospace">move</span> should be used for casual decomposition,
such as splitting a pair, and <span style="font-family:monospace">case</span> should be used for actual decompositions,
in particular for type families (see <a href="#ssec%3Atypefam">11.5.6</a>)
and proof by contradiction.</p><p>The trivial branching <span style="font-style:oblique">i-pattern</span> can be used to force the branching
interpretation, e.g.,
</p><div class="lstlisting">  case=&gt; [] [a b] c.
  move=&gt; [[a b] c].
  case;  case=&gt; a b c.</div><p>are all equivalent.</p>
<h3 id="sec550" class="subsection">11.5.5  Generation of equations</h3>
<p><a id="ssec:equations"></a>
<a id="hevea_default925"></a><a id="hevea_tactic252"></a></p><p>The generation of named equations option stores the definition of a
new constant as an equation. The tactic:
</p><div class="lstlisting">  move En: (size l) =&gt; n.</div><p>where <span style="font-family:monospace">l</span> is a list, replaces <span style="font-family:monospace">size l</span> by <span style="font-family:monospace">n</span> in the goal and
adds the fact <span style="font-family:monospace">En : size l = n</span> to the context.
This is quite different from:
</p><div class="lstlisting">  pose n := (size l).</div><p>which generates a definition <span style="font-family:monospace">n := (size l)</span>. It is not possible to
generalize or
rewrite such a definition; on the other hand, it is automatically
expanded during
computation, whereas expanding the equation <span style="font-family:monospace">En</span> requires explicit
rewriting.</p><p>The use of this equation name generation option with a <span style="font-family:monospace">case</span> or an
<span style="font-family:monospace">elim</span> tactic changes the status of the first <span style="font-style:italic">i-item</span>, in order to
deal with the possible parameters of the constants introduced.</p><p>On the
goal <span style="font-family:monospace">a &lt;&gt; b</span> where <span style="font-family:monospace">a, b</span> are natural numbers, the tactic:
</p><div class="lstlisting">  case E : a =&gt; [|n].</div><p>generates two subgoals. The equation <span style="font-family:monospace">E : a = 0</span> (resp. <span style="font-family:monospace">E : a =
S n</span>, and the constant <span style="font-family:monospace">n : nat</span>) has been added to
the context of the goal <span style="font-family:monospace">0 &lt;&gt; b</span> (resp. <span style="font-family:monospace">S n &lt;&gt; b</span>).</p><p>If the user does not provide a branching <span style="font-style:italic">i-item</span> as first <span style="font-style:italic">i-item</span>,
or if the <span style="font-style:italic">i-item</span> does not provide enough names for the arguments of
a constructor,
then the constants generated are introduced under fresh <span style="font-variant:small-caps">SSReflect</span> names.
For instance, on the goal <span style="font-family:monospace">a &lt;&gt; b</span>, the tactic:
</p><div class="lstlisting">  case E : a =&gt; H.</div><p>also generates two subgoals, both requiring a proof of <span style="font-family:monospace">False</span>.
The hypotheses <span style="font-family:monospace">E : a = 0</span> and
<span style="font-family:monospace">H : 0 = b</span> (resp. <span style="font-family:monospace">E : a = S _n_</span> and
<span style="font-family:monospace">H : S _n_ = b</span>) have been added to the context of the first
subgoal (resp. the second subgoal).</p><p>Combining the generation of named equations mechanism with the
<span style="font-family:monospace">case</span> tactic strengthens the power of a case analysis. On the other
hand, when combined with the <span style="font-family:monospace">elim</span> tactic, this feature is mostly
useful for
debug purposes, to trace the values of decomposed parameters and
pinpoint failing branches.</p>
<h3 id="sec551" class="subsection">11.5.6  Type families</h3>
<p><a id="ssec:typefam"></a>
<a id="hevea_default926"></a><a id="hevea_tactic253"></a></p><p>When the top assumption of a goal has an inductive type, two
specific operations are possible: the case analysis performed by the
<span style="font-family:monospace">case</span> tactic, and the application of an induction principle,
performed by the <span style="font-family:monospace">elim</span> tactic. When this top assumption has an
inductive type, which is moreover an instance of a type family, <span style="font-variant:small-caps">Coq</span>
may need help from the user to specify which occurrences of the parameters
of the type should be substituted.</p><p>A specific <span style="font-family:monospace">/</span> switch indicates the type family parameters of the
type of a <span style="font-style:italic">d-item</span> immediately following this <span style="font-family:monospace">/</span> switch, using the
syntax:</p><div class="center"><div class="centered">
<span style="font-family:monospace">[</span> <span style="font-family:monospace">case</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">elim</span> <span style="font-family:monospace">]:</span> <span style="font-style:oblique">d-item</span><sup>+</sup> <span style="font-family:monospace">/</span> <span style="font-style:oblique">d-item</span><sup>*</sup>
</div></div><p>The <span style="font-style:oblique">d-item</span>s on the right side of the <span style="font-family:monospace">/</span> switch are discharged
as described in section <a href="#ssec%3Adischarge">11.5.3</a>. The case analysis or
elimination will be done on the type of the top assumption after these
discharge operations.</p><p>Every <span style="font-style:oblique">d-item</span> preceding the <span style="font-family:monospace">/</span> is interpreted as arguments of this
type, which should be an instance of an inductive type family. These terms are
not actually generalized, but rather selected for substitution. Occurrence
switches can be used to restrict the substitution. If a <span style="font-style:oblique">term</span> is left
completely implicit (e.g. writing just <span style="font-family:monospace">_</span>), then a pattern is inferred
looking at the type of the top assumption. This allows for the compact syntax
<span style="font-family:monospace">case: {2}_ / eqP</span>, were <span style="font-family:monospace">_</span> is interpreted as <span style="font-family:monospace">(_ == _)</span>. Moreover
if the <span style="font-style:oblique">d-item</span>s list is too short, it is padded with an initial
sequence of <span style="font-family:monospace">_</span> of the right length.</p><p>Here is a small example on lists. We define first a function which
adds an element at the end of a given list.
</p><div class="lstlisting">  Require Import List.

  Section LastCases.
  Variable A : Type.

  Fixpoint add_last(a : A)(l : list A): list A :=
  match l with
    |nil =&gt; a :: nil
    |hd :: tl =&gt; hd :: (add_last a tl)
  end.</div><p>Then we define an inductive predicate for
case analysis on lists according to their last element:
</p><div class="lstlisting">  Inductive last_spec : list A -&gt; Type :=
    | LastSeq0 : last_spec nil
    | LastAdd s x : last_spec (add_last x s).

  Theorem lastP : forall l : list A, last_spec l.</div><p>Applied to the goal:
</p><div class="lstlisting">  Goal forall l : list A, (length l) * 2 = length (app l l).</div><p>the command:
</p><div class="lstlisting">  move=&gt; l; case: (lastP l).</div><p>generates two subgoals:
</p><div class="lstlisting">  length nil * 2 = length (nil ++ nil)</div><p>and
</p><div class="lstlisting">  forall (s : list A) (x : A),
    length (add_last x s) * 2 = length (add_last x s ++ add_last x s)</div><p>both having <span style="font-family:monospace">l : list A</span> in their context.</p><p>Applied to the same goal, the command:
</p><div class="lstlisting">  move=&gt; l; case: l / (lastP l).</div><p>generates the same subgoals but <span style="font-family:monospace">l</span> has been cleared from both
contexts.</p><p>Again applied to the same goal, the command:
</p><div class="lstlisting">  move=&gt; l; case: {1 3}l / (lastP l).</div><p>generates the subgoals <code>length</code><code> </code><code>l</code><code> * 2 = </code><code>length</code><code> (</code><code>nil</code><code> ++ </code><code>l</code><code>)</code> and
<code>forall</code><code> (</code><code>s</code><code> : </code><code>list</code><code> </code><code>A</code><code>) (</code><code>x</code><code> : </code><code>A</code><code>), </code><code>length</code><code> </code><code>l</code><code> * 2 = </code><code>length</code><code> (</code><code>add_last</code><code> </code><code>x</code><code> </code><code>s</code><code>++</code><code>l</code><code>)</code>
where the selected occurrences on the left of the <span style="font-family:monospace">/</span> switch have
been substituted with <span style="font-family:monospace">l</span> instead of being affected by the case
analysis.</p><p>The equation name generation feature combined with a type family <span style="font-family:monospace">/</span>
switch generates an equation for the <em>first</em> dependent d-item
specified by the user.
Again starting with the above goal, the command:
</p><div class="lstlisting">  move=&gt; l; case E: {1 3}l / (lastP l)=&gt;[|s x].</div><p>adds <span style="font-family:monospace">E : l = nil</span> and <span style="font-family:monospace">E : l = add_last x s</span>,
respectively, to the context of the two subgoals it generates.</p><p>There must be at least one <em>d-item</em> to the left of the <span style="font-family:monospace">/</span>
switch; this prevents any
confusion with the view feature. However, the <span style="font-style:italic">d-item</span>s to the right of
the <span style="font-family:monospace">/</span> are optional, and if they are omitted the first assumption
provides the instance of the type family.</p><p>The equation always refers to the first <em>d-item</em> in the actual
tactic call, before any padding with initial <span style="font-family:monospace">_</span>s. Thus, if an
inductive type has two family parameters, it is possible to have
<span style="font-variant:small-caps">SSReflect</span> generate an equation for the second one by omitting the pattern
for the first; note however that this will fail if the type of the
second parameter depends on the value of the first parameter.
</p>
<h2 id="sec552" class="section">11.6  Control flow</h2>
<h3 id="sec553" class="subsection">11.6.1  Indentation and bullets</h3>
<p><a id="ssec:indent"></a></p><p>A linear development of <span style="font-variant:small-caps">Coq</span> scripts gives little information on
the structure of the proof. In addition, replaying a proof after some
changes in the statement to be proved will usually not display information to
distinguish between the various branches of case analysis for instance.</p><p>To help the user in this organization of the proof script at
development time, <span style="font-variant:small-caps">SSReflect</span> provides some bullets to highlight the
structure of branching proofs. The available bullets are <span style="font-family:monospace">-</span>,
<span style="font-family:monospace">+</span> and <span style="font-family:monospace">*</span>. Combined with tabulation, this lets us highlight four
nested levels of branching; the most we have ever
needed is three. Indeed, the use of “simpl and closing” switches, of
terminators (see above section <a href="#ssec%3Atermin">11.6.2</a>) and selectors (see
section <a href="#ssec%3Aselect">11.6.3</a>) is powerful enough
to avoid most of the time more than two levels of indentation.</p><p>Here is a fragment of such a structured script:</p><div class="lstlisting">case E1: (abezoutn _ _) =&gt; [[| k1] [| k2]].
- rewrite !muln0 !gexpn0 mulg1 =&gt; H1.
  move/eqP: (sym_equal F0); rewrite -H1 orderg1 eqn_mul1.
  by case/andP; move/eqP.
- rewrite muln0 gexpn0 mulg1 =&gt; H1.
  have F1: t %| t * S k2.+1 - 1.
    apply: (@dvdn_trans (orderg x)); first by rewrite F0; exact: dvdn_mull.
    rewrite orderg_dvd; apply/eqP; apply: (mulgI x).
    rewrite -{1}(gexpn1 x) mulg1 gexpn_add leq_add_sub //.
    by move: P1; case t.
  rewrite dvdn_subr in F1; last by exact: dvdn_mulr.
  + rewrite H1 F0 -{2}(muln1 (p ^ l)); congr (_ * _).
    by apply/eqP; rewrite -dvdn1.
  + by move: P1; case: (t) =&gt; [| [| s1]].
- rewrite muln0  gexpn0 mul1g =&gt; H1.
...</div>
<h3 id="sec554" class="subsection">11.6.2  Terminators</h3>
<p><a id="ssec:termin"></a>
<a id="hevea_default927"></a><a id="hevea_tactic254"></a></p><p>To further structure scripts, <span style="font-variant:small-caps">SSReflect</span>
supplies <em>terminating</em> tacticals to explicitly close off tactics.
When replaying scripts, we then have the nice property that
an error immediately occurs when a closed tactic fails to prove its
subgoal.</p><p>It is hence recommended practice that the proof of any subgoal should
end with a tactic which <em>fails if it does not solve the current
goal</em>, like <span style="font-family:monospace">discriminate</span>, <span style="font-family:monospace">contradiction</span> or <span style="font-family:monospace">assumption</span>.</p><p>In fact, <span style="font-variant:small-caps">SSReflect</span> provides a generic tactical which turns any tactic into
a closing one (similar to <span style="font-family:monospace">now</span>). Its general syntax is:</p><div class="center"><div class="centered">
<span style="font-family:monospace">by</span> <span style="font-style:oblique">tactic</span><span style="font-family:monospace">.</span>
</div></div><p>The Ltac expression:</p><div class="center"><div class="centered">
<span style="font-family:monospace">by [</span><span style="font-style:oblique">tactic</span><sub>1</sub> <span style="font-family:monospace">| [</span><span style="font-style:oblique">tactic</span><sub>2</sub> <span style="font-family:monospace">| ...].</span>
</div></div><p>is equivalent to:</p><div class="center"><div class="centered">
<span style="font-family:monospace">[by</span> <span style="font-style:oblique">tactic</span><sub>1</sub> <span style="font-family:monospace">| by</span> <span style="font-style:oblique">tactic</span><sub>2</sub> <span style="font-family:monospace">| ...].</span>
</div></div><p>and this form should be preferred to the former.</p><p>In the script provided as example in section <a href="#ssec%3Aindent">11.6.1</a>, the
paragraph corresponding to each sub-case ends with a tactic line prefixed
with a <span style="font-family:monospace">by</span>, like in:</p><div class="center"><div class="centered">
<span style="font-family:monospace">by apply/eqP; rewrite -dvdn1.</span>
</div></div><p>The <span style="font-family:monospace">by</span> tactical is implemented using the user-defined,
and extensible <span style="font-family:monospace">done</span> tactic. This <span style="font-family:monospace">done</span> tactic tries to solve
the current goal by some trivial means and fails if it doesn’t succeed.
Indeed, the tactic expression:</p><div class="center"><div class="centered">
<span style="font-family:monospace">by</span> <span style="font-style:oblique">tactic</span><span style="font-family:monospace">.</span>
</div></div><p>is equivalent to:</p><div class="center"><div class="centered">
<span style="font-style:oblique">tactic</span><span style="font-family:monospace">; done.</span>
</div></div><p>Conversely, the tactic</p><div class="center"><div class="centered">
<span style="font-family:monospace">by [ ].</span>
</div></div><p>is equivalent to:</p><div class="center"><div class="centered">
<span style="font-family:monospace">done.</span>
</div></div><p>The default implementation of the <span style="font-family:monospace">done</span> tactic, in the <span style="font-family:monospace">ssreflect.v</span> file, is:</p><div class="lstlisting">Ltac done :=
  trivial; hnf; intros; solve
   [ do ![solve [trivial | apply: sym_equal; trivial]
         | discriminate | contradiction | split]
   | case not_locked_false_eq_true; assumption
   | match goal with H : ~ _ |- _ =&gt; solve [case H; trivial] end ].</div><p>The lemma <span style="font-family:monospace">|*not_locked_false_eq_true*|</span> is needed to discriminate
<em>locked</em> boolean predicates (see section <a href="#ssec%3Alock">11.7.3</a>).
The iterator tactical <span style="font-family:monospace">do</span> is presented in section
<a href="#ssec%3Aiter">11.6.4</a>.
This tactic can be customized by the user, for instance to include an
<span style="font-family:monospace">auto</span> tactic.</p><p>A natural and common way of closing a goal is to apply a lemma which
is the <span style="font-family:monospace">exact</span> one needed for the goal to be solved. The defective
form of the tactic:
</p><div class="lstlisting">  exact.</div><p>is equivalent to:
</p><div class="lstlisting">  do [done | by move=&gt; top; apply top].</div><p>where <span style="font-family:monospace">top</span> is a fresh name affected to the top assumption of the goal.
This applied form is supported by the <span style="font-family:monospace">:</span> discharge tactical, and
the tactic:
</p><div class="lstlisting">  exact: MyLemma.</div><p>is equivalent to:
</p><div class="lstlisting">  by apply: MyLemma.</div><p>(see section <a href="#sss%3Astrongapply">11.5.3</a> for the documentation of the <span style="font-family:monospace">apply:</span>
combination).</p><p><span style="font-style:italic">Warning</span> The list of tactics, possibly chained by
semi-columns, that follows a <span style="font-family:monospace">by</span> keyword is considered as a
parenthesized block
applied to the current goal. Hence for example if the tactic:
</p><div class="lstlisting">   by rewrite my_lemma1.</div><p>succeeds, then the tactic:
</p><div class="lstlisting">   by rewrite my_lemma1; apply my_lemma2.</div><p>usually fails since it is equivalent to:
</p><div class="lstlisting">   by (rewrite my_lemma1; apply my_lemma2).</div>
<h3 id="sec555" class="subsection">11.6.3  Selectors</h3>
<p><a id="ssec:select"></a>
<a id="hevea_default928"></a><a id="hevea_tactic255"></a>
<a id="hevea_default929"></a><a id="hevea_tactic256"></a></p><p>When composing tactics, the two tacticals <span style="font-family:monospace">first</span> and
<span style="font-family:monospace">last</span> let the user restrict the application of a tactic to only one
of the subgoals generated by the previous tactic. This
covers the frequent cases where a tactic generates two subgoals one of
which can be easily disposed of.</p><p>This is an other powerful way of linearization of scripts, since it
happens very often that a trivial subgoal can be solved in a less than
one line tactic. For instance, the tactic:</p><div class="center"><div class="centered">
<span style="font-style:oblique">tactic</span><sub>1</sub><span style="font-family:monospace">; last by</span> <span style="font-style:oblique">tactic</span><sub>2</sub><span style="font-family:monospace">.</span>
</div></div><p>tries to solve the last subgoal generated by <span style="font-style:oblique">tactic</span><sub>1</sub> using the
<span style="font-style:oblique">tactic</span><sub>2</sub>, and fails if it does not succeeds. Its analogous</p><div class="center"><div class="centered">
<span style="font-style:oblique">tactic</span><sub>1</sub><span style="font-family:monospace">; first by</span> <span style="font-style:oblique">tactic</span><sub>2</sub>.
</div></div><p>tries to solve the first subgoal generated by <span style="font-style:oblique">tactic</span><sub>1</sub> using the
tactic <span style="font-style:oblique">tactic</span><sub>2</sub>, and fails if it does not succeeds.</p><p><span style="font-variant:small-caps">SSReflect</span> also offers an extension of this facility, by supplying
tactics to <em>permute</em> the subgoals generated by a tactic.
The tactic:</p><div class="center"><div class="centered">
<span style="font-style:oblique">tactic</span><span style="font-family:monospace">; last first.</span>
</div></div><p>inverts the order of the subgoals generated by <span style="font-style:oblique">tactic</span>. It is
equivalent to:</p><div class="center"><div class="centered">
<span style="font-style:oblique">tactic</span><span style="font-family:monospace">; first last.</span>
</div></div><p>More generally, the tactic:</p><div class="center"><div class="centered">
<span style="font-style:oblique">tactic</span><span style="font-family:monospace">; last </span><span style="font-style:oblique">natural</span> <span style="font-family:monospace">first.</span>
</div></div><p>where <span style="font-style:oblique">natural</span> is
a <span style="font-variant:small-caps">Coq</span> numeral, or and Ltac variable denoting
a <span style="font-variant:small-caps">Coq</span> numeral, having the value <span style="font-style:italic">k</span>. It
rotates the <span style="font-style:italic">n</span> subgoals <span style="font-style:italic">G</span><sub>1</sub>,
…, <span style="font-style:italic">G</span><sub><span style="font-style:italic">n</span></sub> generated by <span style="font-style:oblique">tactic</span>. The first subgoal becomes
<span style="font-style:italic">G</span><sub><span style="font-style:italic">n</span> + 1 − <span style="font-style:italic">k</span></sub> and the circular order of subgoals remains unchanged.</p><p>Conversely, the tactic:</p><p><span style="font-style:oblique">tactic</span><span style="font-family:monospace">; first </span><span style="font-style:oblique">natural</span> <span style="font-family:monospace">last.</span></p><p>rotates the <span style="font-style:italic">n</span> subgoals <span style="font-style:italic">G</span><sub>1</sub>,
…, <span style="font-style:italic">G</span><sub><span style="font-style:italic">n</span></sub> generated by <span style="font-family:monospace">tactic</span> in order that the first subgoal
becomes <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub>.</p><p>Finally, the tactics <span style="font-family:monospace">last</span> and <span style="font-family:monospace">first</span> combine with the
branching syntax of Ltac:
if the tactic <span style="font-style:oblique">tactic</span><sub>0</sub> generates <span style="font-style:italic">n</span>
subgoals on a given goal, then the tactic</p><p><span style="font-style:italic">tactic</span><sub>0</sub><span style="font-family:monospace">; last </span><span style="font-style:oblique">natural</span> <span style="font-family:monospace">[</span><span style="font-style:italic">tactic</span><sub>1</sub><span style="font-family:monospace">|</span>…<span style="font-family:monospace">|</span><span style="font-style:italic">tactic</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace">] || </span><span style="font-style:italic">tactic</span><sub><span style="font-style:italic">m</span>+1</sub><span style="font-family:monospace">.</span></p><p>where <span style="font-style:oblique">natural</span> denotes the integer <span style="font-style:italic">k</span> as above, applies <span style="font-style:italic">tactic</span><sub>1</sub> to the
<span style="font-style:italic">n</span> −<span style="font-style:italic">k</span> + 1-th goal, … <span style="font-style:italic">tactic</span><sub><span style="font-style:italic">m</span></sub> to the <span style="font-style:italic">n</span> −<span style="font-style:italic">k</span> + 2 − <span style="font-style:italic">m</span>-th
goal and <span style="font-style:italic">tactic</span><sub><span style="font-style:italic">m</span>+1</sub> to the others.</p><p>For instance, the script:
</p><div class="lstlisting">  Inductive test : nat -&gt;  Prop :=
    C1 : forall n, test n | C2 : forall n, test n |
    C3 : forall n, test n | C4 : forall n, test n.

  Goal forall n, test n -&gt; True.
  move=&gt; n t; case: t; last 2 [move=&gt; k| move=&gt; l]; idtac.</div><p>creates a goal with four subgoals, the first and the last being
<span style="font-family:monospace">nat -&gt; True</span>, the second and the third being <span style="font-family:monospace">True</span> with
respectively <span style="font-family:monospace">k : nat</span> and <span style="font-family:monospace">l : nat</span> in their context.</p>
<h3 id="sec556" class="subsection">11.6.4  Iteration</h3>
<p><a id="ssec:iter"></a>
<a id="hevea_default930"></a><a id="hevea_tactic257"></a></p><p><span style="font-variant:small-caps">SSReflect</span> offers an accurate control on the repetition of
tactics, thanks to the <span style="font-family:monospace">do</span> tactical, whose general syntax is:</p><div class="center"><div class="centered">
	<span style="font-family:monospace">do</span> <span style="font-style:italic">[</span><span style="font-style:oblique">mult</span><span style="font-style:italic">]</span> <span style="font-family:monospace">[</span> <span style="font-style:oblique">tactic</span><sub>1</sub> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">tactic</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">]</span>
</div></div><p>
where <span style="font-style:oblique">mult</span> is a <em>multiplier</em>.</p><p>Brackets can only be omitted if a single tactic is given <em>and</em> a
multiplier is present.</p><p>A tactic of the form:</p><div class="center"><div class="centered">
<span style="font-family:monospace">do [</span> <span style="font-style:oblique">tactic</span><sub>1</sub> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">tactic</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">].</span>
</div></div><p>is equivalent to the standard Ltac expression:</p><div class="center"><div class="centered">
<span style="font-family:monospace">first [</span> <span style="font-style:oblique">tactic</span><sub>1</sub> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">tactic</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">].</span>
</div></div><p>The optional multiplier <span style="font-style:oblique">mult</span> specifies how many times
the action of <span style="font-style:oblique">tactic</span> should be repeated on the current subgoal.</p><p>There are four kinds of multipliers:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">n!</span>: the step <span style="font-style:oblique">tactic</span> is repeated exactly <span style="font-style:italic">n</span> times
(where <span style="font-style:italic">n</span> is a positive integer argument).
</li><li class="li-itemize"><span style="font-family:monospace">!</span>: the step <span style="font-style:oblique">tactic</span> is repeated as many times as possible,
and done at least once.
</li><li class="li-itemize"><span style="font-family:monospace">?</span>: the step <span style="font-style:oblique">tactic</span> is repeated as many times as possible,
optionally.
</li><li class="li-itemize"><span style="font-family:monospace">n?</span>: the step <span style="font-style:oblique">tactic</span> is repeated up to <span style="font-style:italic">n</span> times,
optionally.
</li></ul><p>For instance, the tactic:</p><div class="center"><div class="centered">
<span style="font-style:oblique">tactic</span> <code>; </code><code>do</code><code> 1?</code><code>rewrite</code><code> </code><code>mult_comm</code><code>.</code>
</div></div><p>rewrites at most one time the lemma <span style="font-family:monospace">mult_com</span> in all the subgoals
generated by <span style="font-style:oblique">tactic</span> , whereas the tactic:</p><div class="center"><div class="centered">
<span style="font-style:oblique">tactic</span> <code>; </code><code>do</code><code> 2!</code><code>rewrite</code><code> </code><code>mult_comm</code><code>.</code>
</div></div><p>rewrites exactly two times the lemma <span style="font-family:monospace">mult_com</span> in all the subgoals
generated by <span style="font-style:oblique">tactic</span>, and fails if this rewrite is not possible
in some subgoal.</p><p>Note that the combination of multipliers and <span style="font-family:monospace">rewrite</span> is so often
used that multipliers are in fact integrated to the syntax of the <span style="font-variant:small-caps">SSReflect</span>
<span style="font-family:monospace">rewrite</span> tactic, see section <a href="#sec%3Arw">11.7</a>.</p>
<h3 id="sec557" class="subsection">11.6.5  Localization</h3>
<p><a id="ssec:gloc"></a>
<a id="hevea_default931"></a><a id="hevea_tactic258"></a></p><p>In sections <a href="#ssec%3Aloc">11.4.3</a> and <a href="#ssec%3Aprofstack">11.5.1</a>, we have already
presented the <em>localization</em> tactical <span style="font-family:monospace">in</span>, whose general
syntax is:
</p><div class="center"><div class="centered">
	<span style="font-style:oblique">tactic</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">ident</span><sup>+</sup> <span style="font-style:italic">[</span><span style="font-family:monospace">*</span><span style="font-style:italic">]</span>
</div></div><p>where <span style="font-style:oblique">ident</span><sup>+</sup> is a non empty list of fact
names in the context. On the left side of <span style="font-family:monospace">in</span>, <span style="font-style:oblique">tactic</span> can be
<span style="font-family:monospace">move</span>, <span style="font-family:monospace">case</span>, <span style="font-family:monospace">elim</span>, <span style="font-family:monospace">rewrite</span>, <span style="font-family:monospace">set</span>,
or any tactic formed with the general iteration tactical <span style="font-family:monospace">do</span> (see
section <a href="#ssec%3Aiter">11.6.4</a>).</p><p>The operation described by <span style="font-style:oblique">tactic</span> is performed in the facts
listed in <span style="font-style:oblique">ident</span><sup>+</sup> and in the goal if a <span style="font-family:monospace">*</span> ends
the list.</p><p>The <span style="font-family:monospace">in</span> tactical successively:
</p><ul class="itemize"><li class="li-itemize">
generalizes the selected hypotheses, possibly “protecting” the
goal if <span style="font-family:monospace">*</span> is not present,
</li><li class="li-itemize">performs <span style="font-style:oblique">tactic</span>, on the obtained goal,
</li><li class="li-itemize">reintroduces the generalized facts, under the same names.
</li></ul><p>This defective form of the <span style="font-family:monospace">do</span> tactical is useful to avoid clashes
between standard Ltac <span style="font-family:monospace">in</span> and the <span style="font-variant:small-caps">SSReflect</span> tactical <span style="font-family:monospace">in</span>.
For example, in the following script:
</p><div class="lstlisting">  Ltac mytac H := rewrite H.

  Goal forall x y, x = y -&gt; y = 3 -&gt; x + y  = 6.
  move=&gt; x y H1 H2.
  do [mytac H2] in H1 *.</div><p>the last tactic rewrites the hypothesis <span style="font-family:monospace">H2 : y = 3</span> both in
<span style="font-family:monospace">H1 : x = y</span> and in the goal <span style="font-family:monospace">x + y = 6</span>.</p><p>By default <span style="font-family:monospace">in</span> keeps the body of local definitions. To erase
the body of a local definition during the generalization phase,
the name of the local definition must be written between parentheses,
like in <span style="font-family:monospace">rewrite H in H1 (def_n) </span>  <span style="font-family:monospace">H2</span>.</p><p>From <span style="font-variant:small-caps">SSReflect</span> 1.5 the grammar for the <span style="font-family:monospace">in</span> tactical has been extended
to the following one:</p><div class="center"><div class="centered">
<span style="font-style:oblique">tactic</span> <span style="font-family:monospace">in</span> <span style="font-style:italic">[</span> 
	 <span style="font-style:oblique">clear-switch</span> <span style="font-style:italic">|</span>
	 <span style="font-style:italic">[</span><span style="font-family:monospace">@</span><span style="font-style:italic">]</span><span style="font-style:oblique">ident</span> <span style="font-style:italic">|</span>
<span style="font-family:monospace">(</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">)</span> <span style="font-style:italic">|</span>
	 <span style="font-family:monospace">(</span><span style="font-style:italic">[</span><span style="font-family:monospace">@</span><span style="font-style:italic">]</span><span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">c-pattern</span><span style="font-family:monospace">)</span>
		<span style="font-style:italic">]</span><sup>+</sup> <span style="font-style:italic">[</span><span style="font-family:monospace">*</span><span style="font-style:italic">]</span>
</div></div><p>In its simplest form the last option lets one rename hypotheses that can’t be
cleared (like section variables). For example <span style="font-family:monospace">(y := x)</span> generalizes
over <span style="font-family:monospace">x</span> and reintroduces the generalized
variable under the name <span style="font-family:monospace">y</span> (and does not clear <span style="font-family:monospace">x</span>).<br>
For a more precise description the <span style="font-family:monospace">(</span>[<span style="font-family:monospace">@</span>]<span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">c-pattern</span><span style="font-family:monospace">)</span>
item refer to the “Advanced generalization” paragraph at page <a href="#par%3Aadvancedgen">??</a>.</p>
<h3 id="sec558" class="subsection">11.6.6  Structure</h3>
<p><a id="ssec:struct"></a></p><p>Forward reasoning structures the script by explicitly specifying some
assumptions to be added to the proof context. It is closely associated
with the declarative style of proof, since an extensive use of these
highlighted statements
make the script closer to a (very detailed) text book proof.</p><p>Forward chaining tactics allow to state an intermediate lemma and start a
piece of script dedicated to the proof of this statement. The use of
closing tactics (see section <a href="#ssec%3Atermin">11.6.2</a>) and of
indentation makes syntactically explicit the portion of the script
building the proof of the intermediate statement.</p><h4 id="sec559" class="subsubsection">The <span style="font-family:monospace">have</span> tactic.</h4>
<p>
<a id="sssec:have"></a>
<a id="hevea_default932"></a><a id="hevea_tactic259"></a>
<a id="hevea_default933"></a><a id="hevea_tactic260"></a></p><p>The main <span style="font-variant:small-caps">SSReflect</span> forward reasoning tactic is the <span style="font-family:monospace">have</span> tactic. It
can be use in two modes: one starts a new (sub)proof for an
intermediate result in the main proof, and the other
provides explicitly a proof term for this intermediate step.</p><p>In the first mode, the syntax of <span style="font-family:monospace">have</span> in its defective form is:</p><p><span style="font-family:monospace">have: </span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span></p><p>This tactic supports open syntax for <span style="font-style:oblique">term</span>.
Applied to a goal <span style="font-family:monospace">G</span>, it generates a first subgoal requiring a
proof of <span style="font-style:oblique">term</span> in the context of <span style="font-family:monospace">G</span>. The second generated
subgoal is of the form <span style="font-style:oblique">term</span> <span style="font-family:monospace">-&gt; G</span>, where <span style="font-style:oblique">term</span> becomes
the new top assumption, instead of being introduced with a fresh
name. At the proof-term level, the <span style="font-family:monospace">have</span> tactic creates a β
redex, and introduces the lemma under a fresh name, automatically
chosen.</p><p>Like in the case of the <span style="font-family:monospace">pose</span> tactic (see section <a href="#ssec%3Apose">11.4.1</a>),
the types of the holes are abstracted in <span style="font-style:oblique">term</span>.
For instance, the tactic:
</p><div class="lstlisting">  have: _ * 0 = 0.</div><p>is equivalent to:
</p><div class="lstlisting">  have: forall n : nat, n * 0 = 0.</div><p>The <span style="font-family:monospace">have</span> tactic also enjoys the same abstraction mechanism as the
<span style="font-family:monospace">pose</span> tactic for the non-inferred implicit arguments. For instance,
the tactic:
</p><div class="lstlisting">  have: forall x y, (x, y) = (x, y + 0).</div><p>opens a new subgoal to prove that:</p><p><span style="font-family:monospace">forall (T : Type) (x : T) (y : nat), (x, y) = (x, y + 0)</span></p><p>The behavior of the defective <span style="font-family:monospace">have</span> tactic makes it possible to
generalize it in the
following general construction:
</p><div class="center"><div class="centered">
	<span style="font-family:monospace">have</span> <span style="font-style:oblique">i-item</span><sup>*</sup> <span style="font-style:italic">[</span><span style="font-style:oblique">i-pattern</span><span style="font-style:italic">]</span>
	<span style="font-style:italic">[</span><span style="font-style:oblique">s-item</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">binder</span><sup>+</sup><span style="font-style:italic">]</span>
	<span style="font-style:italic">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><sub>1</sub><span style="font-style:italic">]</span>
	<span style="font-style:italic">[</span><span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span><sub>2</sub> <span style="font-style:italic">|</span> <span style="font-family:monospace">by</span> <span style="font-style:oblique">tactic</span><span style="font-style:italic">]</span>
</div></div><p>Open syntax is supported for <span style="font-style:oblique">term</span><sub>1</sub> and <span style="font-style:oblique">term</span><sub>2</sub>. For the
description of
<span style="font-style:italic">i-item</span>s and clear switches see section <a href="#ssec%3Aintro">11.5.4</a>.
The first mode of the <span style="font-family:monospace">have</span> tactic, which opens a sub-proof for an
intermediate result, uses tactics of the form:</p><div class="center"><div class="centered">
<span style="font-family:monospace">have</span> <span style="font-style:oblique">clear-switch</span> <span style="font-style:oblique">i-item</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">by</span> <span style="font-style:oblique">tactic</span>.
</div></div><p>which behave like:<br>

</p><div class="center"><div class="centered">
<span style="font-family:monospace">have:</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">; first by </span> <span style="font-style:oblique">tactic</span>.
</div></div><div class="center"><div class="centered">
<span style="font-family:monospace"> move=&gt;</span> <span style="font-style:oblique">clear-switch</span> <span style="font-style:oblique">i-item</span>.
</div></div><p>Note that the <span style="font-style:oblique">clear-switch</span> <em>precedes</em> the
<span style="font-style:oblique">i-item</span>, which allows to reuse a name of the context, possibly used
by the proof of the assumption, to introduce the new assumption
itself.</p><p>The <span style="font-family:monospace">by</span> feature is especially convenient when the proof script of the
statement is very short, basically when it fits in one line like in:
</p><div class="lstlisting">  have H : forall x y, x + y = y + x by move=&gt; x y; rewrite addnC.</div><p>The possibility of using <span style="font-style:italic">i-item</span>s supplies a very concise
syntax for the further use of the intermediate step. For instance,
</p><div class="lstlisting">  have -&gt; : forall x, x * a = a.</div><p>on a goal <span style="font-family:monospace">G</span>, opens a new subgoal asking for a proof of
<span style="font-family:monospace">forall x, x * a = a</span>, and a second subgoal in which the lemma
<span style="font-family:monospace">forall x, x * a = a</span> has been rewritten in the goal <span style="font-family:monospace">G</span>. Note
that in this last subgoal, the intermediate result does not appear in
the context.
Note that, thanks to the deferred execution of clears, the following
idiom is supported (assuming <span style="font-family:monospace">x</span> occurs in the goal only):
</p><div class="lstlisting">  have {x} -&gt; : x = y</div><p>An other frequent use of the intro patterns combined with <span style="font-family:monospace">have</span> is the
destruction of existential assumptions like in the tactic:
</p><div class="lstlisting">  have [x Px]: exists x : nat, x &gt; 0.</div><p>which opens a new subgoal asking for a proof of <span style="font-family:monospace">exists x : nat, x &gt;
0</span> and a second subgoal in which the witness is introduced under
the name <span style="font-family:monospace">x : nat</span>, and its property under the name <span style="font-family:monospace">Px : x &gt; 0</span>.</p><p>An alternative use of the <span style="font-family:monospace">have</span> tactic is to provide the explicit proof
term for the intermediate lemma, using tactics of the form:</p><div class="center"><div class="centered">
<span style="font-family:monospace">have</span> <span style="font-style:italic">[</span><span style="font-style:oblique">ident</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span>.
</div></div><p>This tactic creates a new assumption of type the type of
<span style="font-style:oblique">term</span>. If the
optional <span style="font-style:oblique">ident</span> is present, this assumption is introduced under
the name <span style="font-style:oblique">ident</span>. Note that the body of the constant is lost for
the user.</p><p>Again, non inferred implicit arguments and explicit holes are abstracted. For
instance, the tactic:
</p><div class="lstlisting">  have H := forall x, (x, x) = (x, x).</div><p>adds to the context <span style="font-family:monospace">H : Type -&gt; Prop</span>. This is a schematic example but
the feature is specially useful when the proof term to give involves
for instance a lemma with some hidden implicit arguments.</p><p>After the <span style="font-style:oblique">i-pattern</span>, a list of binders is allowed.
For example, if <span style="font-family:monospace">Pos_to_P</span> is a lemma that proves that
<span style="font-family:monospace">P</span> holds for any positive, the following command:
</p><div class="lstlisting">  have H x (y : nat) : 2 * x + y = x + x + y by auto.</div><p>will put in the context <span style="font-family:monospace">H : forall x, 2 * x = x + x</span>. A proof term
provided after <span style="font-family:monospace">:=</span> can mention these bound variables (that are
automatically introduced with the given names).
Since the <span style="font-style:oblique">i-pattern</span> can be omitted, to avoid ambiguity, bound variables
can be surrounded with parentheses even if no type is specified:
</p><div class="lstlisting">  have (x) : 2 * x = x + x by auto.</div><p>The <span style="font-style:oblique">i-item</span>s and <span style="font-style:oblique">s-item</span> can be used to interpret the
asserted hypothesis with views (see section <a href="#sec%3Aviews">11.9</a>) or
simplify the resulting goals.</p><p>The <span style="font-family:monospace">have</span> tactic also supports a <span style="font-family:monospace">suff</span> modifier which allows for
asserting that a given statement implies the current goal without
copying the goal itself. For example, given a goal <span style="font-family:monospace">G</span> the tactic
<span style="font-family:monospace">have suff H : P</span> results in the following two goals:
</p><div class="lstlisting">   |- P -&gt; G
   H : P -&gt; G |- G</div><p>Note that <span style="font-family:monospace">H</span> is introduced in the second goal. The <span style="font-family:monospace">suff</span>
modifier is not compatible with the presence of a list of binders.</p><h4 id="sec560" class="subsubsection">Generating <span style="font-family:monospace">let in</span> context entries with <span style="font-family:monospace">have</span></h4>
<p>
<a id="sec:havetransparent"></a></p><p>Since <span style="font-variant:small-caps">SSReflect</span> 1.5 the <span style="font-family:monospace">have</span> tactic supports a “transparent” modifier to
generate <span style="font-family:monospace">let in</span> context entries: the <span style="font-family:monospace">@</span> symbol in front of the context
entry name. For example:</p><div class="lstlisting">have @i : 'I_n by apply: (Sub m); auto.</div><p>generates the following two context entry:
</p><div class="lstlisting">i := Sub m proof_produced_by_auto : 'I_n</div><p>Note that the sub-term produced by <span style="font-family:monospace">auto</span> is in general huge and
uninteresting, and hence one may want to hide it.</p><p>For this purpose the <span style="font-family:monospace">[: name ]</span> intro pattern and the tactic
<span style="font-family:monospace">abstract</span> (see page <a href="#ssec%3Aabstract">??</a>) are provided.
Example:
</p><div class="lstlisting">have [:blurb] @i : 'I_n by apply: (Sub m); abstract: blurb; auto.</div><p>generates the following two context entries:
</p><div class="lstlisting">blurb : (m &lt; n) (*1*)
i := Sub m blurb : 'I_n</div><p>The type of <span style="font-family:monospace">blurb</span> can be cleaned up by its annotations by just simplifying
it. The annotations are there for technical reasons only.</p><p>When intro patterns for abstract constants are used in conjunction
with <span style="font-family:monospace">have</span> and an explicit term, they must be used as follows:</p><div class="lstlisting">have [:blurb] @i : 'I_n := Sub m blurb.
  by auto.</div><p>In this case the abstract constant <span style="font-family:monospace">blurb</span> is assigned by using it
in the term that follows <span style="font-family:monospace">:=</span> and its corresponding goal is left to
be solved. Goals corresponding to intro patterns for abstract constants
are opened in the order in which the abstract constants are declared (not
in the “order” in which they are used in the term).</p><p>Note that abstract constants do respect scopes. Hence, if a variable
is declared after their introduction, it has to be properly generalized (i.e.
explicitly passed to the abstract constant when one makes use of it).
For example any of the following two lines:
</p><div class="lstlisting">have [:blurb] @i k : 'I_(n+k) by apply: (Sub m); abstract: blurb k; auto.
have [:blurb] @i k : 'I_(n+k) := apply: Sub m (blurb k); first by auto.</div><p>generates the following context:
</p><div class="lstlisting">blurb : (forall k, m &lt; n+k) (*1*)
i := fun k =&gt; Sub m (blurb k) : forall k, 'I_(n+k)</div><p>Last, notice that the use of intro patterns for abstract constants is
orthogonal to the transparent flag <span style="font-family:monospace">@</span> for <span style="font-family:monospace">have</span>.</p><h4 id="sec561" class="subsubsection">The <span style="font-family:monospace">have</span> tactic and type classes resolution</h4>
<p>
<a id="ssec:havetcresolution"></a></p><p>Since <span style="font-variant:small-caps">SSReflect</span> 1.5 the <span style="font-family:monospace">have</span> tactic behaves as follows with respect to type
classes inference.</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">have foo : ty.</span>
	Full inference for <span style="font-family:monospace">ty</span>.
	The first subgoal demands a proof of such instantiated statement.
</li><li class="li-itemize"><span style="font-family:monospace">have foo : ty := .</span>
	No inference for <span style="font-family:monospace">ty</span>. Unresolved instances are quantified in
	<span style="font-family:monospace">ty</span>. The first subgoal demands a proof of such quantified
	statement. Note that no proof term follows <span style="font-family:monospace">:=</span>, hence two
	subgoals are generated.
</li><li class="li-itemize"><span style="font-family:monospace">have foo : ty := t.</span>
	No inference for <span style="font-family:monospace">ty</span> and <span style="font-family:monospace">t</span>.
</li><li class="li-itemize"><span style="font-family:monospace">have foo := t.</span>
	No inference for <span style="font-family:monospace">t</span>. Unresolved instances are quantified in the
	(inferred) type of <span style="font-family:monospace">t</span> and abstracted in <span style="font-family:monospace">t</span>.
</li></ul><p>The behavior of <span style="font-variant:small-caps">SSReflect</span> 1.4 and below (never resolve type classes)
can be restored with the option <span style="font-family:monospace">Set SsrHave NoTCResolution</span>.</p><h4 id="sec562" class="subsubsection">Variants: the <span style="font-family:monospace">suff</span> and <span style="font-family:monospace">wlog</span> tactics.</h4>
<p>
<a id="ssec:wlog"></a>
<a id="hevea_default934"></a><a id="hevea_tactic261"></a>
<a id="hevea_default935"></a><a id="hevea_tactic262"></a>
<a id="hevea_default936"></a><a id="hevea_tactic263"></a>
<a id="hevea_default937"></a><a id="hevea_tactic264"></a></p><p>As it is often the case in mathematical textbooks, forward
reasoning may be used in slightly different variants.
One of these variants is to show that the intermediate step <span style="font-style:italic">L</span>
easily implies the initial goal <span style="font-style:italic">G</span>. By easily we mean here that
the proof of <span style="font-style:italic">L</span> ⇒ <span style="font-style:italic">G</span> is shorter than the one of <span style="font-style:italic">L</span>
itself. This kind of reasoning step usually starts with:
“It suffices to show that …”.</p><p>This is such a frequent way of reasoning that <span style="font-variant:small-caps">SSReflect</span> has a variant of the
<span style="font-family:monospace">have</span> tactic called <span style="font-family:monospace">suffices</span> (whose abridged name is
<span style="font-family:monospace">suff</span>). The <span style="font-family:monospace">have</span> and <span style="font-family:monospace">suff</span> tactics are equivalent and
have the same syntax but:
</p><ul class="itemize"><li class="li-itemize">
the order of the generated subgoals is inversed
</li><li class="li-itemize">but the optional clear item is still performed in the
<em>second</em> branch. This means that the tactic:
<div class="lstlisting">  suff {H} H : forall x : nat, x &gt;= 0.</div>fails if the context of the current goal indeed contains an
assumption named <span style="font-family:monospace">H</span>.
</li></ul><p>
The rationale of this clearing policy is to make possible “trivial”
refinements of an assumption, without changing its name in the main
branch of the reasoning.</p><p>The <span style="font-family:monospace">have</span> modifier can follow the <span style="font-family:monospace">suff</span> tactic.
For example, given a goal <span style="font-family:monospace">G</span> the tactic
<span style="font-family:monospace">suff have H : P</span> results in the following two goals:
</p><div class="lstlisting">  H : P |- G
  |- (P -&gt; G) -&gt; G</div><p>Note that, in contrast with <span style="font-family:monospace">have suff</span>, the name <span style="font-family:monospace">H</span> has been introduced
in the first goal.</p><p>Another useful construct is reduction,
showing that a particular case is in fact general enough to prove
a general property. This kind of reasoning step usually starts with:
“Without loss of generality, we can suppose that …”.
Formally, this corresponds to the proof of a goal <span style="font-family:monospace">G</span> by introducing
a cut <span style="font-style:oblique">wlog_statement</span> <span style="font-family:monospace">-&gt; G</span>. Hence the user shall provide a
proof for both <span style="font-family:monospace">(</span><span style="font-style:oblique">wlog_statement</span> <span style="font-family:monospace">-&gt; G) -&gt; G</span> and
<span style="font-style:oblique">wlog_statement</span> <span style="font-family:monospace">-&gt; G</span>. However, such cuts are usually rather
painful to perform by hand, because the statement
<span style="font-style:oblique">wlog_statement</span> is tedious to write by hand, and somtimes even
to read.</p><p><span style="font-variant:small-caps">SSReflect</span> implements this kind of reasoning step through the <span style="font-family:monospace">without loss</span>
tactic, whose short name is <span style="font-family:monospace">wlog</span>. It offers support to describe
the shape of the cut statements, by providing the simplifying
hypothesis and by pointing at the elements of the initial goals which
should be generalized. The general syntax of <span style="font-family:monospace">without loss</span> is:</p><div class="center"><div class="centered">
<span style="font-family:monospace">wlog</span> <span style="font-style:italic">[</span><span style="font-family:monospace">suff</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">i-item</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:</span> <span style="font-style:italic">[</span><span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:italic">]</span> <span style="font-family:monospace">/</span> <span style="font-style:oblique">term</span>
</div></div><p>where <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> are identifiers for constants
in the context of the goal. Open syntax is supported for <span style="font-style:oblique">term</span>.</p><p>In its defective form:</p><div class="center"><div class="centered">
<span style="font-family:monospace">wlog: /</span> <span style="font-style:oblique">term</span>.
</div></div><p>on a goal <span style="font-family:monospace">G</span>, it creates two subgoals: a first one to prove the formula
<span style="font-family:monospace">(</span><span style="font-style:oblique">term</span> <span style="font-family:monospace">-&gt; G) -&gt; G</span> and a second one to prove the formula
<span style="font-style:oblique">term</span> <span style="font-family:monospace">-&gt; G</span>.</p><p>:browse confirm wa
If the optional list <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> is present on the left
side of <span style="font-family:monospace">/</span>, these constants are generalized in the premise
<span style="font-family:monospace">(</span><span style="font-style:oblique">term</span> <span style="font-family:monospace">-&gt; G)</span> of the first subgoal. By default the body of
local definitions is erased. This behavior can be inhibited
prefixing the name of the local definition with the <span style="font-family:monospace">@</span> character.</p><p>In the second subgoal, the tactic:</p><div class="center"><div class="centered">
<span style="font-family:monospace">move=&gt;</span> <span style="font-style:oblique">clear-switch</span> <span style="font-style:oblique">i-item</span><span style="font-family:monospace">.</span>
</div></div><p>is performed if at least one of these optional switches is present in
the <span style="font-family:monospace">wlog</span> tactic.</p><p>The <span style="font-family:monospace">wlog</span> tactic is specially useful when a symmetry argument
simplifies a proof. Here is an example showing the beginning of the
proof that quotient and reminder of natural number euclidean division
are unique.
</p><div class="lstlisting">  Lemma quo_rem_unicity: forall d q1 q2 r1 r2,
     q1*d + r1 = q2*d + r2 -&gt; r1 &lt; d -&gt; r2 &lt; d -&gt; (q1, r1) =  (q2, r2).
  move=&gt; d q1 q2 r1 r2.
  wlog: q1 q2 r1 r2 / q1 &lt;= q2.
    by case (le_gt_dec q1 q2)=&gt; H; last symmetry; eauto with arith.</div><p>The <span style="font-family:monospace">wlog suff</span> variant is simpler, since it cuts
<span style="font-style:oblique">wlog_statement</span> instead of <span style="font-style:oblique">wlog_statement</span> <span style="font-family:monospace">-&gt; G</span>. It thus
opens the goals <span style="font-style:oblique">wlog_statement</span> <span style="font-family:monospace">-&gt; G</span> and <span style="font-style:oblique">wlog_statement</span>.</p><p>In its simplest form
the <span style="font-family:monospace">generally have :...</span> tactic
is equivalent to <span style="font-family:monospace">wlog suff :...</span> followed by <span style="font-family:monospace">last first</span>.
When the <span style="font-family:monospace">have</span> tactic
is used with the <span style="font-family:monospace">generally</span> (or <span style="font-family:monospace">gen</span>) modifier it accepts an
extra identifier followed by a comma before the usual intro pattern.
The identifier will name the new hypothesis in its more general form,
while the intro pattern will be used to process its instance. For example:
</p><div class="lstlisting">  Lemma simple n (ngt0 : 0 &lt; n ) : P n.
  gen have ltnV, /andP[nge0 neq0] : n ngt0 / (0 &lt;= n) &amp;&amp; (n != 0).</div><p>The first subgoal will be
</p><div class="lstlisting">  n : nat
  ngt0 : 0 &lt; n
  ====================
  (0 &lt;= n) &amp;&amp; (n != 0)</div><p>while the second one will be
</p><div class="lstlisting">  n : nat
  ltnV : forall n, 0 &lt; n -&gt; (0 &lt;= n) &amp;&amp; (n != 0)
  nge0 : 0 &lt;= n
  neqn0 : n != 0
  ====================
  P n</div>
<h5 id="sec563" class="paragraph">Advanced generalization</h5>
<p><a id="par:advancedgen"></a>
The complete syntax for the items on the left hand side of the <span style="font-family:monospace">/</span>
separator is the following one:
</p><div class="center"><div class="centered">
<span style="font-style:oblique">clear-switch</span> <span style="font-style:italic">|</span> <span style="font-style:italic">[</span><span style="font-family:monospace">@</span><span style="font-style:italic">]</span> <span style="font-style:oblique">ident</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">(</span><span style="font-style:italic">[</span><span style="font-family:monospace">@</span><span style="font-style:italic">]</span><span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">c-pattern</span><span style="font-family:monospace">)</span>
</div></div><p>
Clear operations are intertwined with generalization operations. This
helps in particular avoiding dependency issues while generalizing some facts.</p><p>If an <span style="font-style:oblique">ident</span> is prefixed with the <span style="font-family:monospace">@</span> prefix mark, then a
let-in redex is created, which keeps track if its body (if any). The
syntax <span style="font-family:monospace">(</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">:=</span><span style="font-style:oblique">c-pattern</span><span style="font-family:monospace">)</span> allows to
generalize an arbitrary term using a given name. Note that its simplest
form <span style="font-family:monospace">(x := y)</span> is just a renaming of <span style="font-family:monospace">y</span> into <span style="font-family:monospace">x</span>. In
particular, this can be useful in order to simulate the generalization
of a section variable, otherwise not allowed. Indeed renaming does not
require the original variable to be cleared.</p><p>The syntax <span style="font-family:monospace">(@x := y)</span> generates a let-in abstraction but with the following
caveat: <span style="font-family:monospace">x</span> will not bind <span style="font-family:monospace">y</span>, but its body, whenever <span style="font-family:monospace">y</span> can be
unfolded. This cover the case of both local and global definitions, as
illustrated in the following example:</p><div class="lstlisting">Section Test.
Variable x : nat.
Definition addx z := z + x.
Lemma test : x &lt;= addx x.
wlog H : (y := x) (@twoy := addx x) / twoy = 2 * y.</div><p>The first subgoal is:
</p><div class="lstlisting">   (forall y : nat, let twoy := y + y in twoy = 2 * y -&gt; y &lt;= twoy) -&gt;
   x &lt;= addx x</div><p>To avoid unfolding the term captured by the pattern <span style="font-family:monospace">add x</span> one
can use the pattern <span style="font-family:monospace">id (addx x)</span>, that would produce the following first
subgoal:
</p><div class="lstlisting">   (forall y : nat, let twoy := addx y in twoy = 2 * y -&gt; y &lt;= twoy) -&gt;
   x &lt;= addx x</div>
<h2 id="sec564" class="section">11.7  Rewriting</h2>
<p><a id="sec:rw"></a>
<a id="hevea_default938"></a><a id="hevea_tactic265"></a></p><p>The generalized use of reflection implies that most of the
intermediate results handled are properties of effectively computable
functions. The most efficient mean of establishing such results are
computation and simplification of expressions involving such
functions, i.e., rewriting. <span style="font-variant:small-caps">SSReflect</span> therefore includes an extended
<span style="font-family:monospace">rewrite</span> tactic, that unifies and combines most of the rewriting
functionalities.
</p>
<h3 id="sec565" class="subsection">11.7.1  An extended <span style="font-family:monospace">rewrite</span> tactic</h3>
<p><a id="ssec:extrw"></a>
The main features of the <span style="font-family:monospace">rewrite</span> tactic are:
</p><ul class="itemize"><li class="li-itemize">
It can perform an entire series of such operations in any
subset of the goal and/or context;
</li><li class="li-itemize">It allows to perform rewriting,
simplifications, folding/unfolding of definitions, closing of goals;
</li><li class="li-itemize">Several rewriting operations can be chained in a single tactic;
</li><li class="li-itemize">Control over the occurrence at which rewriting is to be performed is
significantly enhanced.
</li></ul><p>The general form of an <span style="font-variant:small-caps">SSReflect</span> rewrite tactic is:</p><div class="center"><div class="centered">
<span style="font-family:monospace">rewrite</span> <span style="font-style:oblique">rstep</span><sup>+</sup><span style="font-family:monospace">.</span>
</div></div><p>The combination of a rewrite tactic with the <span style="font-family:monospace">in</span> tactical (see
section <a href="#ssec%3Aloc">11.4.3</a>) performs rewriting in both the context and the
goal.</p><p>A rewrite step <span style="font-style:oblique">rstep</span> has the general form:</p><div class="center"><div class="centered">
<span style="font-style:italic">[</span><span style="font-style:oblique">r-prefix</span><span style="font-style:italic">]</span><span style="font-style:oblique">r-item</span>
</div></div><p>where:</p><p>


</p><blockquote class="table"><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div><div class="center"><div class="centered"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">r-prefix</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >	<span style="font-style:italic">[</span><span style="font-family:monospace">-</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">mult</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">occ-switch</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-family:monospace">[</span><span style="font-style:oblique">r-pattern</span><span style="font-family:monospace">]</span><span style="font-style:italic">]</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">r-pattern</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">in</span> <span style="font-style:italic">[</span><span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span><span style="font-style:italic">]</span> <span style="font-style:oblique">term</span> <span style="font-style:italic">|</span> <span style="font-style:italic">[</span><span style="font-style:oblique">term</span> <span style="font-family:monospace">in</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">as</span> <span style="font-style:italic">]</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:oblique">r-item</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">[</span><span style="font-family:monospace">/</span><span style="font-style:italic">]</span><span style="font-style:oblique">term</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">s-item</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table>

</div></div><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div></blockquote><p>An <span style="font-style:oblique">r-prefix</span> contains annotations to qualify where and how the
rewrite operation should be performed:
</p><ul class="itemize"><li class="li-itemize">
The optional initial <span style="font-family:monospace">-</span> indicates the direction of the rewriting
of <span style="font-style:oblique">r-item</span>: if present the direction is right-to-left and it is
left-to-right otherwise.
</li><li class="li-itemize">The multiplier <span style="font-style:oblique">mult</span> (see section <a href="#ssec%3Aiter">11.6.4</a>)
specifies if and how the rewrite operation should be repeated.
</li><li class="li-itemize">A rewrite operation matches the occurrences of a <em>rewrite
pattern</em>, and replaces these occurrences by an other term, according
to the given <span style="font-style:oblique">r-item</span>.
The optional <em>redex switch</em> <span style="font-family:monospace">[</span><span style="font-style:oblique">r-pattern</span><span style="font-family:monospace">]</span>, which
should always be surrounded by brackets, gives explicitly this
rewrite pattern. In its simplest form, it is a regular term.
If no explicit redex switch
is present the rewrite pattern to be matched is inferred from the
<span style="font-style:oblique">r-item</span>.
</li><li class="li-itemize">This optional <span style="font-style:oblique">term</span>, or
the <span style="font-style:oblique">r-item</span>, may be preceded by an
occurrence switch (see section <a href="#ssec%3Aselect">11.6.3</a>) or a clear item
(see section <a href="#ssec%3Adischarge">11.5.3</a>), these two possibilities being
exclusive. An occurrence switch selects the occurrences of the
rewrite pattern which should be affected by the rewrite operation.
</li></ul><p>An <span style="font-style:oblique">r-item</span> can be:</p><ul class="itemize"><li class="li-itemize">
A <em>simplification r-item</em>, represented by a
<span style="font-style:oblique">s-item</span> (see section <a href="#ssec%3Aintro">11.5.4</a>).
Simplification operations are
intertwined with the possible other rewrite operations specified by
the list of r-items.
</li><li class="li-itemize">A <em>folding/unfolding r-item</em>. The tactic:<p><span style="font-family:monospace">rewrite /</span><span style="font-style:oblique">term</span></p><p>unfolds the head constant of <span style="font-style:italic">term</span> in every occurrence of the
first matching of <span style="font-style:italic">term</span> in the goal. In particular, if
<span style="font-family:monospace">my_def</span> is a (local or global) defined constant, the tactic:
</p><div class="lstlisting">  rewrite /my_def.</div><p>is analogous to:
</p><div class="lstlisting">  unfold my_def.</div><p>Conversely:
</p><div class="lstlisting">  rewrite -/my_def.</div><p>is equivalent to:
</p><div class="lstlisting">  fold my_def.</div><p>When an unfold r-item is combined with a redex pattern, a conversion
operation is performed. A tactic of the form:</p><div class="center"><div class="centered">
<span style="font-family:monospace">rewrite -[</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">]/</span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">.</span>
</div></div><p>is equivalent to:</p><div class="center"><div class="centered">
<span style="font-family:monospace">change</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">with</span> <span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">.</span>
</div></div><p>If <span style="font-style:oblique">term</span><sub>2</sub> is a single constant and <span style="font-style:oblique">term</span><sub>1</sub> head symbol
is not <span style="font-style:oblique">term</span><sub>2</sub>, then the head symbol of <span style="font-style:oblique">term</span><sub>1</sub> is
repeatedly unfolded until <span style="font-style:oblique">term</span><sub>2</sub> appears.</p><div class="lstlisting">  Definition double x := x + x.
  Definition ddouble x := double (double x).
  Lemma ex1 x : ddouble x = 4 * x.
  rewrite [ddouble _]/double.</div><p>The resulting goal is:</p><div class="lstlisting">  double x + double x = 4 * x</div><p><em>Warning</em> The <span style="font-variant:small-caps">SSReflect</span> terms containing holes are <em>not</em>
typed as abstractions in this context. Hence the following script:
</p><div class="lstlisting">  Definition f := fun x y =&gt; x + y.
  Goal forall x y, x +  y = f y x.
  move=&gt; x y.
  rewrite -[f y]/(y + _).</div><p>raises the error message
</p><pre class="verbatim">   User error: fold pattern (y + _) does not match redex (f y)
</pre><p>but the script obtained by replacing the last line with:
</p><div class="lstlisting">  rewrite -[f y x]/(y + _).</div><p>is valid.</p></li><li class="li-itemize">A term, which can be:
<ul class="itemize"><li class="li-itemize">
A term whose type has the form:
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:monospace">forall</span> (<span style="font-style:italic">x</span><sub>1</sub> : <span style="font-style:italic">A</span><sub>1</sub>)…(<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> : <span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>), <span style="font-style:italic">eq</span> <span style="font-style:italic">term</span><sub>1</sub> <span style="font-style:italic">term</span><sub>2</sub></td></tr>
</table>
where <span style="font-style:italic">eq</span> is the Leibniz equality or a registered setoid
equality. </li><li class="li-itemize">A list of terms (<span style="font-style:italic">t</span><sub>1</sub>,…,<span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>), each <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub> having a type of the
form: <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:monospace">forall</span> (<span style="font-style:italic">x</span><sub>1</sub> : <span style="font-style:italic">A</span><sub>1</sub>)…(<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> : <span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>), <span style="font-style:italic">eq</span> <span style="font-style:italic">term</span><sub>1</sub> <span style="font-style:italic">term</span><sub>2</sub></td></tr>
</table> where
<span style="font-style:italic">eq</span> is the Leibniz equality or a registered setoid
equality. The tactic:<div class="center"><div class="centered"><span style="font-family:monospace">rewrite</span> <span style="font-style:oblique">r-prefix</span><span style="font-family:monospace">(</span><span style="font-style:italic">t</span><sub>1</sub><span style="font-family:monospace">,</span>…<span style="font-family:monospace">,</span><span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">).</span></div></div><p>is equivalent to:</p><div class="center"><div class="centered"><span style="font-family:monospace">do [rewrite</span> <span style="font-style:oblique">r-prefix</span> <span style="font-style:italic">t</span><sub>1</sub> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> rewrite</div></div><p> <span style="font-style:oblique">r-prefix</span> <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">].</span></p></li><li class="li-itemize">An anonymous rewrite lemma
<span style="font-family:monospace">(_ :</span> <span style="font-style:oblique">term</span>), where <span style="font-style:italic">term</span> has again the form:
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:monospace">forall</span> (<span style="font-style:italic">x</span><sub>1</sub> : <span style="font-style:italic">A</span><sub>1</sub>)…(<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> : <span style="font-style:italic">A</span><sub><span style="font-style:italic">n</span></sub>), <span style="font-style:italic">eq</span> <span style="font-style:italic">term</span><sub>1</sub> <span style="font-style:italic">term</span><sub>2</sub></td></tr>
</table>
The tactic:<div class="center"><div class="centered"><span style="font-family:monospace">rewrite (_ :</span> <span style="font-style:oblique">term</span><span style="font-family:monospace">)</span></div></div><p>is in fact synonym of:</p><div class="center"><div class="centered"><span style="font-family:monospace">cutrewrite (</span><span style="font-style:oblique">term</span><span style="font-family:monospace">).</span></div></div></li></ul></li></ul>
<h3 id="sec566" class="subsection">11.7.2  Remarks and examples</h3>
<p><a id="ssec:rwex"></a></p><h4 id="sec567" class="subsubsection">Rewrite redex selection</h4>
<p>
The general strategy of <span style="font-variant:small-caps">SSReflect</span>
is to grasp as many redexes as possible and to let the user select the
ones to be rewritten thanks to the improved syntax for the control of
rewriting.</p><p>This may be a source of incompatibilities between the two <span style="font-family:monospace">rewrite</span>
tactics.</p><p>In a rewrite tactic of the form:</p><p><span style="font-family:monospace">rewrite</span> <span style="font-style:oblique">occ-switch</span><span style="font-family:monospace">[</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">]</span><span style="font-style:oblique">term</span><sub>2</sub>.</p><p><span style="font-style:oblique">term</span><sub>1</sub> is the explicit rewrite redex and
<span style="font-style:oblique">term</span><sub>2</sub> is the
rewrite rule. This execution of this tactic unfolds as follows:</p><ul class="itemize"><li class="li-itemize">
First <span style="font-style:oblique">term</span><sub>1</sub> and <span style="font-style:oblique">term</span><sub>2</sub> are βι normalized. Then
<span style="font-style:oblique">term</span><sub>2</sub> is put in head normal form if the Leibniz equality
constructor <span style="font-family:monospace">eq</span> is not the head symbol. This may involve ζ
reductions.
</li><li class="li-itemize">Then, the matching algorithm (see section <a href="#ssec%3Aset">11.4.2</a>)
determines the first subterm of the goal matching the rewrite pattern.
The rewrite pattern is
given by <span style="font-style:oblique">term</span><sub>1</sub>, if an explicit redex pattern switch is provided, or by
the type of <span style="font-style:oblique">term</span><sub>2</sub> otherwise. However, matching skips over
matches that would lead to trivial rewrites. All the
occurrences of this subterm in the goal are candidates for rewriting.
</li><li class="li-itemize">Then only the occurrences coded by <span style="font-style:oblique">occ-switch</span> (see again
section <a href="#ssec%3Aset">11.4.2</a>) are finally selected for rewriting.
</li><li class="li-itemize">The left hand side of <span style="font-style:oblique">term</span><sub>2</sub> is unified with the subterm found
by the matching algorithm, and if this succeeds, all the selected
occurrences in the goal are replaced by the right hand side of
<span style="font-style:oblique">term</span><sub>2</sub>.
</li><li class="li-itemize">Finally the goal is βι normalized.
</li></ul><p>In the case <span style="font-style:oblique">term</span><sub>2</sub> is a list of terms, the first top-down (in
the goal) left-to-right (in the list) matching rule gets selected.</p><h4 id="sec568" class="subsubsection">Chained rewrite steps</h4>
<p>The possibility to chain rewrite operations in a single tactic makes
scripts more compact and gathers in a single command line a bunch
of surgical
operations which would be described by a one sentence in a pen and
paper proof.</p><p>Performing rewrite and simplification operations in a single tactic
enhances significantly the concision of scripts. For instance the
tactic:
</p><div class="lstlisting">  rewrite /my_def {2}[f _]/= my_eq //=.</div><p>unfolds <span style="font-family:monospace">my_def</span> in the goal, simplifies the second occurrence of the
first subterm matching pattern <span style="font-family:monospace">[f _]</span>, rewrites <span style="font-family:monospace">my_eq</span>,
simplifies the whole goal and closes trivial goals.</p><p>Here are some concrete examples of chained rewrite operations, in the
proof of basic results on natural numbers arithmetic:</p><div class="lstlisting">  Lemma addnS : forall m n, m + n.+1 = (m + n).+1.
  Proof. by move=&gt; m n; elim: m. Qed.

  Lemma addSnnS : forall m n, m.+1 + n = m + n.+1.
  Proof. move=&gt; *; rewrite addnS; apply addSn. Qed.

  Lemma addnCA : forall m n p, m + (n + p) = n + (m + p).
  Proof. by move=&gt; m n; elim: m =&gt; [|m Hrec] p; rewrite ?addSnnS -?addnS. Qed.

  Lemma addnC : forall m n, m + n = n + m.
  Proof. by move=&gt; m n; rewrite -{1}[n]addn0 addnCA addn0. Qed.</div><p>Note the use of the <span style="font-family:monospace">?</span> switch for parallel rewrite operations in
the proof of <span style="font-family:monospace">|*addnCA*|</span>.</p><h4 id="sec569" class="subsubsection">Explicit redex switches are matched first</h4>
<p>
If an <span style="font-style:oblique">r-prefix</span> involves a <em>redex switch</em>, the first step is to
find a subterm matching this redex pattern, independently from the left hand
side <span style="font-family:monospace">t1</span> of the equality the user wants to rewrite.</p><p>For instance, if <code>H</code><code> : </code><code>forall</code><code> </code><code>t</code><code> </code><code>u</code><code>, </code><code>t</code><code> + </code><code>u</code><code> = </code><code>u</code><code> + </code><code>t</code> is in the context of a
goal <code>x</code><code> + </code><code>y</code><code> = </code><code>y</code><code> + </code><code>x</code>, the tactic:
</p><div class="lstlisting">  rewrite [y + _]H.</div><p>transforms the goal into <code>x</code><code> + </code><code>y</code><code> = </code><code>x</code><code> + </code><code>y</code>.</p><p>Note that if this first pattern matching is not compatible with the
<em>r-item</em>, the rewrite fails, even if the goal contains a correct
redex matching both the redex switch and the left hand side of the
equality. For instance, if <code>H</code><code> : </code><code>forall</code><code> </code><code>t</code><code> </code><code>u</code><code>, </code><code>t</code><code> + </code><code>u</code><code> * 0 = </code><code>t</code> is
in the context of a goal <code>x</code><code> + </code><code>y</code><code> * 4 + 2 * 0 = </code><code>x</code><code> + 2 * 0</code>, then tactic:
</p><div class="lstlisting">  rewrite [x + _]H.</div><p>raises the error message:
</p><pre class="verbatim">  User error: rewrite rule H doesn't match redex (x + y * 4)
</pre><p>while the tactic:
</p><div class="lstlisting">  rewrite (H _ 2).</div><p>transforms the goal into <code>x</code><code> + </code><code>y</code><code> * 4 = </code><code>x</code><code> + 2 * 0</code>.</p><h4 id="sec570" class="subsubsection">Occurrence switches and redex switches</h4>
<p>
The tactic:
</p><div class="lstlisting">  rewrite {2}[_ + y + 0](_: forall z, z + 0 = z).</div><p>transforms the goal:
</p><div class="lstlisting">  x + y + 0 = x + y + y + 0 + 0 + (x + y + 0)</div><p>into:
</p><div class="lstlisting">  x + y + 0 = x + y + y + 0 + 0 + (x + y)</div><p>and generates a second subgoal:
</p><div class="lstlisting">  forall z : nat, z + 0 = z</div><p>The second subgoal is generated by the use of an anonymous lemma in
the rewrite tactic. The effect of the tactic on the initial goal is to
rewrite this lemma at the second occurrence of the first matching
<code>x</code><code> + </code><code>y</code><code> + 0</code> of the explicit rewrite redex <code>_</code><code> + </code><code>y</code><code> + 0</code>.</p><h4 id="sec571" class="subsubsection">Occurrence selection and repetition</h4>
<p>
Occurrence selection has priority over repetition switches. This means
the repetition of a rewrite tactic specified by a multiplier
will perform matching each time an elementary rewrite operation is
performed. Repeated rewrite tactics apply to every subgoal generated
by the previous tactic, including the previous instances of the
repetition. For example:
</p><div class="lstlisting">  Goal forall x y z : nat,  x + 1 = x + y + 1.
  move=&gt; x y z.</div><p>creates a goal <span style="font-family:monospace"> x + 1 = x + y + 1</span>, which is turned into <span style="font-family:monospace">z = z</span>
by the additional tactic:
</p><div class="lstlisting">  rewrite 2!(_ : _ + 1 = z).</div><p>In fact, this last tactic generates <em>three</em> subgoals,
respectively
<span style="font-family:monospace"> x + y + 1 = z</span>, <span style="font-family:monospace"> z = z</span> and <span style="font-family:monospace">x + 1 = z</span>. Indeed, the second
rewrite operation specified with the <span style="font-family:monospace">2!</span> multiplier applies to
the two subgoals generated by the first rewrite.</p><h4 id="sec572" class="subsubsection">Multi-rule rewriting</h4>
<p>
The <span style="font-family:monospace">rewrite</span> tactic can be provided a <em>tuple</em> of rewrite rules,
or more generally a tree of such rules, since this tuple can feature
arbitrary inner parentheses. We call <em>multirule</em> such a
generalized rewrite rule. This feature is of special interest when it
is combined with multiplier switches, which makes the <span style="font-family:monospace">rewrite</span>
tactic iterates the rewrite operations prescribed by the rules on the
current goal. For instance, let us define two triples <span style="font-family:monospace">multi1</span> and
<span style="font-family:monospace">multi2</span> as:
</p><div class="lstlisting">  Variables (a b c : nat).

  Hypothesis eqab : a = b.

  Hypothesis eqac : a = c.</div><p>Executing the tactic:
</p><div class="lstlisting">  rewrite (eqab, eqac)</div><p>on the goal:
</p><div class="lstlisting">  =========
  a = a</div><p>turns it into <span style="font-family:monospace">b = b</span>, as rule <span style="font-family:monospace">eqab</span> is the first to apply among
the ones gathered in the tuple passed to the <span style="font-family:monospace">rewrite</span>
tactic. This multirule <span style="font-family:monospace">(eqab, eqac)</span> is actually a <span style="font-variant:small-caps">Coq</span> term and we
can name it with a definition:
</p><div class="lstlisting">Definition multi1 := (eqab, eqac).</div><p>In this case, the tactic <span style="font-family:monospace">rewrite multi1</span> is a synonym for
<span style="font-family:monospace">(eqab, eqac)</span>. More precisely, a multirule rewrites
the first subterm to which one of the rules applies in a left-to-right
traversal of the goal, with the first rule from the multirule tree in
left-to-right order. Matching is performed according to the algorithm
described in Section <a href="#ssec%3Aset">11.4.2</a>, but literal matches have
priority. For instance if we add a definition and a new multirule to
our context:</p><div class="lstlisting">  Definition d := a.

  Hypotheses eqd0 : d = 0.

  Definition multi2 := (eqab, eqd0).</div><p>then executing the tactic:
</p><div class="lstlisting">   rewrite multi2.</div><p>on the goal:
</p><div class="lstlisting">  =========
  d = b</div><p>turns it into <span style="font-family:monospace">0 = b</span>, as rule <span style="font-family:monospace">eqd0</span> applies without unfolding
the definition of <span style="font-family:monospace">d</span>. For repeated rewrites the selection process
is repeated anew. For instance, if we define:</p><div class="lstlisting">   Hypothesis eq_adda_b : forall x, x + a = b.

   Hypothesis eq_adda_c : forall x, x + a = c.

   Hypothesis eqb0 : b = 0.

   Definition multi3 := (eq_adda_b, eq_adda_c, eqb0).</div><p>then executing the tactic:
</p><div class="lstlisting">  rewrite 2!multi3.</div><p>on the goal:
</p><div class="lstlisting">  =========
  1 + a = 12 + a</div><p>turns it into <span style="font-family:monospace">0 = 12 + a</span>: it uses <span style="font-family:monospace">eq_adda_b</span> then <span style="font-family:monospace">eqb0</span> on the
left-hand side only. Now executing the tactic <span style="font-family:monospace">rewrite !multi3</span>
turns the same goal into <span style="font-family:monospace">0 = 0</span>.</p><p>The grouping of rules inside a multirule does not affect the selection
strategy but can make it easier to include one rule set in another or
to (universally) quantify over the parameters of a subset of rules (as
there is special code that will omit unnecessary quantifiers for rules that
can be syntactically extracted). It is also possible to
reverse the direction of a rule subset, using a special dedicated syntax:
the tactic <span style="font-family:monospace">rewrite (=  multi1)</span> is equivalent to
<span style="font-family:monospace">rewrite multi1_rev</span> with:
</p><div class="lstlisting">  Hypothesis eqba : b = a.

  Hypothesis eqca : c = a.

  Definition multi1_rev := (eqba, eqca).</div><p>except that the constants <span style="font-family:monospace">eqba, eqab, mult1_rev</span> have not been created.</p><p>Rewriting with multirules is useful to implement simplification or
transformation procedures, to be applied on terms of small to medium
size. For instance, the library <code>ssrnat</code> — available in the
external math-comp library — provides two implementations for
arithmetic operations on natural numbers: an elementary one and a tail
recursive version, less inefficient but also less convenient for
reasoning purposes. The library also provides one lemma per such
operation, stating that both versions return the same values when
applied to the same arguments:</p><div class="lstlisting">  Lemma addE : add =2 addn.
  Lemma doubleE : double =1 doublen.
  Lemma add_mulE n m s : add_mul n m s = addn (muln n m) s.
  Lemma mulE : mul =2 muln.
  Lemma mul_expE m n p : mul_exp m n p = muln (expn m n) p.
  Lemma expE : exp =2 expn.
  Lemma oddE : odd =1 oddn.</div><p>The operation on the left hand side of each lemma is the efficient
version, and the corresponding naive implementation is on the right
hand side. In order to reason conveniently on expressions involving
the efficient operations, we gather all these rules in the
definition <span style="font-family:monospace">|*trecE*|</span>:
</p><div class="lstlisting"> Definition trecE := (addE, (doubleE, oddE), (mulE, add_mulE, (expE, mul_expE))).</div><p>The tactic:
</p><div class="lstlisting">  rewrite !trecE.</div><p>restores the naive versions of each operation in a goal involving the
efficient ones, e.g. for the purpose of a correctness proof.</p><h4 id="sec573" class="subsubsection">Wildcards vs abstractions</h4>
<p>
The <span style="font-family:monospace">rewrite</span> tactic supports r-items containing holes. For example
in the tactic (1):
</p><div class="lstlisting">  rewrite (_ : _ * 0 = 0).</div><p>the term <span style="font-family:monospace">_ * 0 = 0</span> is interpreted as <span style="font-family:monospace">forall n : nat, n * 0 = 0</span>.
Anyway this tactic is <em>not</em> equivalent to the tactic (2):
</p><div class="lstlisting">  rewrite (_ : forall x, x * 0 = 0).</div><p>The tactic (1) transforms the goal
<code>(</code><code>y</code><code> * 0) + </code><code>y</code><code> * (</code><code>z</code><code> * 0) = 0</code> into <span style="font-family:monospace">y * (z * 0) = 0</span>
and generates a new subgoal to prove the statement <span style="font-family:monospace">y * 0 = 0</span>,
which is the <em>instance</em> of the<br>
<span style="font-family:monospace">forall x, x * 0 = 0</span>
rewrite rule that
has been used to perform the rewriting. On the other hand, tactic
(2) performs the same rewriting on the current goal but generates a
subgoal to prove <span style="font-family:monospace">forall x, x * 0 = 0</span>.</p><h4 id="sec574" class="subsubsection">When <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">rewrite</span> fails on standard <span style="font-variant:small-caps">Coq</span> licit rewrite</h4>
<p>
In a few cases, the <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">rewrite</span> tactic fails
rewriting some redexes which standard <span style="font-variant:small-caps">Coq</span> successfully rewrites.
There are two main cases:</p><ul class="itemize"><li class="li-itemize">
<span style="font-variant:small-caps">SSReflect</span> never accepts to rewrite indeterminate patterns like:
<div class="lstlisting">  Lemma foo : forall x : unit, x = tt.</div><span style="font-variant:small-caps">SSReflect</span> will however accept the ηζ expansion of this rule:
<div class="lstlisting">  Lemma fubar : forall x : unit, (let u := x in u) = tt.</div></li><li class="li-itemize">In standard <span style="font-variant:small-caps">Coq</span>, suppose that we work in the following context:
<div class="lstlisting">  Variable g : nat -&gt; nat.
  Definition f := g.</div>then rewriting <span style="font-family:monospace">H : forall x, f x = 0</span> in the goal
<span style="font-family:monospace">g 3 + g 3 = g 6</span> succeeds
and transforms the goal into <span style="font-family:monospace">0 + 0 = g 6</span>.<p>This rewriting is not possible in <span style="font-variant:small-caps">SSReflect</span> because there is no
occurrence of the head symbol <span style="font-family:monospace">f</span> of the rewrite rule in the
goal. Rewriting with <span style="font-family:monospace">H</span> first requires unfolding the occurrences of
<span style="font-family:monospace">f</span> where the substitution is to be performed (here there is a single
such occurrence), using tactic <span style="font-family:monospace">rewrite /f</span> (for a global
replacement of <span style="font-family:monospace">f</span> by <span style="font-family:monospace">g</span>) or <span style="font-family:monospace">rewrite </span> <span style="font-style:oblique">pattern</span><span style="font-family:monospace">/f</span>, for a
finer selection.
</p></li></ul><h4 id="sec575" class="subsubsection">Existential metavariables and rewriting</h4>
<p>
<a id="ssec:rewcaveats"></a>
The <span style="font-family:monospace">rewrite</span> tactic will not instantiate existing existential
metavariables when matching a redex pattern.</p><p>If a rewrite rule generates a goal
with new existential metavariables, these will be generalized as for <span style="font-family:monospace">apply</span>
(see page <a href="#sssec%3Aapply">??</a>) and corresponding new goals will be generated.
For example, consider the following script:</p><div class="lstlisting">  Lemma ex3 (x : 'I_2) y (le_1 : y &lt; 1) (E : val x = y) : Some x = insub y.
  rewrite insubT ?(leq_trans le_1)// =&gt; le_2.</div><p>Since <span style="font-family:monospace">insubT</span> has the following type:</p><div class="lstlisting">  forall T P (sT : subType P) (x : T) (Px : P x), insub x = Some (Sub x Px)</div><p>and since the implicit argument corresponding to the <span style="font-family:monospace">Px</span> abstraction is not
supplied by the user, the resulting goal should be <span style="font-family:monospace">Some x = Some (Sub y
</span>  ?<sub><span style="font-style:italic">Px</span></sub><span style="font-family:monospace">)</span>. Instead, <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">rewrite</span> tactic generates the two following
goals:
</p><div class="lstlisting">  y &lt; 2
  forall Hyp0 : y &lt; 2, Some x = Some (Sub y Hyp0)</div><p>The script closes the former with <span style="font-family:monospace">?(leq_trans le_1)//</span>, then it introduces
the new generalization naming it <span style="font-family:monospace">le_2</span>.</p><div class="lstlisting">  x : 'I_2
  y : nat
  le_1 : y &lt; 1
  E : val x = y
  le_2 : y &lt; 2
  ============================
   Some x = Some (Sub y le_2)</div><p>As a temporary limitation, this behavior is available only if the rewriting
rule is stated using Leibniz equality (as opposed to setoid relations).
It will be extended to other rewriting relations in the future.</p>
<h3 id="sec576" class="subsection">11.7.3  Locking, unlocking</h3>
<p> <a id="ssec:lock"></a></p><p>As program proofs tend to generate large goals, it is important to be
able to control the partial evaluation performed by the simplification
operations that are performed by the tactics. These evaluations can
for example come from a <span style="font-family:monospace">/=</span> simplification switch, or from rewrite steps
which may expand large terms while performing conversion. We definitely
want to avoid repeating large subterms of the goal in
the proof script. We do this by
“clamping down” selected function symbols in the goal, which
prevents them from
being considered in simplification or rewriting steps. This clamping
is accomplished by using the occurrence switches (see section
<a href="#sssec%3Aoccselect">11.4.2</a>) together with “term tagging” operations.</p><p><span style="font-variant:small-caps">SSReflect</span> provides two levels of tagging.</p><p>The first one uses auxiliary definitions to introduce a provably equal
copy of any term <span style="font-family:monospace">t</span>. However this copy is (on purpose)
<em>not convertible</em> to <span style="font-family:monospace">t</span> in the <span style="font-variant:small-caps">Coq</span> system<sup><a id="text23" href="#note23">8</a></sup>. The job is done by the following construction:</p><div class="lstlisting">  Lemma master_key : unit. Proof. exact tt. Qed.
  Definition locked A := let: tt := master_key in fun x : A =&gt; x.
  Lemma lock : forall A x, x = locked x :&gt; A.</div><p>Note that the definition of <span style="font-family:monospace">|*master_key*|</span> is explicitly opaque.
The equation <span style="font-family:monospace">t = locked t</span> given by the <span style="font-family:monospace">lock</span> lemma can be used
for selective rewriting, blocking on the fly the reduction in the
term <span style="font-family:monospace">t</span>.
For example the script:
</p><div class="lstlisting">  Require Import List.
  Variable A : Type.

  Fixpoint my_has (p : A -&gt; bool)(l : list A){struct l} : bool:=
    match l with
      |nil =&gt; false
      |cons x l =&gt; p x || (my_has p l)
    end.

  Goal forall a x y l, a x = true -&gt; my_has a ( x :: y :: l) = true.
  move=&gt; a x y l Hax.</div><p>where <code>||</code> denotes the boolean disjunction, results in a goal
<span style="font-family:monospace">my_has a ( x :: y :: l) = true</span>. The tactic:
</p><div class="lstlisting">  rewrite {2}[cons]lock /= -lock.</div><p>turns it into <span style="font-family:monospace">a x || my_has a (y :: l) = true</span>.
Let us now start by reducing the initial goal without blocking reduction.
The script:
</p><div class="lstlisting">  Goal forall a x y l, a x = true -&gt; my_has a ( x :: y :: l) = true.
  move=&gt; a x y l Hax /=.</div><p>creates a goal <span style="font-family:monospace">(a x) || (a y) || (my_has a l) = true</span>. Now the
tactic:
</p><div class="lstlisting">  rewrite {1}[orb]lock orbC -lock.</div><p>where <span style="font-family:monospace">orbC</span> states the commutativity of <span style="font-family:monospace">orb</span>, changes the
goal into<br>
<span style="font-family:monospace">(a x) || (my_has a l) || (a y) = true</span>: only the
arguments of the second disjunction where permuted.</p><p>It is sometimes desirable to globally prevent a definition from being
expanded by simplification; this is done by adding <span style="font-family:monospace">locked</span> in the
definition.</p><p>For instance, the function <span style="font-family:monospace">|*fgraph_of_fun*|</span> maps a function whose
domain and codomain are finite types to a concrete representation of
its (finite) graph. Whatever implementation of this transformation we
may use, we want it to be hidden to simplifications and tactics, to
avoid the collapse of the graph object:
</p><div class="lstlisting">  Definition fgraph_of_fun :=
    locked
    (fun (d1 :finType) (d2 :eqType) (f : d1 -&gt; d2) =&gt; Fgraph (size_maps f _)).</div><p>We provide a special tactic <span style="font-family:monospace">unlock</span> for unfolding such definitions
while removing “locks”, e.g., the tactic:</p><p><span style="font-family:monospace">unlock</span> <span style="font-style:oblique">occ-switch</span><span style="font-family:monospace">fgraph_of_fun</span>.</p><p>replaces the occurrence(s) of <span style="font-family:monospace">fgraph_of_fun</span> coded by the <span style="font-style:oblique">occ-switch</span>
with <span style="font-family:monospace">(Fgraph (size_maps _ _))</span> in the goal.</p><p>We found that it was usually preferable to prevent the expansion of
some functions by the partial evaluation switch “/=”, unless
this allowed the evaluation of a condition. This is possible thanks to
an other mechanism of term tagging, resting on the following
<em>Notation</em>:
</p><div class="lstlisting">  Notation "'nosimpl' t" := (let: tt := tt in t).</div><p>The term <span style="font-family:monospace">(nosimpl t)</span> simplifies to t <em>except</em> in a
definition. More precisely,
given:
</p><div class="lstlisting">  Definition foo := (nosimpl bar).</div><p>the term <span style="font-family:monospace">foo (or (foo t’))</span> will <em>not</em> be expanded by the
<em>simpl</em> tactic unless it is in a forcing context (e.g., in
<span style="font-family:monospace">match foo t’ with </span>…<span style="font-family:monospace"> end</span>, <span style="font-family:monospace">foo t’</span> will be reduced if this allows
<span style="font-family:monospace">match</span> to be reduced). Note that <span style="font-family:monospace">nosimpl bar</span> is simply notation
for a term that reduces to <span style="font-family:monospace">bar</span>; hence <span style="font-family:monospace">unfold foo</span> will replace
<span style="font-family:monospace">foo</span> by <span style="font-family:monospace">bar</span>, and <span style="font-family:monospace">fold foo</span> will replace <span style="font-family:monospace">bar</span> by
<span style="font-family:monospace">foo</span>.</p><p><em>Warning</em> The <span style="font-family:monospace">nosimpl</span> trick only works if no reduction is
apparent in <span style="font-family:monospace">t</span>; in particular, the declaration:
</p><div class="lstlisting">  Definition foo x := nosimpl (bar x).</div><p>will usually not work. Anyway, the common practice is to tag only the
function, and to use the following definition, which blocks the
reduction as expected:
</p><div class="lstlisting">  Definition foo x := nosimpl bar x.</div><p>A standard example making this technique shine is the case of
arithmetic operations. We define for instance:
</p><div class="lstlisting">  Definition addn := nosimpl plus.</div><p>The operation <span style="font-family:monospace">addn</span> behaves exactly like plus, except that
<span style="font-family:monospace">(addn (S n) m)</span> will not
simplify spontaneously to <span style="font-family:monospace">(S (addn n m))</span> (the two terms, however, are
inter-convertible). In addition, the unfolding step:
</p><div class="lstlisting">rewrite /addn</div><p>will replace <span style="font-family:monospace">addn</span> directly with <span style="font-family:monospace">plus</span>, so the <span style="font-family:monospace">nosimpl</span> form
is essentially invisible.</p>
<h3 id="sec577" class="subsection">11.7.4  Congruence</h3>
<p><a id="ssec:congr"></a></p><p>Because of the way matching interferes with type families parameters,
the tactic:
</p><div class="lstlisting">  apply: my_congr_property.</div><p>will generally fail to perform congruence simplification, even on
rather simple cases. We therefore provide a
more robust alternative in which the function is supplied:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:monospace">congr</span> [<span style="font-style:oblique">int</span>] <span style="font-style:oblique">term</span></td></tr>
</table><p>This tactic:
</p><ul class="itemize"><li class="li-itemize">
checks that the goal is a Leibniz equality
</li><li class="li-itemize">matches both sides of this equality with “<span style="font-style:oblique">term</span> applied to
some arguments”, inferring the right number of arguments from the goal
and the type of <span style="font-style:oblique">term</span>. This may
expand some definitions or fixpoints.
</li><li class="li-itemize">generates the subgoals corresponding to pairwise equalities of
the arguments present in the goal.
</li></ul><p>The goal can be a non dependent product <span style="font-family:monospace">P -&gt; Q</span>.
In that case, the system asserts the equation <span style="font-family:monospace">P = Q</span>, uses it to solve
the goal, and calls the <span style="font-family:monospace">congr</span> tactic on the remaining goal
<span style="font-family:monospace">P = Q</span>. This can be useful for instance to perform a transitivity
step, like in the following situation:
</p><div class="lstlisting">  x, y, z : nat
  ===============
  x = y -&gt; x = z</div><p>the tactic <span style="font-family:monospace">congr (_ = _)</span> turns this goal into:</p><div class="lstlisting">  x, y, z : nat
  ===============
  y = z</div><p>which can also be obtained starting from:
</p><div class="lstlisting">  x, y, z : nat
  h : x = y
  ===============
  x = z</div><p>and using the tactic <span style="font-family:monospace">congr (_ = _): h</span>.</p><p>The optional <span style="font-style:oblique">int</span> forces the number of arguments for which the
tactic should generate equality proof obligations.</p><p>This tactic supports equalities between applications with dependent
arguments. Yet dependent arguments should have exactly the same
parameters on both sides, and these parameters should appear as first
arguments.</p><p>The following script:
</p><div class="lstlisting">  Definition f n := match n with 0 =&gt; plus | S _ =&gt; mult end.
  Definition g (n m : nat) := plus.

  Goal forall x y, f 0 x y = g 1 1 x y.
  by move=&gt; x y; congr plus.
  Qed.</div><p>shows that the <span style="font-family:monospace">congr</span> tactic matches <span style="font-family:monospace">plus</span> with <span style="font-family:monospace">f 0</span> on the
left hand side and <span style="font-family:monospace">g 1 1</span> on the right hand side, and solves the goal.</p><p>The script:
</p><div class="lstlisting">  Goal forall n m, m &lt;= n -&gt; S m + (S n - S m) = S n.
  move=&gt; n m Hnm; congr S; rewrite -/plus.</div><p>generates the subgoal <span style="font-family:monospace">m + (S n - S m) = n</span>. The tactic
<span style="font-family:monospace">rewrite -/plus</span> folds back the expansion of <span style="font-family:monospace">plus</span> which was
necessary for matching both sides of the equality with an application
of <span style="font-family:monospace">S</span>.</p><p>Like most <span style="font-variant:small-caps">SSReflect</span> arguments, <span style="font-style:oblique">term</span> can contain wildcards.
The script:
</p><div class="lstlisting">  Goal forall x y, x + (y * (y + x - x)) = x * 1 + (y + 0) * y.
  move=&gt; x y; congr ( _ + (_ * _)).</div><p>generates three subgoals, respectively <span style="font-family:monospace">x = x * 1</span>, <span style="font-family:monospace">y = y + 0</span>
and <span style="font-family:monospace"> y + x - x = y</span>.
</p>
<h2 id="sec578" class="section">11.8  Contextual patterns</h2>
<p>
<a id="ssec:rewp"></a></p><p>The simple form of patterns used so far, <span style="font-style:oblique">term</span><span style="font-style:italic">s</span> possibly containing
wild cards, often require an additional <span style="font-style:oblique">occ-switch</span> to be specified.
While this may work pretty fine for small goals, the use of polymorphic
functions and dependent types may lead to an invisible duplication of functions
arguments. These copies usually end up in types hidden by the implicit
arguments machinery or by user defined notations. In these situations
computing the right occurrence numbers is very tedious because they must be
counted on the goal as printed after setting the <span style="font-family:monospace">Printing All</span> flag.
Moreover the resulting script is not really informative for the reader, since
it refers to occurrence numbers he cannot easily see.</p><p>Contextual patterns mitigate these issues allowing to specify occurrences
according to the context they occur in.</p>
<h3 id="sec579" class="subsection">11.8.1  Syntax</h3>
<p>The following table summarizes the full syntax of
<span style="font-style:oblique">c-pattern</span> and the corresponding subterm(s) identified
by the pattern.
In the third column we use s.m.r. for
“the subterms matching the redex” specified in the second column.</p><div class="center"><div class="centered">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">c-pattern</span></td><td style="vertical-align:top;text-align:left;white-space:nowrap" >redex</td><td style="vertical-align:top;text-align:left;" >subterms affected </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span></td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span></td><td style="vertical-align:top;text-align:left;" >all occurrences of <span style="font-style:oblique">term</span></td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="vertical-align:top;text-align:left;white-space:nowrap" > subterm of <span style="font-style:oblique">term</span> selected by <span style="font-style:oblique">ident</span></td><td style="vertical-align:top;text-align:left;" > all the subterms identified by <span style="font-style:oblique">ident</span> in all
the occurrences of <span style="font-style:oblique">term</span> </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">in</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span><sub>2</sub></td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span><sub>1</sub></td><td style="vertical-align:top;text-align:left;" > in all s.m.r. in all the subterms identified by <span style="font-style:oblique">ident</span> in all
the occurrences of <span style="font-style:oblique">term</span><sub>2</sub> </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">as</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span><sub>2</sub></td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span><sub>1</sub></td><td style="vertical-align:top;text-align:left;" > in all the subterms identified by <span style="font-style:oblique">ident</span> in all
the occurrences of <span style="font-style:oblique">term</span><sub>2</sub>[<span style="font-style:oblique">term</span><sub>1</sub>/<span style="font-style:oblique">ident</span>]</td></tr>
<tr><td class="hbar" colspan=3></td></tr>
</table>
</div></div><p>The <span style="font-family:monospace">rewrite</span> tactic supports two more patterns obtained
prefixing the first two with <span style="font-family:monospace">in</span>. The intended meaning is that the
pattern identifies all subterms of the specified context. The
<span style="font-family:monospace">rewrite</span> tactic will infer a pattern for the redex looking at the
rule used for rewriting.</p><div class="center"><div class="centered">
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-style:oblique">r-pattern</span></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" >redex</td><td style="vertical-align:middle;text-align:left;border:solid 1px;" >subterms affected </td></tr>
<tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" >inferred from rule</td><td style="vertical-align:middle;text-align:left;border:solid 1px;" > in all s.m.r. in all occurrences of <span style="font-style:oblique">term</span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-family:monospace">in</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" >inferred from rule</td><td style="vertical-align:middle;text-align:left;border:solid 1px;" > in all s.m.r. in all the subterms identified by <span style="font-style:oblique">ident</span> in all
the occurrences of <span style="font-style:oblique">term</span> </td></tr>
</table>
</div></div><p>The first <span style="font-style:oblique">c-pattern</span> is the simplest form matching any
context but selecting a specific redex and has been described in the
previous sections. We have seen so far that the possibility of
selecting a redex using a term with holes is already a powerful mean of redex
selection. Similarly, any <span style="font-style:oblique">term</span>s provided by the
user in the more complex forms of <span style="font-style:oblique">c-pattern</span>s presented in the
tables above can contain holes.</p><p>For a quick glance at what can be expressed with the last
<span style="font-style:oblique">r-pattern</span> consider the goal <span style="font-family:monospace">a = b</span> and the tactic
</p><div class="lstlisting">  rewrite [in X in _ = X]rule.</div><p>It rewrites all occurrences of the left hand side of <span style="font-family:monospace">rule</span> inside
<span style="font-family:monospace">b</span> only (<span style="font-family:monospace">a</span>, and the hidden type of the equality, are ignored).
Note that the variant <span style="font-family:monospace">rewrite [X in _ = X]rule</span> would have
rewritten <span style="font-family:monospace">b</span> exactly (i.e., it would only work if <span style="font-family:monospace">b</span> and the
left hand side of <span style="font-family:monospace">rule</span> can be unified).</p>
<h3 id="sec580" class="subsection">11.8.2  Matching contextual patterns</h3>
<p>The <span style="font-style:oblique">c-pattern</span>s and <span style="font-style:oblique">r-pattern</span>s involving
<span style="font-style:oblique">term</span>s with holes are matched
against the goal in order to find a closed instantiation. This
matching proceeds as follows:</p><div class="center"><div class="centered">
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-style:oblique">c-pattern</span></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" >instantiation order and place for <span style="font-style:oblique">term</span><sub><span style="font-style:italic">i</span></sub> and redex</td></tr>
<tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-style:oblique">term</span></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-style:oblique">term</span> is matched against the goal, redex is unified with
the instantiation of <span style="font-style:oblique">term</span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" > <span style="font-style:oblique">term</span> is matched against the goal, redex is
unified with the subterm of the
instantiation of <span style="font-style:oblique">term</span> identified by <span style="font-style:oblique">ident</span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">in</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span><sub>2</sub></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" > <span style="font-style:oblique">term</span><sub>2</sub> is matched against the goal, <span style="font-style:oblique">term</span><sub>1</sub> is
matched against the subterm of the
instantiation of <span style="font-style:oblique">term</span><sub>1</sub> identified by <span style="font-style:oblique">ident</span>,
redex is unified with the instantiation of <span style="font-style:oblique">term</span><sub>1</sub></td></tr>
<tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">as</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span><sub>2</sub></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" > <span style="font-style:oblique">term</span><sub>2</sub>[<span style="font-style:oblique">term</span><sub>1</sub>/<span style="font-style:oblique">ident</span>]
is matched against the goal,
redex is unified with the instantiation of <span style="font-style:oblique">term</span><sub>1</sub></td></tr>
</table>
</div></div><p>In the following patterns, the redex is intended to be inferred from the
rewrite rule.</p><div class="center"><div class="centered">
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-style:oblique">r-pattern</span></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" >instantiation order and place for <span style="font-style:oblique">term</span><sub><span style="font-style:italic">i</span></sub> and redex</td></tr>
<tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-family:monospace">in</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" > <span style="font-style:oblique">term</span> is matched against the goal, the redex is
matched against the subterm of the
instantiation of <span style="font-style:oblique">term</span> identified by <span style="font-style:oblique">ident</span></td></tr>
<tr><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="vertical-align:middle;text-align:left;border:solid 1px;" ><span style="font-style:oblique">term</span> is matched against the goal, redex is
matched against the instantiation of <span style="font-style:oblique">term</span></td></tr>
</table>
</div></div>
<h3 id="sec581" class="subsection">11.8.3  Examples</h3>
<h4 id="sec582" class="subsubsection">Contextual pattern in <span style="font-family:monospace">set</span> and the <span style="font-family:monospace">:</span> tactical</h4>
<p>As already mentioned in section <a href="#ssec%3Aset">11.4.2</a> the <span style="font-family:monospace">set</span> tactic
takes as an argument a term in open syntax. This term is interpreted
as the simplest for of <span style="font-style:oblique">c-pattern</span>. To void confusion in the grammar,
open syntax is supported only for the simplest form of patterns, while
parentheses are required around more complex patterns.</p><div class="lstlisting">set t := (X in _ = X).
set t := (a + _ in X in _ = X).</div><p>Given the goal <span style="font-family:monospace">a + b + 1 = b + (a + 1)</span> the first tactic
captures <span style="font-family:monospace">b + (a + 1)</span>, while the latter <span style="font-family:monospace">a + 1</span>.</p><p>Since the user may define an infix notation for <span style="font-family:monospace">in</span> the former
tactic may result ambiguous. The disambiguation rule implemented is
to prefer patterns over simple terms, but to interpret a pattern with
double parentheses as a simple term. For example
the following tactic would capture any occurrence of the term ‘<span style="font-family:monospace">a in A</span>’.</p><div class="lstlisting">set t := ((a in A)).</div><p>Contextual pattern can also be used as arguments of the <span style="font-family:monospace">:</span> tactical.
For example:
</p><div class="lstlisting">elim: n (n in _ = n) (refl_equal n).</div>
<h4 id="sec583" class="subsubsection">Contextual patterns in <span style="font-family:monospace">rewrite</span></h4>
<p>
As a more comprehensive example consider the following goal:
</p><div class="lstlisting">    (x.+1 + y) + f (x.+1 + y) (z + (x + y).+1) = 0</div><p>The tactic <span style="font-family:monospace">rewrite [in f _ _]addSn</span> turns it into:
</p><div class="lstlisting">    (x.+1 + y) + f (x + y).+1 (z + (x + y).+1) = 0</div><p>since the simplification rule <span style="font-family:monospace">addSn</span> is applied only under the <span style="font-family:monospace">f</span> symbol.
Then we simplify also the first addition and expand <span style="font-family:monospace">0</span> into <span style="font-family:monospace">0+0</span>.
</p><div class="lstlisting">    rewrite addSn -[X in _ = X]addn0.</div><p>obtaining:
</p><div class="lstlisting">    (x + y).+1 + f (x + y).+1 (z + (x + y).+1) = 0 + 0</div><p>Note that the right hand side of <span style="font-family:monospace">addn0</span> is undetermined, but the
rewrite pattern specifies the redex explicitly. The right hand side of
<span style="font-family:monospace">addn0</span> is unified with the term identified by <span style="font-family:monospace">X</span>, <span style="font-family:monospace">0</span> here.</p><p>The following pattern does not specify a redex, since it
identifies an entire region, hence the rewrite rule has to be instantiated
explicitly. Thus the tactic:
</p><div class="lstlisting">    rewrite -{2}[in X in _ = X](addn0 0).</div><p>changes the goal as follows:
</p><div class="lstlisting">    (x + y).+1 + f (x + y).+1 (z + (x + y).+1) = 0 + (0 + 0)</div><p>The following tactic is quite tricky:
</p><div class="lstlisting">    rewrite [_.+1 in X in f _ X](addnC x.+1).</div><p>and the resulting goals is:
</p><div class="lstlisting">    (x + y).+1 + f (x + y).+1 (z + (y + x.+1)) = 0 + (0 + 0)</div><p>The explicit redex <span style="font-family:monospace">_.+1</span> is important since its head
constant <span style="font-family:monospace">S</span> differs from the head constant inferred from
<span style="font-family:monospace">(addnC x.+1)</span> (that is <span style="font-family:monospace">addn</span>, denoted <span style="font-family:monospace">+</span> here).
Moreover, the pattern <span style="font-family:monospace">f _ X</span> is important to rule out the first occurrence
of <span style="font-family:monospace">(x + y).+1</span>. Last, only the subterms of <span style="font-family:monospace">f _ X</span> identified by <span style="font-family:monospace">X</span> are
rewritten, thus the first argument of <span style="font-family:monospace">f</span> is skipped too.
Also note the pattern <span style="font-family:monospace">_.+1</span> is interpreted in the context
identified by <span style="font-family:monospace">X</span>, thus it gets instantiated to <span style="font-family:monospace">(y + x).+1</span> and
not <span style="font-family:monospace">(x + y).+1</span>.</p><p>The last rewrite pattern allows to specify exactly the shape of the term
identified by <span style="font-family:monospace">X</span>, that is thus unified with the left hand side of the
rewrite rule.
</p><div class="lstlisting">    rewrite [x.+1 + y as X in f X _]addnC.</div><p>The resulting goal is:
</p><div class="lstlisting">    (x + y).+1 + f (y + x.+1) (z + (y + x.+1)) = 0 + (0 + 0)</div>
<h3 id="sec584" class="subsection">11.8.4  Patterns for recurrent contexts</h3>
<p>The user can define shortcuts for recurrent contexts corresponding to the
<span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span> part. The notation scope identified
with <span style="font-family:monospace">%pattern</span> provides a special notation ‘<span style="font-family:monospace">(X in t)</span>’ the user
must adopt to define context shortcuts.</p><p>The following example is taken from <span style="font-family:monospace">ssreflect.v</span> where the
<span style="font-family:monospace">LHS</span> and <span style="font-family:monospace">RHS</span> shortcuts are defined.</p><div class="lstlisting">Notation RHS := (X in _ = X)%pattern.
Notation LHS := (X in X = _)%pattern.</div><p>Shortcuts defined this way can be freely used in place of the
trailing <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span> part of any contextual
pattern.
Some examples follow:</p><div class="lstlisting">set rhs := RHS.
rewrite [in RHS]rule.
case: (a + _ in RHS).</div>
<h2 id="sec585" class="section">11.9  Views and reflection</h2>
<p><a id="sec:views"></a></p><p>The bookkeeping facilities presented in section <a href="#sec%3Abook">11.5</a> are
crafted to ease simultaneous introductions and generalizations of facts and
casing,
naming … operations. It also a common practice to make a stack
operation immediately followed by an <em>interpretation</em> of the fact
being pushed,
that is, to apply a lemma to this fact before passing it
to a tactic for decomposition, application and so on.</p><p><span style="font-variant:small-caps">SSReflect</span> provides a convenient, unified syntax to combine these
interpretation operations with the proof stack operations. This
<em>view mechanism</em> relies on the combination of the <span style="font-family:monospace">/</span> view
switch with bookkeeping tactics and tacticals.</p>
<h3 id="sec586" class="subsection">11.9.1  Interpreting eliminations</h3>
<p>
<a id="hevea_default939"></a><a id="hevea_tactic266"></a></p><p>The view syntax combined with the <span style="font-family:monospace">elim</span> tactic specifies an
elimination scheme to
be used instead of the default, generated, one. Hence the <span style="font-variant:small-caps">SSReflect</span> tactic:
</p><div class="lstlisting">  elim/V.</div><p>is a synonym for:
</p><div class="lstlisting">  intro top; elim top using V; clear top.</div><p>where <span style="font-family:monospace">top</span> is a fresh name and <span style="font-family:monospace">V</span> any second-order lemma.</p><p>Since an elimination view supports the two bookkeeping tacticals of
discharge and introduction (see section <a href="#sec%3Abook">11.5</a>), the <span style="font-variant:small-caps">SSReflect</span> tactic:
</p><div class="lstlisting">  elim/V: x =&gt; y.</div><p>is a synonym for:
</p><div class="lstlisting">  elim x using V; clear x; intro y.</div><p>where <span style="font-family:monospace">x</span> is a variable in the context, <span style="font-family:monospace">y</span> a fresh name and <span style="font-family:monospace">V</span>
any second order lemma; <span style="font-variant:small-caps">SSReflect</span> relaxes the syntactic restrictions of
the <span style="font-variant:small-caps">Coq</span> <span style="font-family:monospace">elim</span>. The first pattern following <span style="font-family:monospace">:</span> can be a <span style="font-family:monospace">_</span>
wildcard if the conclusion of the view <span style="font-family:monospace">V</span> specifies a pattern for
its last argument (e.g., if <span style="font-family:monospace">V</span> is a functional induction lemma
generated by the <span style="font-family:monospace">Function</span> command).</p><p>The elimination view mechanism is compatible with the equation name
generation (see section <a href="#ssec%3Aequations">11.5.5</a>).</p><p>The following script illustrate a toy example of this feature. Let us
define a function adding an element at the end of a list:
</p><div class="lstlisting">  Require Import List.

  Variable d : Type.

  Fixpoint add_last(s : list d) (z : d) {struct s} : list d :=
    match s with
    | nil =&gt;  z :: nil
    | cons x s' =&gt; cons x (add_last s' z)
    end.</div><p>One can define an alternative, reversed, induction principle on inductively
defined <span style="font-family:monospace">list</span>s, by proving the following lemma:</p><div class="lstlisting">  Lemma last_ind_list : forall (P : list d -&gt; Type),
  P nil -&gt;
  (forall (s : list d) (x : d), P s -&gt; P (add_last s x)) -&gt; forall s : list d, P s.</div><p>Then the combination of elimination views with equation names result
in a concise syntax for reasoning inductively using the user
defined elimination scheme. The script:
</p><div class="lstlisting">  Goal forall (x : d)(l : list d), l = l.
  move=&gt; x l.
  elim/last_ind_list E : l=&gt; [| u v]; last first.</div><p>generates two subgoals: the first one to prove <span style="font-family:monospace">nil = nil</span> in a
context featuring <span style="font-family:monospace">E : l = nil</span> and the second to prove
<span style="font-family:monospace">add_last u v = add_last u v</span>, in a context containing
<span style="font-family:monospace">E : l = add_last u v</span>.</p><p>User provided eliminators (potentially generated with the
<span style="font-family:monospace">Function</span> <span style="font-variant:small-caps">Coq</span>’s command) can be combined with the type family switches
described in section <a href="#ssec%3Atypefam">11.5.6</a>. Consider an eliminator
<span style="font-family:monospace">foo_ind</span> of type:</p><p><span style="font-family:monospace">foo_ind : forall </span>…<span style="font-family:monospace">, forall x : T, P p</span><sub>1</sub><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> p</span><sub><span style="font-style:italic">m</span></sub></p><p>and consider the tactic</p><p><span style="font-family:monospace">elim/foo_ind: e</span><sub>1</sub><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> / e</span><sub><span style="font-style:italic">n</span></sub></p><p>The <span style="font-family:monospace">elim/</span> tactic distinguishes two cases:
</p><dl class="description"><dt class="dt-description">
<span style="font-weight:bold">truncated eliminator</span></dt><dd class="dd-description"> when <span style="font-family:monospace">x</span> does not occur in <span style="font-family:monospace">P p</span><sub>1</sub> …<span style="font-family:monospace"> p</span><sub><span style="font-style:italic">m</span></sub>
and the type of <span style="font-family:monospace">e</span><sub><span style="font-style:italic">n</span></sub> unifies with <span style="font-family:monospace">T</span> and <span style="font-family:monospace">e</span><sub><span style="font-style:italic">n</span></sub> is not <span style="font-family:monospace">_</span>.
In that case, <span style="font-family:monospace">e</span><sub><span style="font-style:italic">n</span></sub> is passed to the eliminator as the last argument
(<span style="font-family:monospace">x</span> in <span style="font-family:monospace">foo_ind</span>) and <span style="font-family:monospace">e</span><sub><span style="font-style:italic">n</span>−1</sub> …<span style="font-family:monospace"> e</span><sub>1</sub> are used as patterns
to select in the goal the occurrences that will be bound by the
predicate <span style="font-family:monospace">P</span>, thus it must be possible to unify the sub-term of
the goal matched by <span style="font-family:monospace">e</span><sub><span style="font-style:italic">n</span>−1</sub> with <span style="font-family:monospace">p</span><sub><span style="font-style:italic">m</span></sub>, the one matched by
<span style="font-family:monospace">e</span><sub><span style="font-style:italic">n</span>−2</sub> with <span style="font-family:monospace">p</span><sub><span style="font-style:italic">m</span>−1</sub> and so on.
</dd><dt class="dt-description"><span style="font-weight:bold">regular eliminator</span></dt><dd class="dd-description"> in all the other cases. Here it must be
possible to unify the term matched by
<span style="font-family:monospace">e</span><sub><span style="font-style:italic">n</span></sub> with <span style="font-family:monospace">p</span><sub><span style="font-style:italic">m</span></sub>, the one matched by
<span style="font-family:monospace">e</span><sub><span style="font-style:italic">n</span>−1</sub> with <span style="font-family:monospace">p</span><sub><span style="font-style:italic">m</span>−1</sub> and so on. Note that
standard eliminators have the shape …<span style="font-family:monospace">forall x, P </span>…<span style="font-family:monospace"> x</span>, thus
<span style="font-family:monospace">e</span><sub><span style="font-style:italic">n</span></sub> is the pattern identifying the eliminated term, as expected.
</dd></dl><p>
As explained in section <a href="#ssec%3Atypefam">11.5.6</a>, the initial prefix of
<span style="font-family:monospace">e</span><sub><span style="font-style:italic">i</span></sub> can be omitted.</p><p>Here an example of a regular, but non trivial, eliminator:
</p><div class="lstlisting">  Function plus (m n : nat) {struct n} : nat :=
     match n with 0 =&gt; m | S p =&gt; S (plus m p) end.</div><p>The type of <span style="font-family:monospace">plus_ind</span> is
</p><div class="lstlisting">plus_ind : forall (m : nat) (P : nat -&gt; nat -&gt; Prop),
  (forall n : nat, n = 0 -&gt; P 0 m) -&gt;
  (forall n p : nat, n = p.+1 -&gt; P p (plus m p) -&gt; P p.+1 (plus m p).+1) -&gt;
    forall n : nat, P n (plus m n)</div><p>Consider the following goal
</p><div class="lstlisting">  Lemma exF x y z: plus (plus x y) z = plus x (plus y z).</div><p>The following tactics are all valid and perform the same elimination
on that goal.
</p><div class="lstlisting">  elim/plus_ind: z / (plus _ z).
  elim/plus_ind: {z}(plus _ z).
  elim/plus_ind: {z}_.
  elim/plus_ind: z / _.</div><p>In the two latter examples, being the user provided pattern a wildcard, the
pattern inferred from the type of the eliminator is used instead. For both
cases it is <span style="font-family:monospace">(plus _ _)</span> and matches the subterm <span style="font-family:monospace">plus (plus x y)</span> <span style="font-family:monospace">z</span> thus
instantiating the latter <span style="font-family:monospace">_</span> with <span style="font-family:monospace">z</span>. Note that the tactic
<span style="font-family:monospace">elim/plus_ind: y / _</span> would have resulted in an error, since <span style="font-family:monospace">y</span> and <span style="font-family:monospace">z</span>
do no unify but the type of the eliminator requires the second argument of
<span style="font-family:monospace">P</span> to be the same as the second argument of <span style="font-family:monospace">plus</span> in the second
argument of <span style="font-family:monospace">P</span>.</p><p>Here an example of a truncated eliminator. Consider the goal
</p><div class="lstlisting">  p : nat_eqType
  n : nat
  n_gt0 : 0 &lt; n
  pr_p : prime p
 =================
  p %| \prod_(i &lt;- prime_decomp n | i \in prime_decomp n) i.1 ^ i.2 -&gt;
    exists2 x : nat * nat, x \in prime_decomp n &amp; p = x.1</div><p>and the tactic
</p><div class="lstlisting">elim/big_prop: _ =&gt; [| u v IHu IHv | [q e] /=].</div><p>where the type of the eliminator is
</p><div class="lstlisting">big_prop: forall (R : Type) (Pb : R -&gt; Type) (idx : R) (op1 : R -&gt; R -&gt; R),
  Pb idx -&gt;
  (forall x y : R, Pb x -&gt; Pb y -&gt; Pb (op1 x y)) -&gt;
  forall (I : Type) (r : seq I) (P : pred I) (F : I -&gt; R),
  (forall i : I, P i -&gt; Pb (F i)) -&gt;
    Pb (\big[op1/idx]_(i &lt;- r | P i) F i)</div><p>Since the pattern for the argument of <span style="font-family:monospace">Pb</span> is not specified, the inferred one
is used instead: <span style="font-family:monospace">(<br>
big[_/_]_(i &lt;- _ | _ i) _ i)</span>, and after the
introductions, the following goals are generated.
</p><div class="lstlisting">subgoal 1 is:
 p %| 1 -&gt; exists2 x : nat * nat, x \in prime_decomp n &amp; p = x.1
subgoal 2 is:
 p %| u * v -&gt; exists2 x : nat * nat, x \in prime_decomp n &amp; p = x.1
subgoal 3 is:
 (q, e) \in prime_decomp n -&gt; p %| q ^ e -&gt;
   exists2 x : nat * nat, x \in prime_decomp n &amp; p = x.1</div><p>Note that the pattern matching algorithm instantiated all the variables
occurring in the pattern.</p>
<h3 id="sec587" class="subsection">11.9.2  Interpreting assumptions</h3>
<p><a id="ssec:assumpinterp"></a>
<a id="hevea_default940"></a><a id="hevea_tactic267"></a></p><p>Interpreting an assumption in the context of a proof is applying it a
correspondence lemma before generalizing, and/or decomposing it.
For instance, with the extensive use of boolean reflection (see
section <a href="#ssec%3Aboolrefl">11.9.4</a>), it is
quite frequent to need to decompose the logical interpretation of (the
boolean expression of) a
fact, rather than the fact itself.
This can be achieved by a combination of <span style="font-family:monospace">move : _ =&gt; _</span>
switches, like in the following script, where <span style="font-family:monospace">||</span> is a notation for
the boolean disjunction:
</p><div class="lstlisting">  Variables P Q : bool -&gt; Prop.
  Hypothesis P2Q : forall a b, P (a || b) -&gt; Q a.

  Goal forall a, P (a || a) -&gt; True.
  move=&gt; a HPa; move: {HPa}(P2Q _ _ HPa) =&gt; HQa.</div><p>which transforms the hypothesis <span style="font-family:monospace">HPn : P n</span> which has been
introduced from the initial statement into <span style="font-family:monospace">HQn : Q n</span>.
This operation is so common that the tactic shell has
specific syntax for it.
The following scripts:
</p><div class="lstlisting">  Goal forall a, P (a || a) -&gt; True.
  move=&gt; a HPa; move/P2Q: HPa =&gt; HQa.</div><p>or more directly:
</p><div class="lstlisting">  Goal forall a, P (a || a) -&gt; True.
  move=&gt; a; move/P2Q=&gt; HQa.</div><p>are equivalent to the former one. The former script shows how to
interpret a fact (already in the context), thanks to the discharge
tactical (see section <a href="#ssec%3Adischarge">11.5.3</a>) and the latter, how to
interpret the top assumption of a goal. Note
that the number of wildcards to be inserted to find the correct
application of the view lemma to the hypothesis has been automatically
inferred.</p><p>The view mechanism is compatible with the <span style="font-family:monospace">case</span> tactic and with the
equation name generation mechanism (see section <a href="#ssec%3Aequations">11.5.5</a>):
</p><div class="lstlisting">  Variables P Q: bool -&gt; Prop.
  Hypothesis Q2P : forall a b, Q (a || b) -&gt; P a \/ P b.

  Goal forall a b, Q (a || b) -&gt; True.
  move=&gt; a b; case/Q2P=&gt; [HPa | HPb].</div><p>creates two new subgoals whose contexts no more contain
<span style="font-family:monospace">HQ : Q (a || b)</span> but respectively <span style="font-family:monospace">HPa : P a</span> and
<span style="font-family:monospace">HPb : P b</span>. This view tactic
performs:
</p><div class="lstlisting">  move=&gt; a b HQ; case: {HQ}(Q2P _ _ HQ) =&gt; [HPa | HPb].</div><p>The term on the right of the <span style="font-family:monospace">/</span> view switch is called a <em>view
lemma</em>. Any <span style="font-variant:small-caps">SSReflect</span> term coercing to a product type can be used as a
view lemma.</p><p>The examples we have given so far explicitly provide the direction of the
translation to be performed. In fact, view lemmas need not to be
oriented. The view mechanism is able to detect which
application is relevant for the current goal. For instance, the
script:
</p><div class="lstlisting">  Variables P Q: bool -&gt; Prop.
  Hypothesis PQequiv : forall a b, P (a || b) &lt;-&gt; Q a.

  Goal forall a b, P (a || b) -&gt; True.
  move=&gt; a b; move/PQequiv=&gt; HQab.</div><p>has the same behavior as the first example above.</p><p>The view mechanism can insert automatically a <em>view hint</em> to
transform the double implication into the expected simple implication.
The last script is in fact equivalent to:
</p><div class="lstlisting">  Goal forall a b, P (a || b) -&gt; True.
  move=&gt; a b; move/(iffLR (PQequiv _ _)).</div><p>where:
</p><div class="lstlisting">  Lemma iffLR : forall P Q, (P &lt;-&gt; Q) -&gt; P -&gt; Q.</div><h4 id="sec588" class="subsubsection">Specializing assumptions</h4>
<p>
<a id="hevea_default941"></a><a id="hevea_tactic268"></a></p><p>The special case when the <em>head symbol</em> of the view lemma is a
wildcard is used to interpret an assumption by <em>specializing</em>
it. The view mechanism hence offers the possibility to
apply a higher-order assumption to some given arguments.</p><p>For example, the script:
</p><div class="lstlisting">  Goal forall z, (forall x y, x + y = z -&gt; z = x) -&gt; z = 0.
  move=&gt; z; move/(_ 0 z).</div><p>changes the goal into:
</p><div class="lstlisting">  (0 + z = z -&gt; z = 0) -&gt; z = 0</div>
<h3 id="sec589" class="subsection">11.9.3  Interpreting goals</h3>
<p><a id="ssec:goalinterp"></a></p><p>In a similar way, it is also often convenient to interpret a goal by changing
it into an equivalent proposition. The view mechanism of <span style="font-variant:small-caps">SSReflect</span> has a
special syntax <span style="font-family:monospace">apply/</span> for combining simultaneous goal
interpretation operations and
bookkeeping steps in a single tactic.</p><p>With the hypotheses of section <a href="#ssec%3Aassumpinterp">11.9.2</a>, the following
script, where <code>~~</code> denotes the boolean negation:
</p><div class="lstlisting">  Goal forall a, P ((~~ a) || a).
  move=&gt; a; apply/PQequiv.</div><p>transforms the goal into <span style="font-family:monospace">Q (   a)</span>, and is equivalent to:
</p><div class="lstlisting">  Goal forall a, P ((~~ a) || a).
  move=&gt; a; apply: (iffRL (PQequiv _ _)).</div><p>where <span style="font-family:monospace">iffLR</span> is the analogous of <span style="font-family:monospace">iffRL</span> for the converse
implication.</p><p>Any <span style="font-variant:small-caps">SSReflect</span> term whose type coerces to a double implication can be used
as a view for goal interpretation.</p><p>Note that the goal interpretation view mechanism supports both
<span style="font-family:monospace">apply</span> and <span style="font-family:monospace">exact</span> tactics. As expected, a goal interpretation
view command <span style="font-family:monospace">exact/</span><span style="font-style:italic">term</span> should solve the current goal or it will
fail.</p><p><em>Warning</em> Goal interpretation view tactics are <em>not</em> compatible
with the bookkeeping tactical <span style="font-family:monospace">=&gt;</span> since this would be redundant with
the <span style="font-family:monospace">apply:</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">=&gt; _</span> construction.</p>
<h3 id="sec590" class="subsection">11.9.4  Boolean reflection</h3>
<p><a id="ssec:boolrefl"></a>
In the Calculus of Inductive Construction, there is
an obvious distinction between logical propositions and boolean values.
On the one hand, logical propositions are objects
of <em>sort</em> <span style="font-family:monospace">Prop</span> which is the carrier of intuitionistic
reasoning. Logical connectives in <span style="font-family:monospace">Prop</span> are <em>types</em>, which give precise
information on the structure of their proofs; this information is
automatically exploited by <span style="font-variant:small-caps">Coq</span> tactics. For example, <span style="font-variant:small-caps">Coq</span> knows that a
proof of <code>A</code><code> \/ </code><code>B</code> is either a proof of <span style="font-family:monospace">A</span> or a proof of <span style="font-family:monospace">B</span>.
The tactics <span style="font-family:monospace">left</span> and <span style="font-family:monospace">right</span> change the goal <code>A</code><code> \/ </code><code>B</code>
to <span style="font-family:monospace">A</span> and <span style="font-family:monospace">B</span>, respectively; dualy, the tactic <span style="font-family:monospace">case</span> reduces the goal
<code>A</code><code> \/ </code><code>B</code><code> =&gt; </code><code>G</code> to two subgoals <span style="font-family:monospace">A =&gt; G</span> and <span style="font-family:monospace">B =&gt; G</span>.</p><p>On the other hand, <span style="font-family:monospace">bool</span> is an inductive <em>datatype</em>
with two constructors <span style="font-family:monospace">true</span> and <span style="font-family:monospace">false</span>.
Logical connectives on <span style="font-family:monospace">bool</span> are <em>computable functions</em>, defined by
their truth tables, using case analysis:
</p><div class="lstlisting">  Definition (b1 || b2) := if b1 then true else b2.</div><p>Properties of such connectives are also established using case
analysis: the tactic <span style="font-family:monospace">by case: b</span> solves the goal
</p><div class="lstlisting">  b || ~~ b = true</div><p>by replacing <span style="font-family:monospace">b</span> first by <span style="font-family:monospace">true</span> and then by <span style="font-family:monospace">false</span>; in either case,
the resulting subgoal reduces by computation to the trivial
<span style="font-family:monospace">true = true</span>.</p><p>Thus, <span style="font-family:monospace">Prop</span> and <span style="font-family:monospace">bool</span> are truly complementary: the former
supports robust natural deduction, the latter allows brute-force
evaluation.
<span style="font-variant:small-caps">SSReflect</span> supplies
a generic mechanism to have the best of the two worlds and move freely
from a propositional version of a
decidable predicate to its boolean version.</p><p>First, booleans are injected into propositions
using the coercion mechanism:
</p><div class="lstlisting">  Coercion is_true (b : bool) := b = true.</div><p>This allows any boolean formula <span style="font-family:monospace">b</span> to be used in a context
where <span style="font-variant:small-caps">Coq</span> would expect a proposition, e.g., after <span style="font-family:monospace">Lemma </span>…<span style="font-family:monospace"> : </span>.
It is then interpreted as <span style="font-family:monospace">(is_true b)</span>, i.e.,
the proposition <span style="font-family:monospace">b = true</span>. Coercions are elided by the pretty-printer,
so they are essentially transparent to the user.</p>
<h3 id="sec591" class="subsection">11.9.5  The <span style="font-family:monospace">reflect</span> predicate</h3>
<p><a id="ssec:reflpred"></a></p><p>To get all the benefits of the boolean reflection, it is in fact
convenient to introduce the following inductive predicate
<span style="font-family:monospace">reflect</span> to relate propositions and booleans:</p><div class="lstlisting">  Inductive reflect (P: Prop): bool -&gt; Type :=
    | Reflect_true: P =&gt; reflect P true
    | Reflect_false: ~P =&gt; reflect P false.</div><p>The statement <span style="font-family:monospace">(reflect P b)</span> asserts that <span style="font-family:monospace">(is_true b)</span>
and <span style="font-family:monospace">P</span> are logically equivalent propositions.</p><p>For instance, the following lemma:
</p><div class="lstlisting">  Lemma andP: forall b1 b2, reflect (b1 /\ b2) (b1 &amp;&amp; b2).</div><p>relates the boolean conjunction  to
the logical one <code>/\</code>.
Note that in <span style="font-family:monospace">andP</span>, <span style="font-family:monospace">b1</span> and <span style="font-family:monospace">b2</span> are two boolean variables and
the proposition <code>b1</code><code> /\ </code><code>b2</code> hides two coercions.
The conjunction of <span style="font-family:monospace">b1</span> and <span style="font-family:monospace">b2</span> can then be viewed
as <code>b1</code><code> /\ </code><code>b2</code> or as <span style="font-family:monospace">b1b2</span>.</p><p>Expressing logical equivalences through this family of inductive types
makes possible to take benefit from <em>rewritable equations</em>
associated to the case analysis of <span style="font-variant:small-caps">Coq</span>’s inductive types.</p><p>Since the equivalence predicate is defined in <span style="font-variant:small-caps">Coq</span> as:
</p><div class="lstlisting">  Definition iff (A B:Prop) := (A -&gt; B) /\ (B -&gt; A).</div><p>where <span style="font-family:monospace">/<br>
</span> is a notation for <span style="font-family:monospace">and</span>:
</p><div class="lstlisting">  Inductive and (A B:Prop) : Prop :=
    conj : A -&gt; B -&gt; and A B</div><p>This make case analysis very different according to the way an
equivalence property has been defined.</p><p>For instance, if we have proved the lemma:
</p><div class="lstlisting">  Lemma andE: forall b1 b2, (b1 /\ b2) &lt;-&gt; (b1 &amp;&amp; b2).</div><p>let us compare the respective behaviours of <span style="font-family:monospace">andE</span> and <span style="font-family:monospace">andP</span> on a
goal:
</p><div class="lstlisting">  Goal forall b1 b2, if (b1 &amp;&amp; b2) then b1 else ~~(b1||b2).</div><p>The command:
</p><div class="lstlisting">  move=&gt; b1 b2; case (@andE b1 b2).</div><p>generates a single subgoal:
</p><div class="lstlisting">  (b1 &amp;&amp; b2 -&gt; b1 /\ b2) -&gt; (b1 /\ b2 -&gt; b1 &amp;&amp; b2) -&gt;
                   if b1 &amp;&amp; b2 then b1 else ~~ (b1 || b2)</div><p>while the command:
</p><div class="lstlisting">  move=&gt; b1 b2; case (@andP b1 b2).</div><p>generates two subgoals, respectively <code>b1</code><code> /\ </code><code>b2</code><code> -&gt; </code><code>b1</code> and
<code>~ (</code><code>b1</code><code> /\ </code><code>b2</code><code>) -&gt; ~~ (</code><code>b1</code><code> || </code><code>b2</code><code>)</code>.</p><p>Expressing reflection relation through the <span style="font-family:monospace">reflect</span> predicate
is hence a very convenient way to deal with classical reasoning, by
case analysis. Using the <span style="font-family:monospace">reflect</span> predicate allows moreover to
program rich specifications inside
its two constructors, which will be automatically taken into account
during destruction. This formalisation style gives far more
efficient specifications than quantified (double) implications.</p><p>A naming convention in <span style="font-variant:small-caps">SSReflect</span> is to postfix the name of view lemmas with <span style="font-family:monospace">P</span>.
For example, <span style="font-family:monospace">orP</span> relates <span style="font-family:monospace">||</span> and <code>\/</code>, <span style="font-family:monospace">negP</span> relates
<code>~~</code> and <code>~</code>.</p><p>The view mechanism is compatible with <span style="font-family:monospace">reflect</span> predicates.</p><p>For example, the script
</p><div class="lstlisting">  Goal forall a b : bool, a -&gt; b -&gt; a /\\ b.
  move=&gt; a b Ha Hb; apply/andP.</div><p>changes the goal <code>a</code><code> /\ </code><code>b</code> to <span style="font-family:monospace">ab</span> (see section <a href="#ssec%3Agoalinterp">11.9.3</a>).</p><p>Conversely, the script
</p><div class="lstlisting">  Goal forall a b : bool, a /\ b -&gt; a.
  move=&gt; a b; move/andP.</div><p>changes the goal <code>a</code><code> /\ </code><code>b</code><code> -&gt; </code><code>a</code> into <span style="font-family:monospace">ab -&gt; a</span> (see section
<a href="#ssec%3Aassumpinterp">11.9.2</a>).</p><p>The same tactics can also be used to perform the converse
operation, changing a boolean conjunction into a logical one. The view
mechanism guesses the direction of the
transformation to be used i.e., the constructor of the <span style="font-family:monospace">reflect</span>
predicate which should be chosen.</p>
<h3 id="sec592" class="subsection">11.9.6  General mechanism for interpreting goals and assumptions</h3>
<h4 id="sec593" class="subsubsection">Specializing assumptions</h4>
<p>
<a id="hevea_default942"></a><a id="hevea_tactic269"></a></p><p>The <span style="font-variant:small-caps">SSReflect</span>
tactic:</p><p><span style="font-family:monospace">move/(_</span> <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span></p><p>is equivalent to the tactic:</p><p><span style="font-family:monospace">intro top; generalize (top</span> <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">); clear top.</span></p><p>where <span style="font-family:monospace">top</span> is a fresh name for introducing the top assumption of
the current goal.</p><h4 id="sec594" class="subsubsection">Interpreting assumptions</h4>
<p>
<a id="sssec:hypview"></a>
The general form of an assumption view tactic is:</p><div class="center"><div class="centered">
<span style="font-style:italic">[</span><span style="font-family:monospace">move</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">case</span><span style="font-style:italic">]</span> <span style="font-family:monospace">/</span> <span style="font-style:oblique">term</span><sub>0</sub>
</div></div><p>The term <span style="font-style:oblique">term</span><sub>0</sub>, called the <em>view lemma</em> can be:
</p><ul class="itemize"><li class="li-itemize">
a (term coercible to a) function;
</li><li class="li-itemize">a (possibly quantified) implication;
</li><li class="li-itemize">a (possibly quantified) double implication;
</li><li class="li-itemize">a (possibly quantified) instance of the <span style="font-family:monospace">reflect</span> predicate
(see section <a href="#ssec%3Areflpred">11.9.5</a>).
</li></ul><p>Let <span style="font-family:monospace">top</span> be the top assumption in the goal.</p><p>There are three steps in the behaviour of an assumption view tactic:
</p><ul class="itemize"><li class="li-itemize">
It first introduces <code>top</code>.
</li><li class="li-itemize">If the type of <span style="font-style:oblique">term</span><sub>0</sub> is neither a double implication nor
an instance of the <span style="font-family:monospace">reflect</span> predicate, then the tactic
automatically generalises a term of the form:<div class="center"><div class="centered">
<span style="font-family:monospace">(</span><span style="font-style:oblique">term</span><sub>0</sub> <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span>
</div></div><p>where the terms <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> instantiate the
possible quantified variables of <span style="font-style:oblique">term</span><sub>0</sub>, in order for
<span style="font-family:monospace">(</span><span style="font-style:oblique">term</span><sub>0</sub> <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">top)</span> to be well typed.
</p></li><li class="li-itemize">If the type of <span style="font-style:oblique">term</span><sub>0</sub> is an equivalence, or
an instance of the <span style="font-family:monospace">reflect</span> predicate, it generalises a term of
the form:
<div class="center"><div class="centered">
(<span style="font-style:oblique">term</span><sub><span style="font-style:italic">vh</span></sub> (<span style="font-style:oblique">term</span><sub>0</sub> <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>))
</div></div>
where the term <span style="font-style:oblique">term</span><sub><span style="font-style:italic">vh</span></sub> inserted is called an
<em>assumption interpretation view hint</em>.
</li><li class="li-itemize">It finally clears <span style="font-family:monospace">top</span>.
</li></ul><p>
For a <span style="font-family:monospace">case/</span><span style="font-style:oblique">term</span><sub>0</sub> tactic, the generalisation step is
replaced by a case analysis step.</p><p><em>View hints</em> are declared by the user (see section
<a href="#ssec%3Avhints">11.9.8</a>) and are stored in the <span style="font-family:monospace">Hint View</span> database.
The proof engine automatically
detects from the shape of the top assumption <span style="font-family:monospace">top</span> and of the view
lemma <span style="font-style:oblique">term</span><sub>0</sub> provided to the tactic the appropriate view hint in
the database to be inserted.</p><p>If <span style="font-style:oblique">term</span><sub>0</sub> is a double implication, then the view hint <span style="font-family:monospace">A</span> will
be one of the defined view hints for implication. These hints are by
default the ones present in the file <span style="font-family:monospace">ssreflect.v</span>:
</p><div class="lstlisting">  Lemma iffLR : forall P Q, (P &lt;-&gt; Q) -&gt; P -&gt; Q.</div><p>which transforms a double implication into the left-to-right one, or:
</p><div class="lstlisting">  Lemma iffRL : forall P Q, (P &lt;-&gt; Q) -&gt; Q -&gt; P.</div><p>which produces the converse implication. In both cases, the two first
<span style="font-family:monospace">Prop</span> arguments are implicit.</p><p>If <span style="font-style:oblique">term</span><sub>0</sub> is an instance of the <span style="font-family:monospace">reflect</span> predicate, then <span style="font-family:monospace">A</span>
will be one of the defined view hints for the <span style="font-family:monospace">reflect</span>
predicate, which are by
default the ones present in the file <span style="font-family:monospace">ssrbool.v</span>.
These hints are not only used for choosing the appropriate direction of
the translation, but they also allow complex transformation, involving
negations.
For instance the hint:
</p><div class="lstlisting">  Lemma introN : forall (P : Prop) (b : bool), reflect P b -&gt; ~ P -&gt; ~~ b.</div><p>makes the following script:
</p><div class="lstlisting">  Goal forall a b : bool, a -&gt; b -&gt; ~~ (a &amp;&amp; b).
  move=&gt; a b Ha Hb. apply/andP.</div><p>transforms the goal into <span style="font-family:monospace"> (a / b)</span>.
In fact<sup><a id="text24" href="#note24">9</a></sup>
this last script does not exactly use the hint <span style="font-family:monospace">introN</span>, but the
more general hint:
</p><div class="lstlisting">  Lemma introNTF : forall (P : Prop) (b c : bool),
      reflect P b -&gt; (if c then ~ P else P) -&gt; ~~ b = c</div><p>The lemma <code><code>introN</code></code> is an instantiation of <span style="font-family:monospace">introNF</span> using
<span style="font-family:monospace">c := true</span>.</p><p>Note that views, being part of <span style="font-style:oblique">i-pattern</span>, can be used to interpret
assertions too. For example the following script asserts <span style="font-family:monospace">a &amp;&amp; b</span>
but actually used its propositional interpretation.
</p><div class="lstlisting">  Lemma test (a b : bool) (pab : b &amp;&amp; a) : b.
  have /andP [pa -&gt;] : (a &amp;&amp; b) by rewrite andbC.</div><h4 id="sec595" class="subsubsection">Interpreting goals</h4>
<p>
<a id="hevea_default943"></a><a id="hevea_tactic270"></a></p><p>A goal interpretation view tactic of the form:</p><div class="center"><div class="centered">
	<span style="font-family:monospace">apply/</span> <span style="font-style:oblique">term</span><sub>0</sub>
</div></div><p>
applied to a goal <span style="font-family:monospace">top</span> is interpreted in the following way:
</p><ul class="itemize"><li class="li-itemize">
If the type of <span style="font-style:oblique">term</span><sub>0</sub> is not an instance of the
<span style="font-family:monospace">reflect</span> predicate, nor an equivalence,
then the term <span style="font-style:oblique">term</span><sub>0</sub> is applied to the current goal <span style="font-family:monospace">top</span>,
possibly inserting implicit arguments.
</li><li class="li-itemize">If the type of <span style="font-style:oblique">term</span><sub>0</sub> is an instance of the <span style="font-family:monospace">reflect</span>
predicate or an equivalence, then
a <em>goal interpretation view hint</em> can possibly be inserted, which
corresponds to the application of a term
<span style="font-family:monospace">(</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">vh</span></sub><span style="font-family:monospace"> (</span><span style="font-style:oblique">term</span><sub>0</sub><span style="font-family:monospace"> _ </span>…<span style="font-family:monospace"> _))</span> to the current
goal, possibly inserting implicit arguments.
</li></ul><p>Like assumption interpretation view hints, goal interpretation ones
are user defined lemmas stored (see section <a href="#ssec%3Avhints">11.9.8</a>) in the
<span style="font-family:monospace">Hint View</span> database bridging
the possible gap between the type of <span style="font-style:oblique">term</span><sub>0</sub> and the type of the
goal.</p>
<h3 id="sec596" class="subsection">11.9.7  Interpreting equivalences</h3>
<p>
<a id="hevea_default944"></a><a id="hevea_tactic271"></a></p><p>Equivalent boolean propositions are simply <em>equal</em> boolean terms.
A special construction helps the user to prove boolean equalities by
considering them as logical double implications (between their coerced
versions), while
performing at the same time logical operations on both sides.</p><p>The syntax of double views is:
</p><div class="center"><div class="centered">
<span style="font-family:monospace">apply/</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">l</span></sub> <span style="font-family:monospace">/</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">r</span></sub>
</div></div><p>The term <span style="font-style:oblique">term</span><sub><span style="font-style:italic">l</span></sub> is the view lemma applied to the left hand side of the
equality, <span style="font-style:oblique">term</span><sub><span style="font-style:italic">r</span></sub> is the one applied to the right hand side.</p><p>In this context, the identity view:
</p><div class="lstlisting">Lemma idP : reflect b1 b1.</div><p>is useful, for example the tactic:
</p><div class="lstlisting">  apply/idP/idP.</div><p>transforms the goal
<code>~~ (</code><code>b1</code><code> || </code><code>b2</code><code>)= </code><code>b3</code>
into two subgoals, respectively
<code>~~  (</code><code>b1</code><code> || </code><code>b2</code><code>) -&gt; </code><code>b3</code> and <br>
<code>b3</code><code> -&gt; ~~  (</code><code>b1</code><code> || </code><code>b2</code><code>).</code></p><p>The same goal can be decomposed in several ways, and the user may
choose the most convenient interpretation. For instance, the tactic:
</p><div class="lstlisting">  apply/norP/idP.</div><p>applied on the same goal <code>~~ (</code><code>b1</code><code> || </code><code>b2</code><code>) = </code><code>b3</code> generates the subgoals
<code>~~  </code><code>b1</code><code> /\ ~~  </code><code>b2</code><code> -&gt; </code><code>b3</code> and<br>
<code>b3</code><code> -&gt; ~~  </code><code>b1</code><code> /\ ~~  </code><code>b2</code>.</p>
<h3 id="sec597" class="subsection">11.9.8  Declaring new <span style="font-family:monospace">Hint View</span>s</h3>
<p><a id="ssec:vhints"></a>
<a id="hevea_default945"></a><a id="hevea_command215"></a></p><p>The database of hints for the view mechanism is extensible via a
dedicated vernacular command. As library <span style="font-family:monospace">ssrbool.v</span> already
declares a corpus of hints, this feature is probably useful only for
users who define their own logical connectives. Users can declare
their own hints following the syntax used in <span style="font-family:monospace">ssrbool.v</span>:</p><div class="center"><div class="centered">
<span style="font-family:monospace">Hint View for</span> <span style="font-style:oblique">tactic</span> <span style="font-family:monospace">/</span> <span style="font-style:oblique">ident</span> <span style="font-style:italic">[</span><span style="font-family:monospace">|</span><span style="font-style:oblique">natural</span><span style="font-style:italic">]</span>
</div></div><p>where <span style="font-style:oblique">tactic</span>∈ {<span style="font-family:monospace">move, apply</span>}, <span style="font-style:oblique">ident</span> is the
name of the lemma to be declared as a hint, and <span style="font-style:oblique">natural</span> a natural
number. If <code>move</code> is used as <span style="font-style:oblique">tactic</span>, the hint is declared for
assumption interpretation tactics, <code>apply</code> declares hints for goal
interpretations.
Goal interpretation view hints are declared for both simple views and
left hand side views. The optional natural number <span style="font-style:oblique">natural</span> is the
number of implicit arguments to be considered for the declared hint
view lemma <span style="font-family:monospace">name_of_the_lemma</span>.</p><p>The command:</p><div class="center"><div class="centered">
<span style="font-family:monospace">Hint View for apply//</span> <span style="font-style:oblique">ident</span><span style="font-style:italic">[</span><span style="font-family:monospace">|</span><span style="font-style:oblique">natural</span><span style="font-style:italic">]</span>.
</div></div><p>with a double slash <code>//</code>, declares hint views for right hand sides of
double views.</p><p>See the files <span style="font-family:monospace">ssreflect.v</span> and <span style="font-family:monospace">ssrbool.v</span> for examples.</p>
<h3 id="sec598" class="subsection">11.9.9  Multiple views</h3>
<p><a id="ssec:multiview"></a></p><p>The hypotheses and the goal can be interpreted applying multiple views in
sequence. Both <span style="font-family:monospace">move</span> and <span style="font-family:monospace">apply</span> can be followed by an arbitrary number
of <span style="font-family:monospace">/</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">i</span></sub>. The main difference between the following two tactics
</p><div class="lstlisting">  apply/v1/v2/v3.
  apply/v1; apply/v2; apply/v3.</div><p>is that the former applies all the views to the principal goal.
Applying a view with hypotheses generates new goals, and the second line
would apply the view <span style="font-family:monospace">v2</span> to all the goals generated by <span style="font-family:monospace">apply/v1</span>.
Note that the NO-OP intro pattern <span style="font-family:monospace">-</span> can be used to separate two
views, making the two following examples equivalent:
</p><div class="lstlisting">  move=&gt; /v1; move=&gt; /v2.
  move=&gt; /v1-/v2.</div><p>The tactic <span style="font-family:monospace">move</span> can be used together with the <span style="font-family:monospace">in</span>
tactical to pass a given hypothesis to a lemma. For example, if
<span style="font-family:monospace">P2Q : P -&gt; Q </span> and <span style="font-family:monospace">Q2R : Q -&gt; R</span>, the following
tactic turns the hypothesis <span style="font-family:monospace">p : P</span> into <span style="font-family:monospace">P : R</span>.
</p><div class="lstlisting">  move/P2Q/Q2R in p.</div><p>If the list of views is of length two, <span style="font-family:monospace">Hint View</span>s for interpreting
equivalences are indeed taken into account, otherwise only single
<span style="font-family:monospace">Hint View</span>s are used.
</p>
<h2 id="sec599" class="section">11.10  <span style="font-variant:small-caps">SSReflect</span> searching tool</h2>
<p>
<a id="hevea_default946"></a><a id="hevea_command216"></a></p><p><span style="font-variant:small-caps">SSReflect</span> proposes an extension of the <span style="font-family:monospace">Search</span> command. Its syntax is:</p><div class="center"><div class="centered">
	<span style="font-family:monospace">Search</span> <span style="font-style:italic">[</span><span style="font-style:oblique">pattern</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:italic">[</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">string</span><span style="font-style:italic">[</span><span style="font-family:monospace">%</span><span style="font-style:oblique">key</span><span style="font-style:italic">]</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">pattern</span><span style="font-style:italic">]</span><span style="font-style:italic">]</span><sup>*</sup> <span style="font-style:italic">[</span><span style="font-family:monospace">in</span> <span style="font-style:italic">[</span><span style="font-style:italic">[</span><span style="font-style:italic">]</span> <span style="font-style:oblique">name</span> <span style="font-style:italic">]</span><sup>+</sup><span style="font-style:italic">]</span>
</div></div><p>where <span style="font-style:oblique">name</span> is the name of an open module.
This command search returns the list of lemmas:
</p><ul class="itemize"><li class="li-itemize">
whose <em>conclusion</em> contains a subterm matching the optional
first <span style="font-style:oblique">pattern</span>. A <span style="font-family:monospace">-</span> reverses the test, producing the list
of lemmas whose conclusion does not contain any subterm matching
the pattern;
</li><li class="li-itemize">whose name contains the given string. A <span style="font-family:monospace">-</span> prefix reverses
the test, producing the list of lemmas whose name does not contain the
string. A string that contains symbols or
is followed by a scope <span style="font-style:oblique">key</span>, is interpreted as the constant whose
notation involves that string (e.g., <code>+</code> for <code>addn</code>), if this is
unambiguous; otherwise the diagnostic includes the output of the
<span style="font-family:monospace">Locate</span> vernacular command.</li><li class="li-itemize">whose statement, including assumptions and types, contains a
subterm matching the next patterns. If a pattern is prefixed by
<span style="font-family:monospace">-</span>, the test is reversed;
</li><li class="li-itemize">contained in the given list of modules, except the ones in the
modules prefixed by a <span style="font-family:monospace">-</span>.
</li></ul><p>Note that:
</p><ul class="itemize"><li class="li-itemize">
As for regular terms, patterns can feature scope
indications. For instance, the command:
<div class="lstlisting">  Search _ (_ + _)%N.</div>lists all the lemmas whose statement (conclusion or hypotheses)
involve an application of the binary operation denoted by the infix
<span style="font-family:monospace">+</span> symbol in the <span style="font-family:monospace">N</span> scope (which is <span style="font-variant:small-caps">SSReflect</span> scope for natural numbers).
</li><li class="li-itemize">Patterns with holes should be surrounded by parentheses.
</li><li class="li-itemize">Search always volunteers the expansion of the notation, avoiding the
need to execute Locate independently. Moreover, a string fragment
looks for any notation that contains fragment as
a substring. If the <code>ssrbool</code> library is imported, the command:
<div class="lstlisting">  Search "~~".</div>answers :
<div class="lstlisting">"~~" is part of notation (~~ _)
In bool_scope, (~~ b) denotes negb b
negbT  forall b : bool, b = false -&gt; ~~ b
contra  forall c b : bool, (c -&gt; b) -&gt; ~~ b -&gt; ~~ c
introN  forall (P : Prop) (b : bool), reflect P b -&gt; ~ P -&gt; ~~ b</div></li><li class="li-itemize">A diagnostic is issued if there are different matching notations;
it is an error if all matches are partial.
</li><li class="li-itemize">Similarly, a diagnostic warns about multiple interpretations, and
signals an error if there is no default one.
</li><li class="li-itemize">The command <span style="font-family:monospace">Search in M.</span>
is a way of obtaining the complete signature of the module <code>M</code>.
</li><li class="li-itemize">Strings and pattern indications can be interleaved, but the
first indication has a special status if it is a pattern, and only
filters the conclusion of lemmas:
<ul class="itemize"><li class="li-itemize">
The command :
<div class="lstlisting">      Search (_ =1 _) "bij".</div>lists all the lemmas whose conclusion features a ’<span style="font-family:monospace">=1</span>’ and whose
name contains the string <code>bij</code>.
</li><li class="li-itemize">The command :
<div class="lstlisting">      Search  "bij" (_ =1 _).</div>lists all the lemmas whose statement, including hypotheses, features a
’<span style="font-family:monospace">=1</span>’ and whose name contains the string <code>bij</code>.</li></ul></li></ul>
<h2 id="sec600" class="section">11.11  Synopsis and Index</h2>
<h3 id="sec601" class="subsection">Parameters</h3>
<div class="minipage">



<blockquote class="table"><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div><div class="center"><div class="centered"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">d-tactic</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >one of the
<span style="font-family:monospace">elim</span>, <span style="font-family:monospace">case</span>, <span style="font-family:monospace">congr</span>, <span style="font-family:monospace">apply</span>, <span style="font-family:monospace">exact</span>
and <span style="font-family:monospace">move</span> <span style="font-variant:small-caps">SSReflect</span> tactics </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">fix-body</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >standard <span style="font-variant:small-caps">Coq</span> <span style="font-style:italic">fix_body</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">ident</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >standard <span style="font-variant:small-caps">Coq</span> identifier</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">int</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >integer literal </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">key</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >notation scope</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">name</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >module name</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">natural</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">int</span> or Ltac variable denoting a standard <span style="font-variant:small-caps">Coq</span> numeral<sup><a id="text25" href="#note25">1</a></sup></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">pattern</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >synonym for <span style="font-style:oblique">term</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">string</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >standard <span style="font-variant:small-caps">Coq</span> string</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">tactic</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >standard <span style="font-variant:small-caps">Coq</span> tactic or <span style="font-variant:small-caps">SSReflect</span> tactic</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">term</span></td><td style="text-align:center;white-space:nowrap" >   </td><td style="text-align:left;white-space:nowrap" >Gallina term, possibly containing wildcards</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
</table>

</div></div><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div></blockquote>
<dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note25" href="#text25">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">The name of this Ltac variable should not be the name of a tactic which can be followed by a bracket
<code>[</code>, like <code>do</code>, <code> </code><code>have</code>,…</div></dd></dl>
</div><h3 id="sec602" class="subsection">Items and switches</h3>
<p>


</p><blockquote class="table"><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div><div class="center"><div class="centered"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">binder</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:oblique">ident</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">(</span> <span style="font-style:oblique">ident</span> <span style="font-style:italic">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-style:italic">]</span> <span style="font-family:monospace">)</span></td><td style="text-align:left;white-space:nowrap" >binder</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Apose">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">clear-switch</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">{</span> <span style="font-style:oblique">ident</span><sup>+</sup> <span style="font-family:monospace">}</span></td><td style="text-align:left;white-space:nowrap" >clear switch</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Adischarge">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">c-pattern</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">[</span><span style="font-style:oblique">term</span> <span style="font-family:monospace">in</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">as</span><span style="font-style:italic">]</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">term</span></td><td style="text-align:left;white-space:nowrap" >context pattern</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Arewp">??</a> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">d-item</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">[</span><span style="font-style:oblique">occ-switch</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">term</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">(</span><span style="font-style:oblique">c-pattern</span><span style="font-family:monospace">)</span><span style="font-style:italic">]</span></td><td style="text-align:left;white-space:nowrap" >discharge item</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Adischarge">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">gen-item</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">[</span><span style="font-family:monospace">@</span><span style="font-style:italic">]</span><span style="font-style:oblique">ident</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">(</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">)</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">(</span><span style="font-style:italic">[</span><span style="font-family:monospace">@</span><span style="font-style:italic">]</span><span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">c-pattern</span><span style="font-family:monospace">)</span></td><td style="text-align:left;white-space:nowrap" >generalization item</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Astruct">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">i-pattern</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:oblique">ident</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">_</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">?</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">*</span> <span style="font-style:italic">|</span> <span style="font-style:italic">[</span><span style="font-style:oblique">occ-switch</span><span style="font-style:italic">]</span><span style="font-family:monospace">-&gt;</span> <span style="font-style:italic">|</span> <span style="font-style:italic">[</span><span style="font-style:oblique">occ-switch</span><span style="font-style:italic">]</span><span style="font-family:monospace">&lt;-</span> <span style="font-style:italic">|</span></td><td style="text-align:left;white-space:nowrap" >intro pattern</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aintro">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">[</span> <span style="font-style:oblique">i-item</span><sup>*</sup> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">i-item</span><sup>*</sup> <span style="font-family:monospace">]</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">-</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">[:</span> <span style="font-style:oblique">ident</span><sup>+</sup><span style="font-family:monospace">]</span></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">i-item</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:oblique">clear-switch</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">s-item</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">i-pattern</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">/</span><span style="font-style:oblique">term</span></td><td style="text-align:left;white-space:nowrap" >intro item</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aintro">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">int-mult</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">[</span><span style="font-style:oblique">natural</span><span style="font-style:italic">]</span> <span style="font-style:oblique">mult-mark</span></td><td style="text-align:left;white-space:nowrap" >multiplier</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aiter">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">occ-switch</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">{</span> <span style="font-style:italic">[</span><span style="font-family:monospace">+</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">-</span><span style="font-style:italic">]</span> <span style="font-style:oblique">natural</span><sup>*</sup><span style="font-family:monospace">}</span></td><td style="text-align:left;white-space:nowrap" >occur. switch</td><td style="text-align:right;white-space:nowrap" >p. <a href="#sssec%3Aoccselect">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">mult</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">[</span><span style="font-style:oblique">natural</span><span style="font-style:italic">]</span> <span style="font-style:oblique">mult-mark</span></td><td style="text-align:left;white-space:nowrap" >multiplier</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aiter">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">mult-mark</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">?</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">!</span></td><td style="text-align:left;white-space:nowrap" >multiplier mark</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aiter">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">r-item</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">[</span><span style="font-family:monospace">/</span><span style="font-style:italic">]</span> <span style="font-style:oblique">term</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">s-item</span></td><td style="text-align:left;white-space:nowrap" >rewrite item</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aextrw">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">r-prefix</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">[</span><span style="font-family:monospace">-</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">int-mult</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">occ-switch</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-family:monospace">[</span><span style="font-style:oblique">r-pattern</span><span style="font-family:monospace">]</span><span style="font-style:italic">]</span></td><td style="text-align:left;white-space:nowrap" >rewrite prefix</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aextrw">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">r-pattern</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:oblique">term</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">c-pattern</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">in</span> <span style="font-style:italic">[</span><span style="font-style:oblique">ident</span> <span style="font-family:monospace">in</span><span style="font-style:italic">]</span> <span style="font-style:oblique">term</span></td><td style="text-align:left;white-space:nowrap" >rewrite pattern</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aextrw">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">r-step</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">[</span><span style="font-style:oblique">r-prefix</span><span style="font-style:italic">]</span><span style="font-style:oblique">r-item</span></td><td style="text-align:left;white-space:nowrap" >rewrite step</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aextrw">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">s-item</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-family:monospace">/=</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">//</span> <span style="font-style:italic">|</span> <span style="font-family:monospace">//=</span></td><td style="text-align:left;white-space:nowrap" >simplify switch</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aintro">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
</table>

</div></div><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div></blockquote><h3 id="sec603" class="subsection">Tactics</h3>
<p>
<em>Note</em>: <span style="font-family:monospace">without loss</span> and <span style="font-family:monospace">suffices</span> are synonyms for <span style="font-family:monospace">wlog</span> and
<span style="font-family:monospace">suff</span> respectively.</p><p>


</p><blockquote class="table"><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div><div class="center"><div class="centered"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">move</span></td><td style="text-align:left;white-space:nowrap" ><span style="color:#00197F"><span style="font-family:monospace">idtac</span></span> or <span style="font-family:monospace">hnf</span></td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aprofstack">??</a> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">apply</span></td><td style="text-align:left;white-space:nowrap" >application</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Abasictac">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">exact</span></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">abstract</span></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aabstract">??</a>, <a href="#sec%3Ahavetransparent">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">elim</span></td><td style="text-align:left;white-space:nowrap" >induction</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Abasictac">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">case</span></td><td style="text-align:left;white-space:nowrap" >case analysis</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Abasictac">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">rewrite</span> <span style="font-style:oblique">rstep</span><sup>+</sup></td><td style="text-align:left;white-space:nowrap" >rewrite</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aextrw">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">have</span> <span style="font-style:oblique">i-item</span><sup>*</sup> <span style="font-style:italic">[</span><span style="font-style:oblique">i-pattern</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">s-item</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">binder</span><sup>+</sup><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span></td><td style="text-align:left;white-space:nowrap" >forward</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Astruct">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">have</span> <span style="font-style:oblique">i-item</span><sup>*</sup> <span style="font-style:italic">[</span><span style="font-style:oblique">i-pattern</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">s-item</span><span style="font-style:italic">|</span> <span style="font-style:oblique">binder</span><sup>+</sup><span style="font-style:italic">]</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-style:italic">[</span><span style="font-family:monospace">by</span> <span style="font-style:oblique">tactic</span><span style="font-style:italic">]</span></td><td style="text-align:left;white-space:nowrap" >chaining</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">have suff</span> <span style="font-style:italic">[</span><span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">i-pattern</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">have suff</span> <span style="font-style:italic">[</span><span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">i-pattern</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-style:italic">[</span><span style="font-family:monospace">by</span> <span style="font-style:oblique">tactic</span><span style="font-style:italic">]</span></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">gen have</span> <span style="font-style:italic">[</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">,</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">i-pattern</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">gen-item</span><sup>+</sup> <span style="font-family:monospace">/</span> <span style="font-style:oblique">term</span> <span style="font-style:italic">[</span><span style="font-family:monospace">by</span> <span style="font-style:oblique">tactic</span><span style="font-style:italic">]</span></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">wlog</span> <span style="font-style:italic">[</span><span style="font-family:monospace">suff</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">i-item</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:</span> <span style="font-style:italic">[</span><span style="font-style:oblique">gen-item</span><span style="font-style:italic">|</span> <span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span><sup>*</sup> <span style="font-family:monospace">/</span> <span style="font-style:oblique">term</span></td><td style="text-align:left;white-space:nowrap" >specializing</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Astruct">??</a> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">suff</span> <span style="font-style:oblique">i-item</span><sup>*</sup> <span style="font-style:italic">[</span><span style="font-style:oblique">i-pattern</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">binder</span><sup>+</sup><span style="font-style:italic">]</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-style:italic">[</span><span style="font-family:monospace">by</span> <span style="font-style:oblique">tactic</span><span style="font-style:italic">]</span></td><td style="text-align:left;white-space:nowrap" >backchaining</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Astruct">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">suff</span> <span style="font-style:italic">[</span><span style="font-family:monospace">have</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">i-pattern</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-style:italic">[</span><span style="font-family:monospace">by</span> <span style="font-style:oblique">tactic</span><span style="font-style:italic">]</span></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">pose</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span></td><td style="text-align:left;white-space:nowrap" >local definition</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Apose">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">pose</span> <span style="font-style:oblique">ident</span> <span style="font-style:oblique">binder</span><sup>+</sup> <span style="font-family:monospace">:=</span> <span style="font-style:oblique">term</span></td><td style="text-align:left;white-space:nowrap" >local function definition</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">pose fix</span> <span style="font-style:oblique">fix-body</span></td><td style="text-align:left;white-space:nowrap" >local fix definition</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">pose cofix</span> <span style="font-style:oblique">fix-body</span></td><td style="text-align:left;white-space:nowrap" >local cofix definition</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">set</span> <span style="font-style:oblique">ident</span> <span style="font-style:italic">[</span><span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:=</span> <span style="font-style:italic">[</span><span style="font-style:oblique">occ-switch</span><span style="font-style:italic">]</span> <span style="font-style:italic">[</span><span style="font-style:oblique">term</span><span style="font-style:italic">|</span> <span style="font-family:monospace">(</span><span style="font-style:oblique">c-pattern</span><span style="font-family:monospace">)</span><span style="font-style:italic">]</span></td><td style="text-align:left;white-space:nowrap" >abbreviation</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aset">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">unlock</span> <span style="font-style:italic">[</span><span style="font-style:oblique">r-prefix</span>]<span style="font-style:oblique">ident</span><span style="font-style:italic">]</span><sup>*</sup></td><td style="text-align:left;white-space:nowrap" >unlock</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Alock">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">congr</span> <span style="font-style:italic">[</span><span style="font-style:oblique">natural</span><span style="font-style:italic">]</span> <span style="font-style:oblique">term</span></td><td style="text-align:left;white-space:nowrap" >congruence</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Acongr">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
</table>

</div></div><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div></blockquote><h3 id="sec604" class="subsection">Tacticals</h3>
<p>


</p><blockquote class="table"><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div><div class="center"><div class="centered"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">d-tactic</span> <span style="font-style:italic">[</span><span style="font-style:oblique">ident</span><span style="font-style:italic">]</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">d-item</span><sup>+</sup> <span style="font-style:italic">[</span><span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >discharge</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Adischarge">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">tactic</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">i-item</span><sup>+</sup></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >introduction</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aintro">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">tactic</span> <span style="font-family:monospace">in</span> <span style="font-style:italic">[</span><span style="font-style:oblique">gen-item</span> <span style="font-style:italic">|</span> <span style="font-style:oblique">clear-switch</span><span style="font-style:italic">]</span><sup>+</sup> <span style="font-style:italic">[</span><span style="font-family:monospace">*</span><span style="font-style:italic">]</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >localization</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Agloc">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">do</span> <span style="font-style:italic">[</span><span style="font-style:oblique">mult</span><span style="font-style:italic">]</span> <span style="font-family:monospace">[</span> <span style="font-style:oblique">tactic</span> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">tactic</span> <span style="font-family:monospace">]</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >iteration</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aiter">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">do</span> <span style="font-style:oblique">mult</span> <span style="font-style:oblique">tactic</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">tactic</span> <span style="font-family:monospace"> ; first</span> <span style="font-style:italic">[</span><span style="font-style:oblique">natural</span><span style="font-style:italic">]</span> <span style="font-family:monospace">[</span><span style="font-style:oblique">tactic</span> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">tactic</span><span style="font-family:monospace">]</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >selector</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aselect">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">tactic</span> <span style="font-family:monospace"> ; last</span> <span style="font-style:italic">[</span><span style="font-style:oblique">natural</span><span style="font-style:italic">]</span> <span style="font-family:monospace">[</span><span style="font-style:oblique">tactic</span> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">tactic</span><span style="font-family:monospace">]</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">tactic</span> <span style="font-family:monospace"> ; first</span> <span style="font-style:italic">[</span><span style="font-style:oblique">natural</span><span style="font-style:italic">]</span> <span style="font-family:monospace">last</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >subgoals</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aselect">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-style:oblique">tactic</span> <span style="font-family:monospace">; last</span> <span style="font-style:italic">[</span><span style="font-style:oblique">natural</span><span style="font-style:italic">]</span> <span style="font-family:monospace">first</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >rotation</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">by [</span> <span style="font-style:oblique">tactic</span> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:oblique">tactic</span> <span style="font-family:monospace">]</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >closing</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Atermin">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">by []</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">by</span> <span style="font-style:oblique">tactic</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
</table>

</div></div><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div></blockquote><h3 id="sec605" class="subsection">Commands</h3>
<p>



</p><blockquote class="table"><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div><div class="center"><div class="centered"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<code>Hint</code><code> </code><code>View</code><code> </code><code>for</code> <span style="font-style:italic">[</span><code>move</code> <span style="font-style:italic">|</span> <code>apply</code><span style="font-style:italic">]</span> <span style="font-family:monospace">/</span> <span style="font-style:oblique">ident</span> <span style="font-style:italic">[</span><span style="font-family:monospace">|</span> <span style="font-style:oblique">natural</span><span style="font-style:italic">]</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >view hint
declaration</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Avhints">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<code>Hint</code><code> </code><code>View</code><code> </code><code>for</code><code> </code><code>apply</code><code>//</code> <span style="font-style:oblique">ident</span> <span style="font-style:italic">[</span><span style="font-family:monospace">|</span><span style="font-style:oblique">natural</span><span style="font-style:italic">]</span></td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >right hand side double</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Avhints">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >view hint declaration</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >
<code>Prenex</code><code> </code><code>Implicits</code> <span style="font-style:oblique">ident</span><sup>+</sup></td><td style="text-align:center;white-space:nowrap" >  </td><td style="text-align:left;white-space:nowrap" >prenex implicits decl.</td><td style="text-align:right;white-space:nowrap" >p. <a href="#ssec%3Aparampoly">??</a></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
</table>

</div></div><div class="center"><div class="centered"><hr style="width:80%;height:2"></div></div></blockquote>
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note16" href="#text16">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Unfortunately,
even after a call to the Set Printing All command, some occurrences are
still not displayed to the user, essentially the ones possibly hidden
in the predicate of a dependent match structure.</div></dd><dt class="dt-thefootnotes"><a id="note17" href="#text17">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Thus scripts that depend on bound variable names, e.g.,
via <span style="font-family:monospace">intros</span> or <span style="font-family:monospace">with</span>, are inherently fragile.</div></dd><dt class="dt-thefootnotes"><a id="note18" href="#text18">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">The name <span style="font-family:monospace">subnK</span> reads as
“right cancellation rule for <span style="font-family:monospace">nat</span> subtraction”.</div></dd><dt class="dt-thefootnotes"><a id="note19" href="#text19">4</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Also, a slightly different variant may be used for the first
<span style="font-style:oblique">d-item</span> of <span style="font-family:monospace">case</span> and <span style="font-family:monospace">elim</span>; see section <a href="#ssec%3Atypefam">11.5.6</a>.</div></dd><dt class="dt-thefootnotes"><a id="note20" href="#text20">5</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Except <span style="font-family:monospace">/=</span> does not
expand the local definitions created by the <span style="font-variant:small-caps">SSReflect</span> <span style="font-family:monospace">in</span> tactical.</div></dd><dt class="dt-thefootnotes"><a id="note21" href="#text21">6</a></dt><dd class="dd-thefootnotes"><div class="footnotetext"><span style="font-variant:small-caps">SSReflect</span> reserves
all identifiers of the form “<span style="font-family:monospace">_x_</span>”, which is used for such
generated names.</div></dd><dt class="dt-thefootnotes"><a id="note22" href="#text22">7</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">More precisely, it should have a quantified
inductive type with <span style="font-style:italic">a</span> assumptions and <span style="font-style:italic">m</span> − <span style="font-style:italic">a</span> constructors.</div></dd><dt class="dt-thefootnotes"><a id="note23" href="#text23">8</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">This is
an implementation feature: there is not such obstruction in the
metatheory</div></dd><dt class="dt-thefootnotes"><a id="note24" href="#text24">9</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">The current state of the proof shall be displayed by
the <span style="font-family:monospace">Show Proof</span> command of <span style="font-variant:small-caps">Coq</span> proof mode.</div></dd></dl>

<div id="sidebarWrapper">
  <div id="sidebar">
    <div class="block">
      <h2 class="title">Navigation</h2>
      <div class="content">
        <ul class="menu">
          <li class="leaf"><a href="index.html">Cover</a></li>
          <li class="leaf"><a href="toc.html">Table of contents</a></li>
          <li class="leaf">Index
            <ul class="menu">
              <li><a href="general-index.html">General</a></li>
              <li><a href="command-index.html">Commands</a></li>
              <li><a href="option-index.html">Options</a></li>
              <li><a href="tactic-index.html">Tactics</a></li>
              <li><a href="error-index.html">Errors</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</body>
</html>
