<!DOCTYPE html>
<html >
<head>


<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/coqdoc.css" /><title>Chapter 8  Tactics

</title>
</head>
<body >

<div id="container">

<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="/" class="active">Home</a></li>
    <li><a href="/about-coq" title="More about coq">About Coq</a></li>
    <li><a href="/download">Get Coq</a></li>
    <li><a href="/documentation">Documentation</a></li>
    <li><a href="/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">
<div id="logoWrapper">
  <div id="logo"><a href="/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
  </div>
  <div id="siteName"><a href="/" title="Home">The Coq Proof Assistant</a>
  </div>
</div>
</div>

<div id="content">

<h1 id="Tactics" class="chapter">Chapter 8  Tactics
<a id="hevea_default530"></a>
</h1>
<ul>
<li><a href="tactics.html#tactic-syntax">8.1  Invocation of tactics

</a>
</li><li><a href="tactics.html#sec357">8.2  Applying theorems</a>
</li><li><a href="tactics.html#sec364">8.3  Managing the local context</a>
</li><li><a href="tactics.html#sec373">8.4  Controlling the proof flow</a>
</li><li><a href="tactics.html#sec383">8.5  Case analysis and induction</a>
</li><li><a href="tactics.html#sec394">8.6  Rewriting expressions</a>
</li><li><a href="tactics.html#Conversion-tactics">8.7  Performing computations

</a>
</li><li><a href="tactics.html#sec409">8.8  Automation</a>
</li><li><a href="tactics.html#sec415">8.9  Controlling automation</a>
</li><li><a href="tactics.html#sec426">8.10  Decision procedures</a>
</li><li><a href="tactics.html#sec432">8.11  Checking properties of terms</a>
</li><li><a href="tactics.html#sec438">8.12  Equality</a>
</li><li><a href="tactics.html#sec443">8.13  Equality and inductive sets</a>
</li><li><a href="tactics.html#inversion">8.14  Inversion
</a>
</li><li><a href="tactics.html#sec451">8.15  Classical tactics</a>
</li><li><a href="tactics.html#Automatizing">8.16  Automatizing
</a>
</li><li><a href="tactics.html#sec459">8.17  Non-logical tactics</a>
</li><li><a href="tactics.html#sec466">8.18  Simple tactic macros</a>
</li></ul>
<p>A deduction rule is a link between some (unique) formula, that we call
the <em>conclusion</em> and (several) formulas that we call the <em>premises</em>. A deduction rule can be read in two ways. The first
one says: <span style="font-style:italic">“if I know this and this then I can deduce
this”</span>. For instance, if I have a proof of <span style="font-style:italic">A</span> and a proof of <span style="font-style:italic">B</span>
then I have a proof of <span style="font-style:italic">A</span> ∧ <span style="font-style:italic">B</span>. This is forward reasoning from
premises to conclusion. The other way says: <span style="font-style:italic">“to prove this I
have to prove this and this”</span>. For instance, to prove <span style="font-style:italic">A</span> ∧ <span style="font-style:italic">B</span>, I
have to prove <span style="font-style:italic">A</span> and I have to prove <span style="font-style:italic">B</span>. This is backward reasoning
from conclusion to premises. We say that the conclusion
is the <em>goal</em><a id="hevea_default531"></a> to prove and premises are the <em>subgoals</em><a id="hevea_default532"></a>. The tactics implement <em>backward
reasoning</em>. When applied to a goal, a tactic replaces this goal with
the subgoals it generates. We say that a tactic reduces a goal to its
subgoal(s).</p><p>Each (sub)goal is denoted with a number. The current goal is numbered
1. By default, a tactic is applied to the current goal, but one can
address a particular goal in the list by writing <span style="font-style:oblique">n:</span><span style="font-style:oblique">tactic</span> which
means <span style="font-style:italic">“apply tactic </span><span style="font-style:oblique">tactic</span><span style="font-style:italic"> to goal number </span><span style="font-style:italic"><span style="font-style:oblique">n</span></span><span style="font-style:italic">”</span>.
We can show the list of subgoals by typing <span style="font-family:monospace">Show</span> (see
Section <a href="proof-handling.html#Show">7.3.1</a>).</p><p>Since not every rule applies to a given statement, every tactic cannot be
used to reduce any goal. In other words, before applying a tactic to a
given goal, the system checks that some <em>preconditions</em> are
satisfied. If it is not the case, the tactic raises an error message.</p><p>Tactics are built from atomic tactics and tactic expressions (which
extends the folklore notion of tactical) to combine those atomic
tactics. This chapter is devoted to atomic tactics. The tactic
language will be described in Chapter <a href="ltac.html#TacticLanguage">9</a>.</p>
<h2 id="tactic-syntax" class="section">8.1  Invocation of tactics

<a id="hevea_default533"></a></h2>
<p>A tactic is applied as an ordinary command. It may be preceded by a
goal selector (see Section <a href="ltac.html#ltac%3Aselector">9.2</a>).
If no selector is specified, the default
selector (see Section <a href="#default-selector">8.1.1</a>) is used.</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">tactic_invocation</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">toplevel_selector</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">tactic</span> <span style="font-family:monospace">.</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">tactic</span> <span style="font-family:monospace">.</span>
</td></tr>
</table><h3 id="default-selector" class="subsection">8.1.1  <span style="font-family:monospace">Set Default Goal Selector ‘‘</span><span style="font-style:oblique">toplevel_selector</span><span style="font-family:monospace">’’.
</span><a id="hevea_default534"></a><a id="hevea_option49"></a><span style="font-family:monospace">
</span></h3>
<p>
After using this command, the default selector – used when no selector
is specified when applying a tactic – is set to the chosen value. The
initial value is 1, hence the tactics are, by default, applied to
the first goal. Using <span style="font-family:monospace">Set Default Goal Selector ‘‘all’’</span> will
make is so that tactics are, by default, applied to every goal
simultaneously. Then, to apply a tactic <span style="font-family:monospace">tac</span> to the first goal
only, you can write <span style="font-family:monospace">1:tac</span>. Although more selectors are available,
only <span style="font-family:monospace">‘‘all’’</span> or a single natural number are valid default
goal selectors.</p><h3 id="sec354" class="subsection">8.1.2  <span style="font-family:monospace">Test Default Goal Selector.</span></h3>
<p>
This command displays the current default selector.</p>
<h3 id="Binding-list" class="subsection">8.1.3  Bindings list
<a id="hevea_default535"></a>
</h3>
<p>Tactics that take a term as argument may also support a bindings list, so
as to instantiate some parameters of the term by name or position.
The general form of a term equipped with a bindings list is <span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span> where <span style="font-style:oblique">bindings_list</span> may be of two
different forms:</p><ul class="itemize"><li class="li-itemize">
In a bindings list of the form <span style="font-family:monospace">(</span><span style="font-style:oblique">ref</span><sub>1</sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">)
… (</span><span style="font-style:oblique">ref</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span>, <span style="font-style:oblique">ref</span> is either an <span style="font-style:oblique">ident</span> or a
<span style="font-style:oblique">num</span>. The references are determined according to the type of
<span style="font-style:oblique">term</span>. If <span style="font-style:oblique">ref</span><sub><span style="font-style:italic">i</span></sub> is an identifier, this identifier has to be
bound in the type of <span style="font-style:oblique">term</span> and the binding provides the tactic
with an instance for the parameter of this name. If <span style="font-style:oblique">ref</span><sub><span style="font-style:italic">i</span></sub> is
some number <span style="font-style:italic">n</span>, this number denotes the <span style="font-style:italic">n</span>-th non dependent
premise of the <span style="font-style:oblique">term</span>, as determined by the type of <span style="font-style:oblique">term</span>.<p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">No such binder</span><a id="hevea_error56"></a></p></li><li class="li-itemize">A bindings list can also be a simple list of terms <span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>. In that case the references to
which these terms correspond are determined by the tactic. In case
of <span style="font-family:monospace">induction</span>, <span style="font-family:monospace">destruct</span>, <span style="font-family:monospace">elim</span> and <span style="font-family:monospace">case</span> (see
Section <a href="#elim">9</a>) the terms have to provide instances for all the
dependent products in the type of <span style="font-style:oblique">term</span> while in the case of <span style="font-family:monospace">apply</span>, or of <span style="font-family:monospace">constructor</span> and its variants, only instances for
the dependent products that are not bound in the conclusion of the
type are required.<p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Not the right number of missing arguments</span><a id="hevea_error57"></a>
</p></li></ul>
<h3 id="sec356" class="subsection">8.1.4  Occurrences sets and occurrences clauses</h3>
<p>
<a id="Occurrences_clauses"></a>
<a id="hevea_default536"></a></p><p>An occurrences clause is a modifier to some tactics that obeys the
following syntax:</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">occurrence_clause</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">in</span> <span style="font-style:oblique">goal_occurrences</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">goal_occurrences</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" > <span style="font-style:oblique">[</span><span style="font-style:oblique">ident</span><sub>1</sub> <span style="font-style:oblique">[</span><span style="font-style:oblique">at_occurrences</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">,</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >… <span style="font-family:monospace">,</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:oblique">[</span><span style="font-style:oblique">at_occurrences</span><span style="font-style:oblique">]</span><span style="font-style:oblique">]</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">[</span><span style="font-family:monospace">|-</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">*</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">at_occurrences</span><span style="font-style:oblique">]</span><span style="font-style:oblique">]</span><span style="font-style:oblique">]</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">*</span> <span style="font-family:monospace">|-</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">*</span> <span style="font-style:oblique">[</span><span style="font-style:oblique">at_occurrences</span><span style="font-style:oblique">]</span><span style="font-style:oblique">]</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">*</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">at_occurrences</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">at</span> <span style="font-style:oblique">occurrences</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">occurrences</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">[</span><span style="font-family:monospace">-</span><span style="font-style:oblique">]</span> <span style="font-style:oblique">num</span><sub>1</sub> … <span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span></sub>
</td></tr>
</table><p>The role of an occurrence clause is to select a set of occurrences of
a <span style="font-style:oblique">term</span> in a goal. In the first case, the <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>
<span style="font-style:oblique">[</span><span style="font-family:monospace">at</span> <span style="font-style:oblique">num</span><sub>1</sub><sup><span style="font-style:italic">i</span></sup> … <span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub></sub><sup><span style="font-style:italic">i</span></sup><span style="font-style:oblique">]</span> parts
indicate that occurrences have to be selected in the hypotheses named
<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>. If no numbers are given for hypothesis <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>,
then all the occurrences of <span style="font-style:oblique">term</span> in the hypothesis are selected. If
numbers are given, they refer to occurrences of <span style="font-style:oblique">term</span> when the term
is printed using option <span style="font-family:monospace">Set Printing All</span> (see
Section <a href="gallina-ext.html#SetPrintingAll">2.9</a>), counting from left to right. In
particular, occurrences of <span style="font-style:oblique">term</span> in implicit arguments (see
Section <a href="gallina-ext.html#Implicit%20Arguments">2.7</a>) or coercions (see
Section <a href="gallina-ext.html#Coercions">2.8</a>) are counted.</p><p>If a minus sign is given between <span style="font-family:monospace">at</span> and the list of occurrences,
it negates the condition so that the clause denotes all the occurrences except
the ones explicitly mentioned after the minus sign.</p><p>As an exception to the left-to-right order, the occurrences in the
<span style="font-family:monospace">return</span> subexpression of a <span style="font-family:monospace">match</span> are considered <em>before</em> the occurrences in the matched term.</p><p>In the second case, the <span style="font-family:monospace">*</span> on the left of <span style="font-family:monospace">|-</span> means that
all occurrences of <span style="font-style:oblique">term</span> are selected in every hypothesis.</p><p>In the first and second case, if <span style="font-family:monospace">*</span> is mentioned on the right of
<span style="font-family:monospace">|-</span>, the occurrences of the conclusion of the goal have to be
selected. If some numbers are given, then only the occurrences denoted
by these numbers are selected. In no numbers are given, all
occurrences of <span style="font-style:oblique">term</span> in the goal are selected.</p><p>Finally, the last notation is an abbreviation for <span style="font-family:monospace">* |- *</span>. Note
also that <span style="font-family:monospace">|-</span> is optional in the first case when no <span style="font-family:monospace">*</span> is
given.</p><p>Here are some tactics that understand occurrences clauses:
<span style="font-family:monospace">set</span>, <span style="font-family:monospace">remember</span>, <span style="font-family:monospace">induction</span>, <span style="font-family:monospace">destruct</span>.</p><p><br>
<span style="font-weight:bold">See also: </span> Sections <a href="#tactic%3Aset">8.3.7</a>, <a href="#Tac-induction">8.5.2</a>, <a href="gallina-ext.html#SetPrintingAll">2.9</a>.</p>
<h2 id="sec357" class="section">8.2  Applying theorems</h2>
<h3 id="sec358" class="subsection">8.2.1  <span style="font-family:monospace">exact </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default537"></a><a id="hevea_tactic3"></a>
<a id="exact"></a></p><p>This tactic applies to any goal. It gives directly the exact proof
term of the goal. Let <span style="font-family:monospace">T</span> be our goal, let <span style="font-family:monospace">p</span> be a term of type
<span style="font-family:monospace">U</span> then <span style="font-family:monospace">exact p</span> succeeds iff <span style="font-family:monospace">T</span> and <span style="font-family:monospace">U</span> are
convertible (see Section <a href="cic.html#conv-rules">4.3</a>).</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Not an exact proof</span><a id="hevea_error58"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">eexact </span><span style="font-style:oblique">term</span><a id="hevea_default538"></a><a id="hevea_tactic4"></a><p>This tactic behaves like <span style="font-family:monospace">exact</span> but is able to handle terms
and goals with meta-variables.</p></li></ol>
<h3 id="sec359" class="subsection">8.2.2  <span style="font-family:monospace">assumption</span></h3>
<p>
<a id="hevea_default539"></a><a id="hevea_tactic5"></a></p><p>This tactic looks in the local context for an
hypothesis which type is equal to the goal. If it is the case, the
subgoal is proved. Otherwise, it fails.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">No such assumption</span><a id="hevea_error59"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<a id="hevea_default540"></a><a id="hevea_tactic6"></a>
<span style="font-family:monospace">eassumption</span><p>This tactic behaves like <span style="font-family:monospace">assumption</span> but is able to handle
goals with meta-variables.</p></li></ol>
<h3 id="sec360" class="subsection">8.2.3  <span style="font-family:monospace">refine </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default541"></a><a id="hevea_tactic7"></a>
<a id="refine"></a>
<a id="refine-example"></a>
<a id="hevea_default542"></a></p><p>This tactic applies to any goal. It behaves like <span style="font-family:monospace">exact</span> with a big
difference: the user can leave some holes (denoted by <span style="font-family:monospace">_</span> or
<span style="font-family:monospace">(_:</span><span style="font-style:oblique">type</span><span style="font-family:monospace">)</span>) in the term. <span style="font-family:monospace">refine</span> will generate as
many subgoals as there are holes in the term. The type of holes must be
either synthesized by the system or declared by an
explicit cast like <code>(_:nat-&gt;Prop)</code>. Any subgoal that occurs in other
subgoals is automatically shelved, as if calling <span style="font-family:monospace">shelve_unifiable</span>
(see Section <a href="#shelve">8.17.4</a>).
This low-level tactic can be useful to advanced users.</p><p><br>
<span style="font-weight:bold">Example: </span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive Option : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | Fail : Option</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | Ok : bool -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Option.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition get : forall x:Option, x </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> bool.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall x : Option, x </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Fail -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> bool</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> refine</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">       (fun x:Option =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          match x return x </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> bool with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          | Fail =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          | Ok b =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> fun </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> b</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          end).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x : Option</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  Fail </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Fail -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> bool</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros; absurd (Fail = Fail); trivial.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Defined.</span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">invalid argument</span><a id="hevea_error60"></a>:
the tactic <span style="font-family:monospace">refine</span> does not know what to do
with the term you gave.
</li><li class="li-enumerate"><span style="font-family:monospace">Refine passed ill-formed term</span>: the term you gave is not
a valid proof (not easy to debug in general).
This message may also occur in higher-level tactics that call
<span style="font-family:monospace">refine</span> internally.
</li><li class="li-enumerate"><span style="font-family:monospace">Cannot infer a term for this placeholder</span><a id="hevea_error61"></a>:
there is a hole in the term you gave
which type cannot be inferred. Put a cast around it.
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">simple refine </span><span style="font-style:oblique">term</span><a id="hevea_default543"></a><a id="hevea_tactic8"></a><p>This tactic behaves like <span style="font-family:monospace">refine</span>, but it does not shelve any
subgoal. It does not perform any beta-reduction either.
</p></li><li class="li-enumerate"><span style="font-family:monospace">notypeclasses refine </span><span style="font-style:oblique">term</span><a id="hevea_default544"></a><a id="hevea_tactic9"></a><p>This tactic behaves like <span style="font-family:monospace">refine</span> except it performs typechecking
without resolution of typeclasses.</p></li><li class="li-enumerate"><span style="font-family:monospace">simple notypeclasses refine </span><span style="font-style:oblique">term</span><a id="hevea_default545"></a><a id="hevea_tactic10"></a><p>This tactic behaves like <span style="font-family:monospace">simple refine</span> except it performs typechecking
without resolution of typeclasses.
</p></li></ol>
<h3 id="sec361" class="subsection">8.2.4  <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default546"></a><a id="hevea_tactic11"></a>
<a id="apply"></a>
<a id="eapply"></a></p><p>This tactic applies to any goal. The argument <span style="font-style:oblique">term</span> is a term
well-formed in the local context. The tactic <span style="font-family:monospace">apply</span> tries to
match the current goal against the conclusion of the type of <span style="font-style:oblique">term</span>.
If it succeeds, then the tactic returns as many subgoals as the number
of non-dependent premises of the type of <span style="font-style:oblique">term</span>. If the conclusion of
the type of <span style="font-style:oblique">term</span> does not match the goal <em>and</em> the conclusion
is an inductive type isomorphic to a tuple type, then each component
of the tuple is recursively matched to the goal in the left-to-right
order.</p><p>The tactic <span style="font-family:monospace">apply</span> relies on first-order unification with
dependent types unless the conclusion of the type of <span style="font-style:oblique">term</span> is of the
form <span style="font-family:monospace">(</span><span style="font-style:italic">P</span><span style="font-family:monospace"> </span><span style="font-style:italic">t</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span> with <span style="font-style:italic">P</span> to be instantiated. In
the latter case, the behavior depends on the form of the goal. If the
goal is of the form <span style="font-family:monospace">(fun </span><span style="font-style:italic">x</span><span style="font-family:monospace"> =&gt; </span><span style="font-style:italic">Q</span><span style="font-family:monospace">) </span><span style="font-style:italic">u</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> and the
<span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub> and <span style="font-style:italic">u</span><sub><span style="font-style:italic">i</span></sub> unifies, then <span style="font-style:italic">P</span> is taken to be <span style="font-family:monospace">(fun </span><span style="font-style:italic">x</span><span style="font-family:monospace"> =&gt; </span><span style="font-style:italic">Q</span><span style="font-family:monospace">)</span>.
Otherwise, <span style="font-family:monospace">apply</span> tries to define <span style="font-style:italic">P</span> by abstracting over
<span style="font-style:italic">t</span><sub>1</sub> … <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub> in the goal. See <span style="font-family:monospace">pattern</span> in
Section <a href="#pattern">8.7.7</a> to transform the goal so that it gets the form
<span style="font-family:monospace">(fun </span><span style="font-style:italic">x</span><span style="font-family:monospace"> =&gt; </span><span style="font-style:italic">Q</span><span style="font-family:monospace">) </span><span style="font-style:italic">u</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Unable to unify … with …</span><a id="hevea_error62"></a><p>The <span style="font-family:monospace">apply</span>
tactic failed to match the conclusion of <span style="font-style:oblique">term</span> and the current goal.
You can help the <span style="font-family:monospace">apply</span> tactic by transforming your
goal with the <span style="font-family:monospace">change</span> or <span style="font-family:monospace">pattern</span> tactics (see
sections <a href="#pattern">8.7.7</a>, <a href="#change">8.6.5</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">Unable to find an instance for the variables
</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><a id="hevea_error63"></a><p>This occurs when some instantiations of the premises of <span style="font-style:oblique">term</span> are not
deducible from the unification. This is the case, for instance, when
you want to apply a transitivity property. In this case, you have to
use one of the variants below:</p></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>
<a id="hevea_default547"></a><a id="hevea_tactic12"></a><p>Provides <span style="font-family:monospace">apply</span> with explicit instantiations for all dependent
premises of the type of <span style="font-style:oblique">term</span> that do not occur in the conclusion
and consequently cannot be found by unification. Notice that
<span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> must be given according to the order
of these dependent premises of the type of <span style="font-style:oblique">term</span>.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Not the right number of missing arguments</span><a id="hevea_error64"></a></p></li><li class="li-enumerate"><span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with (</span><span style="font-style:oblique">ref</span><sub>1</sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">) … (</span><span style="font-style:oblique">ref</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">
:= </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span><p>This also provides <span style="font-family:monospace">apply</span> with values for instantiating
premises. Here, variables are referred by names and non-dependent
products by increasing numbers (see syntax in Section <a href="#Binding-list">8.1.3</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> , </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> , </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><p>This is a shortcut for <span style="font-family:monospace">apply</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">; [ .. |</span>
… <span style="font-family:monospace">; [ .. | </span><span style="font-family:monospace">apply</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> ]</span> … <span style="font-family:monospace">]</span>, i.e. for the
successive applications of <span style="font-style:oblique">term</span><sub><span style="font-style:italic">i</span>+1</sub> on the last subgoal
generated by <span style="font-family:monospace">apply</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">i</span></sub>, starting from the application
of <span style="font-style:oblique">term</span><sub>1</sub>.</p></li><li class="li-enumerate"><span style="font-family:monospace">eapply </span><span style="font-style:oblique">term</span><a id="hevea_default548"></a><a id="hevea_tactic13"></a><p>The tactic <span style="font-family:monospace">eapply</span> behaves like <span style="font-family:monospace">apply</span> but it does not fail
when no instantiations are deducible for some variables in the
premises. Rather, it turns these variables into
existential variables which are variables still to instantiate (see
Section <a href="gallina-ext.html#evars">2.11</a>). The instantiation is intended to be found
later in the proof.</p></li><li class="li-enumerate"><span style="font-family:monospace">simple apply </span><span style="font-style:oblique">term</span> <a id="hevea_default549"></a><a id="hevea_tactic14"></a><p>This behaves like <span style="font-family:monospace">apply</span> but it reasons modulo conversion only
on subterms that contain no variables to instantiate. For instance,
the following example does not succeed because it would require the
conversion of <span style="font-family:monospace">id ?foo</span> and <span style="font-family:monospace">O</span>.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition id (x : nat) := x.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Hypothesis H : forall y, id y = y.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal O = O.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail simple apply H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The command has indeed failed with message:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Unable to unify "id ?M158 = ?M158" with "0 = 0".</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 = 0</span></span></span><span style="font-size:small"><br>
</span></div><p>Because it reasons modulo a limited amount of conversion, <span style="font-family:monospace">simple apply</span> fails quicker than <span style="font-family:monospace">apply</span> and it is then
well-suited for uses in used-defined tactics that backtrack often.
Moreover, it does not traverse tuples as <span style="font-family:monospace">apply</span> does.</p></li><li class="li-enumerate"><span style="font-style:oblique">[</span><span style="font-family:monospace">simple</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">apply</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-style:oblique">[</span><span style="font-family:monospace">with</span>
<span style="font-style:oblique">bindings_list</span><sub>1</sub><span style="font-style:oblique">]</span> <span style="font-family:monospace">,</span> …<span style="font-family:monospace">,</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:oblique">[</span><span style="font-family:monospace">with</span>
<span style="font-style:oblique">bindings_list</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:oblique">]</span><br>
 <span style="font-style:oblique">[</span><span style="font-family:monospace">simple</span><span style="font-style:oblique">]</span> <span style="font-family:monospace">eapply</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-style:oblique">[</span><span style="font-family:monospace">with</span>
<span style="font-style:oblique">bindings_list</span><sub>1</sub><span style="font-style:oblique">]</span> <span style="font-family:monospace">,</span> …<span style="font-family:monospace">,</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:oblique">[</span><span style="font-family:monospace">with</span>
<span style="font-style:oblique">bindings_list</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:oblique">]</span><p>This summarizes the different syntaxes for <span style="font-family:monospace">apply</span> and <span style="font-family:monospace">eapply</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">lapply </span><span style="font-style:oblique">term</span> <a id="hevea_default550"></a><a id="hevea_tactic15"></a><p>This tactic applies to any goal, say <span style="font-family:monospace">G</span>. The argument <span style="font-style:oblique">term</span>
has to be well-formed in the current context, its type being
reducible to a non-dependent product <span style="font-family:monospace">A -&gt; B</span> with <span style="font-family:monospace">B</span>
possibly containing products. Then it generates two subgoals <span style="font-family:monospace">B-&gt;G</span> and <span style="font-family:monospace">A</span>. Applying <span style="font-family:monospace">lapply H</span> (where <span style="font-family:monospace">H</span> has type
<span style="font-family:monospace">A-&gt;B</span> and <span style="font-family:monospace">B</span> does not start with a product) does the same
as giving the sequence <span style="font-family:monospace">cut B. 2:apply H.</span> where <span style="font-family:monospace">cut</span> is
described below.</p><p><br>
<span style="font-weight:bold">Warning: </span>When <span style="font-style:oblique">term</span> contains more than one non
dependent product the tactic <span style="font-family:monospace">lapply</span> only takes into account the
first product.</p></li></ol><p><br>
<span style="font-weight:bold">Example: </span>Assume we have a transitive relation <span style="font-family:monospace">R</span> on <span style="font-family:monospace">nat</span>:
<a id="eapply-example"></a></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variable R : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Hypothesis Rtrans : forall x y z:nat, R x y -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> R y z -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> R x z.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variables n m p : nat.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Hypothesis Rnm : R n m.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Hypothesis Rmp : R m p.</span></span><span style="font-size:small"><br>
</span></div><p>Consider the goal <span style="font-family:monospace">(R n p)</span> provable using the transitivity of
<span style="font-family:monospace">R</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal R n p.</span></span><span style="font-size:small"><br>
</span></div><p>The direct application of <span style="font-family:monospace">Rtrans</span> with <span style="font-family:monospace">apply</span> fails because
no value for <span style="font-family:monospace">y</span> in <span style="font-family:monospace">Rtrans</span> is found by <span style="font-family:monospace">apply</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail apply Rtrans.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The command has indeed failed with message:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Unable to find an instance for the variable y.</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  R n p</span></span></span><span style="font-size:small"><br>
</span></div><p>A solution is to apply <span style="font-family:monospace">(Rtrans n m p)</span> or <span style="font-family:monospace">(Rtrans n m)</span>.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> apply (Rtrans n m p).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">2 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  R n m</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> R m p</span></span></span><span style="font-size:small"><br>
</span></div><p>Note that <span style="font-family:monospace">n</span> can be inferred from the goal, so the following would
work too.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> apply (Rtrans </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> m).</span></span><span style="font-size:small"><br>
</span></div><p>More elegantly, <span style="font-family:monospace">apply Rtrans with (y:=m)</span> allows only mentioning
the unknown <span style="font-family:monospace">m</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> apply Rtrans with (y := m).</span></span><span style="font-size:small"><br>
</span></div><p>Another solution is to mention the proof of <span style="font-family:monospace">(R x y)</span> in <span style="font-family:monospace">Rtrans</span> …</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> apply Rtrans with (1 := Rnm).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  R m p</span></span></span><span style="font-size:small"><br>
</span></div><p>…or the proof of <span style="font-family:monospace">(R y z)</span>.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> apply Rtrans with (2 := Rmp).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  R n m</span></span></span><span style="font-size:small"><br>
</span></div><p>On the opposite, one can use <span style="font-family:monospace">eapply</span> which postpones the problem
of finding <span style="font-family:monospace">m</span>. Then one can apply the hypotheses <span style="font-family:monospace">Rnm</span> and <span style="font-family:monospace">Rmp</span>. This instantiates the existential variable and completes the proof.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> eapply Rtrans.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">2 focused subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">(shelved: 1)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  R n ?y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> R ?y p</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> apply Rnm.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  R m p</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> apply Rmp.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><p><span style="font-weight:bold">Remark: </span> When the conclusion of the type of the term
to apply is an inductive type isomorphic to a tuple type and <em>apply</em>
looks recursively whether a component of the tuple matches the goal,
it excludes components whose statement would result in applying an
universal lemma of the form <span style="font-family:monospace">forall A, ... -&gt; A</span>. Excluding this
kind of lemma can be avoided by setting the following option:</p><blockquote class="quote">
<a id="hevea_default551"></a><a id="hevea_option50"></a>
<span style="font-family:monospace">Set Universal Lemma Under Conjunction</span>
</blockquote><p>This option, which preserves compatibility with versions of <span style="font-variant:small-caps">Coq</span>
prior to 8.4 is also available for <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span>
(see Section <a href="#apply-in">8.2.5</a>).</p>
<h3 id="sec362" class="subsection">8.2.5  <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="apply-in"></a>
<a id="hevea_default552"></a><a id="hevea_tactic16"></a></p><p>This tactic applies to any goal. The argument <span style="font-style:oblique">term</span> is a term
well-formed in the local context and the argument <span style="font-style:oblique">ident</span> is an
hypothesis of the context. The tactic <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span>
tries to match the conclusion of the type of <span style="font-style:oblique">ident</span> against a
non-dependent premise of the type of <span style="font-style:oblique">term</span>, trying them from right to
left. If it succeeds, the statement of hypothesis <span style="font-style:oblique">ident</span> is
replaced by the conclusion of the type of <span style="font-style:oblique">term</span>. The tactic also
returns as many subgoals as the number of other non-dependent premises
in the type of <span style="font-style:oblique">term</span> and of the non-dependent premises of the type
of <span style="font-style:oblique">ident</span>. If the conclusion of the type of <span style="font-style:oblique">term</span> does not match
the goal <em>and</em> the conclusion is an inductive type isomorphic to a
tuple type, then the tuple is (recursively) decomposed and the first
component of the tuple of which a non-dependent premise matches the
conclusion of the type of <span style="font-style:oblique">ident</span>. Tuples are decomposed in a
width-first left-to-right order (for instance if the type of <span style="font-family:monospace">H1</span>
is a <code>A &lt;-&gt; B</code> statement, and the type of <span style="font-family:monospace">H2</span> is <code>A</code>
then <span style="font-family:monospace">apply H1 in H2</span> transforms the type of <span style="font-family:monospace">H2</span> into <span style="font-family:monospace">B</span>). The tactic <span style="font-family:monospace">apply</span> relies on first-order pattern-matching
with dependent types.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Statement without assumptions</span><a id="hevea_error65"></a><p>This happens if the type of <span style="font-style:oblique">term</span> has no non dependent premise.</p></li><li class="li-enumerate"><span style="font-family:monospace">Unable to apply</span><a id="hevea_error66"></a><p>This happens if the conclusion of <span style="font-style:oblique">ident</span> does not match any of the
non dependent premises of the type of <span style="font-style:oblique">term</span>.
</p></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><p>This applies each of <span style="font-style:oblique">term</span> in sequence in <span style="font-style:oblique">ident</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><p>This does the same but uses the bindings in each <span style="font-style:oblique">bindings_list</span> to
instantiate the parameters of the corresponding type of <span style="font-style:oblique">term</span>
(see syntax of bindings in Section <a href="#Binding-list">8.1.3</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">eapply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span>
<a id="hevea_default553"></a><a id="hevea_tactic17"></a><p>This works as <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> in
</span><span style="font-style:oblique">ident</span> but turns unresolved bindings into existential variables, if
any, instead of failing.</p></li><li class="li-enumerate"><span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><p>This works as <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> in
</span><span style="font-style:oblique">ident</span> then applies the <span style="font-style:oblique">intro_pattern</span> to the hypothesis <span style="font-style:oblique">ident</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">eapply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><p>This works as <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span> but using <span style="font-family:monospace">eapply</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">simple apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span>
<a id="hevea_default554"></a><a id="hevea_tactic18"></a>
<a id="hevea_default555"></a><a id="hevea_tactic19"></a><p>This behaves like <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span> but it reasons
modulo conversion only on subterms that contain no variables to
instantiate. For instance, if <span style="font-family:monospace">id := fun x:nat =&gt; x</span> and <span style="font-family:monospace">H :
forall y, id y = y -&gt; True</span> and <span style="font-family:monospace">H0 : O = O</span> then <span style="font-family:monospace">simple
apply H in H0</span> does not succeed because it would require the
conversion of <span style="font-family:monospace">id ?1234</span> and <span style="font-family:monospace">O</span> where <span style="font-family:monospace">?1234</span> is a variable to
instantiate. Tactic <span style="font-family:monospace">simple apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span> does not
either traverse tuples as <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span> does.</p></li><li class="li-enumerate"><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">simple</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><br>
<span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">simple</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> eapply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><p>This summarizes the different syntactic variants of <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace">
in </span><span style="font-style:oblique">ident</span> and <span style="font-family:monospace">eapply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span>.
</p></li></ol>
<h3 id="sec363" class="subsection">8.2.6  <span style="font-family:monospace">constructor </span><span style="font-style:oblique">num</span></h3>
<p>
<a id="constructor"></a>
<a id="hevea_default556"></a><a id="hevea_tactic20"></a></p><p>This tactic applies to a goal such that its conclusion is
an inductive type (say <span style="font-family:monospace">I</span>). The argument <span style="font-style:oblique">num</span> must be less
or equal to the numbers of constructor(s) of <span style="font-family:monospace">I</span>. Let <span style="font-family:monospace">ci</span> be
the <span style="font-family:monospace">i</span>-th constructor of <span style="font-family:monospace">I</span>, then <span style="font-family:monospace">constructor i</span> is
equivalent to <span style="font-family:monospace">intros; apply ci</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Not an inductive product</span><a id="hevea_error67"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">Not enough constructors</span><a id="hevea_error68"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">constructor</span><p>This tries <span style="font-family:monospace">constructor 1</span> then <span style="font-family:monospace">constructor 2</span>,
… , then <span style="font-family:monospace">constructor</span> <span style="font-style:italic">n</span> where <span style="font-style:italic">n</span> is
the number of constructors of the head of the goal.</p></li><li class="li-enumerate"><span style="font-family:monospace">constructor </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> with</span> <span style="font-style:oblique">bindings_list</span><p>Let <span style="font-family:monospace">ci</span> be the <span style="font-family:monospace">i</span>-th constructor of <span style="font-family:monospace">I</span>, then <span style="font-family:monospace">constructor i with </span><span style="font-style:oblique">bindings_list</span> is equivalent to <span style="font-family:monospace">intros;
apply ci with </span><span style="font-style:oblique">bindings_list</span>.</p><p><br>
<span style="font-weight:bold">Warning: </span>the terms in the <span style="font-style:oblique">bindings_list</span> are checked
in the context where <span style="font-family:monospace">constructor</span> is executed and not in the
context where <span style="font-family:monospace">apply</span> is executed (the introductions are not
taken into account).</p></li><li class="li-enumerate"><span style="font-family:monospace">split</span><a id="hevea_default557"></a><a id="hevea_tactic21"></a><p>This applies only if <span style="font-family:monospace">I</span> has a single constructor. It is then
equivalent to <span style="font-family:monospace">constructor 1</span>. It is typically used in the case
of a conjunction <span style="font-style:italic">A</span>∧ <span style="font-style:italic">B</span>.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Not an inductive goal with 1 constructor</span><a id="hevea_error69"></a></p></li><li class="li-enumerate"><span style="font-family:monospace">exists </span><span style="font-style:oblique">bindings_list</span><a id="hevea_default558"></a><a id="hevea_tactic22"></a><p>This applies only if <span style="font-family:monospace">I</span> has a single constructor. It is then
equivalent to <span style="font-family:monospace">intros; constructor 1 with </span><span style="font-style:oblique">bindings_list</span>. It is
typically used in the case of an existential quantification ∃
<span style="font-style:italic">x</span>, <span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>).</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Not an inductive goal with 1 constructor</span><a id="hevea_error70"></a></p></li><li class="li-enumerate"><span style="font-family:monospace">exists </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-family:monospace">,</span><span style="font-family:monospace"> </span><span style="font-style:oblique">bindings_list</span><p>This iteratively applies <span style="font-family:monospace">exists </span><span style="font-style:oblique">bindings_list</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">left</span><a id="hevea_default559"></a><a id="hevea_tactic23"></a><br>
 <span style="font-family:monospace">right</span><a id="hevea_default560"></a><a id="hevea_tactic24"></a><p>These tactics apply only if <span style="font-family:monospace">I</span> has two constructors, for instance
in the case of a
disjunction <span style="font-style:italic">A</span>∨ <span style="font-style:italic">B</span>. Then, they are respectively equivalent to <span style="font-family:monospace">constructor 1</span> and <span style="font-family:monospace">constructor 2</span>.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Not an inductive goal with 2 constructors</span><a id="hevea_error71"></a></p></li><li class="li-enumerate"><span style="font-family:monospace">left with </span><span style="font-style:oblique">bindings_list</span><br>
 <span style="font-family:monospace">right with </span><span style="font-style:oblique">bindings_list</span><br>
 <span style="font-family:monospace">split with </span><span style="font-style:oblique">bindings_list</span><p>As soon as the inductive type has the right number of constructors,
these expressions are equivalent to calling <span style="font-family:monospace">constructor </span><span style="font-style:italic">i</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span> for the appropriate <span style="font-style:italic">i</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">econstructor</span><a id="hevea_default561"></a><a id="hevea_tactic25"></a><br>
 <span style="font-family:monospace">eexists</span><a id="hevea_default562"></a><a id="hevea_tactic26"></a><br>
 <span style="font-family:monospace">esplit</span><a id="hevea_default563"></a><a id="hevea_tactic27"></a><br>
 <span style="font-family:monospace">eleft</span><a id="hevea_default564"></a><a id="hevea_tactic28"></a><br>
 <span style="font-family:monospace">eright</span><a id="hevea_default565"></a><a id="hevea_tactic29"></a><p>These tactics and their variants behave like <span style="font-family:monospace">constructor</span>,
<span style="font-family:monospace">exists</span>, <span style="font-family:monospace">split</span>, <span style="font-family:monospace">left</span>, <span style="font-family:monospace">right</span> and
their variants but they introduce existential variables instead of
failing when the instantiation of a variable cannot be found (cf
<span style="font-family:monospace">eapply</span> and Section <a href="#eapply-example">8.2.4</a>).</p></li></ol>
<h2 id="sec364" class="section">8.3  Managing the local context</h2>
<h3 id="sec365" class="subsection">8.3.1  <span style="font-family:monospace">intro</span></h3>
<p>
<a id="hevea_default566"></a><a id="hevea_tactic30"></a>
<a id="intro"></a></p><p>This tactic applies to a goal that is either a product or starts with
a let binder. If the goal is a product, the tactic implements the
“Lam”<a id="hevea_default567"></a> rule given in
Section <a href="cic.html#Typed-terms">4.2</a><sup><a id="text12" href="#note12">1</a></sup>. If the
goal starts with a let binder, then the tactic implements a mix of the
“Let”<a id="hevea_default568"></a> and “Conv”<a id="hevea_default569"></a>.</p><p>If the current goal is a dependent product ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>, <span style="font-style:italic">U</span> (resp <span style="font-family:monospace">let </span><span style="font-style:italic">x</span><span style="font-family:monospace">:=</span><span style="font-style:italic">t</span><span style="font-family:monospace"> in </span><span style="font-style:italic">U</span>) then <span style="font-family:monospace">intro</span> puts <span style="font-style:italic">x</span><span style="font-family:monospace">:</span><span style="font-style:italic">T</span> (resp <span style="font-style:italic">x</span><span style="font-family:monospace">:=</span><span style="font-style:italic">t</span>)
in the local context.
The new subgoal is <span style="font-style:italic">U</span>.
</p><p>If the goal is a non-dependent product <span style="font-style:italic">T</span> → <span style="font-style:italic">U</span>, then it puts
in the local context either <span style="font-family:monospace">H</span><span style="font-style:italic">n</span><span style="font-family:monospace">:</span><span style="font-style:italic">T</span> (if <span style="font-style:italic">T</span> is of
type <span style="font-family:monospace">Set</span> or <span style="font-family:monospace">Prop</span>) or <span style="font-family:monospace">X</span><span style="font-style:italic">n</span><span style="font-family:monospace">:</span><span style="font-style:italic">T</span> (if the type
of <span style="font-style:italic">T</span> is <span style="font-family:monospace">Type</span>). The optional index <span style="font-style:italic">n</span> is such that <span style="font-family:monospace">H</span><span style="font-style:italic">n</span> or <span style="font-family:monospace">X</span><span style="font-style:italic">n</span> is a fresh identifier.
In both cases, the new subgoal is <span style="font-style:italic">U</span>.</p><p>If the goal is neither a product nor starting with a let definition,
the tactic <span style="font-family:monospace">intro</span> applies the tactic <span style="font-family:monospace">hnf</span> until the tactic
<span style="font-family:monospace">intro</span> can be applied or the goal is not head-reducible.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">No product even after head-reduction</span><a id="hevea_error72"></a>
</li><li class="li-enumerate"><span style="font-style:oblique">ident</span><span style="font-family:monospace"> is already used</span><a id="hevea_error73"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">intros</span><a id="hevea_default570"></a><a id="hevea_tactic31"></a><p>This repeats <span style="font-family:monospace">intro</span> until it meets the head-constant. It never reduces
head-constants and it never fails.</p></li><li class="li-enumerate"><span style="font-family:monospace">intro </span><span style="font-style:oblique">ident</span><p>This applies <span style="font-family:monospace">intro</span> but forces <span style="font-style:oblique">ident</span> to be the name of the
introduced hypothesis.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">name </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> is already used</span><a id="hevea_error74"></a></p><p><br>
<span style="font-weight:bold">Remark: </span>If a name used by <span style="font-family:monospace">intro</span> hides the base name of a global
constant then the latter can still be referred to by a qualified name
(see <a href="gallina-ext.html#LongNames">2.6.2</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">intros </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>This is equivalent to the composed tactic <span style="font-family:monospace">intro </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">; … ;
intro </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>.</p><p>More generally, the <span style="font-family:monospace">intros</span> tactic takes a pattern as
argument in order to introduce names for components of an inductive
definition or to clear introduced hypotheses. This is explained
in <a href="#intros-pattern">8.3.2</a>.</p></li><li class="li-enumerate"><span style="font-family:monospace">intros until </span><span style="font-style:oblique">ident</span> <a id="hevea_default571"></a><a id="hevea_tactic32"></a><p>This repeats <span style="font-family:monospace">intro</span> until it meets a premise of the goal having form
<span style="font-family:monospace">(</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span> and discharges the variable
named <span style="font-style:oblique">ident</span> of the current goal.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">No such hypothesis in current goal</span><a id="hevea_error75"></a></p></li><li class="li-enumerate"><span style="font-family:monospace">intros until </span><span style="font-style:oblique">num</span> <a id="hevea_default572"></a><a id="hevea_tactic33"></a><p>This repeats <span style="font-family:monospace">intro</span> until the <span style="font-style:oblique">num</span>-th non-dependent product. For
instance, on the subgoal <code>forall x y:nat, x=y -&gt; y=x</code> the tactic <span style="font-family:monospace">intros until 1</span>
is equivalent to <span style="font-family:monospace">intros x y H</span>, as <code>x=y -&gt; y=x</code> is the
first non-dependent product. And on the subgoal <code>forall x y z:nat, x=y -&gt; y=x</code> the tactic <span style="font-family:monospace">intros until 1</span>
is equivalent to <span style="font-family:monospace">intros x y z</span> as the product on <span style="font-family:monospace">z</span>
can be rewritten as a non-dependent product: <code>forall x y:nat, nat -&gt; x=y -&gt; y=x</code></p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">No such hypothesis in current goal</span><a id="hevea_error76"></a></p><p>This happens when <span style="font-style:oblique">num</span> is 0 or is greater than the number of non-dependent
products of the goal.</p></li><li class="li-enumerate"><span style="font-family:monospace">intro after </span><span style="font-style:oblique">ident</span> <a id="hevea_default573"></a><a id="hevea_tactic34"></a><br>
 <span style="font-family:monospace">intro before </span><span style="font-style:oblique">ident</span> <a id="hevea_default574"></a><a id="hevea_tactic35"></a><br>
 <span style="font-family:monospace">intro at top</span> <a id="hevea_default575"></a><a id="hevea_tactic36"></a><br>
 <span style="font-family:monospace">intro at bottom</span> <a id="hevea_default576"></a><a id="hevea_tactic37"></a><p>These tactics apply <span style="font-family:monospace">intro</span> and move the freshly introduced hypothesis
respectively after the hypothesis <span style="font-style:oblique">ident</span>, before the hypothesis
<span style="font-style:oblique">ident</span>, at the top of the local context, or at the bottom of the
local context. All hypotheses on which the new hypothesis depends
are moved too so as to respect the order of dependencies between
hypotheses. Note that <span style="font-family:monospace">intro at bottom</span> is a synonym for <span style="font-family:monospace">intro</span> with no argument.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">No such hypothesis</span><a id="hevea_error77"></a> : <span style="font-style:oblique">ident</span></p></li><li class="li-enumerate"><span style="font-family:monospace">intro </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> after </span><span style="font-style:oblique">ident</span><sub>2</sub><br>
 <span style="font-family:monospace">intro </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> before </span><span style="font-style:oblique">ident</span><sub>2</sub><br>
 <span style="font-family:monospace">intro </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> at top</span><br>
 <span style="font-family:monospace">intro </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> at bottom</span><p>These tactics behave as previously but naming the introduced hypothesis
<span style="font-style:oblique">ident</span><sub>1</sub>. It is equivalent to <span style="font-family:monospace">intro </span><span style="font-style:oblique">ident</span><sub>1</sub> followed by
the appropriate call to <span style="font-family:monospace">move</span> (see Section <a href="#move">8.3.5</a>).</p></li></ol>
<h3 id="sec366" class="subsection">8.3.2  <span style="font-family:monospace">intros </span><span style="font-style:oblique">intro_pattern_list</span></h3>
<p>
<a id="intros-pattern"></a>
<a id="hevea_default577"></a><a id="hevea_tactic38"></a>
<a id="hevea_default578"></a>
<a id="hevea_default579"></a>
<a id="hevea_default580"></a>
<a id="hevea_default581"></a>
<a id="hevea_default582"></a></p><p>This extension of the tactic <span style="font-family:monospace">intros</span> allows to apply tactics on
the fly on the variables or hypotheses which have been introduced. An
<em>introduction pattern list</em> <span style="font-style:oblique">intro_pattern_list</span> is a list of
introduction patterns possibly containing the filling introduction
patterns <span style="font-family:monospace">*</span> and <span style="font-family:monospace">**</span>. An <em>introduction pattern</em> is
either:
</p><ul class="itemize"><li class="li-itemize">
a <em>naming introduction pattern</em>, i.e. either one of:
<ul class="itemize"><li class="li-itemize">
the pattern <span style="font-family:monospace">?</span>
</li><li class="li-itemize">the pattern <span style="font-family:monospace">?</span><span style="font-style:oblique">ident</span>
</li><li class="li-itemize">an identifier
</li></ul>
</li><li class="li-itemize">an <em>action introduction pattern</em> which itself classifies into:
<ul class="itemize"><li class="li-itemize">
a <em>disjunctive/conjunctive introduction pattern</em>, i.e. either one of:
<ul class="itemize"><li class="li-itemize">
a disjunction of lists of patterns:
<span style="font-family:monospace">[</span><span style="font-style:oblique">intro_pattern_list</span><sub>1</sub><span style="font-family:monospace"> | … | </span><span style="font-style:oblique">intro_pattern_list</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">]</span>
</li><li class="li-itemize">a conjunction of patterns: <span style="font-family:monospace">(</span><span style="font-style:italic">p</span><sub>1</sub><span style="font-family:monospace"> , … , </span><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span>
</li><li class="li-itemize">a list of patterns <span style="font-family:monospace">(</span><span style="font-style:italic">p</span><sub>1</sub><span style="font-family:monospace"> &amp; … &amp; </span><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span>
for sequence of right-associative binary constructs
</li></ul>
</li><li class="li-itemize">an <em>equality introduction pattern</em>, i.e. either one of:
<ul class="itemize"><li class="li-itemize">
a pattern for decomposing an equality: <span style="font-family:monospace">[= </span><span style="font-style:italic">p</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">]</span>
</li><li class="li-itemize">the rewriting orientations: <span style="font-family:monospace">-&gt;</span> or <span style="font-family:monospace">&lt;-</span>
</li></ul>
</li><li class="li-itemize">the on-the-fly application of lemmas: <span style="font-style:italic">p</span><span style="font-family:monospace">%</span><span style="font-style:oblique">term</span><sub>1</sub>
…<span style="font-family:monospace">%</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> where <span style="font-style:italic">p</span> itself is not a pattern for
on-the-fly application of lemmas (note: syntax is in experimental stage)
</li></ul>
</li><li class="li-itemize">the wildcard: <span style="font-family:monospace">_</span>
</li></ul><p>Assuming a goal of type <span style="font-style:italic">Q</span> → <span style="font-style:italic">P</span> (non-dependent product), or
of type ∀ <span style="font-style:italic">x</span>:<span style="font-style:italic">T</span>, <span style="font-style:italic">P</span> (dependent product), the behavior of
<span style="font-family:monospace">intros </span><span style="font-style:italic">p</span> is defined inductively over the structure of the
introduction pattern <span style="font-style:italic">p</span>:
</p><ul class="itemize"><li class="li-itemize">
introduction on <span style="font-family:monospace">?</span> performs the introduction, and lets <span style="font-variant:small-caps">Coq</span>
choose a fresh name for the variable;
</li><li class="li-itemize">introduction on <span style="font-family:monospace">?</span><span style="font-style:oblique">ident</span> performs the introduction, and
lets <span style="font-variant:small-caps">Coq</span> choose a fresh name for the variable based on <span style="font-style:oblique">ident</span>;
</li><li class="li-itemize">introduction on <span style="font-style:oblique">ident</span> behaves as described in
Section <a href="#intro">8.3.1</a>;
</li><li class="li-itemize">introduction over a disjunction of list of patterns <span style="font-family:monospace">[</span><span style="font-style:oblique">intro_pattern_list</span><sub>1</sub><span style="font-family:monospace"> | … | </span><span style="font-style:oblique">intro_pattern_list</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">]</span> expects
the product to be over an inductive type whose number of
constructors is <span style="font-style:italic">n</span> (or more generally over a type of conclusion an
inductive type built from <span style="font-style:italic">n</span> constructors, e.g. <span style="font-family:monospace">C -&gt;
A\/B</span> with <span style="font-style:italic">n</span>=2 since <span style="font-family:monospace">A\/B</span> has 2
constructors): it destructs the introduced hypothesis as <span style="font-family:monospace">destruct</span> (see Section <a href="#destruct">8.5.1</a>) would and applies on each
generated subgoal the corresponding tactic;
<span style="font-family:monospace">intros</span> <span style="font-style:oblique">intro_pattern_list</span><sub><span style="font-style:italic">i</span></sub>. The introduction patterns in
<span style="font-style:oblique">intro_pattern_list</span><sub><span style="font-style:italic">i</span></sub> are expected to consume no more than the
number of arguments of the <span style="font-style:italic">i</span><sup><span style="font-size:small">th</span></sup>
constructor. If it consumes less, then <span style="font-variant:small-caps">Coq</span> completes the pattern
so that all the arguments of the constructors of the inductive type
are introduced (for instance, the list of patterns <span style="font-family:monospace">[</span> <span style="font-family:monospace">|</span> <span style="font-family:monospace">]
H</span> applied on goal <span style="font-family:monospace">forall x:nat, x=0 -&gt; 0=x</span> behaves the same
as the list of patterns <span style="font-family:monospace">[</span> <span style="font-family:monospace">|</span> <span style="font-family:monospace">?</span> <span style="font-family:monospace">] H</span>);
</li><li class="li-itemize">introduction over a conjunction of patterns <span style="font-family:monospace">(</span><span style="font-style:italic">p</span><sub>1</sub><span style="font-family:monospace">, …,
</span><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span> expects the goal to be a product over an inductive type <span style="font-style:italic">I</span> with a
single constructor that itself has at least <span style="font-style:italic">n</span> arguments: it
performs a case analysis over the hypothesis, as <span style="font-family:monospace">destruct</span>
would, and applies the patterns <span style="font-style:italic">p</span><sub>1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> to the arguments
of the constructor of <span style="font-style:italic">I</span> (observe that <span style="font-family:monospace">(</span><span style="font-style:italic">p</span><sub>1</sub><span style="font-family:monospace">, </span><span style="font-family:monospace">…</span><span style="font-family:monospace">,
</span><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span> is an alternative notation for <span style="font-family:monospace">[</span><span style="font-style:italic">p</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace">
</span><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">]</span>);
</li><li class="li-itemize">introduction via <span style="font-family:monospace">(</span><span style="font-style:italic">p</span><sub>1</sub><span style="font-family:monospace"> &amp; … &amp; </span><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span>
is a shortcut for introduction via
<span style="font-family:monospace">(</span><span style="font-style:italic">p</span><sub>1</sub><span style="font-family:monospace">,(…,(…,</span><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)…))</span>; it expects the
hypothesis to be a sequence of right-associative binary inductive
constructors such as <span style="font-family:monospace">conj</span> or <span style="font-family:monospace">ex_intro</span>; for instance, an
hypothesis with type <span style="font-family:monospace">A</span><code><span style="font-family:monospace">/\</span></code><span style="font-family:monospace">(exists x, B</span><code><span style="font-family:monospace">/\</span></code><span style="font-family:monospace">C</span><code><span style="font-family:monospace">/\</span></code><span style="font-family:monospace">D)</span> can be
introduced via pattern <span style="font-family:monospace">(a &amp; x &amp; b &amp; c &amp; d)</span>;
</li><li class="li-itemize">if the product is over an equality type, then a pattern of the
form <span style="font-family:monospace">[= </span><span style="font-style:italic">p</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">]</span> applies either <span style="font-family:monospace">injection</span>
(see Section <a href="#injection">8.5.7</a>) or <span style="font-family:monospace">discriminate</span> (see
Section <a href="#discriminate">8.5.6</a>) instead of <span style="font-family:monospace">destruct</span>; if <span style="font-family:monospace">injection</span> is applicable, the patterns <span style="font-style:italic">p</span><sub>1</sub>, …, <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> are
used on the hypotheses generated by <span style="font-family:monospace">injection</span>; if the number
of patterns is smaller than the number of hypotheses generated, the
pattern <span style="font-family:monospace">?</span> is used to complete the list;
</li><li class="li-itemize">introduction over <span style="font-family:monospace">-&gt;</span> (respectively <span style="font-family:monospace">&lt;-</span>) expects the
hypothesis to be an equality and the right-hand-side (respectively
the left-hand-side) is replaced by the left-hand-side (respectively
the right-hand-side) in the conclusion of the goal; the hypothesis
itself is erased; if the term to substitute is a variable, it is
substituted also in the context of goal and the variable is removed
too;
</li><li class="li-itemize">introduction over a pattern <span style="font-style:italic">p</span><span style="font-family:monospace">%</span><span style="font-style:oblique">term</span><sub>1</sub> …<span style="font-family:monospace">%</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> first applies <span style="font-style:oblique">term</span><sub>1</sub>,…, <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> on the
hypothesis to be introduced (as in <span style="font-family:monospace">apply </span><span style="font-style:oblique">term</span><sub>1</sub>, …,
<span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">in</span>) prior to the application of the introduction
pattern <span style="font-style:italic">p</span>;
</li><li class="li-itemize">introduction on the wildcard depends on whether the product is
dependent or not: in the non-dependent case, it erases the
corresponding hypothesis (i.e. it behaves as an <span style="font-family:monospace">intro</span> followed
by a <span style="font-family:monospace">clear</span>, cf Section <a href="#clear">8.3.3</a>) while in the dependent
case, it succeeds and erases the variable only if the wildcard is
part of a more complex list of introduction patterns that also
erases the hypotheses depending on this variable;
</li><li class="li-itemize">introduction over <span style="font-family:monospace">*</span> introduces all forthcoming quantified
variables appearing in a row; introduction over <span style="font-family:monospace">**</span> introduces
all forthcoming quantified variables or hypotheses until the goal is
not any more a quantification or an implication.
</li></ul><p><br>
<span style="font-weight:bold">Example: </span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall A B C:Prop, A </span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace">/ B /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> C -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> (A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> C) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> C.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall A B C : Prop, A </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">/ B /</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> C -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> (A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> C) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> C</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros * [a | (</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">,c)] f.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">2 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  A, B, C : Prop</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  a : A</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  f : A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> C</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  C</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> C</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Remark: </span><span style="font-family:monospace">intros </span><span style="font-style:italic">p</span><sub>1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> is not equivalent to <span style="font-family:monospace">intros
</span><span style="font-style:italic">p</span><sub>1</sub><span style="font-family:monospace">;…; intros </span><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> for the following reason: If one of the
<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> is a wildcard pattern, he might succeed in the first case
because the further hypotheses it depends in are eventually erased too
while it might fail in the second case because of dependencies in
hypotheses which are not yet introduced (and a fortiori not yet
erased).</p><p><br>
<span style="font-weight:bold">Remark: </span>In <span style="font-family:monospace">intros </span><span style="font-style:oblique">intro_pattern_list</span>, if the last introduction
pattern is a disjunctive or conjunctive pattern <span style="font-family:monospace">[</span><span style="font-style:oblique">intro_pattern_list</span><sub>1</sub><span style="font-family:monospace"> | … | </span><span style="font-style:oblique">intro_pattern_list</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">]</span>, the
completion of <span style="font-style:oblique">intro_pattern_list</span><sub><span style="font-style:italic">i</span></sub> so that all the arguments of the
<span style="font-style:italic">i</span><sup><span style="font-size:small">th</span></sup> constructors of the corresponding
inductive type are introduced can be controlled with the
following option:
<a id="hevea_default583"></a><a id="hevea_option51"></a></p><blockquote class="quote">
<span style="font-family:monospace">Set Bracketing Last Introduction Pattern</span>
</blockquote><p>Force completion, if needed, when the last introduction pattern is a
disjunctive or conjunctive pattern (this is the default).</p><blockquote class="quote">
<span style="font-family:monospace">Unset Bracketing Last Introduction Pattern</span>
</blockquote><p>Deactivate completion when the last introduction pattern is a disjunctive
or conjunctive pattern.</p>
<h3 id="sec367" class="subsection">8.3.3  <span style="font-family:monospace">clear </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="hevea_default584"></a><a id="hevea_tactic39"></a>
<a id="clear"></a></p><p>This tactic erases the hypothesis named <span style="font-style:oblique">ident</span> in the local context
of the current goal. As a consequence, <span style="font-style:oblique">ident</span> is no more displayed and no more
usable in the proof development.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">No such hypothesis</span><a id="hevea_error78"></a>
</li><li class="li-enumerate"><span style="font-style:oblique">ident</span><span style="font-family:monospace"> is used in the conclusion</span><a id="hevea_error79"></a>
</li><li class="li-enumerate"><span style="font-style:oblique">ident</span><span style="font-family:monospace"> is used in the hypothesis </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">’</span><a id="hevea_error80"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">clear </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>This is equivalent to <span style="font-family:monospace">clear </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">. </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> clear
</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">.</span></p></li><li class="li-enumerate"><span style="font-family:monospace">clearbody </span><span style="font-style:oblique">ident</span><a id="hevea_default585"></a><a id="hevea_tactic40"></a><p>This tactic expects <span style="font-style:oblique">ident</span> to be a local definition then clears
its body. Otherwise said, this tactic turns a definition into an
assumption.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> is not a local definition</span><a id="hevea_error81"></a></p></li><li class="li-enumerate"><span style="font-family:monospace">clear - </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>This tactic clears all the hypotheses except the ones depending in
the hypotheses named <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> and in the
goal.</p></li><li class="li-enumerate"><span style="font-family:monospace">clear</span><p>This tactic clears all the hypotheses except the ones the goal depends on.</p></li><li class="li-enumerate"><span style="font-family:monospace">clear dependent </span><span style="font-style:oblique">ident</span><a id="hevea_default586"></a><a id="hevea_tactic41"></a><p>This clears the hypothesis <span style="font-style:oblique">ident</span> and all the hypotheses
that depend on it.</p></li></ol>
<h3 id="sec368" class="subsection">8.3.4  <span style="font-family:monospace">revert </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub></h3>
<p>
<a id="hevea_default587"></a><a id="hevea_tactic42"></a>
<a id="revert"></a></p><p>This applies to any goal with variables <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>.
It moves the hypotheses (possibly defined) to the goal, if this respects
dependencies. This tactic is the inverse of <span style="font-family:monospace">intro</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">No such hypothesis</span><a id="hevea_error82"></a>
</li><li class="li-enumerate"><span style="font-style:oblique">ident</span><span style="font-family:monospace"> is used in the hypothesis </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">’</span><a id="hevea_error83"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">revert dependent </span><span style="font-style:oblique">ident</span><a id="hevea_default588"></a><a id="hevea_tactic43"></a><p>This moves to the goal the hypothesis <span style="font-style:oblique">ident</span> and all the hypotheses
that depend on it.</p></li></ol>
<h3 id="sec369" class="subsection">8.3.5  <span style="font-family:monospace">move </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> after </span><span style="font-style:oblique">ident</span><sub>2</sub></h3>
<p>
<a id="hevea_default589"></a><a id="hevea_tactic44"></a>
<a id="move"></a></p><p>This moves the hypothesis named <span style="font-style:oblique">ident</span><sub>1</sub> in the local context
after the hypothesis named <span style="font-style:oblique">ident</span><sub>2</sub>, where “after” is in
reference to the direction of the move. The proof term is not changed.</p><p>If <span style="font-style:oblique">ident</span><sub>1</sub> comes before <span style="font-style:oblique">ident</span><sub>2</sub> in the order of
dependencies, then all the hypotheses between <span style="font-style:oblique">ident</span><sub>1</sub> and
<span style="font-style:oblique">ident</span><sub>2</sub> that (possibly indirectly) depend on <span style="font-style:oblique">ident</span><sub>1</sub> are
moved too, and all of them are thus moved after <span style="font-style:oblique">ident</span><sub>2</sub> in the
order of dependencies.</p><p>If <span style="font-style:oblique">ident</span><sub>1</sub> comes after <span style="font-style:oblique">ident</span><sub>2</sub> in the order of dependencies,
then all the hypotheses between <span style="font-style:oblique">ident</span><sub>1</sub> and <span style="font-style:oblique">ident</span><sub>2</sub> that
(possibly indirectly) occur in the type of <span style="font-style:oblique">ident</span><sub>1</sub> are moved
too, and all of them are thus moved before <span style="font-style:oblique">ident</span><sub>2</sub> in the order
of dependencies.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">move </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> before </span><span style="font-style:oblique">ident</span><sub>2</sub><p>This moves <span style="font-style:oblique">ident</span><sub>1</sub> towards and just before the hypothesis named
<span style="font-style:oblique">ident</span><sub>2</sub>. As for <span style="font-family:monospace">move </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> after </span><span style="font-style:oblique">ident</span><sub>2</sub>,
dependencies over <span style="font-style:oblique">ident</span><sub>1</sub> (when <span style="font-style:oblique">ident</span><sub>1</sub> comes before
<span style="font-style:oblique">ident</span><sub>2</sub> in the order of dependencies) or in the type of
<span style="font-style:oblique">ident</span><sub>1</sub> (when <span style="font-style:oblique">ident</span><sub>1</sub> comes after <span style="font-style:oblique">ident</span><sub>2</sub> in the order
of dependencies) are moved too.</p></li><li class="li-enumerate"><span style="font-family:monospace">move </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> at top</span><p>This moves <span style="font-style:oblique">ident</span> at the top of the local context (at the beginning of the context).</p></li><li class="li-enumerate"><span style="font-family:monospace">move </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> at bottom</span><p>This moves <span style="font-style:oblique">ident</span> at the bottom of the local context (at the end of the context).</p></li></ol><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">No such hypothesis</span><a id="hevea_error84"></a></li><li class="li-enumerate"><span style="font-family:monospace">Cannot move </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> after </span><span style="font-style:oblique">ident</span><sub>2</sub><span style="font-family:monospace">:
it occurs in the type of </span><span style="font-style:oblique">ident</span><sub>2</sub><a id="hevea_error85"></a></li><li class="li-enumerate"><span style="font-family:monospace">Cannot move </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> after </span><span style="font-style:oblique">ident</span><sub>2</sub><span style="font-family:monospace">:
it depends on </span><span style="font-style:oblique">ident</span><sub>2</sub><a id="hevea_error86"></a></li></ol><p><br>
<span style="font-weight:bold">Example: </span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall x :nat, x = 0 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forall z y:nat, y=y-</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 0=x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall x : nat, x = 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> forall y : nat, y = y -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0 = x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros x H z y H0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : x = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  z, y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : y = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 = x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> move x after H0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  z, y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : y = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : x = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 = x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Undo.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : x = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  z, y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : y = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 = x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> move x before H0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  z, y, x : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : x = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : y = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 = x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Undo.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : x = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  z, y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : y = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 = x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> move H0 after H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x, y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : y = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : x = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  z : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 = x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Undo.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : x = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  z, y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : y = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 = x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> move H0 before H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : x = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : y = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  z : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 = x</span></span></span><span style="font-size:small"><br>
</span></div>
<h3 id="sec370" class="subsection">8.3.6  <span style="font-family:monospace">rename </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> into </span><span style="font-style:oblique">ident</span><sub>2</sub></h3>
<p>
<a id="hevea_default590"></a><a id="hevea_tactic45"></a></p><p>This renames hypothesis <span style="font-style:oblique">ident</span><sub>1</sub> into <span style="font-style:oblique">ident</span><sub>2</sub> in the current
context. The name of the hypothesis in the proof-term, however, is left
unchanged.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">rename </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> into </span><span style="font-style:oblique">ident</span><sub>2</sub><span style="font-family:monospace">, …,
</span><span style="font-style:oblique">ident</span><sub>2<span style="font-style:italic">k</span>−1</sub><span style="font-family:monospace"> into </span><span style="font-style:oblique">ident</span><sub>2<span style="font-style:italic">k</span></sub><p>This renames the variables <span style="font-style:oblique">ident</span><sub>1</sub> …<span style="font-style:oblique">ident</span><sub>2</sub><span style="font-style:italic">k</span>−1 into respectively
<span style="font-style:oblique">ident</span><sub>2</sub> …<span style="font-style:oblique">ident</span><sub>2</sub><span style="font-style:italic">k</span> in parallel. In particular, the target
identifiers may contain identifiers that exist in the source context, as long
as the latter are also renamed by the same tactic.</p></li></ol><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">No such hypothesis</span><a id="hevea_error87"></a>
</li><li class="li-enumerate"><span style="font-style:oblique">ident</span><sub>2</sub><span style="font-family:monospace"> is already used</span><a id="hevea_error88"></a>
</li></ol>
<h3 id="sec371" class="subsection">8.3.7  <span style="font-family:monospace">set ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span></h3>
<p>
<a id="tactic:set"></a>
<a id="hevea_default591"></a><a id="hevea_tactic46"></a></p><p>This replaces <span style="font-style:oblique">term</span> by <span style="font-style:oblique">ident</span> in the conclusion of the current goal
and adds the new definition <span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span> to the local context.</p><p>If <span style="font-style:oblique">term</span> has holes (i.e. subexpressions of the form “_”), the
tactic first checks that all subterms matching the pattern are
compatible before doing the replacement using the leftmost subterm
matching the pattern.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">The variable </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> is already defined</span><a id="hevea_error89"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">set ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> ) in </span><span style="font-style:oblique">goal_occurrences</span><p>This notation allows specifying which occurrences of <span style="font-style:oblique">term</span> have to
be substituted in the context. The <span style="font-family:monospace">in </span><span style="font-style:oblique">goal_occurrences</span> clause is an
occurrence clause whose syntax and behavior are described in
Section <a href="#Occurrences_clauses">8.1.4</a>.</p></li><li class="li-enumerate"><span style="font-family:monospace">set ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span><p>This is equivalent to <span style="font-family:monospace">set ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := fun
</span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> =&gt; </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">set </span><span style="font-style:oblique">term</span><p>This behaves as <span style="font-family:monospace">set (</span> <span style="font-style:oblique">ident</span> := <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span> but <span style="font-style:oblique">ident</span>
is generated by <span style="font-variant:small-caps">Coq</span>. This variant also supports an occurrence clause.</p></li><li class="li-enumerate"><span style="font-family:monospace">set ( </span><span style="font-style:oblique">ident</span><sub>0</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> ) in </span><span style="font-style:oblique">goal_occurrences</span><br>
 <span style="font-family:monospace">set </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">goal_occurrences</span><p>These are the general forms that combine the previous possibilities.</p></li><li class="li-enumerate"><span style="font-family:monospace">eset ( </span><span style="font-style:oblique">ident</span><sub>0</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> ) in </span><span style="font-style:oblique">goal_occurrences</span><a id="hevea_default592"></a><a id="hevea_tactic47"></a><br>
 <span style="font-family:monospace">eset </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">goal_occurrences</span><p>While the different variants of <span style="font-family:monospace">set</span> expect that no
existential variables are generated by the tactic, <span style="font-family:monospace">eset</span>
removes this constraint. In practice, this is relevant only when
<span style="font-family:monospace">eset</span> is used as a synonym of <span style="font-family:monospace">epose</span>, i.e. when the
term does not occur in the goal.</p></li><li class="li-enumerate"><span style="font-family:monospace">remember </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">ident</span><a id="hevea_default593"></a><a id="hevea_tactic48"></a><p>This behaves as <span style="font-family:monospace">set ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> ) in *</span> and using a
logical (Leibniz’s) equality instead of a local definition.</p></li><li class="li-enumerate"><span style="font-family:monospace">remember </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> eqn:</span><span style="font-style:oblique">ident</span><p>This behaves as <span style="font-family:monospace">remember </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">ident</span>, except
that the name of the generated equality is also given.</p></li><li class="li-enumerate"><span style="font-family:monospace">remember </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">goal_occurrences</span><p>This is a more general form of <span style="font-family:monospace">remember</span> that remembers the
occurrences of <span style="font-style:oblique">term</span> specified by an occurrences set.</p></li><li class="li-enumerate"><span style="font-family:monospace">eremember </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">ident</span><a id="hevea_default594"></a><a id="hevea_tactic49"></a><br>
 <span style="font-family:monospace">eremember </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">goal_occurrences</span><br>
 <span style="font-family:monospace">eremember </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> eqn:</span><span style="font-style:oblique">ident</span><p>While the different variants of <span style="font-family:monospace">remember</span> expect that no
existential variables are generated by the tactic, <span style="font-family:monospace">eremember</span>
removes this constraint.</p></li><li class="li-enumerate"><span style="font-family:monospace">pose ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span><a id="hevea_default595"></a><a id="hevea_tactic50"></a><p>This adds the local definition <span style="font-style:oblique">ident</span> := <span style="font-style:oblique">term</span> to the current
context without performing any replacement in the goal or in the
hypotheses. It is equivalent to <span style="font-family:monospace">set ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-family:monospace">:=</span><span style="font-family:monospace">
</span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace">) in |-</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">pose ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span><p>This is equivalent to <span style="font-family:monospace">pose (</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">:=</span> <span style="font-family:monospace">fun</span>
<span style="font-style:oblique">binder</span> … <span style="font-style:oblique">binder</span> <span style="font-family:monospace">=&gt;</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">)</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">pose </span><span style="font-style:oblique">term</span><p>This behaves as <span style="font-family:monospace">pose ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span> but
<span style="font-style:oblique">ident</span> is generated by <span style="font-variant:small-caps">Coq</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">epose ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span><a id="hevea_default596"></a><a id="hevea_tactic51"></a><br>
 <span style="font-family:monospace">epose ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span><br>
 <span style="font-family:monospace">epose </span><span style="font-style:oblique">term</span><p>While the different variants of <span style="font-family:monospace">pose</span> expect that no
existential variables are generated by the tactic, <span style="font-family:monospace">epose</span>
removes this constraint.</p></li></ol>
<h3 id="sec372" class="subsection">8.3.8  <span style="font-family:monospace">decompose [ </span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> ] </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="decompose"></a>
<a id="hevea_default597"></a><a id="hevea_tactic52"></a></p><p>This tactic recursively decomposes a
complex proposition in order to obtain atomic ones.</p><p><br>
<span style="font-weight:bold">Example: </span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall A B C:Prop, A /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> B /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> C </span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace">/ B /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> C </span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace">/ C /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> C.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall A B C : Prop, A /</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> B /</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> C </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">/ B /</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> C </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">/ C /</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> C</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros A B C H; decompose [and or] H; assumption.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Qed.</span></span><span style="font-size:small"><br>
</span></div><p><span style="font-family:monospace">decompose</span> does not work on right-hand sides of implications or products.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">decompose sum </span><span style="font-style:oblique">term</span><a id="hevea_default598"></a><a id="hevea_tactic53"></a><p>This decomposes sum types (like <span style="font-family:monospace">or</span>).</p></li><li class="li-enumerate"><span style="font-family:monospace">decompose record </span><span style="font-style:oblique">term</span><a id="hevea_default599"></a><a id="hevea_tactic54"></a><p>This decomposes record types (inductive types with one constructor,
like <span style="font-family:monospace">and</span> and <span style="font-family:monospace">exists</span> and those defined with the
<span style="font-family:monospace">Record</span> macro, see Section <a href="gallina-ext.html#Record">2.1</a>).</p></li></ol>
<h2 id="sec373" class="section">8.4  Controlling the proof flow</h2>
<h3 id="sec374" class="subsection">8.4.1  <span style="font-family:monospace">assert ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> )</span></h3>
<p>
<a id="hevea_default600"></a><a id="hevea_tactic55"></a></p><p>This tactic applies to any goal. <span style="font-family:monospace">assert (H : U)</span> adds a new
hypothesis of name <span style="font-family:monospace">H</span> asserting <span style="font-family:monospace">U</span> to the current goal
and opens a new subgoal <span style="font-family:monospace">U</span><sup><a id="text13" href="#note13">2</a></sup>. The subgoal <span style="font-family:monospace">U</span> comes first
in the list of subgoals remaining to prove.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Not a proposition or a type</span><a id="hevea_error90"></a><p>Arises when the argument <span style="font-style:oblique">form</span> is neither of type <span style="font-family:monospace">Prop</span>, <span style="font-family:monospace">Set</span> nor <span style="font-family:monospace">Type</span>.</p></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">assert </span><span style="font-style:oblique">form</span><p>This behaves as <span style="font-family:monospace">assert ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> )</span> but
<span style="font-style:oblique">ident</span> is generated by <span style="font-variant:small-caps">Coq</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">assert </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><a id="hevea_default601"></a><a id="hevea_tactic56"></a><p>This tactic behaves like <span style="font-family:monospace">assert</span> but applies <span style="font-style:oblique">tactic</span>
to solve the subgoals generated by <span style="font-family:monospace">assert</span>.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Proof is not complete</span><a id="hevea_error91"></a></p></li><li class="li-enumerate"><span style="font-family:monospace">assert </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><a id="hevea_default602"></a><a id="hevea_tactic57"></a><p>If <span style="font-style:oblique">intro_pattern</span> is a naming introduction pattern (see
Section <a href="#intros-pattern">8.3.2</a>), the hypothesis is named after this
introduction pattern (in particular, if <span style="font-style:oblique">intro_pattern</span> is <span style="font-style:oblique">ident</span>,
the tactic behaves like <span style="font-family:monospace">assert (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">form</span><span style="font-family:monospace">)</span>).</p><p>If <span style="font-style:oblique">intro_pattern</span> is an action introduction pattern, the tactic
behaves like <span style="font-family:monospace">assert </span><span style="font-style:oblique">form</span> followed by the action done by
this introduction pattern.</p></li><li class="li-enumerate"><span style="font-family:monospace">assert </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><p>This combines the two previous variants of <span style="font-family:monospace">assert</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">assert ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span><p>This behaves as <span style="font-family:monospace">assert (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><span style="font-family:monospace">) by exact </span><span style="font-style:oblique">term</span>
where <span style="font-style:oblique">type</span> is the type of <span style="font-style:oblique">term</span>. This is deprecated in favor of
<span style="font-family:monospace">pose proof</span>.</p><p>If the head of <span style="font-style:oblique">term</span> is <span style="font-style:oblique">ident</span>, the tactic behaves as
<span style="font-family:monospace">specialize </span><span style="font-style:oblique">term</span>.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Variable </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> is already declared</span><a id="hevea_error92"></a></p></li><li class="li-enumerate"><span style="font-family:monospace">eassert </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><a id="hevea_default603"></a><a id="hevea_tactic58"></a><a id="hevea_default604"></a><a id="hevea_tactic59"></a><a id="hevea_default605"></a><a id="hevea_tactic60"></a><br>
 <span style="font-family:monospace">assert ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span><p>While the different variants of <span style="font-family:monospace">assert</span> expect that no
existential variables are generated by the tactic, <span style="font-family:monospace">eassert</span>
removes this constraint. This allows not to specify the asserted
statement completely before starting to prove it.</p></li><li class="li-enumerate"><span style="font-family:monospace">pose proof </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><a id="hevea_default606"></a><a id="hevea_tactic61"></a><p>This tactic behaves like <span style="font-family:monospace">assert T </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> by
exact </span><span style="font-style:oblique">term</span> where <span style="font-family:monospace">T</span> is the type of <span style="font-style:oblique">term</span>.</p><p>In particular, <span style="font-family:monospace">pose proof </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">ident</span> behaves as
<span style="font-family:monospace">assert (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace">)</span> and <span style="font-family:monospace">pose proof </span><span style="font-style:oblique">term</span><span style="font-family:monospace">
as </span><span style="font-style:oblique">intro_pattern</span> is the same as applying
the <span style="font-style:oblique">intro_pattern</span> to <span style="font-style:oblique">term</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">epose proof </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><a id="hevea_default607"></a><a id="hevea_tactic62"></a><p>While <span style="font-family:monospace">pose proof</span> expects that no existential variables are generated by the tactic,
<span style="font-family:monospace">epose proof</span> removes this constraint.</p></li><li class="li-enumerate"><span style="font-family:monospace">enough (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">form</span><span style="font-family:monospace">)</span><a id="hevea_default608"></a><a id="hevea_tactic63"></a><p>This adds a new hypothesis of name <span style="font-style:oblique">ident</span> asserting <span style="font-style:oblique">form</span> to the
goal the tactic <span style="font-family:monospace">enough</span> is applied to. A new subgoal stating
<span style="font-style:oblique">form</span> is inserted after the initial goal rather than before
it as <span style="font-family:monospace">assert</span> would do.</p></li><li class="li-enumerate"><span style="font-family:monospace">enough </span><span style="font-style:oblique">form</span><a id="hevea_default609"></a><a id="hevea_tactic64"></a><p>This behaves like <span style="font-family:monospace">enough (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">form</span><span style="font-family:monospace">)</span> with the name
<span style="font-style:oblique">ident</span> of the hypothesis generated by <span style="font-variant:small-caps">Coq</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">enough </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><a id="hevea_default610"></a><a id="hevea_tactic65"></a><p>This behaves like <span style="font-family:monospace">enough</span> <span style="font-style:oblique">form</span> using <span style="font-style:oblique">intro_pattern</span> to
name or destruct the new hypothesis.</p></li><li class="li-enumerate"><span style="font-family:monospace">enough (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">form</span><span style="font-family:monospace">) by </span><span style="font-style:oblique">tactic</span><a id="hevea_default611"></a><a id="hevea_tactic66"></a><br>
 <span style="font-family:monospace">enough </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><a id="hevea_default612"></a><a id="hevea_tactic67"></a><br>
 <span style="font-family:monospace">enough </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><p>This behaves as above but with <span style="font-style:oblique">tactic</span> expected to solve the initial
goal after the extra assumption <span style="font-style:oblique">form</span> is added and possibly
destructed. If the <span style="font-family:monospace">as</span> <span style="font-style:oblique">intro_pattern</span> clause generates more
than one subgoal, <span style="font-style:oblique">tactic</span> is applied to all of them.</p></li><li class="li-enumerate"><span style="font-family:monospace">eenough (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">form</span><span style="font-family:monospace">) by </span><span style="font-style:oblique">tactic</span><a id="hevea_default613"></a><a id="hevea_tactic68"></a><a id="hevea_default614"></a><a id="hevea_tactic69"></a><a id="hevea_default615"></a><a id="hevea_tactic70"></a><br>
 <span style="font-family:monospace">eenough </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><a id="hevea_default616"></a><a id="hevea_tactic71"></a><br>
 <span style="font-family:monospace">eenough </span><span style="font-style:oblique">form</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><p>While the different variants of <span style="font-family:monospace">enough</span> expect that no
existential variables are generated by the tactic, <span style="font-family:monospace">eenough</span>
removes this constraint.</p></li><li class="li-enumerate"><span style="font-family:monospace">cut </span><span style="font-style:oblique">form</span><a id="hevea_default617"></a><a id="hevea_tactic72"></a><p>This tactic applies to any goal. It implements the non-dependent
case of the “App”<a id="hevea_default618"></a> rule given in
Section <a href="cic.html#Typed-terms">4.2</a>. (This is Modus Ponens inference rule.)
<span style="font-family:monospace">cut U</span> transforms the current goal <span style="font-family:monospace">T</span> into the two
following subgoals: <span style="font-family:monospace">U -&gt; T</span> and <span style="font-family:monospace">U</span>. The subgoal <span style="font-family:monospace">U
-&gt; T</span> comes first in the list of remaining subgoal to prove.</p></li><li class="li-enumerate"><span style="font-family:monospace">specialize (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span><a id="hevea_default619"></a><a id="hevea_tactic73"></a><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><br>
 <span style="font-family:monospace">specialize </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><p>The tactic <span style="font-family:monospace">specialize</span> works on local hypothesis <span style="font-style:oblique">ident</span>.
The premises of this hypothesis (either universal
quantifications or non-dependent implications) are instantiated
by concrete terms coming either from arguments <span style="font-style:oblique">term</span><sub>1</sub>
… <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> or from a bindings list (see
Section <a href="#Binding-list">8.1.3</a> for more about bindings lists).
In the first form the application to <span style="font-style:oblique">term</span><sub>1</sub> …
<span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> can be partial. The first form is equivalent to
<span style="font-family:monospace">assert (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span>.</p><p>In the second form, instantiation elements can also be partial.
In this case the uninstantiated arguments are inferred by
unification if possible or left quantified in the hypothesis
otherwise.</p><p>With the <span style="font-family:monospace">as</span> clause, the local hypothesis <span style="font-style:oblique">ident</span> is left
unchanged and instead, the modified hypothesis is introduced as
specified by the <span style="font-style:oblique">intro_pattern</span>.</p><p>The name <span style="font-style:oblique">ident</span> can also refer to a global lemma or
hypothesis. In this case, for compatibility reasons, the
behavior of <span style="font-family:monospace">specialize</span> is close to that of <span style="font-family:monospace">generalize</span>: the instantiated statement becomes an additional
premise of the goal. The <span style="font-family:monospace">as</span> clause is especially useful
in this case to immediately introduce the instantiated statement
as a local hypothesis.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=a><li class="li-enumerate">
<span style="font-style:oblique">ident</span><span style="font-family:monospace"> is used in hypothesis </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">’</span><a id="hevea_error93"></a>
</li><li class="li-enumerate"><span style="font-style:oblique">ident</span><span style="font-family:monospace"> is used in conclusion</span><a id="hevea_error94"></a>
</li></ol></li></ol>
<h3 id="sec375" class="subsection">8.4.2  <span style="font-family:monospace">generalize </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default620"></a><a id="hevea_tactic74"></a>
<a id="generalize"></a></p><p>This tactic applies to any goal. It generalizes the conclusion with
respect to some term.</p><p><br>
<span style="font-weight:bold">Example: </span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Show.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x, y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= x + y + y</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> generalize (x + y + y).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x, y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall n : nat, 0 </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= n</span></span></span><span style="font-size:small"><br>
</span></div><p>If the goal is <span style="font-style:italic">G</span> and <span style="font-style:italic">t</span> is a subterm of type <span style="font-style:italic">T</span> in the goal, then
<span style="font-family:monospace">generalize</span> <span style="font-style:italic">t</span> replaces the goal by <span style="font-family:monospace">forall (x:</span><span style="font-style:italic">T</span><span style="font-family:monospace">), </span><span style="font-style:italic">G</span>′
where <span style="font-style:italic">G</span>′ is obtained from <span style="font-style:italic">G</span> by replacing all occurrences of <span style="font-style:italic">t</span> by
<span style="font-family:monospace">x</span>. The name of the variable (here <span style="font-family:monospace">n</span>) is chosen based on <span style="font-style:italic">T</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">generalize </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> , … , </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><p>This is equivalent to <span style="font-family:monospace">generalize </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">; … ; generalize
</span><span style="font-style:oblique">term</span><sub>1</sub>. Note that the sequence of <span style="font-style:oblique">term</span><sub><span style="font-style:italic">i</span></sub>’s are processed
from <span style="font-style:italic">n</span> to 1.</p></li><li class="li-enumerate"><span style="font-family:monospace">generalize </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub><p>This is equivalent to <span style="font-family:monospace">generalize </span><span style="font-style:oblique">term</span> but it generalizes only over
the specified occurrences of <span style="font-style:oblique">term</span> (counting from left to right on the
expression printed using option <span style="font-family:monospace">Set Printing All</span>).</p></li><li class="li-enumerate"><span style="font-family:monospace">generalize </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">ident</span><p>This is equivalent to <span style="font-family:monospace">generalize </span><span style="font-style:oblique">term</span> but it uses <span style="font-style:oblique">ident</span> to name the
generalized hypothesis.</p></li><li class="li-enumerate"><span style="font-family:monospace">generalize </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>11</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub>1<span style="font-style:italic">i</span><sub>1</sub></sub><span style="font-family:monospace">
as </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">
, </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> ,
</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">ni</span><sub><span style="font-style:italic">n</span></sub></sub><span style="font-family:monospace">
as </span><span style="font-style:oblique">ident</span><sub>2</sub><p>This is the most general form of <span style="font-family:monospace">generalize</span> that combines the
previous behaviors.</p></li><li class="li-enumerate"><span style="font-family:monospace">generalize dependent </span><span style="font-style:oblique">term</span> <a id="hevea_default621"></a><a id="hevea_tactic75"></a><p>This generalizes <span style="font-style:oblique">term</span> but also <em>all</em> hypotheses that depend
on <span style="font-style:oblique">term</span>. It clears the generalized hypotheses.</p></li></ol>
<h3 id="sec376" class="subsection">8.4.3  <span style="font-family:monospace">evar ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span></h3>
<p>
<a id="hevea_default622"></a><a id="hevea_tactic76"></a>
<a id="evar"></a></p><p>The <span style="font-family:monospace">evar</span> tactic creates a new local definition named <span style="font-style:oblique">ident</span> with
type <span style="font-style:oblique">term</span> in the context. The body of this binding is a fresh
existential variable.</p>
<h3 id="sec377" class="subsection">8.4.4  <span style="font-family:monospace">instantiate ( </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span></h3>
<p>
<a id="hevea_default623"></a><a id="hevea_tactic77"></a>
<a id="instantiate"></a></p><p>The <span style="font-family:monospace">instantiate</span> tactic refines (see Section <a href="#refine">8.2.3</a>)
an existential variable <span style="font-style:oblique">ident</span> with the term <span style="font-style:oblique">term</span>.
It is equivalent to <span style="font-family:monospace">only [</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">]: refine </span><span style="font-style:oblique">term</span> (preferred alternative).</p><p><br>
<span style="font-weight:bold">Remarks: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
To be able to refer to an existential variable by name, the
user must have given the name explicitly (see <a href="gallina-ext.html#ExistentialVariables">2.11</a>).</li><li class="li-enumerate">When you are referring to hypotheses which you did not name
explicitly, be aware that Coq may make a different decision on how to
name the variable in the current goal and in the context of the
existential variable. This can lead to surprising behaviors.
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">instantiate ( </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> )</span>
This variant allows to refer to an existential variable which was not
named by the user. The <span style="font-style:oblique">num</span> argument is the position of the
existential variable from right to left in the goal.
Because this variant is not robust to slight changes in the goal,
its use is strongly discouraged.</li><li class="li-enumerate"><span style="font-family:monospace">instantiate ( </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> ) in </span><span style="font-style:oblique">ident</span></li><li class="li-enumerate"><span style="font-family:monospace">instantiate ( </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> ) in ( Value of </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> )</span></li><li class="li-enumerate"><span style="font-family:monospace">instantiate ( </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> := </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> ) in ( Type of </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> )</span><p>These allow to refer respectively to existential variables occurring in
a hypothesis or in the body or the type of a local definition.</p></li><li class="li-enumerate"><span style="font-family:monospace">instantiate</span><p>Without argument, the <span style="font-family:monospace">instantiate</span> tactic tries to solve as
many existential variables as possible, using information gathered
from other tactics in the same tactical. This is automatically
done after each complete tactic (i.e. after a dot in proof mode),
but not, for example, between each tactic when they are sequenced
by semicolons.</p></li></ol>
<h3 id="sec378" class="subsection">8.4.5  <span style="font-family:monospace">admit</span></h3>
<p>
<a id="hevea_default624"></a><a id="hevea_tactic78"></a>
<a id="hevea_default625"></a><a id="hevea_tactic79"></a>
<a id="admit"></a></p><p>The <span style="font-family:monospace">admit</span> tactic allows temporarily skipping a subgoal so as to
progress further in the rest of the proof. A proof containing
admitted goals cannot be closed with <span style="font-family:monospace">Qed</span> but only with
<span style="font-family:monospace">Admitted</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">give_up</span><p>Synonym of <span style="font-family:monospace">admit</span>.</p></li></ol>
<h3 id="sec379" class="subsection">8.4.6  <span style="font-family:monospace">absurd </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default626"></a><a id="hevea_tactic80"></a>
<a id="absurd"></a></p><p>This tactic applies to any goal. The argument <span style="font-style:oblique">term</span> is any
proposition <span style="font-family:monospace">P</span> of type <span style="font-family:monospace">Prop</span>. This tactic applies <span style="font-family:monospace">False</span> elimination, that is it deduces the current goal from <span style="font-family:monospace">False</span>, and generates as subgoals ∼<span style="font-family:monospace">P</span> and <span style="font-family:monospace">P</span>. It is
very useful in proofs by cases, where some cases are impossible. In
most cases, <span style="font-family:monospace">P</span> or ∼<span style="font-family:monospace">P</span> is one of the hypotheses of
the local context.</p>
<h3 id="sec380" class="subsection">8.4.7  <span style="font-family:monospace">contradiction</span></h3>
<p>
<a id="contradiction"></a>
<a id="hevea_default627"></a><a id="hevea_tactic81"></a></p><p>This tactic applies to any goal. The <span style="font-family:monospace">contradiction</span> tactic
attempts to find in the current context (after all <span style="font-family:monospace">intros</span>) an
hypothesis that is equivalent to an empty inductive type (e.g. <span style="font-family:monospace">False</span>), to the negation of a singleton inductive type (e.g. <span style="font-family:monospace">True</span> or <span style="font-family:monospace">x=x</span>), or two contradictory hypotheses.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">No such assumption</span><a id="hevea_error95"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">contradiction </span><span style="font-style:oblique">ident</span><p>The proof of <span style="font-family:monospace">False</span> is searched in the hypothesis named <span style="font-style:oblique">ident</span>.
</p></li></ol>
<h3 id="sec381" class="subsection">8.4.8  <span style="font-family:monospace">contradict </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="contradict"></a>
<a id="hevea_default628"></a><a id="hevea_tactic82"></a></p><p>This tactic allows manipulating negated hypothesis and goals. The
name <span style="font-style:oblique">ident</span> should correspond to a hypothesis. With
<span style="font-family:monospace">contradict H</span>, the current goal and context is transformed in
the following way:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">H:</span>¬<span style="font-family:monospace">A </span>⊢<span style="font-family:monospace"> B</span>  becomes  ⊢<span style="font-family:monospace"> A</span>
</li><li class="li-itemize"><span style="font-family:monospace">H:</span>¬<span style="font-family:monospace">A </span>⊢<span style="font-family:monospace"> </span>¬<span style="font-family:monospace">B</span>   becomes  <span style="font-family:monospace">H: B </span>⊢<span style="font-family:monospace"> A </span>
</li><li class="li-itemize"><span style="font-family:monospace">H: A </span>⊢<span style="font-family:monospace"> B</span>  becomes  ⊢<span style="font-family:monospace"> </span>¬<span style="font-family:monospace">A</span>
</li><li class="li-itemize"><span style="font-family:monospace">H: A </span>⊢<span style="font-family:monospace"> </span>¬<span style="font-family:monospace">B</span>  becomes  <span style="font-family:monospace">H: B </span>⊢<span style="font-family:monospace"> </span>¬<span style="font-family:monospace">A</span>
</li></ul>
<h3 id="sec382" class="subsection">8.4.9  <span style="font-family:monospace">exfalso</span></h3>
<p>
<a id="exfalso"></a>
<a id="hevea_default629"></a><a id="hevea_tactic83"></a></p><p>This tactic implements the “ex falso quodlibet” logical principle:
an elimination of <span style="font-family:monospace">False</span> is performed on the current goal, and the
user is then required to prove that <span style="font-family:monospace">False</span> is indeed provable in
the current context. This tactic is a macro for <span style="font-family:monospace">elimtype False</span>.</p>
<h2 id="sec383" class="section">8.5  Case analysis and induction</h2>
<p>The tactics presented in this section implement induction or case
analysis on inductive or co-inductive objects (see
Section <a href="cic.html#Cic-inductive-definitions">4.5</a>).</p>
<h3 id="sec384" class="subsection">8.5.1  <span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default630"></a><a id="hevea_tactic84"></a>
<a id="destruct"></a></p><p>This tactic applies to any goal. The argument <span style="font-style:oblique">term</span> must be of
inductive or co-inductive type and the tactic generates subgoals, one
for each possible form of <span style="font-style:oblique">term</span>, i.e. one for each constructor of
the inductive or co-inductive type. Unlike <span style="font-family:monospace">induction</span>, no
induction hypothesis is generated by <span style="font-family:monospace">destruct</span>.</p><p>There are special cases:</p><ul class="itemize"><li class="li-itemize">If <span style="font-style:oblique">term</span> is an identifier <span style="font-style:oblique">ident</span> denoting a quantified
variable of the conclusion of the goal, then <span style="font-family:monospace">destruct </span><span style="font-style:oblique">ident</span>
behaves as <span style="font-family:monospace">intros until </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">; destruct </span><span style="font-style:oblique">ident</span>. If
<span style="font-style:oblique">ident</span> is not anymore dependent in the goal after application of
<span style="font-family:monospace">destruct</span>, it is erased (to avoid erasure, use
parentheses, as in <span style="font-family:monospace">destruct (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">)</span>).</li><li class="li-itemize">If <span style="font-style:oblique">term</span> is a <span style="font-style:oblique">num</span>, then <span style="font-family:monospace">destruct </span><span style="font-style:oblique">num</span> behaves as
<span style="font-family:monospace">intros until </span><span style="font-style:oblique">num</span> followed by <span style="font-family:monospace">destruct</span> applied to the
last introduced hypothesis. Remark: For destruction of a numeral, use
syntax <span style="font-family:monospace">destruct (</span><span style="font-style:oblique">num</span><span style="font-family:monospace">)</span> (not very interesting anyway).</li><li class="li-itemize">In case <span style="font-style:oblique">term</span> is an hypothesis <span style="font-style:oblique">ident</span> of the context,
and <span style="font-style:oblique">ident</span> is not anymore dependent in the goal after
application of <span style="font-family:monospace">destruct</span>, it is erased (to avoid erasure, use
parentheses, as in <span style="font-family:monospace">destruct (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">)</span>).</li><li class="li-itemize">The argument <span style="font-style:oblique">term</span> can also be a pattern of which holes are
denoted by “_”. In this case, the tactic checks that all subterms
matching the pattern in the conclusion and the hypotheses are
compatible and performs case analysis using this subterm.</li></ul><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">, …, </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><p>This is a shortcut for <span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">; …; destruct </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>.</p></li><li class="li-enumerate"><span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">disj_conj_intro_pattern</span><p>This behaves as <span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span> but uses the names in
<span style="font-style:oblique">intro_pattern</span> to name the variables introduced in the context.
The <span style="font-style:oblique">intro_pattern</span> must have the form <span style="font-family:monospace">[</span> <span style="font-style:italic">p</span><sub>11</sub> …<span style="font-style:italic">p</span><sub>1<span style="font-style:italic">n</span><sub>1</sub></sub> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span>1</sub> …<span style="font-style:italic">p</span><sub><span style="font-style:italic">mn</span><sub><span style="font-style:italic">m</span></sub></sub>
<span style="font-family:monospace">]</span> with <span style="font-style:italic">m</span> being the number of constructors of the type of
<span style="font-style:oblique">term</span>. Each variable introduced by <span style="font-family:monospace">destruct</span> in the context
of the <span style="font-style:italic">i</span><sup><span style="font-style:italic">th</span></sup> goal gets its name from the list <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>1</sub> …<span style="font-style:italic">p</span><sub><span style="font-style:italic">in</span><sub><span style="font-style:italic">i</span></sub></sub> in order. If there are not enough names, <span style="font-family:monospace">destruct</span>
invents names for the remaining variables to introduce. More
generally, the <span style="font-style:italic">p</span><sub><span style="font-style:italic">ij</span></sub> can be any introduction pattern (see
Section <a href="#intros-pattern">8.3.2</a>). This provides a concise notation for
chaining destruction of an hypothesis.</p></li><li class="li-enumerate"><span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> eqn:</span><span style="font-style:oblique">naming_intro_pattern</span><p>This behaves as <span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span> but adds an equation between
<span style="font-style:oblique">term</span> and the value that <span style="font-style:oblique">term</span> takes in each of the possible
cases. The name of the equation is specified by <span style="font-style:oblique">naming_intro_pattern</span>
(see Section <a href="#intros-pattern">8.3.2</a>), in particular <span style="font-family:monospace">?</span> can be
used to let Coq generate a fresh name.</p></li><li class="li-enumerate"><span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><p>This behaves like <span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span> providing explicit
instances for the dependent premises of the type of <span style="font-style:oblique">term</span> (see
syntax of bindings in Section <a href="#Binding-list">8.1.3</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">edestruct </span><span style="font-style:oblique">term</span><a id="hevea_default631"></a><a id="hevea_tactic85"></a><p>This tactic behaves like <span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span> except that it
does not fail if the instance of a dependent premises of the type of
<span style="font-style:oblique">term</span> is not inferable. Instead, the unresolved instances are left
as existential variables to be inferred later, in the same way as
<span style="font-family:monospace">eapply</span> does (see Section <a href="#eapply-example">8.2.4</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><br>
 <span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><p>These are synonyms of <span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub> and
<span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">goal_occurrences</span><p>This syntax is used for selecting which occurrences of <span style="font-style:oblique">term</span> the
case analysis has to be done on. The <span style="font-family:monospace">in </span><span style="font-style:oblique">goal_occurrences</span> clause is an
occurrence clause whose syntax and behavior is described in
Section <a href="#Occurrences_clauses">8.1.4</a>.</p></li><li class="li-enumerate"><span style="font-family:monospace">destruct </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>1</sub><span style="font-family:monospace">
as </span><span style="font-style:oblique">disj_conj_intro_pattern</span><span style="font-family:monospace"> eqn:</span><span style="font-style:oblique">naming_intro_pattern</span><span style="font-family:monospace">
using </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>2</sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">goal_occurrences</span><br>
 <span style="font-family:monospace">edestruct </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>1</sub><span style="font-family:monospace">
as </span><span style="font-style:oblique">disj_conj_intro_pattern</span><span style="font-family:monospace"> eqn:</span><span style="font-style:oblique">naming_intro_pattern</span><span style="font-family:monospace">
using </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>2</sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">goal_occurrences</span><p>These are the general forms of <span style="font-family:monospace">destruct</span> and <span style="font-family:monospace">edestruct</span>.
They combine the effects of the <span style="font-family:monospace">with</span>, <span style="font-family:monospace">as</span>, <span style="font-family:monospace">eqn:</span>, <span style="font-family:monospace">using</span>,
and <span style="font-family:monospace">in</span> clauses.</p></li><li class="li-enumerate"><span style="font-family:monospace">case </span><span style="font-style:oblique">term</span><a id="case"></a><a id="hevea_default632"></a><a id="hevea_tactic86"></a><p>The tactic <span style="font-family:monospace">case</span> is a more basic tactic to perform case
analysis without recursion. It behaves as <span style="font-family:monospace">elim </span><span style="font-style:oblique">term</span> but using
a case-analysis elimination principle and not a recursive one.</p></li><li class="li-enumerate"><span style="font-family:monospace">case </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><p>Analogous to <span style="font-family:monospace">elim </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span> above.</p></li><li class="li-enumerate"><span style="font-family:monospace">ecase </span><span style="font-style:oblique">term</span><a id="hevea_default633"></a><a id="hevea_tactic87"></a><br>
 <span style="font-family:monospace">ecase </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><p>In case the type of <span style="font-style:oblique">term</span> has dependent premises, or dependent
premises whose values are not inferable from the <span style="font-family:monospace">with
</span><span style="font-style:oblique">bindings_list</span> clause, <span style="font-family:monospace">ecase</span> turns them into existential
variables to be resolved later on.</p></li><li class="li-enumerate"><span style="font-family:monospace">simple destruct </span><span style="font-style:oblique">ident</span><a id="hevea_default634"></a><a id="hevea_tactic88"></a><p>This tactic behaves as <span style="font-family:monospace">intros until
</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">; case </span><span style="font-style:oblique">ident</span> when <span style="font-style:oblique">ident</span> is a quantified
variable of the goal.</p></li><li class="li-enumerate"><span style="font-family:monospace">simple destruct </span><span style="font-style:oblique">num</span><p>This tactic behaves as <span style="font-family:monospace">intros until
</span><span style="font-style:oblique">num</span><span style="font-family:monospace">; case </span><span style="font-style:oblique">ident</span> where <span style="font-style:oblique">ident</span> is the name given by
<span style="font-family:monospace">intros until </span><span style="font-style:oblique">num</span> to the <span style="font-style:oblique">num</span>-th non-dependent premise of
the goal.</p></li><li class="li-enumerate"><span style="font-family:monospace">case_eq </span><span style="font-style:oblique">term</span><a id="case_eq"></a><a id="hevea_default635"></a><a id="hevea_tactic89"></a><p>The tactic <span style="font-family:monospace">case_eq</span> is a variant of the <span style="font-family:monospace">case</span> tactic that
allow to perform case analysis on a term without completely
forgetting its original form. This is done by generating equalities
between the original form of the term and the outcomes of the case
analysis.</p></li></ol>
<h3 id="sec385" class="subsection">8.5.2  <span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default636"></a><a id="hevea_tactic90"></a>
<a id="Tac-induction"></a></p><p>This tactic applies to any goal. The argument <span style="font-style:oblique">term</span> must be of
inductive type and the tactic <span style="font-family:monospace">induction</span> generates subgoals,
one for each possible form of <span style="font-style:oblique">term</span>, i.e. one for each constructor
of the inductive type.</p><p>If the argument is dependent in either the conclusion or some
hypotheses of the goal, the argument is replaced by the appropriate
constructor form in each of the resulting subgoals and induction
hypotheses are added to the local context using names whose prefix is
<span style="font-family:monospace">IH</span>.</p><p>There are particular cases:</p><ul class="itemize"><li class="li-itemize">If <span style="font-style:oblique">term</span> is an identifier <span style="font-style:oblique">ident</span> denoting a quantified
variable of the conclusion of the goal, then <span style="font-family:monospace">induction
</span><span style="font-style:oblique">ident</span> behaves as <span style="font-family:monospace">intros until </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">; induction
</span><span style="font-style:oblique">ident</span>. If <span style="font-style:oblique">ident</span> is not anymore dependent in the goal
after application of <span style="font-family:monospace">induction</span>, it is erased (to avoid
erasure, use parentheses, as in <span style="font-family:monospace">induction (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">)</span>).</li><li class="li-itemize">If <span style="font-style:oblique">term</span> is a <span style="font-style:oblique">num</span>, then <span style="font-family:monospace">induction </span><span style="font-style:oblique">num</span> behaves as
<span style="font-family:monospace">intros until </span><span style="font-style:oblique">num</span> followed by <span style="font-family:monospace">induction</span> applied to the
last introduced hypothesis. Remark: For simple induction on a numeral,
use syntax <span style="font-family:monospace">induction (</span><span style="font-style:oblique">num</span><span style="font-family:monospace">)</span> (not very interesting anyway).</li><li class="li-itemize">In case <span style="font-style:oblique">term</span> is an hypothesis <span style="font-style:oblique">ident</span> of the context,
and <span style="font-style:oblique">ident</span> is not anymore dependent in the goal after
application of <span style="font-family:monospace">induction</span>, it is erased (to avoid erasure, use
parentheses, as in <span style="font-family:monospace">induction (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">)</span>).</li><li class="li-itemize">The argument <span style="font-style:oblique">term</span> can also be a pattern of which holes are
denoted by “_”. In this case, the tactic checks that all subterms
matching the pattern in the conclusion and the hypotheses are
compatible and performs induction using this subterm.</li></ul><p><br>
<span style="font-weight:bold">Example: </span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma induction</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">test : forall n:nat, n = n -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> n </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">= n.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall n : nat, n = n -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= n</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros n H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : n = n</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= n</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> induction n.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">2 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : 0 = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> S n </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= S n</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Not an inductive product</span><a id="hevea_error96"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">Unable to find an instance for the variables
</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> …</span><span style="font-style:oblique">ident</span><a id="hevea_error97"></a><p>Use in this case
the variant <span style="font-family:monospace">elim … with …</span> below.
</p></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">disj_conj_intro_pattern</span><p>This behaves as <span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span> but uses the names in
<span style="font-style:oblique">disj_conj_intro_pattern</span> to name the variables introduced in the context.
The <span style="font-style:oblique">disj_conj_intro_pattern</span> must typically be of the form
<span style="font-family:monospace">[</span> <span style="font-style:italic">p</span><sub>11</sub> …
<span style="font-style:italic">p</span><sub>1<span style="font-style:italic">n</span><sub>1</sub></sub> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span> <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span>1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">mn</span><sub><span style="font-style:italic">m</span></sub></sub> <span style="font-family:monospace">]</span> with <span style="font-style:italic">m</span> being the number of constructors of the type of
<span style="font-style:oblique">term</span>. Each variable introduced by <span style="font-family:monospace">induction</span> in the context
of the <span style="font-style:italic">i</span><sup><span style="font-style:italic">th</span></sup> goal gets its name from the list <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>1</sub> …
<span style="font-style:italic">p</span><sub><span style="font-style:italic">in</span><sub><span style="font-style:italic">i</span></sub></sub> in order. If there are not enough names, <span style="font-family:monospace">induction</span>
invents names for the remaining variables to introduce. More
generally, the <span style="font-style:italic">p</span><sub><span style="font-style:italic">ij</span></sub> can be any disjunctive/conjunctive
introduction pattern (see Section <a href="#intros-pattern">8.3.2</a>). For instance,
for an inductive type with one constructor, the pattern notation
<span style="font-family:monospace">(</span><span style="font-style:italic">p</span><sub>1</sub> <span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span> can be used instead of
<span style="font-family:monospace">[</span> <span style="font-style:italic">p</span><sub>1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-family:monospace">]</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><p>This behaves like <span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span> providing explicit
instances for the premises of the type of <span style="font-style:oblique">term</span> (see the syntax of
bindings in Section <a href="#Binding-list">8.1.3</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">einduction </span><span style="font-style:oblique">term</span><a id="hevea_default637"></a><a id="hevea_tactic91"></a><p>This tactic behaves like <span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span> excepts that it
does not fail if some dependent premise of the type of <span style="font-style:oblique">term</span> is
not inferable. Instead, the unresolved premises are posed as
existential variables to be inferred later, in the same way as <span style="font-family:monospace">eapply</span> does (see Section <a href="#eapply-example">8.2.4</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><p>This behaves as <span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><sub>1</sub> but using <span style="font-style:oblique">term</span><sub>2</sub> as
induction scheme. It does not expect the conclusion of the type of
<span style="font-style:oblique">term</span><sub>1</sub> to be inductive.</p></li><li class="li-enumerate"><span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><p>This behaves as <span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub> but
also providing instances for the premises of the type of <span style="font-style:oblique">term</span><sub>2</sub>.</p></li><li class="li-enumerate"><span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">, </span><span style="font-family:monospace">…</span><span style="font-family:monospace">, </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">qualid</span><p>This syntax is used for the case <span style="font-style:oblique">qualid</span> denotes an induction principle
with complex predicates as the induction principles generated by
<span style="font-family:monospace">Function</span> or <span style="font-family:monospace">Functional Scheme</span> may be.</p></li><li class="li-enumerate"><span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">goal_occurrences</span><p>This syntax is used for selecting which occurrences of <span style="font-style:oblique">term</span> the
induction has to be carried on. The <span style="font-family:monospace">in </span><span style="font-style:oblique">goal_occurrences</span> clause is
an occurrence clause whose syntax and behavior is described in
Section <a href="#Occurrences_clauses">8.1.4</a>. If variables or hypotheses not
mentioning <span style="font-style:oblique">term</span> in their type are listed in <span style="font-style:oblique">goal_occurrences</span>, those
are generalized as well in the statement to prove.</p><p><br>
<span style="font-weight:bold">Example: </span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma comm x y : x + y = y + x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x, y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x + y = y + x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> induction y in x |- *.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">2 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x + 0 = 0 + x</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> x + S y = S y + x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Show 2.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x, y : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  IHy : forall x : nat, x + y = y + x</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x + S y = S y + x</span></span></span><span style="font-size:small"><br>
</span></div></li><li class="li-enumerate"><span style="font-family:monospace">induction </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>1</sub><span style="font-family:monospace">
as </span><span style="font-style:oblique">disj_conj_intro_pattern</span><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>2</sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">goal_occurrences</span><br>
 <span style="font-family:monospace">einduction </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>1</sub><span style="font-family:monospace">
as </span><span style="font-style:oblique">disj_conj_intro_pattern</span><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>2</sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">goal_occurrences</span><p>These are the most general forms of <span style="font-family:monospace">induction</span> and <span style="font-family:monospace">einduction</span>. It combines the effects of the <span style="font-family:monospace">with</span>, <span style="font-family:monospace">as</span>, <span style="font-family:monospace">using</span>, and <span style="font-family:monospace">in</span> clauses.</p></li><li class="li-enumerate"><span style="font-family:monospace">elim </span><span style="font-style:oblique">term</span><a id="elim"></a><p>This is a more basic induction tactic. Again, the type of the
argument <span style="font-style:oblique">term</span> must be an inductive type. Then, according to
the type of the goal, the tactic <span style="font-family:monospace">elim</span> chooses the appropriate
destructor and applies it as the tactic <span style="font-family:monospace">apply</span>
would do. For instance, if the proof context contains <span style="font-family:monospace">n:nat</span> and the current goal is <span style="font-family:monospace">T</span> of type <span style="font-family:monospace">Prop</span>, then <span style="font-family:monospace">elim n</span> is equivalent to <span style="font-family:monospace">apply nat_ind with
(n:=n)</span>. The tactic <span style="font-family:monospace">elim</span> does not modify the context of
the goal, neither introduces the induction loading into the context
of hypotheses.</p><p>More generally, <span style="font-family:monospace">elim </span><span style="font-style:oblique">term</span> also works when the type of <span style="font-style:oblique">term</span>
is a statement with premises and whose conclusion is inductive. In
that case the tactic performs induction on the conclusion of the
type of <span style="font-style:oblique">term</span> and leaves the non-dependent premises of the type as
subgoals. In the case of dependent products, the tactic tries to
find an instance for which the elimination lemma applies and fails
otherwise.</p></li><li class="li-enumerate"><span style="font-family:monospace">elim </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><p>Allows to give explicit instances to the premises of the type
of <span style="font-style:oblique">term</span> (see Section <a href="#Binding-list">8.1.3</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">eelim </span><span style="font-style:oblique">term</span><a id="hevea_default638"></a><a id="hevea_tactic92"></a><p>In case the type of <span style="font-style:oblique">term</span> has dependent premises, this turns them into
existential variables to be resolved later on.</p></li><li class="li-enumerate"><span style="font-family:monospace">elim </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><br>
 <span style="font-family:monospace">elim </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><a id="hevea_default639"></a><a id="hevea_tactic93"></a><p>Allows the user to give explicitly an elimination predicate
<span style="font-style:oblique">term</span><sub>2</sub> that is not the standard one for the underlying inductive
type of <span style="font-style:oblique">term</span><sub>1</sub>. The <span style="font-style:oblique">bindings_list</span> clause allows
instantiating premises of the type of <span style="font-style:oblique">term</span><sub>2</sub>.</p></li><li class="li-enumerate"><span style="font-family:monospace">elim </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>2</sub><br>
 <span style="font-family:monospace">eelim </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>1</sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><sub>2</sub><p>These are the most general forms of <span style="font-family:monospace">elim</span> and <span style="font-family:monospace">eelim</span>. It
combines the effects of the <span style="font-family:monospace">using</span> clause and of the two uses
of the <span style="font-family:monospace">with</span> clause.</p></li><li class="li-enumerate"><span style="font-family:monospace">elimtype </span><span style="font-style:oblique">form</span><a id="hevea_default640"></a><a id="hevea_tactic94"></a><p>The argument <span style="font-style:oblique">form</span> must be inductively defined. <span style="font-family:monospace">elimtype I</span>
is equivalent to <span style="font-family:monospace">cut I. intro H</span><span style="font-style:oblique">n</span><span style="font-family:monospace">; elim H</span><span style="font-style:oblique">n</span><span style="font-family:monospace">;
clear H</span><span style="font-style:oblique">n</span>. Therefore the hypothesis <span style="font-family:monospace">H</span><span style="font-style:oblique">n</span> will
not appear in the context(s) of the subgoal(s). Conversely, if <span style="font-family:monospace">t</span> is a term of (inductive) type <span style="font-family:monospace">I</span> that does not occur
in the goal, then <span style="font-family:monospace">elim t</span> is equivalent to <span style="font-family:monospace">elimtype I; 2:
exact t.</span></p></li><li class="li-enumerate"><span style="font-family:monospace">simple induction </span><span style="font-style:oblique">ident</span><a id="hevea_default641"></a><a id="hevea_tactic95"></a><p>This tactic behaves as <span style="font-family:monospace">intros until
</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">; elim </span><span style="font-style:oblique">ident</span> when <span style="font-style:oblique">ident</span> is a quantified
variable of the goal.</p></li><li class="li-enumerate"><span style="font-family:monospace">simple induction </span><span style="font-style:oblique">num</span><p>This tactic behaves as <span style="font-family:monospace">intros until
</span><span style="font-style:oblique">num</span><span style="font-family:monospace">; elim </span><span style="font-style:oblique">ident</span> where <span style="font-style:oblique">ident</span> is the name given by
<span style="font-family:monospace">intros until </span><span style="font-style:oblique">num</span> to the <span style="font-style:oblique">num</span>-th non-dependent premise of
the goal.</p></li></ol>
<h3 id="sec386" class="subsection">8.5.3  <span style="font-family:monospace">double induction </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub>2</sub></h3>
<p>
<a id="hevea_default642"></a><a id="hevea_tactic96"></a></p><p>This tactic is deprecated and should be replaced by <span style="font-family:monospace">induction </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">; induction </span><span style="font-style:oblique">ident</span><sub>2</sub> (or <span style="font-family:monospace">induction </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">; destruct </span><span style="font-style:oblique">ident</span><sub>2</sub> depending on the exact needs).</p><p><br>
<span style="font-weight:bold">Variant: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">double induction </span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">num</span><sub>2</sub><p>This tactic is deprecated and should be replaced by <span style="font-family:monospace">induction
</span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace">; induction </span><span style="font-style:oblique">num</span><sub>3</sub> where <span style="font-style:oblique">num</span><sub>3</sub> is the result of
<span style="font-style:oblique">num</span><sub>2</sub>-<span style="font-style:oblique">num</span><sub>1</sub>.</p></li></ol>
<h3 id="sec387" class="subsection">8.5.4  <span style="font-family:monospace">dependent induction </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="hevea_default643"></a><a id="hevea_tactic97"></a>
<a id="DepInduction"></a></p><p>The <em>experimental</em> tactic <span style="font-family:monospace">dependent induction</span> performs
induction-inversion on an instantiated inductive predicate.
One needs to first require the <span style="font-family:monospace">Coq.Program.Equality</span> module to use
this tactic. The tactic is based on the BasicElim tactic by Conor
McBride [<a href="biblio.html#DBLP%3Aconf%2Ftypes%2FMcBride00">107</a>] and the work of Cristina Cornes
around inversion [<a href="biblio.html#DBLP%3Aconf%2Ftypes%2FCornesT95">36</a>]. From an instantiated
inductive predicate and a goal, it generates an equivalent goal where the
hypothesis has been generalized over its indexes which are then
constrained by equalities to be the right instances. This permits to
state lemmas without resorting to manually adding these equalities and
still get enough information in the proofs.</p><p><br>
<span style="font-weight:bold">Example: </span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma le</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">minus : forall n:nat, n </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 1 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> n = 0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall n : nat, n </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 1 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n = 0</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros n H ; induction H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">2 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n = 0</span></span></span><span style="font-size:small"><br>
</span></div><p>Here we did not get any information on the indexes to help fulfill this
proof. The problem is that, when we use the <span style="font-family:monospace">induction</span> tactic,
we lose information on the hypothesis instance, notably that the second
argument is <span style="font-family:monospace">1</span> here. Dependent induction solves this problem by
adding the corresponding equality to the context.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import Coq.Program.Equality.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma le</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">minus : forall n:nat, n </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 1 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> n = 0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall n : nat, n </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 1 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n = 0</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros n H ; dependent induction H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">2 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  0 = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n = 0</span></span></span><span style="font-size:small"><br>
</span></div><p>The subgoal is cleaned up as the tactic tries to automatically
simplify the subgoals with respect to the generated equalities.
In this enriched context, it becomes possible to solve this subgoal.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> reflexivity.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : S n </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  IHle : 0 = 1 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n = 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n = 0</span></span></span><span style="font-size:small"><br>
</span></div><p>Now we are in a contradictory context and the proof can be solved.
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> inversion H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><p>This technique works with any inductive predicate.
In fact, the <span style="font-family:monospace">dependent induction</span> tactic is just a wrapper around
the <span style="font-family:monospace">induction</span> tactic. One can make its own variant by just
writing a new tactic based on the definition found in
<span style="font-family:monospace">Coq.Program.Equality</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">dependent induction </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> generalizing </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><a id="hevea_default644"></a><a id="hevea_tactic98"></a><p>This performs dependent induction on the hypothesis <span style="font-style:oblique">ident</span> but first
generalizes the goal by the given variables so that they are
universally quantified in the goal. This is generally what one wants
to do with the variables that are inside some constructors in the
induction hypothesis. The other ones need not be further generalized.</p></li><li class="li-enumerate"><span style="font-family:monospace">dependent destruction </span><span style="font-style:oblique">ident</span><a id="hevea_default645"></a><a id="hevea_tactic99"></a><p>This performs the generalization of the instance <span style="font-style:oblique">ident</span> but uses <span style="font-family:monospace">destruct</span>
instead of <span style="font-family:monospace">induction</span> on the generalized hypothesis. This gives
results equivalent to <span style="font-family:monospace">inversion</span> or <span style="font-family:monospace">dependent inversion</span> if
the hypothesis is dependent.
</p></li></ol><p><br>
<span style="font-weight:bold">See also: </span><a href="tactic-examples.html#dependent-induction-example">10.1</a> for a larger example of
dependent induction and an explanation of the underlying technique.</p>
<h3 id="sec388" class="subsection">8.5.5  <span style="font-family:monospace">functional induction (</span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span></h3>
<p>
<a id="hevea_default646"></a><a id="hevea_tactic100"></a>
<a id="FunInduction"></a></p><p>The tactic <span style="font-family:monospace">functional induction</span> performs
case analysis and induction following the definition of a function. It
makes use of a principle generated by <span style="font-family:monospace">Function</span>
(see Section <a href="gallina-ext.html#Function">2.3</a>) or <span style="font-family:monospace">Functional Scheme</span>
(see Section <a href="schemes.html#FunScheme">13.2</a>). Note that this tactic is only available
after a <span style="font-family:monospace">Require Import FunInd</span>.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import FunInd.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">[Loading ML file extraction</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">plugin.cmxs ... done]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">[Loading ML file recdef</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">plugin.cmxs ... done]</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Functional Scheme minus</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">ind := Induction for minus Sort Prop.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">sub</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">equation is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">minus</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ind is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Check minus</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">ind.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">minus</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ind</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">     : forall P : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall n m : nat, n = 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 0 m n) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall n m k : nat, n = S k -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> m = 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (S k) 0 n) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       (forall n m k : nat,</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        n = S k -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">        forall l : nat, m = S l -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P k l (k - l) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P (S k) (S l) (k - l)) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       forall n m : nat, P n m (n - m)</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma le</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">minus (n m:nat) : n - m </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">= n.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n, m : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n - m </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">= n</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> functional induction (minus n m) using minus</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">ind; simpl; auto.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Qed.</span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Remark: </span><span style="font-family:monospace">(</span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span> must be a correct
full application of <span style="font-style:oblique">qualid</span>. In particular, the rules for implicit
arguments are the same as usual. For example use <span style="font-family:monospace">@</span><span style="font-style:oblique">qualid</span> if
you want to write implicit arguments explicitly.</p><p><br>
<span style="font-weight:bold">Remark: </span>Parentheses over <span style="font-style:oblique">qualid</span>…<span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> are mandatory.</p><p><br>
<span style="font-weight:bold">Remark: </span><span style="font-family:monospace">functional induction (f x1 x2 x3)</span> is actually a wrapper
for <span style="font-family:monospace">induction x1, x2, x3, (f x1 x2 x3) using </span><span style="font-style:oblique">qualid</span> followed by
a cleaning phase, where <span style="font-style:oblique">qualid</span> is the induction principle
registered for <span style="font-style:italic">f</span> (by the <span style="font-family:monospace">Function</span> (see Section <a href="gallina-ext.html#Function">2.3</a>)
or <span style="font-family:monospace">Functional Scheme</span> (see Section <a href="schemes.html#FunScheme">13.2</a>) command)
corresponding to the sort of the goal. Therefore <span style="font-family:monospace">functional
induction</span> may fail if the induction scheme <span style="font-style:oblique">qualid</span> is
not defined. See also Section <a href="gallina-ext.html#Function">2.3</a> for the function terms
accepted by <span style="font-family:monospace">Function</span>.</p><p><br>
<span style="font-weight:bold">Remark: </span>There is a difference between obtaining an induction scheme for a
function by using <span style="font-family:monospace">Function</span> (see Section <a href="gallina-ext.html#Function">2.3</a>) and by
using <span style="font-family:monospace">Functional Scheme</span> after a normal definition using
<span style="font-family:monospace">Fixpoint</span> or <span style="font-family:monospace">Definition</span>. See <a href="gallina-ext.html#Function">2.3</a> for
details.</p><p><br>
<span style="font-weight:bold">See also: </span><a href="gallina-ext.html#Function">2.3</a>,<a href="schemes.html#FunScheme">13.2</a>,<a href="schemes.html#FunScheme-examples">13.2</a>,
<a href="#sec%3Afunctional-inversion">8.14.1</a></p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Cannot find induction information on </span><span style="font-style:oblique">qualid</span><a id="hevea_error98"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">Not the right number of induction arguments</span><a id="hevea_error99"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">functional induction (</span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)
as </span><span style="font-style:oblique">disj_conj_intro_pattern</span><span style="font-family:monospace"> using </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span>+1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><p>Similarly to <span style="font-family:monospace">Induction</span> and <span style="font-family:monospace">elim</span>
(see Section <a href="#Tac-induction">8.5.2</a>), this allows giving explicitly the
name of the introduced variables, the
induction principle, and the values of dependent premises of the
elimination scheme, including <em>predicates</em> for mutual induction
when <span style="font-style:oblique">qualid</span> is part of a mutually recursive definition.</p></li></ol>
<h3 id="sec389" class="subsection">8.5.6  <span style="font-family:monospace">discriminate </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="discriminate"></a>
<a id="hevea_default647"></a><a id="hevea_tactic101"></a></p><p>This tactic proves any goal from an assumption stating that two
structurally different terms of an inductive set are equal. For
example, from <span style="font-family:monospace">(S (S O))=(S O)</span> we can derive by absurdity any
proposition.</p><p>The argument <span style="font-style:oblique">term</span> is assumed to be a proof of a statement
of conclusion <span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> = </span><span style="font-style:oblique">term</span><sub>2</sub> with <span style="font-style:oblique">term</span><sub>1</sub> and
<span style="font-style:oblique">term</span><sub>2</sub> being elements of an inductive set. To build the proof,
the tactic traverses the normal forms<sup><a id="text14" href="#note14">3</a></sup> of
<span style="font-style:oblique">term</span><sub>1</sub> and <span style="font-style:oblique">term</span><sub>2</sub> looking for a couple of subterms <span style="font-family:monospace">u</span>
and <span style="font-family:monospace">w</span> (<span style="font-family:monospace">u</span> subterm of the normal form of <span style="font-style:oblique">term</span><sub>1</sub> and
<span style="font-family:monospace">w</span> subterm of the normal form of <span style="font-style:oblique">term</span><sub>2</sub>), placed at the same
positions and whose head symbols are two different constructors. If
such a couple of subterms exists, then the proof of the current goal
is completed, otherwise the tactic fails.</p><p><br>
<span style="font-weight:bold">Remark: </span>The syntax <span style="font-family:monospace">discriminate </span><span style="font-style:oblique">ident</span> can be used to refer to a
hypothesis quantified in the goal. In this case, the quantified
hypothesis whose name is <span style="font-style:oblique">ident</span> is first introduced in the local
context using <span style="font-family:monospace">intros until </span><span style="font-style:oblique">ident</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">No primitive equality found</span><a id="hevea_error100"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">Not a discriminable equality</span><a id="hevea_error101"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">discriminate </span><span style="font-style:oblique">num</span><p>This does the same thing as <span style="font-family:monospace">intros until </span><span style="font-style:oblique">num</span> followed by
<span style="font-family:monospace">discriminate </span><span style="font-style:oblique">ident</span> where <span style="font-style:oblique">ident</span> is the identifier for
the last introduced hypothesis.</p></li><li class="li-enumerate"><span style="font-family:monospace">discriminate </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><p>This does the same thing as <span style="font-family:monospace">discriminate </span><span style="font-style:oblique">term</span> but using
the given bindings to instantiate parameters or hypotheses of <span style="font-style:oblique">term</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">ediscriminate </span><span style="font-style:oblique">num</span><a id="hevea_default648"></a><a id="hevea_tactic102"></a><br>
 <span style="font-family:monospace">ediscriminate </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><p>This works the same as <span style="font-family:monospace">discriminate</span> but if the type of <span style="font-style:oblique">term</span>,
or the type of the hypothesis referred to by <span style="font-style:oblique">num</span>, has uninstantiated
parameters, these parameters are left as existential variables.</p></li><li class="li-enumerate"><span style="font-family:monospace">discriminate</span><p>This behaves like <span style="font-family:monospace">discriminate </span><span style="font-style:oblique">ident</span> if <span style="font-style:oblique">ident</span> is the
name of an hypothesis to which <span style="font-family:monospace">discriminate</span> is applicable; if
the current goal is of the form <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">&lt;&gt;</span> <span style="font-style:oblique">term</span><sub>2</sub>,
this behaves as <span style="font-family:monospace">intro </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">; discriminate </span><span style="font-style:oblique">ident</span>.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">No discriminable equalities</span><a id="hevea_error102"></a>
</p></li></ol>
<h3 id="sec390" class="subsection">8.5.7  <span style="font-family:monospace">injection </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="injection"></a>
<a id="hevea_default649"></a><a id="hevea_tactic103"></a></p><p>The <span style="font-family:monospace">injection</span> tactic exploits the property that constructors of
inductive types are injective, i.e. that if <span style="font-style:italic">c</span> is a constructor
of an inductive type and <span style="font-style:italic">c</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span><sub><span style="font-weight:bold">1</span></sub> and <span style="font-style:italic">c</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span><sub><span style="font-weight:bold">2</span></sub> are equal
then <span style="font-weight:bold"><span style="font-style:italic">t</span></span><sub><span style="font-weight:bold">1</span></sub> and <span style="font-weight:bold"><span style="font-style:italic">t</span></span><sub><span style="font-weight:bold">2</span></sub> are equal too.</p><p>If <span style="font-style:oblique">term</span> is a proof of a statement of conclusion
<span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> = </span><span style="font-style:oblique">term</span><sub>2</sub>,
then <span style="font-family:monospace">injection</span> applies the injectivity of constructors as deep as possible to
derive the equality of all the subterms of <span style="font-style:oblique">term</span><sub>1</sub> and <span style="font-style:oblique">term</span><sub>2</sub> at positions
where <span style="font-style:oblique">term</span><sub>1</sub> and <span style="font-style:oblique">term</span><sub>2</sub> start to differ.
For example, from <span style="font-family:monospace">(S p, S n) = (q, S (S m)</span> we may derive <span style="font-family:monospace">S
p = q</span> and <span style="font-family:monospace">n = S m</span>. For this tactic to work, <span style="font-style:oblique">term</span><sub>1</sub> and
<span style="font-style:oblique">term</span><sub>2</sub> should be typed with an inductive
type and they should be neither convertible, nor having a different
head constructor. If these conditions are satisfied, the tactic
derives the equality of all the subterms of <span style="font-style:oblique">term</span><sub>1</sub> and
<span style="font-style:oblique">term</span><sub>2</sub> at positions where they differ and adds them as
antecedents to the conclusion of the current goal.</p><p><br>
<span style="font-weight:bold">Example: </span>Consider the following goal:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive list : Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | nil : list</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | cons : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> list.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variable P : list -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop.</span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Show.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  l : list</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : P nil</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : cons n l = cons 0 nil</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P l</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> injection H0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  l : list</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : P nil</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : cons n l = cons 0 nil</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  l = nil -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> n = 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P l</span></span></span><span style="font-size:small"><br>
</span></div><p>Beware that <span style="font-family:monospace">injection</span> yields an equality in a sigma type
whenever the injected object has a dependent type <span style="font-style:italic">P</span> with its two
instances in different types (<span style="font-style:italic">P</span> <span style="font-style:italic">t</span><sub>1</sub> ... <span style="font-style:italic">t</span><sub><span style="font-style:italic">n</span></sub>) and
(<span style="font-style:italic">P</span> <span style="font-style:italic">u</span><sub>1</sub> ... <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub>). If <span style="font-style:italic">t</span><sub>1</sub> and <span style="font-style:italic">u</span><sub>1</sub> are the same and have for type
an inductive type for which a decidable equality has been declared
using the command <span style="font-family:monospace">Scheme Equality</span> (see <a href="schemes.html#Scheme">13.1</a>), the use of
a sigma type is avoided.</p><p><br>
<span style="font-weight:bold">Remark: </span>If some quantified hypothesis of the goal is named <span style="font-style:oblique">ident</span>, then
<span style="font-family:monospace">injection </span><span style="font-style:oblique">ident</span> first introduces the hypothesis in the local
context using <span style="font-family:monospace">intros until </span><span style="font-style:oblique">ident</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Not a projectable equality but a discriminable one</span><a id="hevea_error103"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">Nothing to do, it is an equality between convertible terms</span><a id="hevea_error104"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">Not a primitive equality</span><a id="hevea_error105"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">Nothing to inject</span><a id="hevea_error106"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">injection </span><span style="font-style:oblique">num</span><p>This does the same thing as <span style="font-family:monospace">intros until </span><span style="font-style:oblique">num</span> followed by
<span style="font-family:monospace">injection </span><span style="font-style:oblique">ident</span> where <span style="font-style:oblique">ident</span> is the identifier for the last
introduced hypothesis.</p></li><li class="li-enumerate"><span style="font-family:monospace">injection </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">bindings_list</span><p>This does the same as <span style="font-family:monospace">injection </span><span style="font-style:oblique">term</span> but using
the given bindings to instantiate parameters or hypotheses of <span style="font-style:oblique">term</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">einjection </span><span style="font-style:oblique">num</span><a id="hevea_default650"></a><a id="hevea_tactic104"></a><br>
 <span style="font-family:monospace">einjection </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><p>This works the same as <span style="font-family:monospace">injection</span> but if the type of <span style="font-style:oblique">term</span>,
or the type of the hypothesis referred to by <span style="font-style:oblique">num</span>, has uninstantiated
parameters, these parameters are left as existential variables.</p></li><li class="li-enumerate"><span style="font-family:monospace">injection</span><p>If the current goal is of the form <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-family:monospace">&lt;&gt;</span> <span style="font-style:oblique">term</span><sub>2</sub>,
this behaves as <span style="font-family:monospace">intro </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">; injection </span><span style="font-style:oblique">ident</span>.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">goal does not satisfy the expected preconditions</span><a id="hevea_error107"></a></p></li><li class="li-enumerate"><span style="font-family:monospace">injection </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">intro_pattern</span><br>
<span style="font-family:monospace">injection </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> … </span><span style="font-style:oblique">intro_pattern</span><br>
<span style="font-family:monospace">injection as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> … </span><span style="font-style:oblique">intro_pattern</span><br>
<span style="font-family:monospace">einjection </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">with </span><span style="font-style:oblique">bindings_list</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">intro_pattern</span><br>
<span style="font-family:monospace">einjection </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> … </span><span style="font-style:oblique">intro_pattern</span><br>
<span style="font-family:monospace">einjection as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> … </span><span style="font-style:oblique">intro_pattern</span>
<a id="hevea_default651"></a><a id="hevea_tactic105"></a><p>These variants apply <span style="font-family:monospace">intros</span> <span style="font-style:oblique">intro_pattern</span> … <span style="font-style:oblique">intro_pattern</span> after
the call to <span style="font-family:monospace">injection</span> or <span style="font-family:monospace">einjection</span> so that all
equalities generated are moved in the context of hypotheses. The
number of <span style="font-style:oblique">intro_pattern</span> must not exceed the number of equalities
newly generated. If it is smaller, fresh names are automatically
generated to adjust the list of <span style="font-style:oblique">intro_pattern</span> to the number of new
equalities. The original equality is erased if it corresponds to an
hypothesis.</p></li></ol><p><a id="hevea_default652"></a><a id="hevea_option52"></a></p><p>It is possible to ensure that <span style="font-family:monospace">injection </span><span style="font-style:oblique">term</span> erases the
original hypothesis and leaves the generated equalities in the context
rather than putting them as antecedents of the current goal, as if
giving <span style="font-family:monospace">injection </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> as</span> (with an empty list of names). To
obtain this behavior, the option <span style="font-family:monospace">Set Structural Injection</span> must
be activated. This option is off by default.</p><p>By default, <span style="font-family:monospace">injection</span> only creates new equalities between
terms whose type is in sort <span style="font-family:monospace">Type</span> or <span style="font-family:monospace">Set</span>, thus
implementing a special behavior for objects that are proofs
of a statement in <span style="font-family:monospace">Prop</span>. This behavior can be turned off
by setting the option <span style="font-family:monospace">Set Keep Proof Equalities</span>.
<a id="hevea_default653"></a><a id="hevea_option53"></a>
</p>
<h3 id="sec391" class="subsection">8.5.8  <span style="font-family:monospace">inversion </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="hevea_default654"></a><a id="hevea_tactic106"></a></p><p>Let the type of <span style="font-style:oblique">ident</span> in the local context be (<span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span>),
where <span style="font-style:italic">I</span> is a (co)inductive predicate. Then,
<span style="font-family:monospace">inversion</span> applied to <span style="font-style:oblique">ident</span>  derives for each possible
constructor <span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub> of (<span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span>), <span style="font-weight:bold">all</span> the necessary
conditions that should hold for the instance (<span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span>) to be
proved by <span style="font-style:italic">c</span><sub><span style="font-style:italic">i</span></sub>.</p><p><br>
<span style="font-weight:bold">Remark: </span>If <span style="font-style:oblique">ident</span> does not denote a hypothesis in the local context
but refers to a hypothesis quantified in the goal, then the
latter is first introduced in the local context using
<span style="font-family:monospace">intros until </span><span style="font-style:oblique">ident</span>.</p><p><br>
<span style="font-weight:bold">Remark: </span>As inversion proofs may be large in size, we recommend the user to
stock the lemmas whenever the same instance needs to be inverted
several times. See Section <a href="schemes.html#Derive-Inversion">13.3</a>.</p><p><br>
<span style="font-weight:bold">Remark: </span>Part of the behavior of the <span style="font-family:monospace">inversion</span> tactic is to generate
equalities between expressions that appeared in the hypothesis that is
being processed. By default, no equalities are generated if they relate
two proofs (i.e. equalities between terms whose type is in
sort <span style="font-family:monospace">Prop</span>). This behavior can be turned off by using the option
<span style="font-family:monospace">Set Keep Proof Equalities.</span>
<a id="hevea_default655"></a><a id="hevea_option54"></a></p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">inversion </span><span style="font-style:oblique">num</span><p>This does the same thing as <span style="font-family:monospace">intros until </span><span style="font-style:oblique">num</span> then
<span style="font-family:monospace">inversion </span><span style="font-style:oblique">ident</span> where <span style="font-style:oblique">ident</span> is the identifier for the
last introduced hypothesis.</p></li><li class="li-enumerate"><a id="hevea_default656"></a><a id="hevea_tactic107"></a> <span style="font-family:monospace">inversion_clear </span><span style="font-style:oblique">ident</span><p>This behaves as <span style="font-family:monospace">inversion</span> and then erases <span style="font-style:oblique">ident</span>  from the
context.</p></li><li class="li-enumerate"><a id="hevea_default657"></a><a id="hevea_tactic108"></a> <span style="font-family:monospace">inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><p>This generally behaves as <span style="font-family:monospace">inversion</span> but using names in
<span style="font-style:oblique">intro_pattern</span> for naming hypotheses. The <span style="font-style:oblique">intro_pattern</span> must have
the form <span style="font-family:monospace">[</span> <span style="font-style:italic">p</span><sub>11</sub> … <span style="font-style:italic">p</span><sub>1<span style="font-style:italic">n</span><sub>1</sub></sub> <span style="font-family:monospace">|</span> … <span style="font-family:monospace">|</span>
<span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span>1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">mn</span><sub><span style="font-style:italic">m</span></sub></sub> <span style="font-family:monospace">]</span> with <span style="font-style:italic">m</span> being the number of
constructors of the type of <span style="font-style:oblique">ident</span>. Be careful that the list must
be of length <span style="font-style:italic">m</span> even if <span style="font-family:monospace">inversion</span> discards some cases (which
is precisely one of its roles): for the discarded cases, just use an
empty list (i.e. <span style="font-style:italic">n</span><sub><span style="font-style:italic">i</span></sub>=0).</p><p>The arguments of the <span style="font-style:italic">i</span><sup><span style="font-style:italic">th</span></sup> constructor and the
equalities that <span style="font-family:monospace">inversion</span> introduces in the context of the
goal corresponding to the <span style="font-style:italic">i</span><sup><span style="font-style:italic">th</span></sup> constructor, if it exists, get
their names from the list <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>1</sub> …<span style="font-style:italic">p</span><sub><span style="font-style:italic">in</span><sub><span style="font-style:italic">i</span></sub></sub> in order. If
there are not enough names, <span style="font-family:monospace">inversion</span> invents names for the
remaining variables to introduce. In case an equation splits into
several equations (because <span style="font-family:monospace">inversion</span> applies <span style="font-family:monospace">injection</span>
on the equalities it generates), the corresponding name <span style="font-style:italic">p</span><sub><span style="font-style:italic">ij</span></sub> in
the list must be replaced by a sublist of the form <span style="font-family:monospace">[</span><span style="font-style:italic">p</span><sub><span style="font-style:italic">ij</span>1</sub><span style="font-family:monospace">
</span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:italic">p</span><sub><span style="font-style:italic">ijq</span></sub><span style="font-family:monospace">]</span> (or, equivalently, <span style="font-family:monospace">(</span><span style="font-style:italic">p</span><sub><span style="font-style:italic">ij</span>1</sub><span style="font-family:monospace">,
…, </span><span style="font-style:italic">p</span><sub><span style="font-style:italic">ijq</span></sub><span style="font-family:monospace">)</span>) where <span style="font-style:italic">q</span> is the number of subequalities
obtained from splitting the original equation. Here is an example.</p><p>The <span style="font-family:monospace">inversion … as</span> variant of <span style="font-family:monospace">inversion</span>
generally behaves in a slightly more expectable way than
<span style="font-family:monospace">inversion</span> (no artificial duplication of some hypotheses
referring to other hypotheses) To take benefit of these
improvements, it is enough to use <span style="font-family:monospace">inversion … as []</span>,
letting the names being finally chosen by <span style="font-variant:small-caps">Coq</span>.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive contains0 : list nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | in</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">hd : forall l, contains0 (0 :: l)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | in</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">tl : forall l b, contains0 l -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> contains0 (b :: l).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">contains0 is defined</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">contains0</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ind is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall l:list nat, contains0 (1 :: l) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> contains0 l.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall l : Datatypes.list nat, contains0 (1 :: l) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> contains0 l</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros l H; inversion H as [ | l</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> p Hl</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> [Heqp Heql</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace">] ].</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  l : Datatypes.list nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : contains0 (1 :: l)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  l</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> : Datatypes.list nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  p : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  Hl</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> : contains0 l</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  Heqp : p = 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  Heql</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> : l</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> = l</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  contains0 l</span></span></span><span style="font-size:small"><br>
</span></div></li><li class="li-enumerate"><span style="font-family:monospace">inversion </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><p>This allows naming the hypotheses introduced by
<span style="font-family:monospace">inversion </span><span style="font-style:oblique">num</span> in the context.</p></li><li class="li-enumerate"><a id="hevea_default658"></a><a id="hevea_tactic109"></a> <span style="font-family:monospace">inversion_clear
</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><p>This allows naming the hypotheses introduced by
<span style="font-family:monospace">inversion_clear</span> in the context. Notice that hypothesis
names can be provided as if <span style="font-family:monospace">inversion</span> were called, even
though the <span style="font-family:monospace">inversion_clear</span> will eventually erase the
hypotheses.</p></li><li class="li-enumerate"><a id="hevea_default659"></a><a id="hevea_tactic110"></a> <span style="font-family:monospace">inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">
in </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>Let <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>, be identifiers in the local context. This
tactic behaves as generalizing <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>, and
then performing <span style="font-family:monospace">inversion</span>.</p></li><li class="li-enumerate"><a id="hevea_default660"></a><a id="hevea_tactic111"></a> <span style="font-family:monospace">inversion
</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> …
 </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>This allows naming the hypotheses introduced in the context by
<span style="font-family:monospace">inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>.</p></li><li class="li-enumerate"><a id="hevea_default661"></a><a id="hevea_tactic112"></a> <span style="font-family:monospace">inversion_clear
</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>Let <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>, be identifiers in the local context. This
tactic behaves as generalizing <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>, and
then performing <span style="font-family:monospace">inversion_clear</span>.</p></li><li class="li-enumerate"><a id="hevea_default662"></a><a id="hevea_tactic113"></a>
<span style="font-family:monospace">inversion_clear </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace">
in </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>This allows naming the hypotheses introduced in the context by
<span style="font-family:monospace">inversion_clear </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>.</p></li><li class="li-enumerate"><a id="hevea_default663"></a><a id="hevea_tactic114"></a> <span style="font-family:monospace">dependent inversion </span><span style="font-style:oblique">ident</span><p>That must be used when <span style="font-style:oblique">ident</span> appears in the current goal. It acts
like <span style="font-family:monospace">inversion</span> and then substitutes <span style="font-style:oblique">ident</span> for the
corresponding term in the goal.</p></li><li class="li-enumerate"><a id="hevea_default664"></a><a id="hevea_tactic115"></a> <span style="font-family:monospace">dependent
inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><p>This allows naming the hypotheses introduced in the context by
<span style="font-family:monospace">dependent inversion</span> <span style="font-style:oblique">ident</span>.</p></li><li class="li-enumerate"><a id="hevea_default665"></a><a id="hevea_tactic116"></a> <span style="font-family:monospace">dependent
inversion_clear </span><span style="font-style:oblique">ident</span><p>Like <span style="font-family:monospace">dependent inversion</span>, except that <span style="font-style:oblique">ident</span> is cleared
from the local context.</p></li><li class="li-enumerate"><a id="hevea_default666"></a><a id="hevea_tactic117"></a>
<span style="font-family:monospace">dependent inversion_clear </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><p>This allows naming the hypotheses introduced in the context by
<span style="font-family:monospace">dependent inversion_clear</span> <span style="font-style:oblique">ident</span>.</p></li><li class="li-enumerate"><a id="hevea_default667"></a><a id="hevea_tactic118"></a> <span style="font-family:monospace">dependent
inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><p>This variant allows you to specify the generalization of the goal. It
is useful when the system fails to generalize the goal automatically. If
<span style="font-style:oblique">ident</span> has type (<span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span>) and <span style="font-style:italic">I</span> has type
∀ (<span style="font-weight:bold"><span style="font-style:italic">x</span></span>:<span style="font-weight:bold"><span style="font-style:italic">T</span></span>), <span style="font-style:italic">s</span>, then <span style="font-style:oblique">term</span>  must be of type
<span style="font-style:italic">I</span>:∀ (<span style="font-weight:bold"><span style="font-style:italic">x</span></span>:<span style="font-weight:bold"><span style="font-style:italic">T</span></span>), <span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">x</span></span>→ <span style="font-style:italic">s</span>′ where <span style="font-style:italic">s</span>′ is the
type of the goal.</p></li><li class="li-enumerate"><a id="hevea_default668"></a><a id="hevea_tactic119"></a>
<span style="font-family:monospace">dependent inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace">
with </span><span style="font-style:oblique">term</span><p>This allows naming the hypotheses introduced in the context by
<span style="font-family:monospace">dependent inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span>.</p></li><li class="li-enumerate"><a id="hevea_default669"></a><a id="hevea_tactic120"></a>
<span style="font-family:monospace">dependent inversion_clear </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><p>Like <span style="font-family:monospace">dependent inversion … with</span> but clears <span style="font-style:oblique">ident</span> from
the local context.</p></li><li class="li-enumerate"><a id="hevea_default670"></a><a id="hevea_tactic121"></a>
<span style="font-family:monospace">dependent inversion_clear </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as
</span><span style="font-style:oblique">intro_pattern</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><p>This allows naming the hypotheses introduced in the context by
<span style="font-family:monospace">dependent inversion_clear </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span>.</p></li><li class="li-enumerate"><a id="hevea_default671"></a><a id="hevea_tactic122"></a> <span style="font-family:monospace">simple inversion </span><span style="font-style:oblique">ident</span><p>It is a very primitive inversion tactic that derives all the necessary
equalities but it does not simplify the constraints as
<span style="font-family:monospace">inversion</span> does.</p></li><li class="li-enumerate"><a id="hevea_default672"></a><a id="hevea_tactic123"></a> <span style="font-family:monospace">simple inversion
</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> as </span><span style="font-style:oblique">intro_pattern</span><p>This allows naming the hypotheses introduced in the context by
<span style="font-family:monospace">simple inversion</span>.</p></li><li class="li-enumerate"><a id="hevea_default673"></a><a id="hevea_tactic124"></a> <span style="font-family:monospace">inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">
using </span><span style="font-style:oblique">ident</span>′<p>Let <span style="font-style:oblique">ident</span> have type (<span style="font-style:italic">I</span> <span style="font-weight:bold"><span style="font-style:italic">t</span></span>) (<span style="font-style:italic">I</span> an inductive
predicate) in the local context, and <span style="font-style:oblique">ident</span>′ be a (dependent) inversion
lemma. Then, this tactic refines the current goal with the specified
lemma.</p></li><li class="li-enumerate"><a id="hevea_default674"></a><a id="hevea_tactic125"></a> <span style="font-family:monospace">inversion
</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> using </span><span style="font-style:oblique">ident</span>′<span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">… </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>This tactic behaves as generalizing <span style="font-style:oblique">ident</span><sub>1</sub>… <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>,
then doing <span style="font-family:monospace">inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> using </span><span style="font-style:oblique">ident</span>′.</p></li><li class="li-enumerate"><a id="hevea_default675"></a><a id="hevea_tactic126"></a> <span style="font-family:monospace">inversion_sigma</span><p>This tactic turns equalities of dependent pairs (e.g.,
<span style="font-family:monospace">existT P x p = existT P y q</span>, frequently left over by
<span style="font-family:monospace">inversion</span> on a dependent type family) into pairs of
equalities (e.g., a hypothesis <span style="font-family:monospace">H : x = y</span> and a hypothesis
of type <span style="font-family:monospace">rew H in p = q</span>); these hypotheses can subsequently
be simplified using <span style="font-family:monospace">subst</span>, without ever invoking any kind
of axiom asserting uniqueness of identity proofs. If you want to
explicitly specify the hypothesis to be inverted, or name the
generated hypotheses, you can invoke <span style="font-family:monospace">induction H as [H1 H2]
using eq_sigT_rect</span>. This tactic also works for <span style="font-family:monospace">sig</span>,
<span style="font-family:monospace">sigT2</span>, and <span style="font-family:monospace">sig2</span>, and there are similar
<span style="font-family:monospace">eq_sig</span><span style="font-family:monospace"><em>*</em></span><span style="font-family:monospace">_rect</span> induction lemmas.</p></li></ol><p>
<br>
<span style="font-weight:bold">Example 1: </span><span style="font-style:italic">Non-dependent inversion</span>

<a id="inversion-examples"></a></p><p>Let us consider the relation <span style="font-family:monospace">Le</span> over natural numbers and the
following variables:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive Le : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Set :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | LeO : forall n:nat, Le 0 n</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | LeS : forall n m:nat, Le n m -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Le (S n) (S m).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variable P : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Variable Q : forall n m:nat, Le n m -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop.</span></span><span style="font-size:small"><br>
</span></div><p>Let us consider the following goal:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Show.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n, m : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : Le (S n) m</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P n m</span></span></span><span style="font-size:small"><br>
</span></div><p>To prove the goal, we may need to reason by cases on <span style="font-family:monospace">H</span> and to
derive that <span style="font-family:monospace">m</span> is necessarily of
the form (<span style="font-style:italic">S</span> <span style="font-style:italic">m</span><sub>0</sub>) for certain <span style="font-style:italic">m</span><sub>0</sub> and that (<span style="font-style:italic">Le</span> <span style="font-style:italic">n</span> <span style="font-style:italic">m</span><sub>0</sub>).
Deriving these conditions corresponds to prove that the
only possible constructor of <span style="font-family:monospace">(Le (S n) m)</span> is
<span style="font-family:monospace">LeS</span> and that we can invert the
<span style="font-family:monospace">-&gt;</span> in the type of <span style="font-family:monospace">LeS</span>.
This inversion is possible because <span style="font-family:monospace">Le</span> is the smallest set closed by
the constructors <span style="font-family:monospace">LeO</span> and <span style="font-family:monospace">LeS</span>.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> inversion</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">clear H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n, m, m0 : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : Le n m0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P n (S m0)</span></span></span><span style="font-size:small"><br>
</span></div><p>Note that <span style="font-family:monospace">m</span> has been substituted in the goal for <span style="font-family:monospace">(S m0)</span>
and that the hypothesis <span style="font-family:monospace">(Le n m0)</span> has been added to the
context.</p><p>Sometimes it is
interesting to have the equality <span style="font-family:monospace">m=(S m0)</span> in the
context to use it after. In that case we can use <span style="font-family:monospace">inversion</span> that
does not clear the equalities:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> inversion H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n, m : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : Le (S n) m</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n0, m0 : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H1 : Le n m0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : n0 = n</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H2 : S m0 = m</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P n (S m0)</span></span></span><span style="font-size:small"><br>
</span></div><p>
<br>
<span style="font-weight:bold">Example 2: </span><span style="font-style:italic">Dependent inversion</span>
</p><p>Let us consider the following goal:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Show.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n, m : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : Le (S n) m</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  Q (S n) m H</span></span></span><span style="font-size:small"><br>
</span></div><p>As <span style="font-family:monospace">H</span> occurs in the goal, we may want to reason by cases on its
structure and so, we would like inversion tactics to
substitute <span style="font-family:monospace">H</span> by the corresponding term in constructor form.
Neither <span style="font-family:monospace">Inversion</span> nor <span style="font-family:monospace">Inversion_clear</span> make such a
substitution.
To have such a behavior we use the dependent inversion tactics:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> dependent inversion</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">clear H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n, m, m0 : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  l : Le n m0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  Q (S n) (S m0) (LeS n m0 l)</span></span></span><span style="font-size:small"><br>
</span></div><p>Note that <span style="font-family:monospace">H</span> has been substituted by <span style="font-family:monospace">(LeS n m0 l)</span> and
<span style="font-family:monospace">m</span> by <span style="font-family:monospace">(S m0)</span>.</p><p>
<br>
<span style="font-weight:bold">Example 3: </span><span style="font-style:italic">Using </span><span style="font-style:italic"><span style="font-family:monospace">inversion_sigma</span></span>
</p><p>Let us consider the following inductive type of length-indexed lists,
and a lemma about inverting equality of <span style="font-family:monospace">cons</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Coq.Logic.Eqdep</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">dec.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Inductive vec A : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Type :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      | nil : vec A O</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      | cons {n} (x : A) (xs : vec A n) : vec A (S n).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Lemma invert</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">cons : forall A n x xs y ys,</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          @cons A n x xs = @cons A n y ys</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> xs = ys.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Proof.</span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros A n x xs y ys H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  A : Type   n : nat   x : A   xs : vec A n   y : A   ys : vec A n</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : cons A x xs = cons A y ys</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  xs = ys</span></span></span><span style="font-size:small"><br>
</span></div><p>After performing <span style="font-family:monospace">inversion</span>, we are left with an equality of
<span style="font-family:monospace">existT</span>s:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> inversion H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  A : Type   n : nat   x : A   xs : vec A n   y : A   ys : vec A n</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : cons A x xs = cons A y ys</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H1 : x = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H2 : existT (fun n : nat =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> vec A n) n xs =</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">       existT (fun n : nat =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> vec A n) n ys</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  xs = ys</span></span></span><span style="font-size:small"><br>
</span></div><p>We can turn this equality into a usable form with
<span style="font-family:monospace">inversion_sigma</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> inversion</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">sigma.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  A : Type   n : nat   x : A   xs : vec A n   y : A   ys : vec A n</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : cons A x xs = cons A y ys</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H1 : x = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : n = n</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H3 : eq</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">rect n (fun a : nat =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> vec A a) xs n H0 = ys</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  xs = ys</span></span></span><span style="font-size:small"><br>
</span></div><p>To finish cleaning up the proof, we will need to use the fact that
that all proofs of <span style="font-family:monospace">n = n</span> for <span style="font-family:monospace">n</span> a <span style="font-family:monospace">nat</span> are
<span style="font-family:monospace">eq_refl</span>:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> let H := match goal with H : n = n |- </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> H end in</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      pose proof (Eqdep</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">dec.UIP</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">refl</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">nat </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> H); subst H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  A : Type   n : nat   x : A   xs : vec A n   y : A   ys : vec A n</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : cons A x xs = cons A y ys</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H1 : x = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H3 : eq</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">rect n (fun a : nat =</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> vec A a) xs n eq</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">refl = ys</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  xs = ys</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> simpl in *.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  A : Type   n : nat   x : A   xs : vec A n   y : A   ys : vec A n</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : cons A x xs = cons A y ys</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H1 : x = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H3 : xs = ys</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  xs = ys</span></span></span><span style="font-size:small"><br>
</span></div><p>Finally, we can finish the proof:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> assumption.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Qed.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">invert</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">cons is defined</span></span></span><span style="font-size:small"><br>
</span></div>
<h3 id="sec392" class="subsection">8.5.9  <span style="font-family:monospace">fix </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">num</span></h3>
<p>
<a id="hevea_default676"></a><a id="hevea_tactic127"></a>
<a id="tactic:fix"></a></p><p>This tactic is a primitive tactic to start a proof by induction. In
general, it is easier to rely on higher-level induction tactics such
as the ones described in Section <a href="#Tac-induction">8.5.2</a>.</p><p>In the syntax of the tactic, the identifier <span style="font-style:oblique">ident</span> is the name given
to the induction hypothesis. The natural number <span style="font-style:oblique">num</span> tells on which
premise of the current goal the induction acts, starting
from 1, counting both dependent and non dependent
products, but skipping local definitions. Especially, the current
lemma must be composed of at least <span style="font-style:oblique">num</span> products.</p><p>Like in a <span style="font-family:monospace">fix</span> expression, the induction
hypotheses have to be used on structurally smaller arguments.
The verification that inductive proof arguments are correct is done
only at the time of registering the lemma in the environment. To know
if the use of induction hypotheses is correct at some
time of the interactive development of a proof, use the command <span style="font-family:monospace">Guarded</span> (see Section <a href="proof-handling.html#Guarded">7.3.2</a>).</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">fix </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> with ( </span><span style="font-style:oblique">ident</span><sub>2</sub><span style="font-family:monospace">
</span><span style="font-style:oblique">binder</span><sub>2</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>2</sub><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">{ struct </span><span style="font-style:oblique">ident</span>′<sub>2</sub><span style="font-family:monospace">
}</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><sub>2</sub><span style="font-family:monospace"> ) … ( </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">
</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">{ struct </span><span style="font-style:oblique">ident</span>′<sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> }</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> )</span><p>This starts a proof by mutual induction. The statements to be
simultaneously proved are respectively <span style="font-family:monospace">forall</span>
<span style="font-style:oblique">binder</span><sub>2</sub> … <span style="font-style:oblique">binder</span><sub>2</sub><span style="font-family:monospace">,</span> <span style="font-style:oblique">type</span><sub>2</sub>, …, <span style="font-family:monospace">forall</span>
<span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub> … <span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">,</span> <span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span></sub>. The identifiers
<span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> are the names of the induction
hypotheses. The identifiers <span style="font-style:oblique">ident</span>′<sub>2</sub> … <span style="font-style:oblique">ident</span>′<sub><span style="font-style:italic">n</span></sub> are the
respective names of the premises on which the induction is performed
in the statements to be simultaneously proved (if not given, the
system tries to guess itself what they are).</p></li></ol>
<h3 id="sec393" class="subsection">8.5.10  <span style="font-family:monospace">cofix </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="hevea_default677"></a><a id="hevea_tactic128"></a>
<a id="tactic:cofix"></a></p><p>This tactic starts a proof by coinduction. The identifier <span style="font-style:oblique">ident</span> is
the name given to the coinduction hypothesis. Like in a <span style="font-family:monospace">cofix</span>
expression, the use of induction hypotheses have to guarded by a
constructor. The verification that the use of co-inductive hypotheses
is correct is done only at the time of registering the lemma in the
environment. To know if the use of coinduction hypotheses is correct
at some time of the interactive development of a proof, use the
command <span style="font-family:monospace">Guarded</span> (see Section <a href="proof-handling.html#Guarded">7.3.2</a>).</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">cofix </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> with ( </span><span style="font-style:oblique">ident</span><sub>2</sub><span style="font-family:monospace">
</span><span style="font-style:oblique">binder</span><sub>2</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>2</sub><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><sub>2</sub><span style="font-family:monospace"> ) … (
</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> )</span><p>This starts a proof by mutual coinduction. The statements to be
simultaneously proved are respectively <span style="font-family:monospace">forall</span>
<span style="font-style:oblique">binder</span><sub>2</sub> … <span style="font-style:oblique">binder</span><sub>2</sub><span style="font-family:monospace">,</span> <span style="font-style:oblique">type</span><sub>2</sub>, …, <span style="font-family:monospace">forall</span>
<span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub> … <span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">,</span> <span style="font-style:oblique">type</span><sub><span style="font-style:italic">n</span></sub>. The identifiers
<span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> are the names of the
coinduction hypotheses.</p></li></ol>
<h2 id="sec394" class="section">8.6  Rewriting expressions</h2>
<p>These tactics use the equality <span style="font-family:monospace">eq:forall A:Type, A-&gt;A-&gt;Prop</span>
defined in file <span style="font-family:monospace">Logic.v</span> (see Section <a href="stdlib.html#Equality">3.1.2</a>). The
notation for <span style="font-family:monospace">eq</span> <span style="font-style:italic">T</span> <span style="font-style:italic">t</span> <span style="font-style:italic">u</span> is simply <span style="font-style:italic">t</span><span style="font-family:monospace">=</span><span style="font-style:italic">u</span> dropping the
implicit type of <span style="font-style:italic">t</span> and <span style="font-style:italic">u</span>.</p>
<h3 id="sec395" class="subsection">8.6.1  <span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="rewrite"></a>
<a id="hevea_default678"></a><a id="hevea_tactic129"></a></p><p>This tactic applies to any goal. The type of <span style="font-style:oblique">term</span>
must have the form</p><p><span style="font-family:monospace">forall (x</span><sub>1</sub><span style="font-family:monospace">:A</span><sub>1</sub><span style="font-family:monospace">) … (x</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">:A</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">)</span><span style="font-family:monospace">eq</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-style:oblique">term</span><sub>2</sub>.</p><p>where <span style="font-family:monospace">eq</span> is the Leibniz equality or a registered
setoid equality.</p><p>Then <span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span> finds the first subterm matching
<span style="font-style:oblique">term</span><sub>1</sub> in the goal, resulting in instances <span style="font-style:oblique">term</span><sub>1</sub>′ and <span style="font-style:oblique">term</span><sub>2</sub>′
and then replaces every occurrence of <span style="font-style:oblique">term</span><sub>1</sub>′ by <span style="font-style:oblique">term</span><sub>2</sub>′.
Hence, some of the variables x<sub><span style="font-style:italic">i</span></sub> are
solved by unification, and some of the types <span style="font-family:monospace">A</span><sub>1</sub>, …,
<span style="font-family:monospace">A</span><sub><span style="font-style:italic">n</span></sub> become new subgoals.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">The term provided does not end with an equation</span><a id="hevea_error108"></a></li><li class="li-enumerate"><span style="font-family:monospace">Tactic generated a subgoal identical to the original goal</span><a id="hevea_error109"></a><p>This happens if <span style="font-style:oblique">term</span><sub>1</sub> does not occur in the goal.
</p></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">rewrite -&gt; </span><span style="font-style:oblique">term</span><a id="hevea_default679"></a><a id="hevea_tactic130"></a><p>Is equivalent to <span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span></p></li><li class="li-enumerate"><span style="font-family:monospace">rewrite &lt;- </span><span style="font-style:oblique">term</span><a id="hevea_default680"></a><a id="hevea_tactic131"></a><p>Uses the equality <span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">=</span><span style="font-style:oblique">term</span><sub>2</sub> from right to left</p></li><li class="li-enumerate"><span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">clause</span>
<a id="hevea_default681"></a><a id="hevea_tactic132"></a><p>Analogous to <span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span> but rewriting is done following
<span style="font-style:oblique">clause</span> (similarly to <a href="#Conversion-tactics">8.7</a>). For
instance:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">rewrite H in H1</span> will rewrite <span style="font-family:monospace">H</span> in the hypothesis
<span style="font-family:monospace">H1</span> instead of the current goal.
</li><li class="li-itemize"><span style="font-family:monospace">rewrite H in H1 at 1, H2 at - 2 |- *</span> means <span style="font-family:monospace">rewrite H; rewrite H in H1 at 1;
rewrite H in H2 at - 2</span>. In particular a failure will happen if any of
these three simpler tactics fails.
</li><li class="li-itemize"><span style="font-family:monospace">rewrite H in * |- </span> will do <span style="font-family:monospace">rewrite H in
H</span><sub><span style="font-style:italic">i</span></sub> for all hypothesis <span style="font-family:monospace">H</span><sub><span style="font-style:italic">i</span></sub><span style="font-family:monospace"> &lt;&gt; H</span>. A success will happen
as soon as at least one of these simpler tactics succeeds.
</li><li class="li-itemize"><span style="font-family:monospace">rewrite H in *</span> is a combination of <span style="font-family:monospace">rewrite H</span>
and <span style="font-family:monospace">rewrite H in * |-</span> that succeeds if at
least one of these two tactics succeeds.
</li></ul><p>
Orientation <span style="font-family:monospace">-&gt;</span> or <span style="font-family:monospace">&lt;-</span> can be
inserted before the term to rewrite.</p></li><li class="li-enumerate"><span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> at </span><span style="font-style:oblique">occurrences</span>
<a id="hevea_default682"></a><a id="hevea_tactic133"></a><p>Rewrite only the given occurrences of <span style="font-style:oblique">term</span><sub>1</sub>′. Occurrences are
specified from left to right as for <span style="font-family:monospace">pattern</span> (§<a href="#pattern">8.7.7</a>). The rewrite is always performed using setoid
rewriting, even for Leibniz’s equality, so one has to
<span style="font-family:monospace">Import Setoid</span> to use this variant.</p></li><li class="li-enumerate"><span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span>
<a id="hevea_default683"></a><a id="hevea_tactic134"></a><p>Use <span style="font-style:oblique">tactic</span> to completely solve the side-conditions arising from the
rewrite.</p></li><li class="li-enumerate"><span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> , </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> , </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><p>Is equivalent to the <span style="font-style:italic">n</span> successive tactics <span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span><sub>1</sub>
up to <span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>, each one working on the first subgoal
generated by the previous one.
Orientation <span style="font-family:monospace">-&gt;</span> or <span style="font-family:monospace">&lt;-</span> can be
inserted before each term to rewrite. One unique <span style="font-style:oblique">clause</span>
can be added at the end after the keyword <span style="font-family:monospace">in</span>; it will
then affect all rewrite operations.</p></li><li class="li-enumerate">In all forms of <span style="font-family:monospace">rewrite</span> described above, a term to rewrite
can be immediately prefixed by one of the following modifiers:
<ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">?</span> : the tactic <span style="font-family:monospace">rewrite ?</span><span style="font-style:oblique">term</span> performs the
rewrite of <span style="font-style:oblique">term</span> as many times as possible (perhaps zero time).
This form never fails.
</li><li class="li-itemize"><span style="font-style:italic">n</span><span style="font-family:monospace">?</span> : works similarly, except that it will do at most
<span style="font-style:italic">n</span> rewrites.
</li><li class="li-itemize"><span style="font-family:monospace">!</span> : works as <span style="font-family:monospace">?</span>, except that at least one rewrite
should succeed, otherwise the tactic fails.
</li><li class="li-itemize"><span style="font-style:italic">n</span><span style="font-family:monospace">!</span> (or simply <span style="font-style:italic">n</span>) : precisely <span style="font-style:italic">n</span> rewrites
of <span style="font-style:oblique">term</span> will be done, leading to failure if these <span style="font-style:italic">n</span> rewrites are not possible.
</li></ul></li><li class="li-enumerate"><span style="font-family:monospace">erewrite </span><span style="font-style:oblique">term</span><a id="hevea_default684"></a><a id="hevea_tactic135"></a><p>This tactic works as <span style="font-family:monospace">rewrite </span><span style="font-style:oblique">term</span> but turning unresolved
bindings into existential variables, if any, instead of failing. It has
the same variants as <span style="font-family:monospace">rewrite</span> has.</p></li></ol>
<h3 id="sec396" class="subsection">8.6.2  <span style="font-family:monospace">replace </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><sub>2</sub></h3>
<p>
<a id="tactic:replace"></a>
<a id="hevea_default685"></a><a id="hevea_tactic136"></a></p><p>This tactic applies to any goal. It replaces all free occurrences of
<span style="font-style:oblique">term</span><sub>1</sub> in the current goal with <span style="font-style:oblique">term</span><sub>2</sub> and generates the
equality <span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">=</span><span style="font-style:oblique">term</span><sub>1</sub> as a subgoal. This equality is
automatically solved if it occurs among the assumption, or if its
symmetric form occurs. It is equivalent to <span style="font-family:monospace">cut
</span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">=</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">; [intro H</span><span style="font-family:monospace"><span style="font-style:oblique">n</span></span><span style="font-family:monospace">; rewrite &lt;- H</span><span style="font-family:monospace"><span style="font-style:oblique">n</span></span><span style="font-family:monospace">; clear H</span><span style="font-family:monospace"><span style="font-style:oblique">n</span></span><span style="font-family:monospace">| assumption || symmetry; try assumption]</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">terms do not have convertible types</span><a id="hevea_error110"></a>
</li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">replace </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><p>This acts as <span style="font-family:monospace">replace </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><sub>2</sub> but applies <span style="font-style:oblique">tactic</span>
to solve the generated subgoal <span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">=</span><span style="font-style:oblique">term</span><sub>1</sub>.</p></li><li class="li-enumerate"><span style="font-family:monospace">replace </span><span style="font-style:oblique">term</span><p>Replaces <span style="font-style:oblique">term</span> with <span style="font-style:oblique">term</span>’ using the
first assumption whose type has the form <span style="font-style:oblique">term</span><span style="font-family:monospace">=</span><span style="font-style:oblique">term</span><span style="font-family:monospace">’</span> or <span style="font-style:oblique">term</span><span style="font-family:monospace">’=</span><span style="font-style:oblique">term</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">replace -&gt; </span><span style="font-style:oblique">term</span><p>Replaces <span style="font-style:oblique">term</span> with <span style="font-style:oblique">term</span>’ using the
first assumption whose type has the form <span style="font-style:oblique">term</span><span style="font-family:monospace">=</span><span style="font-style:oblique">term</span><span style="font-family:monospace">’</span></p></li><li class="li-enumerate"><span style="font-family:monospace">replace &lt;- </span><span style="font-style:oblique">term</span><p>Replaces <span style="font-style:oblique">term</span> with <span style="font-style:oblique">term</span>’ using the
first assumption whose type has the form <span style="font-style:oblique">term</span><span style="font-family:monospace">’=</span><span style="font-style:oblique">term</span></p></li><li class="li-enumerate"><span style="font-family:monospace">replace </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">clause</span><span style="font-family:monospace"> </span><br>
 <span style="font-family:monospace">replace </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">clause</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><br>
 <span style="font-family:monospace">replace </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">clause</span><br>
 <span style="font-family:monospace">replace -&gt; </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">clause</span><br>
 <span style="font-family:monospace">replace &lt;- </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">clause</span><p>Acts as before but the replacements take place in
<span style="font-style:oblique">clause</span> (see Section <a href="#Conversion-tactics">8.7</a>) and not only
in the conclusion of the goal.
The <span style="font-style:oblique">clause</span> argument must not contain any <span style="font-family:monospace">type of</span> nor <span style="font-family:monospace">value of</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">cutrewrite &lt;- (</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> = </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">)</span>
<a id="hevea_default686"></a><a id="hevea_tactic137"></a><p>This tactic is deprecated. It acts like <span style="font-family:monospace">replace </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with
</span><span style="font-style:oblique">term</span><sub>1</sub>, or, equivalently as <span style="font-family:monospace">enough</span> (<span style="font-style:oblique">term</span><sub>1</sub> =
<span style="font-style:oblique">term</span><sub>2</sub>) <span style="font-family:monospace">as &lt;-</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">cutrewrite -&gt; (</span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> = </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace">)</span>
<a id="hevea_default687"></a><a id="hevea_tactic138"></a><p>This tactic is deprecated. It can be replaced by <span style="font-family:monospace">enough</span>
(<span style="font-style:oblique">term</span><sub>1</sub> = <span style="font-style:oblique">term</span><sub>2</sub>) <span style="font-family:monospace">as -&gt;</span>.</p></li></ol>
<h3 id="sec397" class="subsection">8.6.3  <span style="font-family:monospace">subst </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="hevea_default688"></a><a id="hevea_tactic139"></a>
<a id="hevea_default689"></a><a id="hevea_option55"></a></p><p>This tactic applies to a goal that has <span style="font-style:oblique">ident</span> in its context and (at
least) one hypothesis, say <span style="font-style:italic">H</span>, of type <span style="font-style:oblique">ident</span> = <span style="font-style:italic">t</span> or <span style="font-style:italic">t</span>
<span style="font-family:monospace">= </span><span style="font-style:oblique">ident</span> with <span style="font-style:oblique">ident</span> not occurring in <span style="font-style:italic">t</span>. Then it replaces
<span style="font-style:oblique">ident</span> by <span style="font-style:italic">t</span> everywhere in the goal (in the hypotheses and in the
conclusion) and clears <span style="font-style:oblique">ident</span> and <span style="font-style:italic">H</span> from the context.</p><p>If <span style="font-style:oblique">ident</span> is a local definition of the form <span style="font-style:oblique">ident</span> := <span style="font-style:italic">t</span>, it is
also unfolded and cleared.</p><p><br>
<span style="font-weight:bold">Remark: </span>When several hypotheses have the form <span style="font-style:oblique">ident</span> = <span style="font-style:italic">t</span> or <span style="font-style:italic">t</span><span style="font-family:monospace"> = </span><span style="font-style:oblique">ident</span>, the first one is used.</p><p><br>
<span style="font-weight:bold">Remark: </span>If <span style="font-style:italic">H</span> is itself dependent in the goal, it is replaced by the
proof of reflexivity of equality.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">subst </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>This is equivalent to <span style="font-family:monospace">subst </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">; …; subst </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>.
</p></li><li class="li-enumerate"><span style="font-family:monospace">subst</span><p>This applies <span style="font-family:monospace">subst</span> repeatedly from top to bottom to all
identifiers of the context for which an equality of the form <span style="font-style:oblique">ident</span> = <span style="font-style:italic">t</span> or <span style="font-style:italic">t</span> <span style="font-family:monospace">= </span><span style="font-style:oblique">ident</span> or <span style="font-style:oblique">ident</span> := <span style="font-style:italic">t</span> exists, with
<span style="font-style:oblique">ident</span> not occurring in <span style="font-style:italic">t</span>.</p><p><span style="font-weight:bold">Remark: </span> The behavior of <span style="font-family:monospace">subst</span> can be controlled
using option <span style="font-family:monospace">Set Regular Subst Tactic</span>. When this option is
activated, <span style="font-family:monospace">subst</span> also deals with the following corner cases:
</p><ul class="itemize"><li class="li-itemize">
A context with ordered hypotheses <span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> = </span><span style="font-style:oblique">ident</span><sub>2</sub>
and <span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> = </span><span style="font-style:italic">t</span>, or <span style="font-style:italic">t</span>′ = <span style="font-style:oblique">ident</span><sub>1</sub> with <span style="font-style:italic">t</span>′ not a
variable, and no other hypotheses of the form <span style="font-style:oblique">ident</span><sub>2</sub><span style="font-family:monospace"> = </span><span style="font-style:italic">u</span>
or <span style="font-style:italic">u</span><span style="font-family:monospace"> = </span><span style="font-style:oblique">ident</span><sub>2</sub>; without the option, a second call to <span style="font-family:monospace">subst</span> would be necessary to replace <span style="font-style:oblique">ident</span><sub>2</sub> by <span style="font-style:italic">t</span> or <span style="font-style:italic">t</span>′
respectively.</li><li class="li-itemize">The presence of a recursive equation which without the option
would be a cause of failure of <span style="font-family:monospace">subst</span>.</li><li class="li-itemize">A context with cyclic dependencies as with hypotheses <span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> = f </span><span style="font-style:oblique">ident</span><sub>2</sub> and <span style="font-style:oblique">ident</span><sub>2</sub><span style="font-family:monospace"> = g </span><span style="font-style:oblique">ident</span><sub>1</sub> which
without the option would be a cause of failure of <span style="font-family:monospace">subst</span>.
</li></ul><p>
Additionally, it prevents a local definition such as <span style="font-style:oblique">ident</span> :=
<span style="font-style:italic">t</span> to be unfolded which otherwise it would exceptionally unfold in
configurations containing hypotheses of the form <span style="font-style:oblique">ident</span><span style="font-family:monospace"> = </span><span style="font-style:italic">u</span>,
or <span style="font-style:italic">u</span>′<span style="font-family:monospace"> = </span><span style="font-style:oblique">ident</span> with <span style="font-style:italic">u</span>′ not a variable.</p><p>Finally, it preserves the initial order of hypotheses, which without
the option it may break.</p><p>The option is on by default.</p></li></ol>
<h3 id="sec398" class="subsection">8.6.4  <span style="font-family:monospace">stepl </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default690"></a><a id="hevea_tactic140"></a></p><p>This tactic is for chaining rewriting steps. It assumes a goal of the
form “<span style="font-style:italic">R</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-style:oblique">term</span><sub>2</sub>” where <span style="font-style:italic">R</span> is a binary relation
and relies on a database of lemmas of the form <span style="font-family:monospace">forall</span> <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>
<span style="font-style:italic">z</span>, <span style="font-style:italic">R</span> <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> <span style="font-family:monospace">-&gt;</span> <span style="font-style:italic">eq</span> <span style="font-style:italic">x</span> <span style="font-style:italic">z</span> <span style="font-family:monospace">-&gt;</span> <span style="font-style:italic">R</span> <span style="font-style:italic">z</span> <span style="font-style:italic">y</span> where <span style="font-style:italic">eq</span>
is typically a setoid equality. The application of <span style="font-family:monospace">stepl </span><span style="font-style:oblique">term</span>
then replaces the goal by “<span style="font-style:italic">R</span> <span style="font-style:oblique">term</span> <span style="font-style:oblique">term</span><sub>2</sub>” and adds a new
goal stating “<span style="font-style:italic">eq</span> <span style="font-style:oblique">term</span> <span style="font-style:oblique">term</span><sub>1</sub>”.</p><p>Lemmas are added to the database using the command
<a id="hevea_default691"></a><a id="hevea_command183"></a>
</p><blockquote class="quote">
<span style="font-family:monospace">Declare Left Step </span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span>
</blockquote><p>The tactic is especially useful for parametric setoids which are not
accepted as regular setoids for <span style="font-family:monospace">rewrite</span> and <span style="font-family:monospace">setoid_replace</span> (see Chapter <a href="setoid.html#setoids">27</a>).</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">stepl </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><p>This applies <span style="font-family:monospace">stepl </span><span style="font-style:oblique">term</span> then applies <span style="font-style:oblique">tactic</span> to the second goal.</p></li><li class="li-enumerate"><span style="font-family:monospace">stepr </span><span style="font-style:oblique">term</span><br>
 <span style="font-family:monospace">stepr </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> by </span><span style="font-style:oblique">tactic</span><a id="hevea_default692"></a><a id="hevea_tactic141"></a><p>This behaves as <span style="font-family:monospace">stepl</span> but on the right-hand-side of the binary relation.
Lemmas are expected to be of the form
“<span style="font-family:monospace">forall</span> <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>
<span style="font-style:italic">z</span>, <span style="font-style:italic">R</span> <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> <span style="font-family:monospace">-&gt;</span> <span style="font-style:italic">eq</span> <span style="font-style:italic">y</span> <span style="font-style:italic">z</span> <span style="font-family:monospace">-&gt;</span> <span style="font-style:italic">R</span> <span style="font-style:italic">x</span> <span style="font-style:italic">z</span>”
and are registered using the command
<a id="hevea_default693"></a><a id="hevea_command184"></a>
</p><blockquote class="quote">
<span style="font-family:monospace">Declare Right Step </span><span style="font-style:oblique">term</span><span style="font-family:monospace">.</span>
</blockquote></li></ol>
<h3 id="sec399" class="subsection">8.6.5  <span style="font-family:monospace">change </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default694"></a><a id="hevea_tactic142"></a>
<a id="change"></a></p><p>This tactic applies to any goal. It implements the rule
“Conv”<a id="hevea_default695"></a> given in Section <a href="cic.html#Conv">4.4</a>. <span style="font-family:monospace">change U</span> replaces the current goal <span style="font-family:monospace">T</span> with <span style="font-family:monospace">U</span> providing that
<span style="font-family:monospace">U</span> is well-formed and that <span style="font-family:monospace">T</span> and <span style="font-family:monospace">U</span> are convertible.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Not convertible</span><a id="hevea_error111"></a>
</li></ol><p><a id="hevea_default696"></a><a id="hevea_tactic143"></a>
<br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">change </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><sub>2</sub><p>This replaces the occurrences of <span style="font-style:oblique">term</span><sub>1</sub> by <span style="font-style:oblique">term</span><sub>2</sub> in the
current goal. The terms <span style="font-style:oblique">term</span><sub>1</sub> and <span style="font-style:oblique">term</span><sub>2</sub> must be
convertible.</p></li><li class="li-enumerate"><span style="font-family:monospace">change </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><sub>2</sub><p>This replaces the occurrences numbered <span style="font-style:oblique">num</span><sub>1</sub> … <span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub> of
<span style="font-style:oblique">term</span><sub>1</sub> by <span style="font-style:oblique">term</span><sub>2</sub> in the current goal.
The terms <span style="font-style:oblique">term</span><sub>1</sub> and <span style="font-style:oblique">term</span><sub>2</sub> must be convertible.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Too few occurrences</span></p></li><li class="li-enumerate"><span style="font-family:monospace">change </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span></li><li class="li-enumerate"><span style="font-family:monospace">change </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span></li><li class="li-enumerate"><span style="font-family:monospace">change </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> in
</span><span style="font-style:oblique">ident</span><p>This applies the <span style="font-family:monospace">change</span> tactic not to the goal but to the
hypothesis <span style="font-style:oblique">ident</span>.</p></li></ol><p><br>
<span style="font-weight:bold">See also: </span><a href="#Conversion-tactics">8.7</a></p>
<h2 id="Conversion-tactics" class="section">8.7  Performing computations
<a id="hevea_default697"></a>
</h2>
<p>This set of tactics implements different specialized usages of the
tactic <span style="font-family:monospace">change</span>.</p><p>All conversion tactics (including <span style="font-family:monospace">change</span>) can be
parameterized by the parts of the goal where the conversion can
occur. This is done using <em>goal clauses</em> which consists in a list
of hypotheses and, optionally, of a reference to the conclusion of the
goal. For defined hypothesis it is possible to specify if the
conversion should occur on the type part, the body part or both
(default).</p><p><a id="hevea_default698"></a>
<a id="hevea_default699"></a>
Goal clauses are written after a conversion tactic (tactics
<span style="font-family:monospace">set</span> <a href="#tactic%3Aset">8.3.7</a>, <span style="font-family:monospace">rewrite</span> <a href="#rewrite">8.6.1</a>,
<span style="font-family:monospace">replace</span> <a href="#tactic%3Areplace">8.6.2</a> and
<span style="font-family:monospace">autorewrite</span> <a href="#tactic%3Aautorewrite">8.8.4</a> also use goal clauses) and
are introduced by the keyword <span style="font-family:monospace">in</span>. If no goal clause is provided,
the default is to perform the conversion only in the conclusion.</p><p>The syntax and description of the various goal clauses is the following:
</p><dl class="description"><dt class="dt-description">
</dt><dd class="dd-description"><span style="font-family:monospace">in </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> |- </span> only in hypotheses <span style="font-style:oblique">ident</span><sub>1</sub>
…<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>
</dd><dt class="dt-description"></dt><dd class="dd-description"><span style="font-family:monospace">in </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span>…<span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> |- *</span> in hypotheses <span style="font-style:oblique">ident</span><sub>1</sub> …<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> and in the conclusion
</dd><dt class="dt-description"></dt><dd class="dd-description"><span style="font-family:monospace">in * |-</span> in every hypothesis
</dd><dt class="dt-description"></dt><dd class="dd-description"><span style="font-family:monospace">in *</span> (equivalent to <span style="font-family:monospace">in * |- *</span>) everywhere
</dd><dt class="dt-description"></dt><dd class="dd-description"><span style="font-family:monospace">in (type of </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">) (value of </span><span style="font-style:oblique">ident</span><sub>2</sub><span style="font-family:monospace">) </span>…<span style="font-family:monospace"> |-</span> in
type part of <span style="font-style:oblique">ident</span><sub>1</sub>, in the value part of <span style="font-style:oblique">ident</span><sub>2</sub>, etc.
</dd></dl><p>For backward compatibility, the notation <span style="font-family:monospace">in</span> <span style="font-style:oblique">ident</span><sub>1</sub>…<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>
performs the conversion in hypotheses <span style="font-style:oblique">ident</span><sub>1</sub>…<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>.</p>
<h3 id="sec401" class="subsection">8.7.1  <span style="font-family:monospace">cbv </span><span style="font-style:oblique">flag</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">flag</span><sub><span style="font-style:italic">n</span></sub>, <span style="font-family:monospace">lazy </span><span style="font-style:oblique">flag</span><sub>1</sub><span style="font-family:monospace">
</span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">flag</span><sub><span style="font-style:italic">n</span></sub>, and <span style="font-family:monospace">compute</span></h3>
<p>
<a id="hevea_default700"></a><a id="hevea_tactic144"></a>
<a id="hevea_default701"></a><a id="hevea_tactic145"></a>
<a id="hevea_default702"></a><a id="hevea_tactic146"></a>
<a id="hevea_default703"></a><a id="hevea_tactic147"></a><a id="vmcompute"></a>
<a id="hevea_default704"></a><a id="hevea_tactic148"></a><a id="nativecompute"></a></p><p>These parameterized reduction tactics apply to any goal and perform
the normalization of the goal according to the specified flags. In
correspondence with the kinds of reduction considered in <span style="font-variant:small-caps">Coq</span>  namely
β (reduction of functional application), δ (unfolding of
transparent constants, see <a href="vernacular.html#Transparent">6.10.2</a>), ι (reduction of
pattern-matching over a constructed term, and unfolding of <span style="font-family:monospace">fix</span>
and <span style="font-family:monospace">cofix</span> expressions) and ζ (contraction of local
definitions), the flags are either <span style="font-family:monospace">beta</span>, <span style="font-family:monospace">delta</span>,
<span style="font-family:monospace">match</span>, <span style="font-family:monospace">fix</span>, <span style="font-family:monospace">cofix</span>, <span style="font-family:monospace">iota</span> or <span style="font-family:monospace">zeta</span>.
The <span style="font-family:monospace">iota</span> flag is a shorthand for <span style="font-family:monospace">match</span>, <span style="font-family:monospace">fix</span> and <span style="font-family:monospace">cofix</span>.
The <span style="font-family:monospace">delta</span> flag itself can be refined into <span style="font-family:monospace">delta [</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">]</span> or <span style="font-family:monospace">delta
-[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">]</span>, restricting in the first case the
constants to unfold to the constants listed, and restricting in the
second case the constant to unfold to all but the ones explicitly
mentioned. Notice that the <span style="font-family:monospace">delta</span> flag does not apply to
variables bound by a let-in construction inside the term itself (use
here the <span style="font-family:monospace">zeta</span> flag). In any cases, opaque constants are not
unfolded (see Section <a href="vernacular.html#Opaque">6.10.1</a>).</p><p>Normalization according to the flags is done by first evaluating the
head of the expression into a <em>weak-head</em> normal form, i.e. until
the evaluation is bloked by a variable (or an opaque constant, or an
axiom), as e.g. in <span style="font-family:monospace">x u</span><sub>1</sub><span style="font-family:monospace"> ... u</span><sub><span style="font-style:italic">n</span></sub>, or <span style="font-family:monospace">match x with
... end</span>, or <span style="font-family:monospace">(fix f x {struct x} := ...) x</span>, or is a
constructed form (a λ-expression, a constructor, a cofixpoint,
an inductive type, a product type, a sort), or is a redex that the
flags prevent to reduce. Once a weak-head normal form is obtained,
subterms are recursively reduced using the same strategy.</p><p>Reduction to weak-head normal form can be done using two strategies:
<em>lazy</em> (<span style="font-family:monospace">lazy</span> tactic), or <em>call-by-value</em> (<span style="font-family:monospace">cbv</span>
tactic). The lazy strategy is a call-by-need strategy, with sharing of
reductions: the arguments of a function call are weakly evaluated only
when necessary, and if an argument is used several times then it is
weakly computed only once. This reduction is efficient for reducing
expressions with dead code. For instance, the proofs of a proposition
<span style="font-family:monospace">exists </span><span style="font-style:italic">x</span><span style="font-family:monospace">. </span><span style="font-style:italic">P</span>(<span style="font-style:italic">x</span>) reduce to a pair of a witness <span style="font-style:italic">t</span>, and a
proof that <span style="font-style:italic">t</span> satisfies the predicate <span style="font-style:italic">P</span>. Most of the time, <span style="font-style:italic">t</span> may
be computed without computing the proof of <span style="font-style:italic">P</span>(<span style="font-style:italic">t</span>), thanks to the lazy
strategy.</p><p>The call-by-value strategy is the one used in ML languages: the
arguments of a function call are systematically weakly evaluated
first. Despite the lazy strategy always performs fewer reductions than
the call-by-value strategy, the latter is generally more efficient for
evaluating purely computational expressions (i.e. with few dead code).</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">compute</span> <a id="hevea_default705"></a><a id="hevea_tactic149"></a><br>
 <span style="font-family:monospace">cbv</span><p>These are synonyms for <span style="font-family:monospace">cbv beta delta iota zeta</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">lazy</span><p>This is a synonym for <span style="font-family:monospace">lazy beta delta iota zeta</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">compute [</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">]</span><br>
 <span style="font-family:monospace">cbv [</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">]</span><p>These are synonyms of <span style="font-family:monospace">cbv beta delta
[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">] iota zeta</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">compute -[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">]</span><br>
 <span style="font-family:monospace">cbv -[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">]</span><p>These are synonyms of <span style="font-family:monospace">cbv beta delta
-[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">] iota zeta</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">lazy [</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">]</span><br>
 <span style="font-family:monospace">lazy -[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">]</span><p>These are respectively synonyms of <span style="font-family:monospace">lazy beta delta
[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">] iota zeta</span> and <span style="font-family:monospace">lazy beta delta
-[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">] iota zeta</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">vm_compute</span> <a id="hevea_default706"></a><a id="hevea_tactic150"></a><p>This tactic evaluates the goal using the optimized call-by-value evaluation
bytecode-based virtual machine described in
[<a href="biblio.html#CompiledStrongReduction">77</a>]. This algorithm is dramatically more efficient
than the algorithm used for the <span style="font-family:monospace">cbv</span> tactic, but it cannot be
fine-tuned. It is specially interesting for full evaluation of algebraic
objects. This includes the case of reflection-based tactics.</p></li><li class="li-enumerate"><span style="font-family:monospace">native_compute</span> <a id="hevea_default707"></a><a id="hevea_tactic151"></a><p>This tactic evaluates the goal by compilation to <span style="font-variant:small-caps">OCaml</span> as described in
[<a href="biblio.html#FullReduction">16</a>]. If <span style="font-variant:small-caps">Coq</span> is running in native code, it can be typically
two to five times faster than <span style="font-family:monospace">vm_compute</span>. Note however that the
compilation cost is higher, so it is worth using only for intensive
computations.</p></li></ol><p><br>
<span style="font-weight:bold">Remark: </span>The following option makes <span style="font-family:monospace">cbv</span> (and its derivative <span style="font-family:monospace">compute</span>) print information about the constants it encounters and
the unfolding decisions it makes.
</p><blockquote class="quote">
<a id="hevea_default708"></a><a id="hevea_option56"></a>
<span style="font-family:monospace">Set Debug Cbv</span>
</blockquote>
<h3 id="sec402" class="subsection">8.7.2  <span style="font-family:monospace">red</span></h3>
<p>
<a id="hevea_default709"></a><a id="hevea_tactic152"></a></p><p>This tactic applies to a goal that has the form <span style="font-family:monospace">forall (x:T1)…(xk:Tk), t</span> with <span style="font-family:monospace">t</span>
βιζ-reducing to <span style="font-family:monospace">c t1 … tn</span> and <span style="font-family:monospace">c</span> a
constant. If
<span style="font-family:monospace">c</span> is transparent then it replaces <span style="font-family:monospace">c</span> with its definition
(say <span style="font-family:monospace">t</span>) and then reduces <span style="font-family:monospace">(t t1 … tn)</span> according to
βιζ-reduction rules.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Not reducible</span><a id="hevea_error112"></a>
</li></ol>
<h3 id="sec403" class="subsection">8.7.3  <span style="font-family:monospace">hnf</span></h3>
<p>
<a id="hevea_default710"></a><a id="hevea_tactic153"></a></p><p>This tactic applies to any goal. It replaces the current goal with its
head normal form according to the βδιζ-reduction
rules, i.e. it reduces the head of the goal until it becomes a
product or an irreducible term. All inner βι-redexes are also
reduced.</p><p><br>
<span style="font-weight:bold">Example: </span>The term <code>forall n:nat, (plus (S n) (S n))</code> is not reduced by <span style="font-family:monospace">hnf</span>.</p><p><br>
<span style="font-weight:bold">Remark: </span>The δ rule only applies to transparent constants
(see Section <a href="vernacular.html#Opaque">6.10.1</a> on transparency and opacity).</p>
<h3 id="sec404" class="subsection">8.7.4  <span style="font-family:monospace">cbn</span> and <span style="font-family:monospace">simpl</span></h3>
<p>
<a id="hevea_default711"></a><a id="hevea_tactic154"></a> <a id="hevea_default712"></a><a id="hevea_tactic155"></a></p><p>These tactics apply to any goal. They try to reduce a term to
something still readable instead of fully normalizing it. They perform
a sort of strong normalization with two key differences:
</p><ul class="itemize"><li class="li-itemize">
They unfold a constant if and only if it leads to a
ι-reduction, i.e. reducing a match or unfolding a fixpoint.
</li><li class="li-itemize">While reducing a constant unfolding to (co)fixpoints,
the tactics use the name of the
constant the (co)fixpoint comes from instead of the (co)fixpoint
definition in recursive calls.
</li></ul><p>The <span style="font-family:monospace">cbn</span> tactic is claimed to be a more principled, faster and more
predictable replacement for <span style="font-family:monospace">simpl</span>.</p><p>The <span style="font-family:monospace">cbn</span> tactic accepts the same flags as <span style="font-family:monospace">cbv</span> and
<span style="font-family:monospace">lazy</span>. The behavior of both <span style="font-family:monospace">simpl</span> and <span style="font-family:monospace">cbn</span>
can be tuned using the <span style="font-family:monospace">Arguments</span> vernacular command as
follows: <a id="hevea_default713"></a><a id="hevea_command185"></a>
</p><ul class="itemize"><li class="li-itemize">
A constant can be marked to be never unfolded by <span style="font-family:monospace">cbn</span> or
<span style="font-family:monospace">simpl</span>:
<span style="font-size:small">
</span><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments minus n m : simpl never.</span></span><span style="font-size:small"><br>
</span></div><span style="font-size:small">
</span>
After that command an expression like <span style="font-family:monospace">(minus (S x) y)</span> is left
untouched by the tactics <span style="font-family:monospace">cbn</span> and <span style="font-family:monospace">simpl</span>.
</li><li class="li-itemize">A constant can be marked to be unfolded only if applied to enough arguments.
The number of arguments required can be specified using
the <span style="font-family:monospace">/</span> symbol in the arguments list of the <span style="font-family:monospace">Arguments</span> vernacular
command.
<span style="font-size:small">
</span><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition fcomp A B C f (g : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> B) (x : A) : C := f (g x).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Notation "f </span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace">o g" := (fcomp f g) (at level 50).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments fcomp {A B C} f g x /.</span></span><span style="font-size:small"><br>
</span></div><span style="font-size:small">
</span>
After that command the expression <span style="font-family:monospace">(f </span><code><span style="font-family:monospace">\</span></code><span style="font-family:monospace">o g)</span> is left untouched by
<span style="font-family:monospace">simpl</span> while <span style="font-family:monospace">((f </span><code><span style="font-family:monospace">\</span></code><span style="font-family:monospace">o g) t)</span> is reduced to <span style="font-family:monospace">(f (g t))</span>.
The same mechanism can be used to make a constant volatile, i.e. always
unfolded.
<span style="font-size:small">
</span><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition volatile := fun x : nat =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> x.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments volatile / x.</span></span><span style="font-size:small"><br>
</span></div><span style="font-size:small">
</span>
</li><li class="li-itemize">A constant can be marked to be unfolded only if an entire set of arguments
evaluates to a constructor. The <span style="font-family:monospace">!</span> symbol can be used to mark such
arguments.
<span style="font-size:small">
</span><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments minus !n !m.</span></span><span style="font-size:small"><br>
</span></div><span style="font-size:small">
</span>
After that command, the expression <span style="font-family:monospace">(minus (S x) y)</span> is left untouched by
<span style="font-family:monospace">simpl</span>, while <span style="font-family:monospace">(minus (S x) (S y))</span> is reduced to <span style="font-family:monospace">(minus x y)</span>.
</li><li class="li-itemize">A special heuristic to determine if a constant has to be unfolded can be
activated with the following command:
<span style="font-size:small">
</span><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Arguments minus n m : simpl nomatch.</span></span><span style="font-size:small"><br>
</span></div><span style="font-size:small">
</span>
The heuristic avoids to perform a simplification step that would
expose a <span style="font-family:monospace">match</span> construct in head position. For example the
expression <span style="font-family:monospace">(minus (S (S x)) (S y))</span> is simplified to
<span style="font-family:monospace">(minus (S x) y)</span> even if an extra simplification is possible.
</li></ul><p>In detail, the tactic <span style="font-family:monospace">simpl</span> first applies
βι-reduction. Then, it expands transparent constants and
tries to reduce further using βι-reduction. But, when no
ι rule is applied after unfolding then δ-reductions are
not applied. For instance trying to use <span style="font-family:monospace">simpl</span> on
<span style="font-family:monospace">(plus n O)=n</span> changes nothing.</p><p>Notice that only transparent constants whose name can be reused in the
recursive calls are possibly unfolded by <span style="font-family:monospace">simpl</span>. For instance
a constant defined by <span style="font-family:monospace">plus’ := plus</span> is possibly unfolded and
reused in the recursive calls, but a constant such as <span style="font-family:monospace">succ :=
plus (S O)</span> is never unfolded. This is the main difference between
<span style="font-family:monospace">simpl</span> and <span style="font-family:monospace">cbn</span>. The tactic <span style="font-family:monospace">cbn</span> reduces
whenever it will be able to reuse it or not: <span style="font-family:monospace">succ t</span> is
reduced to <span style="font-family:monospace">S t</span>.</p><p><a id="hevea_default714"></a><a id="hevea_tactic156"></a>
<br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">cbn [</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">]</span><br>
 <span style="font-family:monospace">cbn -[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">]</span><p>These are respectively synonyms of <span style="font-family:monospace">cbn beta delta
[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">] iota zeta</span> and <span style="font-family:monospace">cbn beta delta
-[</span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace">] iota zeta</span> (see <a href="#vmcompute">8.7.1</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">simpl </span><span style="font-style:oblique">pattern</span><p>This applies <span style="font-family:monospace">simpl</span> only to the subterms matching <span style="font-style:oblique">pattern</span> in the
current goal.</p></li><li class="li-enumerate"><span style="font-family:monospace">simpl </span><span style="font-style:oblique">pattern</span><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub><p>This applies <span style="font-family:monospace">simpl</span> only to the <span style="font-style:oblique">num</span><sub>1</sub>, …, <span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub>
occurrences of the subterms matching <span style="font-style:oblique">pattern</span> in the current goal.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Too few occurrences</span></p></li><li class="li-enumerate"><span style="font-family:monospace">simpl </span><span style="font-style:oblique">qualid</span><br>
 <span style="font-family:monospace">simpl </span><span style="font-style:oblique">string</span><p>This applies <span style="font-family:monospace">simpl</span> only to the applicative subterms whose head
occurrence is the unfoldable constant <span style="font-style:oblique">qualid</span> (the constant can be
referred to by its notation using <span style="font-style:oblique">string</span> if such a notation
exists).</p></li><li class="li-enumerate"><span style="font-family:monospace">simpl </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub><br>
 <span style="font-family:monospace">simpl </span><span style="font-style:oblique">string</span><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub><br>

This applies <span style="font-family:monospace">simpl</span> only to the <span style="font-style:oblique">num</span><sub>1</sub>, …, <span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub>
applicative subterms whose head occurrence is <span style="font-style:oblique">qualid</span> (or
<span style="font-style:oblique">string</span>).</li></ol><blockquote class="quote">
<a id="hevea_default715"></a><a id="hevea_option57"></a>
<span style="font-family:monospace">Refolding Reduction</span>
</blockquote><p>
<em>Deprecated since 8.7</em></p><p>This option (off by default) controls the use of the refolding strategy
of <span style="font-family:monospace">cbn</span> while doing reductions in unification, type inference and
tactic applications. It can result in expensive unifications, as
refolding currently uses a potentially exponential heuristic.</p><blockquote class="quote">
<a id="hevea_default716"></a><a id="hevea_option58"></a>
<span style="font-family:monospace">Set Debug RAKAM</span>
</blockquote><p>
This option makes <span style="font-family:monospace">cbn</span> print various debugging information.
<span style="font-family:monospace">RAKAM</span> is the Refolding Algebraic Krivine Abstract Machine.</p>
<h3 id="sec405" class="subsection">8.7.5  <span style="font-family:monospace">unfold </span><span style="font-style:oblique">qualid</span></h3>
<p>
<a id="hevea_default717"></a><a id="hevea_tactic157"></a>
<a id="unfold"></a></p><p>This tactic applies to any goal. The argument <span style="font-style:oblique">qualid</span> must denote a
defined transparent constant or local definition (see Sections <a href="gallina.html#Basic-definitions">1.3.2</a> and <a href="vernacular.html#Transparent">6.10.2</a>). The tactic <span style="font-family:monospace">unfold</span> applies the δ rule to each occurrence of the constant
to which <span style="font-style:oblique">qualid</span> refers in the current goal and then replaces it
with its βι-normal form.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-style:oblique">qualid</span> <span style="font-family:monospace">does not denote an evaluable constant</span><a id="hevea_error113"></a></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">unfold </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> in </span><span style="font-style:oblique">ident</span>
<a id="hevea_default718"></a><a id="hevea_tactic158"></a><p>Replaces <span style="font-style:oblique">qualid</span> in hypothesis <span style="font-style:oblique">ident</span> with its definition
and replaces the hypothesis with its βι normal form.</p></li><li class="li-enumerate"><span style="font-family:monospace">unfold </span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace">, …, </span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">n</span></sub><p>Replaces <em>simultaneously</em> <span style="font-style:oblique">qualid</span><sub>1</sub>, …, <span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">n</span></sub>
with their definitions and replaces the current goal with its
βι normal form.</p></li><li class="li-enumerate"><span style="font-family:monospace">unfold </span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><sup>1</sup><span style="font-family:monospace">, …, </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub><sup>1</sup><span style="font-family:monospace">,
…, </span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><sup><span style="font-style:italic">n</span></sup><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">n</span></sup><p>The lists <span style="font-style:oblique">num</span><sub>1</sub><sup>1</sup>, …, <span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub><sup>1</sup> and <span style="font-style:oblique">num</span><sub>1</sub><sup><span style="font-style:italic">n</span></sup>, …,
<span style="font-style:oblique">num</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">n</span></sup> specify the occurrences of <span style="font-style:oblique">qualid</span><sub>1</sub>, …,
<span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">n</span></sub> to be unfolded. Occurrences are located from left to
right.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">bad occurrence number of </span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">i</span></sub></p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">i</span></sub> <span style="font-family:monospace">does not occur</span></p></li><li class="li-enumerate"><span style="font-family:monospace">unfold </span><span style="font-style:oblique">string</span><p>If <span style="font-style:oblique">string</span> denotes the discriminating symbol of a notation (e.g. <span style="font-family:monospace">"+"</span>) or an expression defining a notation (e.g. <code>"_ + _"</code>), and
this notation refers to an unfoldable constant, then the tactic
unfolds it.</p></li><li class="li-enumerate"><span style="font-family:monospace">unfold </span><span style="font-style:oblique">string</span><span style="font-family:monospace">%</span><span style="font-style:oblique">key</span><p>This is variant of <span style="font-family:monospace">unfold </span><span style="font-style:oblique">string</span> where <span style="font-style:oblique">string</span> gets its
interpretation from the scope bound to the delimiting key
<span style="font-style:oblique">key</span> instead of its default interpretation (see
Section <a href="syntax-extensions.html#scopechange">12.2.2</a>).</p></li><li class="li-enumerate"><span style="font-family:monospace">unfold </span><span style="font-style:oblique">qualid_or_string</span><sub>1</sub><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><sup>1</sup><span style="font-family:monospace">, …, </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub><sup>1</sup><span style="font-family:monospace">,
…, </span><span style="font-style:oblique">qualid_or_string</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><sup><span style="font-style:italic">n</span></sup><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">n</span></sup><p>This is the most general form, where <span style="font-style:oblique">qualid_or_string</span> is either a
<span style="font-style:oblique">qualid</span> or a <span style="font-style:oblique">string</span> referring to a notation.</p></li></ol>
<h3 id="sec406" class="subsection">8.7.6  <span style="font-family:monospace">fold </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default719"></a><a id="hevea_tactic159"></a></p><p>This tactic applies to any goal. The term <span style="font-style:oblique">term</span> is reduced using the <span style="font-family:monospace">red</span>
tactic. Every occurrence of the resulting term in the goal is then
replaced by <span style="font-style:oblique">term</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">fold</span> <span style="font-style:oblique">term</span><sub>1</sub> … <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><p>Equivalent to <span style="font-family:monospace">fold</span> <span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">;</span>…<span style="font-family:monospace">; fold</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>.
</p></li></ol>
<h3 id="sec407" class="subsection">8.7.7  <span style="font-family:monospace">pattern </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default720"></a><a id="hevea_tactic160"></a>
<a id="pattern"></a></p><p>This command applies to any goal. The argument <span style="font-style:oblique">term</span> must be a free
subterm of the current goal. The command <span style="font-family:monospace">pattern</span> performs
β-expansion (the inverse of β-reduction) of the current goal
(say <span style="font-family:monospace">T</span>) by
</p><ol class="enumerate" type=1><li class="li-enumerate">
replacing all occurrences of <span style="font-style:oblique">term</span> in <span style="font-family:monospace">T</span> with a fresh variable
</li><li class="li-enumerate">abstracting this variable
</li><li class="li-enumerate">applying the abstracted goal to <span style="font-style:oblique">term</span>
</li></ol><p>For instance, if the current goal <span style="font-style:italic">T</span> is expressible has φ(<span style="font-style:italic">t</span>)
where the notation captures all the instances of <span style="font-style:italic">t</span> in φ(<span style="font-style:italic">t</span>),
then <span style="font-family:monospace">pattern </span><span style="font-style:italic">t</span> transforms it into <span style="font-family:monospace">(fun x:</span><span style="font-style:italic">A</span><span style="font-family:monospace"> =&gt; </span>φ(<span style="font-family:monospace">x</span>)<span style="font-family:monospace">) </span><span style="font-style:italic">t</span>. This command can be used, for instance, when the tactic
<span style="font-family:monospace">apply</span> fails on matching.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">pattern </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span></sub><p>Only the occurrences <span style="font-style:oblique">num</span><sub>1</sub> … <span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span></sub> of <span style="font-style:oblique">term</span> are
considered for β-expansion. Occurrences are located from left
to right.</p></li><li class="li-enumerate"><span style="font-family:monospace">pattern </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> at - </span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span></sub><p>All occurrences except the occurrences of indexes <span style="font-style:oblique">num</span><sub>1</sub> …
 <span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span></sub> of <span style="font-style:oblique">term</span> are considered for
β-expansion. Occurrences are located from left to right.</p></li><li class="li-enumerate"><span style="font-family:monospace">pattern </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">, …, </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span></sub><p>Starting from a goal φ(<span style="font-style:italic">t</span><sub>1</sub> … <span style="font-style:italic">t</span><sub><span style="font-style:italic">m</span></sub>), the tactic
<span style="font-family:monospace">pattern </span><span style="font-style:italic">t</span><sub>1</sub><span style="font-family:monospace">, …, </span><span style="font-style:italic">t</span><sub><span style="font-style:italic">m</span></sub> generates the equivalent goal <span style="font-family:monospace">(fun (x</span><sub>1</sub><span style="font-family:monospace">:</span><span style="font-style:italic">A</span><sub>1</sub><span style="font-family:monospace">) … (x</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace">:</span><span style="font-style:italic">A</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace">) =&gt; </span>φ(<span style="font-family:monospace">x</span><sub>1</sub><span style="font-family:monospace">…
 x</span><sub><span style="font-style:italic">m</span></sub>)<span style="font-family:monospace">) </span><span style="font-style:italic">t</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:italic">t</span><sub><span style="font-style:italic">m</span></sub>. If <span style="font-style:italic">t</span><sub><span style="font-style:italic">i</span></sub> occurs in one of the
generated types <span style="font-style:italic">A</span><sub><span style="font-style:italic">j</span></sub> these occurrences will also be considered and
possibly abstracted.</p></li><li class="li-enumerate"><span style="font-family:monospace">pattern </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><sup>1</sup><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span><sub>1</sub></sub><sup>1</sup><span style="font-family:monospace">, …,
</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace"> at </span><span style="font-style:oblique">num</span><sub>1</sub><sup><span style="font-style:italic">m</span></sup><span style="font-family:monospace"> … </span><span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span><sub><span style="font-style:italic">m</span></sub></sub><sup><span style="font-style:italic">m</span></sup><p>This behaves as above but processing only the occurrences <span style="font-style:oblique">num</span><sub>1</sub><sup>1</sup>,
…, <span style="font-style:oblique">num</span><sub><span style="font-style:italic">i</span></sub><sup>1</sup> of <span style="font-style:oblique">term</span><sub>1</sub>, …, <span style="font-style:oblique">num</span><sub>1</sub><sup><span style="font-style:italic">m</span></sup>, …, <span style="font-style:oblique">num</span><sub><span style="font-style:italic">j</span></sub><sup><span style="font-style:italic">m</span></sup>
of <span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span></sub> starting from <span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span></sub>.</p></li><li class="li-enumerate"><span style="font-family:monospace">pattern</span> <span style="font-style:oblique">term</span><sub>1</sub> <span style="font-style:oblique">[</span><span style="font-family:monospace">at </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">-</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span> <span style="font-style:oblique">num</span><sub>1</sub><sup>1</sup> … <span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span><sub>1</sub></sub><sup>1</sup><span style="font-style:oblique">]</span> <span style="font-family:monospace">,</span> …<span style="font-family:monospace">,</span>
<span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:oblique">[</span><span style="font-family:monospace">at </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">-</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span> <span style="font-style:oblique">num</span><sub>1</sub><sup><span style="font-style:italic">m</span></sup> … <span style="font-style:oblique">num</span><sub><span style="font-style:italic">n</span><sub><span style="font-style:italic">m</span></sub></sub><sup><span style="font-style:italic">m</span></sup><span style="font-style:oblique">]</span><p>This is the most general syntax that combines the different variants.</p></li></ol>
<h3 id="sec408" class="subsection">8.7.8  Conversion tactics applied to hypotheses</h3>
<p><span style="font-style:oblique">conv_tactic</span> <span style="font-family:monospace">in</span> <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub></p><p>Applies the conversion tactic <span style="font-style:oblique">conv_tactic</span> to the
hypotheses <span style="font-style:oblique">ident</span><sub>1</sub>, …, <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>. The tactic <span style="font-style:oblique">conv_tactic</span> is
any of the conversion tactics listed in this section.</p><p>If <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub> is a local definition, then <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub> can be replaced
by (Type of <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>) to address not the body but the type of the
local definition. Example: <span style="font-family:monospace">unfold not in (Type of H1) (Type of H3).</span></p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">No such hypothesis</span><a id="hevea_error114"></a> : <span style="font-style:oblique">ident</span>.
</li></ol>
<h2 id="sec409" class="section">8.8  Automation</h2>
<h3 id="sec410" class="subsection">8.8.1  <span style="font-family:monospace">auto</span></h3>
<p>
<a id="auto"></a>
<a id="hevea_default721"></a><a id="hevea_tactic161"></a></p><p>This tactic implements a Prolog-like resolution procedure to solve the
current goal. It first tries to solve the goal using the <span style="font-family:monospace">assumption</span> tactic, then it reduces the goal to an atomic one using
<span style="font-family:monospace">intros</span> and introduces the newly generated hypotheses as hints.
Then it looks at the list of tactics associated to the head symbol of
the goal and tries to apply one of them (starting from the tactics
with lower cost). This process is recursively applied to the generated
subgoals.</p><p>By default, <span style="font-family:monospace">auto</span> only uses the hypotheses of the current goal and the
hints of the database named <span style="font-family:monospace">core</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">auto </span><span style="font-style:oblique">num</span><p>Forces the search depth to be <span style="font-style:oblique">num</span>. The maximal search depth is 5 by
default.</p></li><li class="li-enumerate"><span style="font-family:monospace">auto with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>Uses the hint databases <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> in addition to
the database <span style="font-family:monospace">core</span>. See Section <a href="#Hints-databases">8.9.1</a> for the
list of pre-defined databases and the way to create or extend a
database.</p></li><li class="li-enumerate"><span style="font-family:monospace">auto with *</span><p>Uses all existing hint databases. See Section <a href="#Hints-databases">8.9.1</a></p></li><li class="li-enumerate"><span style="font-family:monospace">auto using</span> <span style="font-style:oblique">lemma</span><sub>1</sub> <span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> <span style="font-style:oblique">lemma</span><sub><span style="font-style:italic">n</span></sub><p>Uses <span style="font-style:oblique">lemma</span><sub>1</sub>, …, <span style="font-style:oblique">lemma</span><sub><span style="font-style:italic">n</span></sub> in addition to
hints (can be combined with the <span style="font-family:monospace">with </span><span style="font-style:oblique">ident</span> option). If
<span style="font-style:italic">lemma</span><sub><span style="font-style:italic">i</span></sub> is an inductive type, it is the collection of its
constructors which is added as hints.</p></li><li class="li-enumerate"><span style="font-family:monospace">info_auto</span><p>Behaves like <span style="font-family:monospace">auto</span> but shows the tactics it uses to solve the goal.
This variant is very useful for getting a better understanding of automation,
or to know what lemmas/assumptions were used.</p></li><li class="li-enumerate"><span style="font-family:monospace">debug auto</span> Behaves like <span style="font-family:monospace">auto</span> but shows the tactics
it tries to solve the goal, including failing paths.</li><li class="li-enumerate"><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">info_</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace">auto </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">num</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span> <span style="font-style:oblique">[</span><span style="font-family:monospace">using</span> <span style="font-style:oblique">lemma</span><sub>1</sub>
<span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> <span style="font-style:oblique">lemma</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:oblique">]</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">with</span>
<span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:oblique">]</span><p>This is the most general form, combining the various options.</p></li><li class="li-enumerate"><span style="font-family:monospace">trivial</span><a id="hevea_default722"></a><a id="hevea_tactic162"></a><p>This tactic is a restriction of <span style="font-family:monospace">auto</span> that is not recursive and
tries only hints that cost 0. Typically it solves trivial
equalities like <span style="font-style:italic">X</span>=<span style="font-style:italic">X</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">trivial with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub></li><li class="li-enumerate"><span style="font-family:monospace">trivial with *</span></li><li class="li-enumerate"><span style="font-family:monospace">trivial using</span> <span style="font-style:oblique">lemma</span><sub>1</sub> <span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> <span style="font-style:oblique">lemma</span><sub><span style="font-style:italic">n</span></sub></li><li class="li-enumerate"><span style="font-family:monospace">info_trivial</span></li><li class="li-enumerate"><span style="font-family:monospace">debug trivial</span></li><li class="li-enumerate"><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">info_</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace">trivial</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">using</span> <span style="font-style:oblique">lemma</span><sub>1</sub>
<span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> <span style="font-style:oblique">lemma</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:oblique">]</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">with</span>
<span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:oblique">]</span></li></ol><p><br>
<span style="font-weight:bold">Remark: </span><span style="font-family:monospace">auto</span> either solves completely the goal or else leaves it
intact. <span style="font-family:monospace">auto</span> and <span style="font-family:monospace">trivial</span> never fail.</p><p><br>
<span style="font-weight:bold">Remark: </span>The following options enable printing of informative or debug
information for the <span style="font-family:monospace">auto</span> and <span style="font-family:monospace">trivial</span> tactics:
</p><blockquote class="quote">
<a id="hevea_default723"></a><a id="hevea_option59"></a>
<span style="font-family:monospace">Set Info Auto</span>
<a id="hevea_default724"></a><a id="hevea_option60"></a>
<span style="font-family:monospace">Set Debug Auto</span>
<a id="hevea_default725"></a><a id="hevea_option61"></a>
<span style="font-family:monospace">Set Info Trivial</span>
<a id="hevea_default726"></a><a id="hevea_option62"></a>
<span style="font-family:monospace">Set Debug Trivial</span>
</blockquote><p><br>
<span style="font-weight:bold">See also: </span>Section <a href="#Hints-databases">8.9.1</a></p>
<h3 id="sec411" class="subsection">8.8.2  <span style="font-family:monospace">eauto</span></h3>
<p>
<a id="hevea_default727"></a><a id="hevea_tactic163"></a>
<a id="eauto"></a></p><p>This tactic generalizes <span style="font-family:monospace">auto</span>. While <span style="font-family:monospace">auto</span> does not try
resolution hints which would leave existential variables in the goal,
<span style="font-family:monospace">eauto</span> does try them (informally speaking, it uses
<span style="font-family:monospace">simple eapply</span> where <span style="font-family:monospace">auto</span> uses <span style="font-family:monospace">simple apply</span>).
As a consequence, <span style="font-family:monospace">eauto</span> can solve such a goal:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Hint Resolve ex</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">intro.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">the hint: eapply ex</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">intro will only be used by eauto</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall P:nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop, P 0 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">  exists n, P n.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall P : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop, P 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> exists n : nat, P n</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> eauto.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><p>Note that <span style="font-family:monospace">ex_intro</span> should be declared as a hint.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">info_</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace">eauto </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">num</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span> <span style="font-style:oblique">[</span><span style="font-family:monospace">using</span> <span style="font-style:oblique">lemma</span><sub>1</sub>
<span style="font-family:monospace">,</span> … <span style="font-family:monospace">,</span> <span style="font-style:oblique">lemma</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:oblique">]</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">with</span>
<span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-style:oblique">]</span><p>The various options for eauto are the same as for auto.</p></li></ol><p><br>
<span style="font-weight:bold">Remark: </span><span style="font-family:monospace">eauto</span> obeys the following options:
</p><blockquote class="quote">
<a id="hevea_default728"></a><a id="hevea_option63"></a>
<span style="font-family:monospace">Set Info Eauto</span>
<a id="hevea_default729"></a><a id="hevea_option64"></a>
<span style="font-family:monospace">Set Debug Eauto</span>
</blockquote><p><br>
<span style="font-weight:bold">See also: </span>Section <a href="#Hints-databases">8.9.1</a></p>
<h3 id="sec412" class="subsection">8.8.3  <span style="font-family:monospace">autounfold with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub></h3>
<p>
<a id="hevea_default730"></a><a id="hevea_tactic164"></a>
<a id="autounfold"></a></p><p>This tactic unfolds constants that were declared through a <span style="font-family:monospace">Hint
Unfold</span> in the given databases.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">autounfold with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">clause</span><p>Performs the unfolding in the given clause.</p></li><li class="li-enumerate"><span style="font-family:monospace">autounfold with *</span><p>Uses the unfold hints declared in all the hint databases.
</p></li></ol>
<h3 id="sec413" class="subsection">8.8.4  <span style="font-family:monospace">autorewrite with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub></h3>
<p>
<a id="tactic:autorewrite"></a>
<a id="hevea_default731"></a><a id="hevea_tactic165"></a></p><p>This tactic <sup><a id="text15" href="#note15">4</a></sup> carries out rewritings according
the rewriting rule bases <span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>.</p><p>Each rewriting rule of a base <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub> is applied to the main subgoal until
it fails. Once all the rules have been processed, if the main subgoal has
progressed (e.g., if it is distinct from the initial main goal) then the rules
of this base are processed again. If the main subgoal has not progressed then
the next base is processed. For the bases, the behavior is exactly similar to
the processing of the rewriting rules.</p><p>The rewriting rule bases are built with the <span style="font-family:monospace">Hint Rewrite</span> vernacular
command.</p><p><br>
<span style="font-weight:bold">Warning: </span> This tactic may loop if you build non terminating rewriting systems.</p><p><br>
<span style="font-weight:bold">Variant: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">autorewrite with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">tactic</span><p>Performs, in the same way, all the rewritings of the bases <span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">
</span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> applying <span style="font-style:oblique">tactic</span> to the main subgoal after each
rewriting step.</p></li><li class="li-enumerate"><span style="font-family:monospace">autorewrite with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">qualid</span><p>Performs all the rewritings in hypothesis <span style="font-style:oblique">qualid</span>.
</p></li><li class="li-enumerate"><span style="font-family:monospace">autorewrite with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> using </span><span style="font-style:oblique">tactic</span><p>Performs all the rewritings in hypothesis <span style="font-style:oblique">qualid</span> applying <span style="font-style:oblique">tactic</span> to the main subgoal after each rewriting step.</p></li><li class="li-enumerate"><span style="font-family:monospace">autorewrite with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> in </span><span style="font-style:oblique">clause</span><p>Performs all the rewriting in the clause <span style="font-style:oblique">clause</span>.
The <span style="font-style:oblique">clause</span> argument must not contain any <span style="font-family:monospace">type of</span> nor <span style="font-family:monospace">value of</span>.</p></li></ol><p><br>
<span style="font-weight:bold">See also: </span>Section <a href="#HintRewrite">8.9.5</a> for feeding the database of lemmas used by <span style="font-family:monospace">autorewrite</span>.</p><p><br>
<span style="font-weight:bold">See also: </span>Section <a href="tactic-examples.html#autorewrite-example">10.2</a> for examples showing the use of
this tactic.</p>
<h3 id="sec414" class="subsection">8.8.5  <span style="font-family:monospace">easy</span></h3>
<p>
<a id="hevea_default732"></a><a id="hevea_tactic166"></a>
<a id="easy"></a></p><p>This tactic tries to solve the current goal by a number of standard closing steps.
In particular, it tries to close the current goal using the closing tactics
<span style="font-family:monospace">trivial</span>, reflexivity, symmetry, contradiction and inversion of hypothesis.
If this fails, it tries introducing variables and splitting and-hypotheses,
using the closing tactics afterwards, and splitting the goal using <span style="font-family:monospace">split</span> and recursing.</p><p>This tactic solves goals that belong to many common classes; in particular, many cases of
unsatisfiable hypotheses, and simple equality goals are usually solved by this tactic.</p><p><br>
<span style="font-weight:bold">Variant: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">now </span><span style="font-style:oblique">tactic</span>
<a id="hevea_default733"></a><a id="hevea_tactic167"></a><p>Run <span style="font-style:oblique">tactic</span> followed by easy. This is a notation for <span style="font-style:oblique">tactic</span><span style="font-family:monospace">; easy</span>.
</p></li></ol>
<h2 id="sec415" class="section">8.9  Controlling automation</h2>
<h3 id="sec416" class="subsection">8.9.1  The hints databases for <span style="font-family:monospace">auto</span> and <span style="font-family:monospace">eauto</span></h3>
<p>
<a id="hevea_default734"></a>
<a id="Hints-databases"></a>
<a id="hevea_default735"></a><a id="hevea_command186"></a></p><p>The hints for <span style="font-family:monospace">auto</span> and <span style="font-family:monospace">eauto</span> are stored in
databases. Each database maps head symbols to a list of hints. One can
use the command <span style="font-family:monospace">Print Hint </span><span style="font-style:oblique">ident</span> to display the hints
associated to the head symbol <span style="font-style:oblique">ident</span> (see <a href="#PrintHint">8.9.4</a>). Each
hint has a cost that is a nonnegative integer, and an optional pattern.
The hints with lower cost are tried first. A hint is tried by
<span style="font-family:monospace">auto</span> when the conclusion of the current goal
matches its pattern or when it has no pattern.</p><h4 id="CreateHintDb" class="subsubsection">Creating Hint databases
<a id="hevea_default736"></a><a id="hevea_command187"></a></h4>
<p>One can optionally declare a hint database using the command
<span style="font-family:monospace">Create HintDb</span>. If a hint is added to an unknown database, it
will be automatically created.</p><p><br>
<span style="font-family:monospace">Create HintDb</span> <span style="font-style:oblique">ident</span> [<span style="font-family:monospace">discriminated</span>]
<br>
</p><p>This command creates a new database named <span style="font-style:oblique">ident</span>.
The database is implemented by a Discrimination Tree (DT) that serves as
an index of all the lemmas. The DT can use transparency information to decide
if a constant should be indexed or not (c.f. <a href="#HintTransparency">8.9.1</a>),
making the retrieval more efficient.
The legacy implementation (the default one for new databases) uses the
DT only on goals without existentials (i.e., auto goals), for non-Immediate
hints and do not make use of transparency hints, putting more work on the
unification that is run after retrieval (it keeps a list of the lemmas
in case the DT is not used). The new implementation enabled by
the <span style="font-family:monospace">discriminated</span> option makes use of DTs in all cases and takes
transparency information into account. However, the order in which hints
are retrieved from the DT may differ from the order in which they were
inserted, making this implementation observationally different from the
legacy one.</p><p>The general
command to add a hint to some databases <span style="font-style:oblique">ident</span><sub>1</sub>, …, <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> is
</p><table style="border:0;border-spacing:0" class="cellpadding0"><tr><td style="text-align:left;white-space:nowrap" >
<span style="font-family:monospace">Hint </span><span style="font-style:oblique">hint_definition</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>
</td></tr>
</table><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Hint </span><span style="font-style:oblique">hint_definition</span><p>No database name is given: the hint is registered in the <span style="font-family:monospace">core</span>
database.</p></li><li class="li-enumerate"><span style="font-family:monospace">Local Hint </span><span style="font-style:oblique">hint_definition</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>This is used to declare hints that must not be exported to the other
modules that require and import the current module. Inside a
section, the option <span style="font-family:monospace">Local</span> is useless since hints do not
survive anyway to the closure of sections.</p></li><li class="li-enumerate"><span style="font-family:monospace">Local Hint </span><span style="font-style:oblique">hint_definition</span><p>Idem for the <span style="font-family:monospace">core</span> database.</p></li></ol><p>The <span style="font-style:oblique">hint_definition</span> is one of the following expressions:</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">Resolve </span><span style="font-style:oblique">term</span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-family:monospace">|</span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">num</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">pattern</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span>
<a id="hevea_default737"></a><a id="hevea_command188"></a><p>This command adds <span style="font-family:monospace">simple apply </span><span style="font-style:oblique">term</span> to the hint list
with the head symbol of the type of <span style="font-style:oblique">term</span>. The cost of that hint is
the number of subgoals generated by <span style="font-family:monospace">simple apply </span><span style="font-style:oblique">term</span> or <span style="font-style:oblique">num</span>if specified. The associated pattern is inferred from the conclusion
of the type of <span style="font-style:oblique">term</span>or the given <span style="font-style:oblique">pattern</span>if specified.
</p><p>In case the inferred type of <span style="font-style:oblique">term</span> does not start with a product
the tactic added in the hint list is <span style="font-family:monospace">exact </span><span style="font-style:oblique">term</span>.
In case
this type can however be reduced to a type starting with a product,
the tactic <span style="font-family:monospace">simple apply </span><span style="font-style:oblique">term</span> is also stored in the hints list.</p><p>If the inferred type of <span style="font-style:oblique">term</span> contains a dependent quantification
on a variable which occurs only in the premisses of the type and not
in its conclusion, no instance could be inferred for the variable by
unification with the goal. In this case, the hint is added to the
hint list of <span style="font-family:monospace">eauto</span> (see <a href="#eauto">8.8.2</a>) instead of the hint list
of <span style="font-family:monospace">auto</span> and a warning is printed. A typical example of a hint
that is used only by <span style="font-family:monospace">eauto</span> is a transitivity lemma.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-style:oblique">term</span> <span style="font-family:monospace">cannot be used as a hint</span><a id="hevea_error115"></a><p>The head symbol of the type of <span style="font-style:oblique">term</span> is a bound variable such
that this tactic cannot be associated to a constant.</p></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Resolve </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span></sub><p>Adds each <span style="font-family:monospace">Resolve</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">i</span></sub>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Resolve -&gt; </span><span style="font-style:oblique">term</span><p>Adds the left-to-right implication of an equivalence as a hint
(informally the hint will be used as <span style="font-family:monospace">apply &lt;- </span><span style="font-style:oblique">term</span>,
although as mentionned before, the tactic actually used is
a restricted version of apply).</p></li><li class="li-enumerate"><span style="font-family:monospace">Resolve &lt;- </span><span style="font-style:oblique">term</span><p>Adds the right-to-left implication of an equivalence as a hint.</p></li></ol></li><li class="li-itemize"><span style="font-family:monospace">Immediate </span><span style="font-style:oblique">term</span>
<a id="hevea_default738"></a><a id="hevea_command189"></a><p>This command adds <span style="font-family:monospace">simple apply </span><span style="font-style:oblique">term</span><span style="font-family:monospace">; trivial</span> to the hint list
associated with the head symbol of the type of <span style="font-style:oblique">ident</span> in the given
database. This tactic will fail if all the subgoals generated by
<span style="font-family:monospace">simple apply </span><span style="font-style:oblique">term</span> are not solved immediately by the <span style="font-family:monospace">trivial</span>
tactic (which only tries tactics with cost 0).</p><p>This command is useful for theorems such as the symmetry of equality
or <span style="font-style:italic">n</span>+1=<span style="font-style:italic">m</span>+1 → <span style="font-style:italic">n</span>=<span style="font-style:italic">m</span> that we may like to introduce with a
limited use in order to avoid useless proof-search.</p><p>The cost of this tactic (which never generates subgoals) is always 1,
so that it is not used by <span style="font-family:monospace">trivial</span> itself.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-style:oblique">term</span> <span style="font-family:monospace">cannot be used as a hint</span><a id="hevea_error116"></a></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Immediate </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">m</span></sub><p>Adds each <span style="font-family:monospace">Immediate</span> <span style="font-style:oblique">term</span><sub><span style="font-style:italic">i</span></sub>.</p></li></ol></li><li class="li-itemize"><span style="font-family:monospace">Constructors</span> <span style="font-style:oblique">ident</span>
<a id="hevea_default739"></a><a id="hevea_command190"></a><p>If <span style="font-style:oblique">ident</span> is an inductive type, this command adds all its
constructors as hints of type <span style="font-family:monospace">Resolve</span>. Then, when the
conclusion of current goal has the form <span style="font-family:monospace">(</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> …)</span>,
<span style="font-family:monospace">auto</span> will try to apply each constructor.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-style:oblique">ident</span> <span style="font-family:monospace">is not an inductive type</span><a id="hevea_error117"></a></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Constructors </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><p>Adds each <span style="font-family:monospace">Constructors</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>.</p></li></ol></li><li class="li-itemize"><span style="font-family:monospace">Unfold</span> <span style="font-style:oblique">qualid</span>
<a id="hevea_default740"></a><a id="hevea_command191"></a><p>This adds the tactic <span style="font-family:monospace">unfold </span><span style="font-style:oblique">qualid</span> to the hint list that
will only be used when the head constant of the goal is <span style="font-style:oblique">ident</span>. Its
cost is 4.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Unfold </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><p>Adds each <span style="font-family:monospace">Unfold</span> <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub>.</p></li></ol></li><li class="li-itemize"><span style="font-family:monospace">Transparent</span>, <span style="font-family:monospace">Opaque</span> <span style="font-style:oblique">qualid</span>
<a id="HintTransparency"></a>
<a id="hevea_default741"></a><a id="hevea_command192"></a>
<a id="hevea_default742"></a><a id="hevea_command193"></a><p>This adds a transparency hint to the database, making <span style="font-style:oblique">qualid</span>
a transparent or opaque constant during resolution. This information
is used during unification of the goal with any lemma in the database
and inside the discrimination network to relax or constrain it in the
case of <span style="font-family:monospace">discriminated</span> databases.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Transparent</span>, <span style="font-family:monospace">Opaque</span> <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><p>Declares each <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">i</span></sub> as a transparent or opaque constant.</p></li></ol></li><li class="li-itemize"><span style="font-family:monospace">Extern </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> [</span><span style="font-style:oblique">pattern</span><span style="font-family:monospace">] =&gt; </span><span style="font-style:oblique">tactic</span>
<a id="hevea_default743"></a><a id="hevea_command194"></a><p>This hint type is to extend <span style="font-family:monospace">auto</span> with tactics other than
<span style="font-family:monospace">apply</span> and <span style="font-family:monospace">unfold</span>. For that, we must specify a
cost, an optional pattern and a tactic to execute. Here is an example:</p><blockquote class="quotation">
<pre class="verbatim">Hint Extern 4 (~(_ = _)) =&gt; discriminate.
</pre></blockquote><p>Now, when the head of the goal is a disequality, <span style="font-family:monospace">auto</span> will
try <span style="font-family:monospace">discriminate</span> if it does not manage to solve the goal
with hints with a cost less than 4.</p><p>One can even use some sub-patterns of the pattern in the tactic
script. A sub-pattern is a question mark followed by an identifier, like
<span style="font-family:monospace">?X1</span> or <span style="font-family:monospace">?X2</span>. Here is an example:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import List.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Hint Extern 5   ({?X1 = ?X2} + {?X1 </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> ?X2}) =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">       generalize X1, X2; decide equality : eqdec.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      forall a b:list (nat * nat), {a = b} + {a </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> b}.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall a b : list (nat * nat), {a = b} + {a </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> b}</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Info 1 auto with eqdec.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ltac</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">plugin::auto@0</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> "eqdec"</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div></li><li class="li-itemize"><span style="font-family:monospace">Cut</span> <span style="font-style:italic">regexp</span>
<a id="HintCut"></a>
<a id="hevea_default744"></a><a id="hevea_command195"></a><p><span style="font-style:italic">Warning:</span> these hints currently only apply to typeclass proof search and
the <span style="font-family:monospace">typeclasses eauto</span> tactic (<a href="type-classes.html#typeclasseseauto">20.6.5</a>).</p><p>This command can be used to cut the proof-search tree according to a
regular expression matching paths to be cut. The grammar for regular
expressions is the following. Beware, there is no operator precedence
during parsing, one can check with <span style="font-family:monospace">Print HintDb</span> to verify the
current cut expression:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >  <span style="font-style:italic">e</span></td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:oblique">ident</span></td><td style="text-align:left;white-space:nowrap" > hint or instance identifier  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">_</span></td><td style="text-align:left;white-space:nowrap" > any hint  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">e</span> | <span style="font-style:italic">e</span>′</td><td style="text-align:left;white-space:nowrap" > disjunction  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">e</span> <span style="font-style:italic">e</span>′</td><td style="text-align:left;white-space:nowrap" > sequence  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">e</span> *</td><td style="text-align:left;white-space:nowrap" > Kleene star  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">emp</span></td><td style="text-align:left;white-space:nowrap" > empty  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">eps</span></td><td style="text-align:left;white-space:nowrap" > epsilon  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(</span> <span style="font-style:italic">e</span> <span style="font-family:monospace">)</span></td></tr>
</table></td></tr>
</table><p>The <span style="font-family:monospace">emp</span> regexp does not match any search path while
<span style="font-family:monospace">eps</span> matches the empty path. During proof search, the path of
successive successful hints on a search branch is recorded, as a list of
identifiers for the hints (note <span style="font-family:monospace">Hint Extern</span>’s do not have an
associated identifier). Before applying any hint <span style="font-style:oblique">ident</span> the current
path <span style="font-style:italic">p</span> extended with <span style="font-style:oblique">ident</span> is matched against the current cut
expression <span style="font-style:italic">c</span> associated to the hint database. If matching succeeds,
the hint is <em>not</em> applied. The semantics of <span style="font-family:monospace">Hint Cut</span> <span style="font-style:italic">e</span>
is to set the cut expression to <span style="font-style:italic">c</span> | <span style="font-style:italic">e</span>, the initial cut expression
being <span style="font-family:monospace">emp</span>.</p></li><li class="li-itemize"><span style="font-family:monospace">Mode</span> <span style="font-style:oblique">qualid</span> <span style="font-family:monospace">(+ | ! | -)</span><sup>*</sup>
<a id="HintMode"></a>
<a id="hevea_default745"></a><a id="hevea_command196"></a><p>This sets an optional mode of use of the identifier <span style="font-style:oblique">qualid</span>. When
proof-search faces a goal that ends in an application of <span style="font-style:oblique">qualid</span> to
arguments <span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>, the mode tells if the
hints associated to qualid can be applied or not. A mode specification
is a list of <span style="font-style:italic">n</span> <span style="font-family:monospace">+</span>, <span style="font-family:monospace">!</span> or <span style="font-family:monospace">-</span> items that specify if an
argument of the identifier is to be treated as an input (<span style="font-family:monospace">+</span>), if
its head only is an input (<span style="font-family:monospace">!</span>) or an output (<span style="font-family:monospace">-</span>) of the
identifier. For a mode to match a list of arguments, input terms and
input heads <em>must not</em> contain existential variables or be
existential variables respectively, while outputs can be any
term. Multiple modes can be declared for a single identifier, in that
case only one mode needs to match the arguments for the hints to be
applied.</p><p>The head of a term is understood here as the applicative head, or the
match or projection scrutinee’s head, recursively, casts being ignored.</p><p><span style="font-family:monospace">Hint Mode</span> is especially useful for typeclasses, when one does not
want to support default instances and avoid ambiguity in
general. Setting a parameter of a class as an input forces proof-search
to be driven by that index of the class, with <span style="font-family:monospace">!</span> giving more
flexibility by allowing existentials to still appear deeper in the index
but not at its head.</p></li></ul><p><br>
<span style="font-weight:bold">Remark: </span>One can use an <span style="font-family:monospace">Extern</span> hint with no pattern to do
pattern-matching on hypotheses using <span style="font-family:monospace">match goal with</span> inside
the tactic.</p>
<h3 id="sec418" class="subsection">8.9.2  Hint databases defined in the <span style="font-variant:small-caps">Coq</span> standard library</h3>
<p>Several hint databases are defined in the <span style="font-variant:small-caps">Coq</span> standard library. The
actual content of a database is the collection of the hints declared
to belong to this database in each of the various modules currently
loaded. Especially, requiring new modules potentially extend a
database. At <span style="font-variant:small-caps">Coq</span> startup, only the <span style="font-family:monospace">core</span> database is non empty
and can be used.</p><dl class="description"><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:monospace">core</span></span></dt><dd class="dd-description"> This special database is automatically used by
<span style="font-family:monospace">auto</span>, except when pseudo-database <span style="font-family:monospace">nocore</span> is
given to <span style="font-family:monospace">auto</span>. The <span style="font-family:monospace">core</span> database contains
only basic lemmas about negation,
conjunction, and so on from. Most of the hints in this database come
from the <span style="font-family:monospace">Init</span> and <span style="font-family:monospace">Logic</span> directories.</dd><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:monospace">arith</span></span></dt><dd class="dd-description"> This database contains all lemmas about Peano’s
arithmetic proved in the directories <span style="font-family:monospace">Init</span> and
<span style="font-family:monospace">Arith</span></dd><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:monospace">zarith</span></span></dt><dd class="dd-description"> contains lemmas about binary signed integers from
the directories <span style="font-family:monospace">theories/ZArith</span>. When required, the module
<span style="font-family:monospace">Omega</span> also extends the database <span style="font-family:monospace">zarith</span> with a high-cost
hint that calls <span style="font-family:monospace">omega</span> on equations and inequalities in <span style="font-family:monospace">nat</span> or <span style="font-family:monospace">Z</span>.</dd><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:monospace">bool</span></span></dt><dd class="dd-description"> contains lemmas about booleans, mostly from directory
<span style="font-family:monospace">theories/Bool</span>.</dd><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:monospace">datatypes</span></span></dt><dd class="dd-description"> is for lemmas about lists, streams and so on that
are mainly proved in the <span style="font-family:monospace">Lists</span> subdirectory.</dd><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:monospace">sets</span></span></dt><dd class="dd-description"> contains lemmas about sets and relations from the
directories <span style="font-family:monospace">Sets</span> and <span style="font-family:monospace">Relations</span>.</dd><dt class="dt-description"><span style="font-weight:bold"><span style="font-family:monospace">typeclass_instances</span></span></dt><dd class="dd-description"> contains all the type class instances
declared in the environment, including those used for <span style="font-family:monospace">setoid_rewrite</span>,
from the <span style="font-family:monospace">Classes</span> directory.
</dd></dl><p>You are advised not to put your own hints in the <span style="font-family:monospace">core</span> database,
but use one or several databases specific to your development.</p>
<h3 id="sec419" class="subsection">8.9.3  <span style="font-family:monospace">Remove Hints </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> :  </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace">
</span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub></h3>
<p>
<a id="RemoveHints"></a>
<a id="hevea_default746"></a><a id="hevea_command197"></a></p><p>This command removes the hints associated to terms <span style="font-style:oblique">term</span><sub>1</sub> …
<span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> in databases <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub>.</p>
<h3 id="sec420" class="subsection">8.9.4  <span style="font-family:monospace">Print Hint</span></h3>
<p>
<a id="PrintHint"></a>
<a id="hevea_default747"></a><a id="hevea_command198"></a></p><p>This command displays all hints that apply to the current goal. It
fails if no proof is being edited, while the two variants can be used at
every moment.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Print Hint </span><span style="font-style:oblique">ident</span><p>This command displays only tactics associated with <span style="font-style:oblique">ident</span> in the
hints list. This is independent of the goal being edited, so this
command will not fail if no goal is being edited.</p></li><li class="li-enumerate"><span style="font-family:monospace">Print Hint *</span><p>This command displays all declared hints.</p></li><li class="li-enumerate"><span style="font-family:monospace">Print HintDb </span><span style="font-style:oblique">ident</span>
<a id="PrintHintDb"></a>
<a id="hevea_default748"></a><a id="hevea_command199"></a><p>This command displays all hints from database <span style="font-style:oblique">ident</span>.</p></li></ol>
<h3 id="sec421" class="subsection">8.9.5  <span style="font-family:monospace">Hint Rewrite </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> :  </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub></h3>
<p>
<a id="HintRewrite"></a>
<a id="hevea_default749"></a><a id="hevea_command200"></a></p><p>This vernacular command adds the terms <span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>
(their types must be equalities) in the rewriting bases <span style="font-style:oblique">ident</span><sub>1</sub>, …, <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub>
with the default orientation (left to right). Notice that the
rewriting bases are distinct from the <span style="font-family:monospace">auto</span> hint bases and that
<span style="font-family:monospace">auto</span> does not take them into account.</p><p>This command is synchronous with the section mechanism (see <a href="gallina-ext.html#Section">2.4</a>):
when closing a section, all aliases created by <span style="font-family:monospace">Hint Rewrite</span> in that
section are lost. Conversely, when loading a module, all <span style="font-family:monospace">Hint Rewrite</span>
declarations at the global level of that module are loaded.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Hint Rewrite -&gt; </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> : </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><p>This is strictly equivalent to the command above (we only make explicit the
orientation which otherwise defaults to <span style="font-family:monospace">-&gt;</span>).</p></li><li class="li-enumerate"><span style="font-family:monospace">Hint Rewrite &lt;- </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> : </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><p>Adds the rewriting rules <span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> with a right-to-left
orientation in the bases <span style="font-style:oblique">ident</span><sub>1</sub>, …, <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub>.</p></li><li class="li-enumerate"><span style="font-family:monospace">Hint Rewrite </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> using </span><span style="font-style:oblique">tactic</span><span style="font-family:monospace"> : </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub><p>When the rewriting rules <span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> in <span style="font-style:oblique">ident</span><sub>1</sub>, …, <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">m</span></sub> will
be used, the tactic <span style="font-style:oblique">tactic</span> will be applied to the generated subgoals, the
main subgoal excluded.</p></li><li class="li-enumerate"><span style="font-family:monospace">Print Rewrite HintDb </span><span style="font-style:oblique">ident</span><p>This command displays all rewrite hints contained in <span style="font-style:oblique">ident</span>.</p></li></ol>
<h3 id="Hint-Locality" class="subsection">8.9.6  Hint locality
</h3>
<p>
<a id="hevea_default750"></a><a id="hevea_option65"></a></p><p>Hints provided by the <span style="font-family:monospace">Hint</span> commands are erased when closing a
section. Conversely, all hints of a module <span style="font-family:monospace">A</span> that are not
defined inside a section (and not defined with option <span style="font-family:monospace">Local</span>) become
available when the module <span style="font-family:monospace">A</span> is imported (using
e.g. <span style="font-family:monospace">Require Import A.</span>).</p><p>As of today, hints only have a binary behavior regarding locality, as described
above: either they disappear at the end of a section scope, or they remain
global forever. This causes a scalability issue, because hints coming from an
unrelated part of the code may badly influence another development. It can be
mitigated to some extent thanks to the <span style="font-family:monospace">Remove Hints</span> command
(see  <a href="#RemoveHints">8.9.3</a>), but this is a mere workaround and has some
limitations (for instance, external hints cannot be removed).</p><p>A proper way to fix this issue is to bind the hints to their module scope, as
for most of the other objects Coq uses. Hints should only made available when
the module they are defined in is imported, not just required. It is very
difficult to change the historical behavior, as it would break a lot of scripts.
We propose a smooth transitional path by providing the <span style="font-family:monospace">Loose Hint Behavior</span>
option which accepts three flags allowing for a fine-grained handling of
non-imported hints.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Set Loose Hint Behavior "Lax"</span><p>This is the default, and corresponds to the historical behavior, that is,
hints defined outside of a section have a global scope.</p></li><li class="li-enumerate"><span style="font-family:monospace">Set Loose Hint Behavior "Warn"</span><p>When set, it outputs a warning when a non-imported hint is used. Note that
this is an over-approximation, because a hint may be triggered by a run that
will eventually fail and backtrack, resulting in the hint not being actually
useful for the proof.</p></li><li class="li-enumerate"><span style="font-family:monospace">Set Loose Hint Behavior "Strict"</span><p>When set, it changes the behavior of an unloaded hint to a immediate fail
tactic, allowing to emulate an import-scoped hint mechanism.</p></li></ol>
<h3 id="sec423" class="subsection">8.9.7  Setting implicit automation tactics</h3>
<h4 id="sec424" class="subsubsection"><span style="font-family:monospace">Proof with </span><span style="font-style:oblique">tactic</span></h4>
<p>
<a id="ProofWith"></a>
<a id="hevea_default751"></a><a id="hevea_command201"></a></p><p>This command may be used to start a proof. It defines a default
tactic to be used each time a tactic command <span style="font-style:oblique">tactic</span><sub>1</sub> is ended by
“<code>...</code>”. In this case the tactic command typed by the user is
equivalent to <span style="font-style:oblique">tactic</span><sub>1</sub>;<span style="font-style:oblique">tactic</span>.</p><p><br>
<span style="font-weight:bold">See also: </span><span style="font-family:monospace">Proof.</span> in Section <a href="proof-handling.html#BeginProof">7.1.4</a>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">Proof with </span><span style="font-style:oblique">tactic</span><span style="font-family:monospace"> using </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>Combines in a single line <span style="font-family:monospace">Proof with</span> and <span style="font-family:monospace">Proof using</span>,
see <a href="proof-handling.html#ProofUsing">7.1.5</a></p></li><li class="li-enumerate"><span style="font-family:monospace">Proof using </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">tactic</span><p>Combines in a single line <span style="font-family:monospace">Proof with</span> and <span style="font-family:monospace">Proof using</span>,
see <a href="proof-handling.html#ProofUsing">7.1.5</a></p></li></ol>
<h4 id="sec425" class="subsubsection"><span style="font-family:monospace">Declare Implicit Tactic </span><span style="font-style:oblique">tactic</span></h4>
<p><a id="DeclareImplicit"></a>
<a id="hevea_default752"></a><a id="hevea_command202"></a></p><p>This command declares a tactic to be used to solve implicit arguments
that <span style="font-variant:small-caps">Coq</span> does not know how to solve by unification. It is used
every time the term argument of a tactic has one of its holes not
fully resolved.</p><p>Here is an example:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Parameter quo : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forall n:nat, n</span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">0 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> nat.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">quo is declared</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Notation "x // y" := (quo x y </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">) (at level 40).</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Declare Implicit Tactic assumption.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall n m, m</span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">0 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> { q:nat &amp; { r | q * m + r = n } }.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall n m : nat, m </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> {q : nat &amp; {r : nat | q * m + r = n}}</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n, m : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : m </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  {q : nat &amp; {r : nat | q * m + r = n}}</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> exists (n // m).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  n, m : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : m </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  {r : nat | n // m * m + r = n}</span></span></span><span style="font-size:small"><br>
</span></div><p>The tactic <span style="font-family:monospace">exists (n // m)</span> did not fail. The hole was solved by
<span style="font-family:monospace">assumption</span> so that it behaved as <span style="font-family:monospace">exists (quo n m H)</span>.</p>
<h2 id="sec426" class="section">8.10  Decision procedures</h2>
<h3 id="sec427" class="subsection">8.10.1  <span style="font-family:monospace">tauto</span></h3>
<p>
<a id="hevea_default753"></a><a id="hevea_tactic168"></a>
<a id="hevea_default754"></a><a id="hevea_tactic169"></a>
<a id="tauto"></a></p><p>This tactic implements a decision procedure for intuitionistic propositional
calculus based on the contraction-free sequent calculi LJT* of Roy Dyckhoff
[<a href="biblio.html#Dyc92">56</a>]. Note that <span style="font-family:monospace">tauto</span> succeeds on any instance of an
intuitionistic tautological proposition. <span style="font-family:monospace">tauto</span> unfolds negations
and logical equivalence but does not unfold any other definition.</p><p>The following goal can be proved by <span style="font-family:monospace">tauto</span> whereas <span style="font-family:monospace">auto</span>
would fail:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall (x:nat) (P:nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop), x = 0 </span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace">/ P x -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> x </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 0 -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> P x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall (x : nat) (P : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop), x = 0 </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">/ P x -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> x </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0 -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   intros.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x : nat</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : x = 0 </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">/ P x</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : x </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   tauto.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><p>Moreover, if it has nothing else to do, <span style="font-family:monospace">tauto</span> performs
introductions. Therefore, the use of <span style="font-family:monospace">intros</span> in the previous
proof is unnecessary. <span style="font-family:monospace">tauto</span> can for instance prove the
following:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> (* auto would fail *)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      Goal forall (A:Prop) (P:nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop),</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          A </span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace">/ (forall x:nat, </span></span><span style="font-size:small"><span style="font-family:monospace">~</span></span><span style="font-size:small"><span style="font-family:monospace"> A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> P x) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forall x:nat, </span></span><span style="font-size:small"><span style="font-family:monospace">~</span></span><span style="font-size:small"><span style="font-family:monospace"> A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> P x.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall (A : Prop) (P : nat -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Prop),</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  A </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">/ (forall x : nat, </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">~</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P x) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> forall x : nat, </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">~</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P x</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   tauto.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Remark: </span>In contrast, <span style="font-family:monospace">tauto</span> cannot solve the following goal</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall (A:Prop) (P:nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop),</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          A </span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace">/ (forall x:nat, </span></span><span style="font-size:small"><span style="font-family:monospace">~</span></span><span style="font-size:small"><span style="font-family:monospace"> A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> P x) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> forall x:nat, </span></span><span style="font-size:small"><span style="font-family:monospace">~</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">~</span></span><span style="font-size:small"><span style="font-family:monospace"> (A </span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace">/ P x).</span></span><span style="font-size:small"><br>
</span></div><p>because <code>(forall x:nat, ~ A -&gt; P x)</code> cannot be treated as atomic and an
instantiation of <code>x</code> is necessary.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">dtauto</span><p>While <span style="font-family:monospace">tauto</span> recognizes inductively defined connectives
isomorphic to the standard connective <span style="font-family:monospace">and</span>, <span style="font-family:monospace">prod</span>, <span style="font-family:monospace">or</span>, <span style="font-family:monospace">sum</span>, <span style="font-family:monospace">False</span>, <span style="font-family:monospace">Empty_set</span>, <span style="font-family:monospace">unit</span>, <span style="font-family:monospace">True</span>, <span style="font-family:monospace">dtauto</span> recognizes also all inductive types with
one constructors and no indices, i.e. record-style connectives.</p></li></ol>
<h3 id="sec428" class="subsection">8.10.2  <span style="font-family:monospace">intuition </span><span style="font-style:oblique">tactic</span></h3>
<p>
<a id="hevea_default755"></a><a id="hevea_tactic170"></a>
<a id="hevea_default756"></a><a id="hevea_tactic171"></a>
<a id="intuition"></a></p><p>The tactic <span style="font-family:monospace">intuition</span> takes advantage of the search-tree built
by the decision procedure involved in the tactic <span style="font-family:monospace">tauto</span>. It uses
this information to generate a set of subgoals equivalent to the
original one (but simpler than it) and applies the tactic
<span style="font-style:oblique">tactic</span> to them [<a href="biblio.html#Mun94">113</a>]. If this tactic fails on some goals then
<span style="font-family:monospace">intuition</span> fails. In fact, <span style="font-family:monospace">tauto</span> is simply <span style="font-family:monospace">intuition
fail</span>.</p><p>For instance, the tactic <span style="font-family:monospace">intuition auto</span> applied to the goal
</p><pre class="verbatim">(forall (x:nat), P x)/\B -&gt; (forall (y:nat),P y)/\ P O \/B/\ P O
</pre><p>internally replaces it by the equivalent one:
</p><pre class="verbatim">(forall (x:nat), P x), B |- P O
</pre><p>and then uses <span style="font-family:monospace">auto</span> which completes the proof.</p><p>Originally due to César Muñoz, these tactics (<span style="font-family:monospace">tauto</span> and <span style="font-family:monospace">intuition</span>)
have been completely re-engineered by David Delahaye using mainly the tactic
language (see Chapter <a href="ltac.html#TacticLanguage">9</a>). The code is now much shorter and
a significant increase in performance has been noticed. The general behavior
with respect to dependent types, unfolding and introductions has
slightly changed to get clearer semantics. This may lead to some
incompatibilities.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">intuition</span><p>Is equivalent to <span style="font-family:monospace">intuition auto with *</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">dintuition</span><p>While <span style="font-family:monospace">intuition</span> recognizes inductively defined connectives
isomorphic to the standard connective <span style="font-family:monospace">and</span>, <span style="font-family:monospace">prod</span>, <span style="font-family:monospace">or</span>, <span style="font-family:monospace">sum</span>, <span style="font-family:monospace">False</span>, <span style="font-family:monospace">Empty_set</span>, <span style="font-family:monospace">unit</span>, <span style="font-family:monospace">True</span>, <span style="font-family:monospace">dintuition</span> recognizes also all inductive types with
one constructors and no indices, i.e. record-style connectives.</p></li></ol><p><a id="hevea_default757"></a><a id="hevea_option66"></a>
<a id="hevea_default758"></a><a id="hevea_option67"></a></p><p>Some aspects of the tactic <span style="font-family:monospace">intuition</span> can be
controlled using options. To avoid that inner negations which do not
need to be unfolded are unfolded, use:</p><blockquote class="quote">
<span style="font-family:monospace">Unset Intuition Negation Unfolding</span>
</blockquote><p>To do that all negations of the goal are unfolded even inner ones
(this is the default), use:</p><blockquote class="quote">
<span style="font-family:monospace">Set Intuition Negation Unfolding</span>
</blockquote><p>To avoid that inner occurrence of <span style="font-family:monospace">iff</span> which do not need to be
unfolded are unfolded (this is the default), use:</p><blockquote class="quote">
<span style="font-family:monospace">Unset Intuition Iff Unfolding</span>
</blockquote><p>To do that all negations of the goal are unfolded even inner ones
(this is the default), use:</p><blockquote class="quote">
<span style="font-family:monospace">Set Intuition Iff Unfolding</span>
</blockquote>
<h3 id="sec429" class="subsection">8.10.3  <span style="font-family:monospace">rtauto</span></h3>
<p>
<a id="hevea_default759"></a><a id="hevea_tactic172"></a>
<a id="rtauto"></a></p><p>The <span style="font-family:monospace">rtauto</span> tactic solves propositional tautologies similarly to what <span style="font-family:monospace">tauto</span> does. The main difference is that the proof term is built using a reflection scheme applied to a sequent calculus proof of the goal. The search procedure is also implemented using a different technique.</p><p>Users should be aware that this difference may result in faster proof-search but slower proof-checking, and <span style="font-family:monospace">rtauto</span> might not solve goals that <span style="font-family:monospace">tauto</span> would be able to solve (e.g. goals involving universal quantifiers).</p>
<h3 id="sec430" class="subsection">8.10.4  <span style="font-family:monospace">firstorder</span></h3>
<p>
<a id="hevea_default760"></a><a id="hevea_tactic173"></a>
<a id="firstorder"></a></p><p>The tactic <span style="font-family:monospace">firstorder</span> is an <span style="font-style:italic">experimental</span> extension of
<span style="font-family:monospace">tauto</span> to
first-order reasoning, written by Pierre Corbineau.
It is not restricted to usual logical connectives but
instead may reason about any first-order class inductive definition.</p><p>The default tactic used by <span style="font-family:monospace">firstorder</span> when no rule applies is <span style="font-family:monospace">auto with *</span>, it can be reset locally or globally using the <span style="font-family:monospace">Set Firstorder Solver </span><span style="font-style:oblique">tactic</span> <a id="hevea_default761"></a><a id="hevea_option68"></a>
vernacular command and printed using <span style="font-family:monospace">Print Firstorder
Solver</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">firstorder </span><span style="font-style:oblique">tactic</span>
<a id="hevea_default762"></a><a id="hevea_tactic174"></a><p>Tries to solve the goal with <span style="font-style:oblique">tactic</span> when no logical rule may apply.</p></li><li class="li-enumerate"><span style="font-family:monospace">firstorder using </span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace"> , … , </span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span>
<a id="hevea_default763"></a><a id="hevea_tactic175"></a><p>Adds lemmas <span style="font-style:oblique">qualid</span><sub>1</sub> … <span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">n</span></sub> to the proof-search
environment. If <span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">i</span></sub> refers to an inductive type, it is
the collection of its constructors which are added to the
proof-search environment.</p></li><li class="li-enumerate"><span style="font-family:monospace">firstorder with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> </span>
<a id="hevea_default764"></a><a id="hevea_tactic176"></a><p>Adds lemmas from <span style="font-family:monospace">auto</span> hint bases <span style="font-style:oblique">ident</span><sub>1</sub> … <span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>
to the proof-search environment.</p></li><li class="li-enumerate"><span style="font-family:monospace">firstorder </span><span style="font-style:oblique">tactic</span><span style="font-family:monospace"> using </span><span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace"> , … , </span><span style="font-style:oblique">qualid</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><p>This combines the effects of the different variants of <span style="font-family:monospace">firstorder</span>.</p></li></ol><p>Proof-search is bounded by a depth parameter which can be set by typing the
<span style="font-family:monospace">Set Firstorder Depth </span><span style="font-style:italic">n</span> <a id="hevea_default765"></a><a id="hevea_option69"></a>
vernacular command.</p>
<h3 id="sec431" class="subsection">8.10.5  <span style="font-family:monospace">congruence</span></h3>
<p>
<a id="hevea_default766"></a><a id="hevea_tactic177"></a>
<a id="congruence"></a></p><p>The tactic <span style="font-family:monospace">congruence</span>, by Pierre Corbineau, implements the standard Nelson and Oppen
congruence closure algorithm, which is a decision procedure for ground
equalities with uninterpreted symbols. It also include the constructor theory
(see <a href="#injection">8.5.7</a> and <a href="#discriminate">8.5.6</a>).
If the goal is a non-quantified equality, <span style="font-family:monospace">congruence</span> tries to
prove it with non-quantified equalities in the context. Otherwise it
tries to infer a discriminable equality from those in the context. Alternatively, congruence tries to prove that a hypothesis is equal to the goal or to the negation of another hypothesis.</p><p><span style="font-family:monospace">congruence</span> is also able to take advantage of hypotheses stating quantified equalities, you have to provide a bound for the number of extra equalities generated that way. Please note that one of the members of the equality must contain all the quantified variables in order for <span style="font-family:monospace">congruence</span> to match against it.</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Theorem T:</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        a=(f a) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> (g b (f a))=(f (f a)) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> (g a b)=(f (g b a)) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> (g a b)=a.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  a = f a -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> g b (f a) = f (f a) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> g a b = f (g b a) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> g a b = a</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : a = f a</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : g b (f a) = f (f a)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H1 : g a b = f (g b a)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  g a b = a</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> congruence.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Theorem inj : f = pair a -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Some (f c) = Some (f d) -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> c=d.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  f = pair a -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> Some (f c) = Some (f d) -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> c = d</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : f = pair a</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H0 : Some (f c) = Some (f d)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  c = d</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> congruence.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">congruence </span><span style="font-family:monospace"><span style="font-style:oblique">n</span></span><p>Tries to add at most <span style="font-family:monospace"><span style="font-style:oblique">n</span></span> instances of hypotheses stating quantified equalities to the problem in order to solve it. A bigger value of <span style="font-family:monospace"><span style="font-style:oblique">n</span></span> does not make success slower, only failure. You might consider adding some lemmas as hypotheses using <span style="font-family:monospace">assert</span> in order for congruence to use them.</p></li><li class="li-enumerate"><span style="font-family:monospace">congruence with </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><p>Adds <span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> to the pool of terms used by
<span style="font-family:monospace">congruence</span>. This helps in case you have partially applied
constructors in your goal.
</p></li></ol><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">I don’t know how to handle dependent equality</span><a id="hevea_error118"></a><p>The decision procedure managed to find a proof of the goal or of
a discriminable equality but this proof could not be built in <span style="font-variant:small-caps">Coq</span>
because of dependently-typed functions.</p></li><li class="li-enumerate"><span style="font-family:monospace">Goal is solvable by congruence but some arguments are missing. Try "congruence with …", replacing metavariables by arbitrary terms.</span><a id="hevea_error119"></a><p>The decision procedure could solve the goal with the provision
that additional arguments are supplied for some partially applied
constructors. Any term of an appropriate type will allow the
tactic to successfully solve the goal. Those additional arguments
can be given to <span style="font-family:monospace">congruence</span> by filling in the holes in the
terms given in the error message, using the <span style="font-family:monospace">with</span> variant
described above.
</p></li></ol><p><span style="font-weight:bold">Remark: </span> <span style="font-family:monospace">congruence</span> can be made to print debug
information by setting the following option:</p><blockquote class="quote">
<a id="hevea_default767"></a><a id="hevea_option70"></a>
<span style="font-family:monospace">Set Congruence Verbose</span>
</blockquote>
<h2 id="sec432" class="section">8.11  Checking properties of terms</h2>
<p>Each of the following tactics acts as the identity if the check succeeds, and results in an error otherwise.</p>
<h3 id="sec433" class="subsection">8.11.1  <span style="font-family:monospace">constr_eq </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>2</sub></h3>
<p>
<a id="hevea_default768"></a><a id="hevea_tactic178"></a>
<a id="constreq"></a></p><p>This tactic checks whether its arguments are equal modulo alpha conversion and casts.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Not equal</span><a id="hevea_error120"></a></p>
<h3 id="sec434" class="subsection">8.11.2  <span style="font-family:monospace">unify </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>2</sub></h3>
<p>
<a id="hevea_default769"></a><a id="hevea_tactic179"></a>
<a id="unify"></a></p><p>This tactic checks whether its arguments are unifiable, potentially
instantiating existential variables.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Not unifiable</span><a id="hevea_error121"></a></p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">unify </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>2</sub><span style="font-family:monospace"> with </span><span style="font-style:oblique">ident</span><p>Unification takes the transparency information defined in the
hint database <span style="font-style:oblique">ident</span> into account (see Section <a href="#HintTransparency">8.9.1</a>).
</p></li></ol>
<h3 id="sec435" class="subsection">8.11.3  <span style="font-family:monospace">is_evar </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default770"></a><a id="hevea_tactic180"></a>
<a id="isevar"></a></p><p>This tactic checks whether its argument is a current existential
variable. Existential variables are uninstantiated variables generated
by <span style="font-family:monospace">eapply</span> (see Section <a href="#apply">8.2.4</a>) and some other tactics.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Not an evar</span><a id="hevea_error122"></a></p>
<h3 id="sec436" class="subsection">8.11.4  <span style="font-family:monospace">has_evar </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default771"></a><a id="hevea_tactic181"></a>
<a id="hasevar"></a></p><p>This tactic checks whether its argument has an existential variable as
a subterm. Unlike <span style="font-family:monospace">context</span> patterns combined with <span style="font-family:monospace">is_evar</span>,
this tactic scans all subterms, including those under binders.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">No evars</span><a id="hevea_error123"></a></p>
<h3 id="sec437" class="subsection">8.11.5  <span style="font-family:monospace">is_var </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default772"></a><a id="hevea_tactic182"></a>
<a id="isvar"></a></p><p>This tactic checks whether its argument is a variable or hypothesis in the
current goal context or in the opened sections.</p><p><br>
<span style="font-weight:bold">Error message: </span><span style="font-family:monospace">Not a variable or hypothesis</span><a id="hevea_error124"></a></p>
<h2 id="sec438" class="section">8.12  Equality</h2>
<h3 id="sec439" class="subsection">8.12.1  <span style="font-family:monospace">f_equal</span></h3>
<p>
<a id="f-equal"></a>
<a id="hevea_default773"></a><a id="hevea_tactic183"></a></p><p>This tactic applies to a goal of the form <span style="font-style:italic">f</span> <span style="font-style:italic">a</span><sub>1</sub> … <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> = <span style="font-style:italic">f</span>′
<span style="font-style:italic">a</span>′<sub>1</sub> … <span style="font-style:italic">a</span>′<sub><span style="font-style:italic">n</span></sub>. Using <span style="font-family:monospace">f_equal</span> on such a goal leads to
subgoals <span style="font-style:italic">f</span>=<span style="font-style:italic">f</span>′ and <span style="font-style:italic">a</span><sub>1</sub>=<span style="font-style:italic">a</span>′<sub>1</sub> and so on up to <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>=<span style="font-style:italic">a</span>′<sub><span style="font-style:italic">n</span></sub>. Amongst
these subgoals, the simple ones (e.g. provable by
reflexivity or congruence) are automatically solved by <span style="font-family:monospace">f_equal</span>.</p>
<h3 id="sec440" class="subsection">8.12.2  <span style="font-family:monospace">reflexivity</span></h3>
<p>
<a id="reflexivity"></a>
<a id="hevea_default774"></a><a id="hevea_tactic184"></a></p><p>This tactic applies to a goal that has the form <span style="font-family:monospace">t=u</span>. It checks
that <span style="font-family:monospace">t</span> and <span style="font-family:monospace">u</span> are convertible and then solves the goal.
It is equivalent to <span style="font-family:monospace">apply refl_equal</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">The conclusion is not a substitutive equation</span><a id="hevea_error125"></a>
</li><li class="li-enumerate"><span style="font-family:monospace">Unable to unify … with …</span><a id="hevea_error126"></a>
</li></ol>
<h3 id="sec441" class="subsection">8.12.3  <span style="font-family:monospace">symmetry</span></h3>
<p>
<a id="hevea_default775"></a><a id="hevea_tactic185"></a></p><p>This tactic applies to a goal that has the form <span style="font-family:monospace">t=u</span> and changes it
into <span style="font-family:monospace">u=t</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">symmetry in </span><span style="font-style:oblique">ident</span> <a id="hevea_default776"></a><a id="hevea_tactic186"></a><p>If the statement of the hypothesis <span style="font-style:oblique">ident</span> has the form <span style="font-family:monospace">t=u</span>,
the tactic changes it to <span style="font-family:monospace">u=t</span>.
</p></li></ol>
<h3 id="sec442" class="subsection">8.12.4  <span style="font-family:monospace">transitivity </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default777"></a><a id="hevea_tactic187"></a></p><p>This tactic applies to a goal that has the form <span style="font-family:monospace">t=u</span>
and transforms it into the two subgoals
<span style="font-family:monospace">t=</span><span style="font-style:oblique">term</span> and <span style="font-style:oblique">term</span><span style="font-family:monospace">=u</span>.</p>
<h2 id="sec443" class="section">8.13  Equality and inductive sets</h2>
<p>We describe in this section some special purpose tactics dealing with
equality and inductive sets or types. These tactics use the equality
<span style="font-family:monospace">eq:forall (A:Type), A-&gt;A-&gt;Prop</span>, simply written with the
infix symbol <span style="font-family:monospace">=</span>.</p>
<h3 id="sec444" class="subsection">8.13.1  <span style="font-family:monospace">decide equality</span></h3>
<p>
<a id="decideequality"></a>
<a id="hevea_default778"></a><a id="hevea_tactic188"></a></p><p>This tactic solves a goal of the form
<span style="font-family:monospace">forall </span><span style="font-style:italic">x</span><span style="font-family:monospace"> </span><span style="font-style:italic">y</span><span style="font-family:monospace">:</span><span style="font-style:italic">R</span><span style="font-family:monospace">, {</span><span style="font-style:italic">x</span><span style="font-family:monospace">=</span><span style="font-style:italic">y</span><span style="font-family:monospace">}+{</span><code><span style="font-family:monospace">~</span></code><span style="font-style:italic">x</span><span style="font-family:monospace">=</span><span style="font-style:italic">y</span><span style="font-family:monospace">}</span>, where <span style="font-style:italic">R</span>
is an inductive type such that its constructors do not take proofs or
functions as arguments, nor objects in dependent types.
It solves goals of the form <span style="font-family:monospace">{</span><span style="font-style:italic">x</span><span style="font-family:monospace">=</span><span style="font-style:italic">y</span><span style="font-family:monospace">}+{</span><code><span style="font-family:monospace">~</span></code><span style="font-style:italic">x</span><span style="font-family:monospace">=</span><span style="font-style:italic">y</span><span style="font-family:monospace">}</span> as well.</p>
<h3 id="sec445" class="subsection">8.13.2  <span style="font-family:monospace">compare </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>2</sub></h3>
<p>
<a id="hevea_default779"></a><a id="hevea_tactic189"></a></p><p>This tactic compares two given objects <span style="font-style:oblique">term</span><sub>1</sub> and <span style="font-style:oblique">term</span><sub>2</sub>
of an inductive datatype. If <span style="font-style:italic">G</span> is the current goal, it leaves the sub-goals
<span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">=</span><span style="font-style:oblique">term</span><sub>2</sub> <span style="font-family:monospace">-&gt;</span> <span style="font-style:italic">G</span> and <code>~</code><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">=</span><span style="font-style:oblique">term</span><sub>2</sub>
<span style="font-family:monospace">-&gt;</span> <span style="font-style:italic">G</span>. The type
of <span style="font-style:oblique">term</span><sub>1</sub> and <span style="font-style:oblique">term</span><sub>2</sub> must satisfy the same restrictions as in the tactic
<span style="font-family:monospace">decide equality</span>.</p>
<h3 id="sec446" class="subsection">8.13.3  <span style="font-family:monospace">simplify_eq </span><span style="font-style:oblique">term</span></h3>
<p>
<a id="hevea_default780"></a><a id="hevea_tactic190"></a>
<a id="hevea_default781"></a><a id="hevea_tactic191"></a>
<a id="simplify-eq"></a></p><p>Let <span style="font-style:oblique">term</span> be the proof of a statement of conclusion <span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">=</span><span style="font-style:oblique">term</span><sub>2</sub>. If <span style="font-style:oblique">term</span><sub>1</sub> and
<span style="font-style:oblique">term</span><sub>2</sub> are structurally different (in the sense described for the
tactic <span style="font-family:monospace">discriminate</span>), then the tactic <span style="font-family:monospace">simplify_eq</span> behaves as <span style="font-family:monospace">discriminate </span><span style="font-style:oblique">term</span>, otherwise it behaves as <span style="font-family:monospace">injection
</span><span style="font-style:oblique">term</span>.</p><p><br>
<span style="font-weight:bold">Remark: </span>If some quantified hypothesis of the goal is named <span style="font-style:oblique">ident</span>, then
<span style="font-family:monospace">simplify_eq </span><span style="font-style:oblique">ident</span> first introduces the hypothesis in the local
context using <span style="font-family:monospace">intros until </span><span style="font-style:oblique">ident</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">simplify_eq</span> <span style="font-style:oblique">num</span><p>This does the same thing as <span style="font-family:monospace">intros until </span><span style="font-style:oblique">num</span> then
<span style="font-family:monospace">simplify_eq </span><span style="font-style:oblique">ident</span> where <span style="font-style:oblique">ident</span> is the identifier for the last
introduced hypothesis.</p></li><li class="li-enumerate"><span style="font-family:monospace">simplify_eq</span> <span style="font-style:oblique">term</span> <span style="font-family:monospace">with</span> <span style="font-style:oblique">bindings_list</span><p>This does the same as <span style="font-family:monospace">simplify_eq </span><span style="font-style:oblique">term</span> but using
the given bindings to instantiate parameters or hypotheses of <span style="font-style:oblique">term</span>.</p></li><li class="li-enumerate"><span style="font-family:monospace">esimplify_eq</span> <span style="font-style:oblique">num</span><br>
 <span style="font-family:monospace">esimplify_eq</span> <span style="font-style:oblique">term</span> <span style="font-style:oblique">[</span><span style="font-family:monospace">with</span> <span style="font-style:oblique">bindings_list</span><span style="font-style:oblique">]</span><p>This works the same as <span style="font-family:monospace">simplify_eq</span> but if the type of <span style="font-style:oblique">term</span>,
or the type of the hypothesis referred to by <span style="font-style:oblique">num</span>, has uninstantiated
parameters, these parameters are left as existential variables.</p></li><li class="li-enumerate"><span style="font-family:monospace">simplify_eq</span><p>If the current goal has form <span style="font-style:italic">t</span><sub>1</sub><code>&lt;&gt;</code><span style="font-style:italic">t</span><sub>2</sub>, it behaves as
<span style="font-family:monospace">intro </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">; simplify_eq </span><span style="font-style:oblique">ident</span>.
</p></li></ol>
<h3 id="sec447" class="subsection">8.13.4  <span style="font-family:monospace">dependent rewrite -&gt; </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="hevea_default782"></a><a id="hevea_tactic192"></a>
<a id="dependent-rewrite"></a></p><p>This tactic applies to any goal. If <span style="font-style:oblique">ident</span> has type
<code>(existT B a b)=(existT B a' b')</code>
in the local context (i.e. each term of the
equality has a sigma type { <span style="font-style:italic">a</span>:<span style="font-style:italic">A</span>  &amp; (<span style="font-style:italic">B</span> <span style="font-style:italic">a</span>)}) this tactic rewrites
<code>a</code> into <code>a'</code> and <code>b</code> into <code>b'</code> in the current
goal. This tactic works even if <span style="font-style:italic">B</span> is also a sigma type. This kind
of equalities between dependent pairs may be derived by the injection
and inversion tactics.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">dependent rewrite &lt;- </span><span style="font-style:oblique">ident</span>
<a id="hevea_default783"></a><a id="hevea_tactic193"></a><p>Analogous to <span style="font-family:monospace">dependent rewrite -&gt;</span> but uses the equality from
right to left.
</p></li></ol>
<h2 id="inversion" class="section">8.14  Inversion
</h2>
<h3 id="sec449" class="subsection">8.14.1  <span style="font-family:monospace">functional inversion </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="hevea_default784"></a><a id="hevea_tactic194"></a>
<a id="sec:functional-inversion"></a></p><p><span style="font-family:monospace">functional inversion</span> is a tactic
that performs inversion on hypothesis <span style="font-style:oblique">ident</span> of the form
<span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> = </span><span style="font-style:oblique">term</span> or <span style="font-style:oblique">term</span><span style="font-family:monospace"> =
</span><span style="font-style:oblique">qualid</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> where <span style="font-style:oblique">qualid</span> must have been
defined using <span style="font-family:monospace">Function</span> (see Section <a href="gallina-ext.html#Function">2.3</a>).
Note that this tactic is only available after a <span style="font-family:monospace">Require Import FunInd</span>.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Hypothesis </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> must contain at least one Function</span><a id="hevea_error127"></a></li><li class="li-enumerate"><span style="font-family:monospace">Cannot find inversion information for hypothesis </span><span style="font-style:oblique">ident</span><a id="hevea_error128"></a><p>This error may be raised when some inversion lemma failed to be
generated by Function.
</p></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">functional inversion </span><span style="font-style:oblique">num</span><p>This does the same thing as <span style="font-family:monospace">intros until </span><span style="font-style:oblique">num</span> then
<span style="font-family:monospace">functional inversion </span><span style="font-style:oblique">ident</span> where <span style="font-style:oblique">ident</span> is the
identifier for the last introduced hypothesis.
</p></li><li class="li-enumerate"><span style="font-family:monospace">functional inversion </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">qualid</span><br>
 <span style="font-family:monospace">functional inversion </span><span style="font-style:oblique">num</span><span style="font-family:monospace"> </span><span style="font-style:oblique">qualid</span><p>If the hypothesis <span style="font-style:oblique">ident</span> (or <span style="font-style:oblique">num</span>) has a type of the form
<span style="font-style:oblique">qualid</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> = </span><span style="font-style:oblique">qualid</span><sub>2</sub><span style="font-family:monospace">
 </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span>+1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span>+<span style="font-style:italic">m</span></sub> where <span style="font-style:oblique">qualid</span><sub>1</sub> and <span style="font-style:oblique">qualid</span><sub>2</sub>
are valid candidates to functional inversion, this variant allows
choosing which <span style="font-style:oblique">qualid</span> is inverted.
</p></li></ol>
<h3 id="sec450" class="subsection">8.14.2  <span style="font-family:monospace">quote </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="hevea_default785"></a><a id="hevea_tactic195"></a>
<a id="hevea_default786"></a></p><p>This kind of inversion has nothing to do with the tactic
<span style="font-family:monospace">inversion</span> above. This tactic does <span style="font-family:monospace">change (</span><span style="font-style:oblique">ident</span><span style="font-family:monospace">
 t)</span>, where <span style="font-family:monospace">t</span> is a term built in order to ensure the
convertibility. In other words, it does inversion of the function
<span style="font-style:oblique">ident</span>. This function must be a fixpoint on a simple recursive
datatype: see <a href="tactic-examples.html#quote-examples">10.3</a> for the full details.</p><p><br>
<span style="font-weight:bold">Error messages: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">quote: not a simple fixpoint</span><a id="hevea_error129"></a><p>Happens when <span style="font-family:monospace">quote</span> is not able to perform inversion properly.
</p></li></ol><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">quote </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> [ </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> ]</span><p>All terms that are built only with <span style="font-style:oblique">ident</span><sub>1</sub> …<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> will be
considered by <span style="font-family:monospace">quote</span> as constants rather than variables.
</p></li></ol>
<h2 id="sec451" class="section">8.15  Classical tactics</h2>
<p>
<a id="ClassicalTactics"></a></p><p>In order to ease the proving process, when the <span style="font-family:monospace">Classical</span> module is loaded. A few more tactics are available. Make sure to load the module using the <span style="font-family:monospace">Require Import</span> command.</p>
<h3 id="sec452" class="subsection">8.15.1  <span style="font-family:monospace">classical_left</span> and <span style="font-family:monospace">classical_right</span></h3>
<p>
<a id="hevea_default787"></a><a id="hevea_tactic196"></a>
<a id="hevea_default788"></a><a id="hevea_tactic197"></a></p><p>The tactics <span style="font-family:monospace">classical_left</span> and <span style="font-family:monospace">classical_right</span> are the analog of the <span style="font-family:monospace">left</span> and <span style="font-family:monospace">right</span> but using classical logic. They can only be used for disjunctions.
Use <span style="font-family:monospace">classical_left</span> to prove the left part of the disjunction with the assumption that the negation of right part holds.
Use <span style="font-family:monospace">classical_right</span> to prove the right part of the disjunction with the assumption that the negation of left part holds.</p>
<h2 id="Automatizing" class="section">8.16  Automatizing
</h2>
<h3 id="sec454" class="subsection">8.16.1  <span style="font-family:monospace">btauto</span></h3>
<p>
<a id="hevea_default789"></a><a id="hevea_tactic198"></a>
<a id="btauto"></a></p><p>The tactic <span style="font-family:monospace">btauto</span> implements a reflexive solver for boolean tautologies. It
solves goals of the form <span style="font-family:monospace">t = u</span> where <span style="font-family:monospace">t</span> and <span style="font-family:monospace">u</span> are constructed
over the following grammar:</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-family:monospace"><span style="font-style:italic">t</span></span> ::= <span style="font-style:italic">x</span> ∣ <span style="font-family:monospace"><span style="font-style:italic">true</span></span> ∣ <span style="font-family:monospace"><span style="font-style:italic">false</span></span>∣ <span style="font-family:monospace"><span style="font-style:italic">orb</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace">2</span></sub>
∣ <span style="font-family:monospace"><span style="font-style:italic">andb</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace">2</span></sub> ∣<span style="font-family:monospace"><span style="font-style:italic">xorb</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace">2</span></sub> ∣<span style="font-family:monospace"><span style="font-style:italic">negb</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">t</span></span>
∣<span style="font-family:monospace"><span style="font-style:italic">if</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace">1</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">then</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace">2</span></sub><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">else</span></span><span style="font-family:monospace"> </span><span style="font-family:monospace"><span style="font-style:italic">t</span></span><sub><span style="font-family:monospace">3</span></sub>
</td></tr>
</table><p>Whenever the formula supplied is not a tautology, it also provides a counter-example.</p><p>Internally, it uses a system very similar to the one of the <span style="font-family:monospace">ring</span> tactic.</p>
<h3 id="sec455" class="subsection">8.16.2  <span style="font-family:monospace">omega</span></h3>
<p>
<a id="hevea_default790"></a><a id="hevea_tactic199"></a>
<a id="omega"></a></p><p>The tactic <span style="font-family:monospace">omega</span>, due to Pierre Crégut,
is an automatic decision procedure for Presburger
arithmetic. It solves quantifier-free
formulas built with <code>~</code>, <code>\/</code>, <code>/\</code>,
<code>-&gt;</code> on top of equalities, inequalities and disequalities on
both the type <span style="font-family:monospace">nat</span> of natural numbers and <span style="font-family:monospace">Z</span> of binary
integers. This tactic must be loaded by the command <span style="font-family:monospace">Require Import
Omega</span>. See the additional documentation about <span style="font-family:monospace">omega</span>
(see Chapter <a href="omega.html#OmegaChapter">21</a>).</p>
<h3 id="sec456" class="subsection">8.16.3  <span style="font-family:monospace">ring</span> and <span style="font-family:monospace">ring_simplify </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace"> </span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub></h3>
<p>
<a id="hevea_default791"></a><a id="hevea_tactic200"></a>
<a id="hevea_default792"></a><a id="hevea_tactic201"></a>
<a id="hevea_default793"></a><a id="hevea_command203"></a>
<a id="hevea_default794"></a><a id="hevea_command204"></a></p><p>The <span style="font-family:monospace">ring</span> tactic solves equations upon polynomial expressions of
a ring (or semi-ring) structure. It proceeds by normalizing both hand
sides of the equation (w.r.t. associativity, commutativity and
distributivity, constant propagation) and comparing syntactically the
results.</p><p><span style="font-family:monospace">ring_simplify</span> applies the normalization procedure described
above to the terms given. The tactic then replaces all occurrences of
the terms given in the conclusion of the goal by their normal
forms. If no term is given, then the conclusion should be an equation
and both hand sides are normalized.</p><p>See Chapter <a href="ring.html#ring">25</a> for more information on the tactic and how to
declare new ring structures. All declared field structures can be
printed with the <span style="font-family:monospace">Print Rings</span> command.</p>
<h3 id="sec457" class="subsection">8.16.4  <span style="font-family:monospace">field</span>, <span style="font-family:monospace">field_simplify </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-family:monospace">…</span><span style="font-family:monospace">
</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub>, and <span style="font-family:monospace">field_simplify_eq</span></h3>
<p>
<a id="hevea_default795"></a><a id="hevea_tactic202"></a>
<a id="hevea_default796"></a><a id="hevea_tactic203"></a>
<a id="hevea_default797"></a><a id="hevea_tactic204"></a>
<a id="hevea_default798"></a><a id="hevea_command205"></a>
<a id="hevea_default799"></a><a id="hevea_command206"></a></p><p>The <span style="font-family:monospace">field</span> tactic is built on the same ideas as <span style="font-family:monospace">ring</span>: this
is a reflexive tactic that solves or simplifies equations in a field
structure. The main idea is to reduce a field expression (which is an
extension of ring expressions with the inverse and division
operations) to a fraction made of two polynomial expressions.</p><p>Tactic <span style="font-family:monospace">field</span> is used to solve subgoals, whereas <span style="font-family:monospace">field_simplify </span><span style="font-style:oblique">term</span><sub>1</sub><span style="font-family:monospace">…</span><span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> replaces the provided terms
by their reduced fraction. <span style="font-family:monospace">field_simplify_eq</span> applies when the
conclusion is an equation: it simplifies both hand sides and multiplies
so as to cancel denominators. So it produces an equation without
division nor inverse.</p><p>All of these 3 tactics may generate a subgoal in order to prove that
denominators are different from zero.</p><p>See Chapter <a href="ring.html#ring">25</a> for more information on the tactic and how to
declare new field structures. All declared field structures can be
printed with the <span style="font-family:monospace">Print Fields</span> command.</p><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import Reals.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall x y:R,</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          (x * y </span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> 0)%R -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          (x * (1 / x + x / (x + y)))%R =</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          ((- 1 / y) * y * (- x * (x / (x + y)) - 1))%R.</span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros; field.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x, y : R</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : (x * y </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0)%R</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  (x + y)%R </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0%R /</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> y </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0%R /</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">\</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> x </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&lt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> 0%R</span></span></span><span style="font-size:small"><br>
</span></div><p><br>
<span style="font-weight:bold">See also: </span>file <span style="font-family:monospace">plugins/setoid_ring/RealField.v</span> for an example of instantiation,<br>
    theory <span style="font-family:monospace">theories/Reals</span> for many examples of use of <span style="font-family:monospace">field</span>.</p>
<h3 id="sec458" class="subsection">8.16.5  <span style="font-family:monospace">fourier</span></h3>
<p>
<a id="hevea_default800"></a><a id="hevea_tactic205"></a></p><p>This tactic written by Loïc Pottier solves linear inequalities on
real numbers using Fourier’s method [<a href="biblio.html#Fourier">65</a>]. This tactic must
be loaded by <span style="font-family:monospace">Require Import Fourier</span>.</p><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import Reals.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Require Import Fourier.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal forall x y:R, (x </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> y)%R -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> (y + 1 </span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace">= x - 1)%R.</span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> intros; fourier.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div>
<h2 id="sec459" class="section">8.17  Non-logical tactics</h2>
<h3 id="sec460" class="subsection">8.17.1  <span style="font-family:monospace">cycle </span><span style="font-style:oblique">num</span><a id="hevea_default801"></a><a id="hevea_tactic206"></a></h3>
<p>This tactic puts the <span style="font-style:oblique">num</span> first goals at the end of the list of
goals. If <span style="font-style:oblique">num</span> is negative, it will put the last |<span style="font-style:oblique">num</span>| goals at
the beginning of the list.</p><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Parameter P : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal P 1 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 2 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 3 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 4 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 5.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> repeat split.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">5 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 3 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 3</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 4 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 4</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 5 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 5</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> all: cycle 2.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">5 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P 3</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 4</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 3 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 5</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 4 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 5 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 2</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> all: cycle -3.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">5 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P 5</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 3 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 4 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 3</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 5 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 4</span></span></span><span style="font-size:small"><br>
</span></div><h3 id="sec461" class="subsection">8.17.2  <span style="font-family:monospace">swap </span><span style="font-style:oblique">num</span><sub>1</sub><span style="font-family:monospace"> </span><span style="font-style:oblique">num</span><sub>2</sub><a id="hevea_default802"></a><a id="hevea_tactic207"></a></h3>
<p>This tactic switches the position of the goals of indices <span style="font-style:oblique">num</span><sub>1</sub> and <span style="font-style:oblique">num</span><sub>2</sub>. If either <span style="font-style:oblique">num</span><sub>1</sub> or <span style="font-style:oblique">num</span><sub>2</sub> is negative then goals are counted from the end of the focused goal list. Goals are indexed from 1, there is no goal with position 0.</p><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Parameter P : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal P 1 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 2 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 3 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 4 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 5.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> repeat split.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">5 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 3 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 3</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 4 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 4</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 5 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 5</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> all: swap 1 3.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">5 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P 3</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 3 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 4 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 4</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 5 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 5</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> all: swap 1 -1.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">5 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P 5</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 3 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 4 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 4</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 5 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 3</span></span></span><span style="font-size:small"><br>
</span></div><h3 id="sec462" class="subsection">8.17.3  <span style="font-family:monospace">revgoals</span><a id="hevea_default803"></a><a id="hevea_tactic208"></a></h3>
<p>This tactics reverses the list of the focused goals.</p><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Parameter P : nat -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Prop.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal P 1 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 2 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 3 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 4 /</span></span><span style="font-size:small"><span style="font-family:monospace">\</span></span><span style="font-size:small"><span style="font-family:monospace"> P 5.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> repeat split.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">5 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P 1</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 3 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 3</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 4 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 4</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 5 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 5</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> all: revgoals.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">5 subgoals</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  P 5</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 2 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 4</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 3 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 3</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 4 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 2</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">subgoal 5 is:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> P 1</span></span></span><span style="font-size:small"><br>
</span></div><h3 id="shelve" class="subsection">8.17.4  <span style="font-family:monospace">shelve</span><a id="hevea_default804"></a><a id="hevea_tactic209"></a></h3>
<p>This tactic moves all goals under focus to a shelf. While on the shelf, goals
will not be focused on. They can be solved by unification, or they can be called
back into focus with the command <span style="font-family:monospace">Unshelve</span> (Section <a href="#unshelve">8.17.5</a>).</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">shelve_unifiable</span><a id="hevea_default805"></a><a id="hevea_tactic210"></a><p>Shelves only the goals under focus that are mentioned in other goals.
Goals that appear in the type of other goals can be solved by unification.</p><p><br>
<span style="font-weight:bold">Example: </span><span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Goal exists n, n=0.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  exists n : nat, n = 0</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> refine (ex</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">intro </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 focused subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">(shelved: 1)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ?Goal = 0</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> all:shelve</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">unifiable.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 focused subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">(shelved: 1)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ?Goal = 0</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> reflexivity.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
</span></div></li></ol><h3 id="unshelve" class="subsection">8.17.5  <span style="font-family:monospace">Unshelve</span><a id="hevea_default806"></a><a id="hevea_command207"></a></h3>
<p>This command moves all the goals on the shelf (see Section <a href="#shelve">8.17.4</a>) from the
shelf into focus, by appending them to the end of the current list of focused goals.</p><h3 id="sec465" class="subsection">8.17.6  <span style="font-family:monospace">give_up</span><a id="hevea_default807"></a><a id="hevea_tactic211"></a></h3>
<p>This tactic removes the focused goals from the proof. They are not solved, and cannot
be solved later in the proof. As the goals are not solved, the proof cannot be closed.</p><p>The <span style="font-family:monospace">give_up</span> tactic can be used while editing a proof, to choose to write the
proof script in a non-sequential order.</p>
<h2 id="sec466" class="section">8.18  Simple tactic macros</h2>
<p>
<a id="hevea_default808"></a>
<a id="TacticDefinition"></a></p><p>A simple example has more value than a long explanation:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Ltac Solve := simpl; intros; auto.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Solve is defined</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Ltac ElimBoolRewrite b H1 H2 :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        elim b; [ intros; rewrite H1; eauto | intros; rewrite H2; eauto ].</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ElimBoolRewrite is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>The tactics macros are synchronous with the <span style="font-variant:small-caps">Coq</span> section mechanism:
a tactic definition is deleted from the current environment
when you close the section (see also <a href="gallina-ext.html#Section">2.4</a>)
where it was defined. If you want that a
tactic macro defined in a module is usable in the modules that
require it, you should put it outside of any section.</p><p>Chapter <a href="ltac.html#TacticLanguage">9</a> gives examples of more complex
user-defined tactics.</p><hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note12" href="#text12">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Actually, only the second subgoal will be
generated since the other one can be automatically checked.</div></dd><dt class="dt-thefootnotes"><a id="note13" href="#text13">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">This corresponds to the
cut rule of sequent calculus.</div></dd><dt class="dt-thefootnotes"><a id="note14" href="#text14">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Reminder: opaque
constants will not be expanded by δ reductions.</div></dd><dt class="dt-thefootnotes"><a id="note15" href="#text15">4</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">The behavior of this tactic has much changed compared to
the versions available in the previous distributions (V6). This may cause
significant changes in your theories to obtain the same result. As a drawback
of the re-engineering of the code, this tactic has also been completely revised
to get a very compact and readable version.</div></dd></dl>

<div id="sidebarWrapper">
  <div id="sidebar">
    <div class="block">
      <h2 class="title">Navigation</h2>
      <div class="content">
        <ul class="menu">
          <li class="leaf"><a href="index.html">Cover</a></li>
          <li class="leaf"><a href="toc.html">Table of contents</a></li>
          <li class="leaf">Index
            <ul class="menu">
              <li><a href="general-index.html">General</a></li>
              <li><a href="command-index.html">Commands</a></li>
              <li><a href="option-index.html">Options</a></li>
              <li><a href="tactic-index.html">Tactics</a></li>
              <li><a href="error-index.html">Errors</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</body>
</html>
