<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD><TITLE></TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
</HEAD>
<BODY >
<!--HEVEA command line is: hevea ./book-html.sty ./coq-html.sty ./Tutorial.v -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF chapter 1 -->



<DIV ALIGN=center>
<FONT SIZE=7>
<B>
The Coq Proof Assistant<BR>
<BR>

 A Tutorial<BR>
</B>
</FONT>
<BR>
<BR><FONT SIZE=5><B><BR>
Version 8.0
</B></FONT><SUP><A NAME="text1" HREF="#note1"><FONT SIZE=5><B>1</B></FONT></A></SUP><FONT SIZE=5><B><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

Gérard Huet, Gilles Kahn and Christine Paulin-Mohring<BR>
LogiCal Project<BR>
<BR>

</B></FONT></DIV>
<DIV ALIGN=left>
<FONT SIZE=4>©INRIA 1999-2004 (<FONT COLOR=navy>Coq</FONT></FONT><FONT SIZE=4> versions 7)</FONT><BR>
<FONT SIZE=4>©INRIA 2004 (<FONT COLOR=navy>Coq</FONT></FONT><FONT SIZE=4> version 8)</FONT><BR>
</DIV>
<BR>
<!--CUT CHAPTER-->

<H1>
Getting started
</H1>

<FONT COLOR=navy>Coq</FONT> is a Proof Assistant for a Logical Framework known as the Calculus
of Inductive Constructions. It allows the interactive construction of
formal proofs, and also the manipulation of functional programs 
consistently with their specifications. It runs as a computer program
on many architectures.
It is available with a variety of user interfaces. The present
document does not attempt to present a comprehensive view of all the
possibilities of <FONT COLOR=navy>Coq</FONT>, but rather to present in the most elementary
manner a tutorial on the basic specification language, called Gallina,
in which formal axiomatisations may be developed, and on the main
proof tools. For more advanced information, the reader could refer to
the <FONT COLOR=navy>Coq</FONT> Reference Manual or the <I>Coq'Art</I>, a new book by Y.
Bertot and P. Castéran on practical uses of the <FONT COLOR=navy>Coq</FONT> system.<BR>
<BR>
We assume here that the potential user has installed <FONT COLOR=navy>Coq</FONT>&nbsp; on his workstation,
that he calls <FONT COLOR=navy>Coq</FONT>&nbsp; from a standard teletype-like shell window, and that
he does not use any special interface.
Instructions on installation procedures, as well as more comprehensive
documentation, may be found in the standard distribution of <FONT COLOR=navy>Coq</FONT>,
which may be obtained from <FONT COLOR=navy>Coq</FONT> web site <TT>http://coq.inria.fr</TT>.<BR>
<BR>
In the following, all examples preceded by the prompting sequence
<CODE>Coq &lt; </CODE> represent user input, terminated by a period. The
following lines usually show <FONT COLOR=navy>Coq</FONT>'s answer as it appears on the users
screen. The sequence of such examples is a valid <FONT COLOR=navy>Coq</FONT>&nbsp; session, unless
otherwise specified. This version of the tutorial has been prepared 
on a PC workstation running Linux.
The standard invocation of <FONT COLOR=navy>Coq</FONT> delivers a message such as:<BR>
<BR>

<DIV ALIGN=left>
<PRE>
unix:~&gt; coqtop
Welcome to Coq 8.0 (Mar 2004)

Coq &lt; 
</PRE></DIV>
<BR>
The first line gives a banner stating the precise version of <FONT COLOR=navy>Coq</FONT>&nbsp;
used. You should always return this banner when you report an
anomaly to our hot-line <CODE>coq-bugs@pauillac.inria.fr</CODE> or on our
bug-tracking system&nbsp;:<CODE>http</CODE>//coq.inria.fr/bin/coq-bugs:<BR>
<BR>
<!--CUT CHAPTER-->

<H1>

Chapter&nbsp;1: Basic Predicate Calculus
</H1>

<!--CUT SECTION-->

<H2>

1.1&nbsp;An overview of the specification language Gallina
</H2>

A formal development in Gallina consists in a sequence of <I><FONT COLOR=maroon>declarations</FONT></I>
and <I><FONT COLOR=maroon>definitions</FONT></I>. You may also send <FONT COLOR=navy>Coq</FONT>&nbsp; <I><FONT COLOR=maroon>commands</FONT></I> which are
not really part of the formal development, but correspond to information
requests, or service routine invocations. For instance, the command:
<PRE>
Coq &lt; Quit.
</PRE>terminates the current session.

<H3>

1.1.1&nbsp;Declarations
</H3>

A declaration associates a <I><FONT COLOR=maroon>name</FONT></I> with 
a <I><FONT COLOR=maroon>specification</FONT></I>. 
A name corresponds roughly to an identifier in a programming
language, i.e. to a string of letters, digits, and a few ASCII symbols like
underscore (<CODE>_</CODE>) and prime (<CODE>'</CODE>), starting with a letter. 
We use case distinction, so that the names <CODE>A</CODE> and <CODE>a</CODE> are distinct.
Certain strings are reserved as key-words of <FONT COLOR=navy>Coq</FONT>, and thus are forbidden 
as user identifiers.<BR>
<BR>
A specification is a formal expression which classifies the notion which is
being declared. There are basically three kinds of specifications: 
<I><FONT COLOR=maroon>logical propositions</FONT></I>, <I><FONT COLOR=maroon>mathematical collections</FONT></I>, and
<I><FONT COLOR=maroon>abstract types</FONT></I>. They are classified by the three basic sorts
of the system, called respectively <CODE>Prop</CODE>, <CODE>Set</CODE>, and
<CODE>Type</CODE>, which are themselves atomic abstract types.<BR>
<BR>
Every valid expression <I>e</I> in Gallina is associated with a specification,
itself a valid expression, called its <I><FONT COLOR=maroon>type</FONT></I> <FONT FACE=symbol>t</FONT>(<I>E</I>). We write
<I>e</I>:<FONT FACE=symbol>t</FONT>(<I>E</I>) for the judgment that <I>e</I> is of type <I>E</I>. 
You may request <FONT COLOR=navy>Coq</FONT>&nbsp; to return to you the type of a valid expression by using
the command <CODE>Check</CODE>:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;O.</TT><BR>
<TT><I>0</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat</I></TT><BR>
</DIV>
<BR>
Thus we know that the identifier <CODE>O</CODE> (the name `O', not to be
confused with the numeral `0' which is not a proper identifier!) is
known in the current context, and that its type is the specification 
<CODE>nat</CODE>. This specification is itself classified as a mathematical
collection, as we may readily check:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;nat.</TT><BR>
<TT><I>nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Set</I></TT><BR>
</DIV>
<BR>
The specification <CODE>Set</CODE> is an abstract type, one of the basic
sorts of the Gallina language, whereas the notions <I>nat</I> and <I>O</I> are
notions which are defined in the arithmetic prelude,
automatically loaded when running the <FONT COLOR=navy>Coq</FONT> system.<BR>
<BR>
We start by introducing a so-called section name. The role of sections
is to structure the modelisation by limiting the scope of parameters,
hypotheses and definitions. It will also give a convenient way to
reset part of the development.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;Declaration.</TT><BR>
</DIV>

With what we already know, we may now enter in the system a declaration,
corresponding to the informal mathematics <I><FONT COLOR=maroon>let n be a natural
 number</FONT></I>. <BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;n&nbsp;:&nbsp;nat.</TT><BR>
<TT><I>n&nbsp;is&nbsp;assumed</I></TT><BR>
</DIV>
<BR>
If we want to translate a more precise statement, such as
<I><FONT COLOR=maroon>let n be a positive natural number</FONT></I>,
we have to add another declaration, which will declare explicitly the
hypothesis <CODE>Pos_n</CODE>, with specification the proper logical
proposition:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;Pos_n&nbsp;:&nbsp;(gt&nbsp;n&nbsp;0).</TT><BR>
<TT><I>Pos_n&nbsp;is&nbsp;assumed</I></TT><BR>
</DIV>
<BR>
Indeed we may check that the relation <CODE>gt</CODE> is known with the right type
in the current context:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;gt.</TT><BR>
<TT><I>gt</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
</DIV>
<BR>
which tells us that <CODE>gt</CODE> is a function expecting two arguments of
type <CODE>nat</CODE> in order to build a logical proposition.
What happens here is similar to what we are used to in a functional
programming language: we may compose the (specification) type <CODE>nat</CODE>
with the (abstract) type <CODE>Prop</CODE> of logical propositions through the
arrow function constructor, in order to get a functional type
<CODE>nat-&gt;Prop</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(nat&nbsp;-&gt;&nbsp;Prop).</TT><BR>
<TT><I>nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Type</I></TT><BR>
</DIV>

which may be composed again with <CODE>nat</CODE> in order to obtain the
type <CODE>nat-&gt;nat-&gt;Prop</CODE> of binary relations over natural numbers.
Actually <CODE>nat-&gt;nat-&gt;Prop</CODE> is an abbreviation for 
<CODE>nat-&gt;(nat-&gt;Prop)</CODE>. <BR>
<BR>
Functional notions may be composed in the usual way. An expression <I>f</I>
of type <I>A</I><FONT FACE=symbol>®</FONT> <I>B</I> may be applied to an expression <I>e</I> of type <I>A</I> in order
to form the expression (<I>f</I>&nbsp;<I>e</I>) of type <I>B</I>. Here we get that
the expression <CODE>(gt n)</CODE> is well-formed of type <CODE>nat-&gt;Prop</CODE>,
and thus that the expression <CODE>(gt n O)</CODE>, which abbreviates
<CODE>((gt n) O)</CODE>, is a well-formed proposition.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;gt&nbsp;n&nbsp;O.</TT><BR>
<TT><I>n&nbsp;&gt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Prop</I></TT><BR>
</DIV>


<H3>

1.1.2&nbsp;Definitions
</H3>

The initial prelude contains a few arithmetic definitions:
<CODE>nat</CODE> is defined as a mathematical collection (type <CODE>Set</CODE>), constants
<CODE>O</CODE>, <CODE>S</CODE>, <CODE>plus</CODE>, are defined as objects of types
respectively <CODE>nat</CODE>, <CODE>nat-&gt;nat</CODE>, and <CODE>nat-&gt;nat-&gt;nat</CODE>.
You may introduce new definitions, which link a name to a well-typed value.
For instance, we may introduce the constant <CODE>one</CODE> as being defined
to be equal to the successor of zero:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;one&nbsp;:=&nbsp;(S&nbsp;O).</TT><BR>
<TT><I>one&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>

We may optionally indicate the required type:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;two&nbsp;:&nbsp;nat&nbsp;:=&nbsp;S&nbsp;one.</TT><BR>
<TT><I>two&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Actually <FONT COLOR=navy>Coq</FONT>&nbsp; allows several possible syntaxes:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;three&nbsp;:&nbsp;nat&nbsp;:=&nbsp;S&nbsp;two.</TT><BR>
<TT><I>three&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Here is a way to define the doubling function, which expects an
argument <CODE>m</CODE> of type <CODE>nat</CODE> in order to build its result as
<CODE>(plus m m)</CODE>:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;double&nbsp;(m:nat)&nbsp;:=&nbsp;plus&nbsp;m&nbsp;m.</TT><BR>
<TT><I>double&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>

This definition introduces the constant <TT>double</TT> defined as the
expression <TT>fun m:nat =&gt; plus m m</TT>.
The abstraction introduced by <TT>fun</TT> is explained as follows. The expression
<CODE>fun x:A =&gt; e</CODE> is well formed of type <CODE>A-&gt;B</CODE> in a context
whenever the expression <CODE>e</CODE> is well-formed of type <CODE>B</CODE> in 
the given context to which we add the declaration that <CODE>x</CODE>
is of type <CODE>A</CODE>. Here <CODE>x</CODE> is a bound, or dummy variable in
the expression <CODE>fun x:A =&gt; e</CODE>. For instance we could as well have
defined <CODE>double</CODE> as <CODE>fun n:nat =&gt; (plus n n)</CODE>.<BR>
<BR>
Bound (local) variables and free (global) variables may be mixed.
For instance, we may define the function which adds the constant <CODE>n</CODE>
to its argument as

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;add_n&nbsp;(m:nat)&nbsp;:=&nbsp;plus&nbsp;m&nbsp;n.</TT><BR>
<TT><I>add_n&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>

However, note that here we may not rename the formal argument <I>m</I> into <I>n</I>
without capturing the free occurrence of <I>n</I>, and thus changing the meaning
of the defined notion.<BR>
<BR>
Binding operations are well known for instance in logic, where they
are called quantifiers. Thus we may universally quantify a
proposition such as <I>m</I>&gt;0 in order to get a universal proposition
<FONT FACE=symbol>"</FONT> <I>m</I><FONT SIZE=5>·</FONT> <I>m</I>&gt;0. Indeed this operator is available in <FONT COLOR=navy>Coq</FONT>, with
the following syntax: <CODE>forall m:nat, gt m O</CODE>. Similarly to the
case of the functional abstraction binding, we are obliged to declare
explicitly the type of the quantified variable. We check:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(forall&nbsp;m:nat,&nbsp;gt&nbsp;m&nbsp;0).</TT><BR>
<TT><I>forall&nbsp;m&nbsp;:&nbsp;nat,&nbsp;m&nbsp;&gt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Prop</I></TT><BR>
</DIV>

We may clean-up the development by removing the contents of the
current section:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Reset&nbsp;Declaration.</TT><BR>
</DIV>
<BR>
<!--CUT SECTION-->

<H2>

1.2&nbsp;Introduction to the proof engine: Minimal Logic
</H2>

In the following, we are going to consider various propositions, built
from atomic propositions <I>A</I>, <I>B</I>, <I>C</I>. This may be done easily, by
introducing these atoms as global variables declared of type <CODE>Prop</CODE>.
It is easy to declare several names with the same specification:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;Minimal_Logic.</TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Variables&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop.</TT><BR>
<TT><I>A&nbsp;is&nbsp;assumed</I></TT><BR>
<TT><I>B&nbsp;is&nbsp;assumed</I></TT><BR>
<TT><I>C&nbsp;is&nbsp;assumed</I></TT><BR>
</DIV>
<BR>
We shall consider simple implications, such as <I>A</I><FONT FACE=symbol>®</FONT> <I>B</I>, read as 
``<I>A</I> implies <I>B</I>''. Remark that we overload the arrow symbol, which
has been used above as the functionality type constructor, and which
may be used as well as propositional connective:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(A&nbsp;-&gt;&nbsp;B).</TT><BR>
<TT><I>A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Prop</I></TT><BR>
</DIV>
<BR>
Let us now embark on a simple proof. We want to prove the easy tautology
((<I>A</I><FONT FACE=symbol>®</FONT> (<I>B</I><FONT FACE=symbol>®</FONT> <I>C</I>))<FONT FACE=symbol>®</FONT> (<I>A</I><FONT FACE=symbol>®</FONT> <I>B</I>)<FONT FACE=symbol>®</FONT> (<I>A</I><FONT FACE=symbol>®</FONT> <I>C</I>). 
We enter the proof engine by the command
<CODE>Goal</CODE>, followed by the conjecture we want to verify:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
</DIV>
<BR>
The system displays the current goal below a double line, local hypotheses
(there are none initially) being displayed above the line. We call 
the combination of local hypotheses with a goal a <I><FONT COLOR=maroon>judgment</FONT></I>.
We are now in an inner 
loop of the system, in proof mode. 
New commands are available in this
mode, such as <I><FONT COLOR=maroon>tactics</FONT></I>, which are proof combining primitives.
A tactic operates on the current goal by attempting to construct a proof
of the corresponding judgment, possibly from proofs of some
hypothetical judgments, which are then added to the current
list of conjectured judgments.
For instance, the <CODE>intro</CODE> tactic is applicable to any judgment
whose goal is an implication, by moving the proposition to the left
of the application to the list of local hypotheses:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
</DIV>
<BR>
Several introductions may be done in one step:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;H'&nbsp;HA.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H'&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;HA&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C</I></TT><BR>
</DIV>
<BR>
We notice that <I>C</I>, the current goal, may be obtained from hypothesis
<CODE>H</CODE>, provided the truth of <I>A</I> and <I>B</I> are established.
The tactic <CODE>apply</CODE> implements this piece of reasoning:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H'&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;HA&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;B</I></TT><BR>
</DIV>
<BR>
We are now in the situation where we have two judgments as conjectures
that remain to be proved. Only the first is listed in full, for the
others the system displays only the corresponding subgoal, without its
local hypotheses list. Remark that <CODE>apply</CODE> has kept the local
hypotheses of its father judgment, which are still available for
the judgments it generated.<BR>
<BR>
In order to solve the current goal, we just have to notice that it is
exactly available as hypothesis <I>HA</I>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;exact&nbsp;HA.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H'&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;HA&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B</I></TT><BR>
</DIV>
<BR>
Now <I>H</I>' applies:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H'.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H'&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;HA&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A</I></TT><BR>
</DIV>
<BR>
And we may now conclude the proof as before, with <CODE>exact HA.</CODE>
Actually, we may not bother with the name <CODE>HA</CODE>, and just state that
the current goal is solvable from the current local assumptions:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
The proof is now finished. We may either discard it, by using the
command <CODE>Abort</CODE> which returns to the standard <FONT COLOR=navy>Coq</FONT>&nbsp; toplevel loop
without further ado, or else save it as a lemma in the current context,
under name say <CODE>trivial_lemma</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Save&nbsp;trivial_lemma.</TT><BR>
<TT><I>intro&nbsp;H.</I></TT><BR>
<TT><I>intros&nbsp;H'&nbsp;HA.</I></TT><BR>
<TT><I>apply&nbsp;H.</I></TT><BR>
<TT><I>&nbsp;exact&nbsp;HA.</I></TT><BR>
<TT><I>&nbsp;apply&nbsp;H'.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;assumption.</I></TT><BR>
<TT><I>trivial_lemma&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
As a comment, the system shows the proof script listing all tactic
commands used in the proof. <BR>
<BR>
Let us redo the same proof with a few variations. First of all we may name
the initial goal as a conjectured lemma:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;distr_impl&nbsp;:&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
</DIV>
<BR>
Next, we may omit the names of local assumptions created by the introduction
tactics, they can be automatically created by the proof engine as new
non-clashing names.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C</I></TT><BR>
</DIV>
<BR>
The <CODE>intros</CODE> tactic, with no arguments, effects as many individual
applications of <CODE>intro</CODE> as is legal.<BR>
<BR>
Then, we may compose several tactics together in sequence, or in parallel,
through <I><FONT COLOR=maroon>tacticals</FONT></I>, that is tactic combinators. The main constructions
are the following:
<UL><LI>
<I>T</I><SUB><FONT SIZE=2>1</FONT></SUB> ; <I>T</I><SUB><FONT SIZE=2>2</FONT></SUB> (read <I>T</I><SUB><FONT SIZE=2>1</FONT></SUB> then <I>T</I><SUB><FONT SIZE=2>2</FONT></SUB>) applies tactic <I>T</I><SUB><FONT SIZE=2>1</FONT></SUB> to the current
goal, and then tactic <I>T</I><SUB><FONT SIZE=2>2</FONT></SUB> to all the subgoals generated by <I>T</I><SUB><FONT SIZE=2>1</FONT></SUB>.
<LI><I>T</I>; [<I>T</I><SUB><FONT SIZE=2>1</FONT></SUB> | <I>T</I><SUB><FONT SIZE=2>2</FONT></SUB> | ... | <I>T</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>] applies tactic <I>T</I> to the current
goal, and then tactic <I>T</I><SUB><FONT SIZE=2>1</FONT></SUB> to the first newly generated subgoal, 
..., <I>T</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> to the nth.
</UL>
We may thus complete the proof of <CODE>distr_impl</CODE> with one composite tactic:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H;&nbsp;[&nbsp;assumption&nbsp;|&nbsp;apply&nbsp;H0;&nbsp;assumption&nbsp;].</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
Let us now save lemma <CODE>distr_impl</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Save.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>apply&nbsp;H;&nbsp;[&nbsp;assumption&nbsp;|&nbsp;apply&nbsp;H0;&nbsp;assumption&nbsp;].</I></TT><BR>
<TT><I>distr_impl&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Here <CODE>Save</CODE> needs no argument, since we gave the name <CODE>distr_impl</CODE> 
in advance;
it is however possible to override the given name by giving a different 
argument to command <CODE>Save</CODE>.<BR>
<BR>
Actually, such an easy combination of tactics <CODE>intro</CODE>, <CODE>apply</CODE>
and <CODE>assumption</CODE> may be found completely automatically by an automatic
tactic, called <CODE>auto</CODE>, without user guidance:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;distr_imp&nbsp;:&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
This time, we do not save the proof, we just discard it with the <CODE>Abort</CODE> 
command:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Abort.</TT><BR>
<TT><I>Current&nbsp;goal&nbsp;aborted</I></TT><BR>
</DIV>
<BR>
At any point during a proof, we may use <CODE>Abort</CODE> to exit the proof mode
and go back to Coq's main loop. We may also use <CODE>Restart</CODE> to restart
from scratch the proof of the same lemma. We may also use <CODE>Undo</CODE> to
backtrack one step, and more generally <CODE>Undo n</CODE> to
backtrack n steps.<BR>
<BR>
We end this section by showing a useful command, <CODE>Inspect n.</CODE>,
which inspects the global <FONT COLOR=navy>Coq</FONT>&nbsp; environment, showing the last <CODE>n</CODE> declared
notions: 
<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inspect&nbsp;3.</TT><BR>
<TT><I>***&nbsp;[C&nbsp;:&nbsp;Prop]</I></TT><BR>
<TT><I>trivial_lemma&nbsp;:&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>distr_impl&nbsp;:&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
</DIV>
<BR>
The declarations, whether global parameters or axioms, are shown preceded by 
<CODE>***</CODE>; definitions and lemmas are stated with their specification, but
their value (or proof-term) is omitted.<BR>
<BR>
<!--CUT SECTION-->

<H2>

1.3&nbsp;Propositional Calculus
</H2>


<H3>

1.3.1&nbsp;Conjunction
</H3>

We have seen how <CODE>intro</CODE> and <CODE>apply</CODE> tactics could be combined
in order to prove implicational statements. More generally, <FONT COLOR=navy>Coq</FONT>&nbsp; favors a style
of reasoning, called <I><FONT COLOR=maroon>Natural Deduction</FONT></I>, which decomposes reasoning into 
so called <I><FONT COLOR=maroon>introduction rules</FONT></I>, which tell how to prove a goal whose main 
operator is a given propositional connective, and <I><FONT COLOR=maroon>elimination rules</FONT></I>,
which tell how to use an hypothesis whose main operator is the propositional 
connective. Let us show how to use these ideas for the propositional connectives
<CODE>/\</CODE> and <CODE>\/</CODE>.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;and_commutative&nbsp;:&nbsp;A&nbsp;/\&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;/\&nbsp;A.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;/\&nbsp;A</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;intro.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B&nbsp;/\&nbsp;A</I></TT><BR>
</DIV>
<BR>
We make use of the conjunctive hypothesis <CODE>H</CODE> with the <CODE>elim</CODE> tactic,
which breaks it into its components:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;elim&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;/\&nbsp;A</I></TT><BR>
</DIV>
<BR>
We now use the conjunction introduction tactic <CODE>split</CODE>, which splits the 
conjunctive goal into the two subgoals:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;split.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;A</I></TT><BR>
</DIV>
<BR>
and the proof is now trivial. Indeed, the whole proof is obtainable as follows:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Restart.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;/\&nbsp;A</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;H;&nbsp;elim&nbsp;H;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intro&nbsp;H;&nbsp;elim&nbsp;H;&nbsp;auto.</I></TT><BR>
<TT><I>and_commutative&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
The tactic <CODE>auto</CODE> succeeded here because it knows as a hint the 
conjunction introduction operator <CODE>conj</CODE>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;conj.</TT><BR>
<TT><I>conj</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
</DIV>
<BR>
Actually, the tactic <CODE>Split</CODE> is just an abbreviation for <CODE>apply conj.</CODE><BR>
<BR>
What we have just seen is that the <CODE>auto</CODE> tactic is more powerful than
just a simple application of local hypotheses; it tries to apply as well 
lemmas which have been specified as hints. A 
<CODE>Hint Resolve</CODE> command registers a
lemma as a hint to be used from now on by the <CODE>auto</CODE> tactic, whose power 
may thus be incrementally augmented.

<H3>

1.3.2&nbsp;Disjunction
</H3>

In a similar fashion, let us consider disjunction:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;or_commutative&nbsp;:&nbsp;A&nbsp;\/&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;\/&nbsp;A.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;\/&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;H;&nbsp;elim&nbsp;H.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR>
</DIV>
<BR>
Let us prove the first subgoal in detail. We use <CODE>intro</CODE> in order to
be left to prove <CODE>B\/A</CODE> from <CODE>A</CODE>:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;HA.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;HA&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR>
</DIV>
<BR>
Here the hypothesis <CODE>H</CODE> is not needed anymore. We could choose to
actually erase it with the tactic <CODE>clear</CODE>; in this simple proof it
does not really matter, but in bigger proof developments it is useful to
clear away unnecessary hypotheses which may clutter your screen.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;clear&nbsp;H.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;HA&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR>
</DIV>
<BR>
The disjunction connective has two introduction rules, since <CODE>P\/Q</CODE>
may be obtained from <CODE>P</CODE> or from <CODE>Q</CODE>; the two corresponding
proof constructors are called respectively <CODE>or_introl</CODE> and
<CODE>or_intror</CODE>; they are applied to the current goal by tactics
<CODE>left</CODE> and <CODE>right</CODE> respectively. For instance:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;right.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;HA&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;trivial.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR>
</DIV>

The tactic <CODE>trivial</CODE> works like <CODE>auto</CODE> with the hints
database, but it only tries those tactics that can solve the goal in one
step. <BR>
<BR>
As before, all these tedious elementary steps may be performed automatically,
as shown for the second symmetric case:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
However, <CODE>auto</CODE> alone does not succeed in proving the full lemma, because
it does not try any elimination step.
It is a bit disappointing that <CODE>auto</CODE> is not able to prove automatically 
such a simple tautology. The reason is that we want to keep
<CODE>auto</CODE> efficient, so that it is always effective to use. 

<H3>

1.3.3&nbsp;Tauto
</H3>

A complete tactic for propositional
tautologies is indeed available in <FONT COLOR=navy>Coq</FONT>&nbsp; as the <CODE>tauto</CODE> tactic. 

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Restart.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;\/&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;tauto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>tauto.</I></TT><BR>
<TT><I>or_commutative&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
It is possible to inspect the actual proof tree constructed by <CODE>tauto</CODE>,
using a standard command of the system, which prints the value of any notion 
currently defined in the context:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;or_commutative.</TT><BR>
<TT><I>or_commutative&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fun&nbsp;H&nbsp;:&nbsp;A&nbsp;\/&nbsp;B&nbsp;=&gt;</I></TT><BR>
<TT><I>or_ind&nbsp;(fun&nbsp;H0&nbsp;:&nbsp;A&nbsp;=&gt;&nbsp;or_intror&nbsp;B&nbsp;H0)&nbsp;(fun&nbsp;H0&nbsp;:&nbsp;B&nbsp;=&gt;&nbsp;or_introl&nbsp;A&nbsp;H0)&nbsp;H</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;A&nbsp;\/&nbsp;B&nbsp;-&gt;&nbsp;B&nbsp;\/&nbsp;A</I></TT><BR>
</DIV>
<BR>
It is not easy to understand the notation for proof terms without a few
explanations. The <TT>fun</TT> prefix, such as <CODE>fun H:A\/B =&gt;</CODE>, 
corresponds
to <CODE>intro H</CODE>, whereas a subterm such as 
<CODE>(or_intror</CODE> <CODE>B H0)</CODE>
corresponds to the sequence <CODE>apply or_intror; exact H0</CODE>. 
The generic combinator <CODE>or_intror</CODE> needs to be instantiated by
the two properties <CODE>B</CODE> and <CODE>A</CODE>. Because <CODE>A</CODE> can be
deduced from the type of <CODE>H0</CODE>, only <CODE>B</CODE> is printed.
The two instantiations are effected automatically by the tactic
<CODE>apply</CODE> when pattern-matching a goal. The specialist will of course
recognize our proof term as a <FONT FACE=symbol>l</FONT>-term, used as notation for the
natural deduction proof term through the Curry-Howard isomorphism. The
naive user of <FONT COLOR=navy>Coq</FONT>&nbsp; may safely ignore these formal details.<BR>
<BR>
Let us exercise the <CODE>tauto</CODE> tactic on a more complex example:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;distr_and&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;/\&nbsp;C&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;/\&nbsp;(A&nbsp;-&gt;&nbsp;C).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;/\&nbsp;C&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;/\&nbsp;(A&nbsp;-&gt;&nbsp;C)</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;tauto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>tauto.</I></TT><BR>
<TT><I>distr_and&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>


<H3>

1.3.4&nbsp;Classical reasoning
</H3>
<BR>
<BR>
<CODE>tauto</CODE> always comes back with an answer. Here is an example where it 
fails:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Peirce&nbsp;:&nbsp;((A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;A.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;((A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;A</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;try&nbsp;tauto.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;((A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;A</I></TT><BR>
</DIV>
<BR>
Note the use of the <CODE>Try</CODE> tactical, which does nothing if its tactic
argument fails.<BR>
<BR>
This may come as a surprise to someone familiar with classical reasoning. 
Peirce's lemma is true in Boolean logic, i.e. it evaluates to <CODE>true</CODE> for 
every truth-assignment to <CODE>A</CODE> and <CODE>B</CODE>. Indeed the double negation
of Peirce's law may be proved in <FONT COLOR=navy>Coq</FONT>&nbsp; using <CODE>tauto</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Abort.</TT><BR>
<TT><I>Current&nbsp;goal&nbsp;aborted</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;NNPeirce&nbsp;:&nbsp;~&nbsp;~&nbsp;(((A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;A).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;~&nbsp;~&nbsp;(((A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;A)</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;tauto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>tauto.</I></TT><BR>
<TT><I>NNPeirce&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
In classical logic, the double negation of a proposition is equivalent to this 
proposition, but in the constructive logic of <FONT COLOR=navy>Coq</FONT>&nbsp; this is not so. If you 
want to use classical logic in <FONT COLOR=navy>Coq</FONT>, you have to import explicitly the
<CODE>Classical</CODE> module, which will declare the axiom <CODE>classic</CODE>
of excluded middle, and classical tautologies such as de Morgan's laws.
The <CODE>Require</CODE> command is used to import a module from <FONT COLOR=navy>Coq</FONT>'s library:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Classical.</TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;NNPP.</TT><BR>
<TT><I>NNPP</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;p&nbsp;:&nbsp;Prop,&nbsp;~&nbsp;~&nbsp;p&nbsp;-&gt;&nbsp;p</I></TT><BR>
</DIV>
<BR>
and it is now easy (although admittedly not the most direct way) to prove
a classical law such as Peirce's:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Peirce&nbsp;:&nbsp;((A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;A.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;((A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;A</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;NNPP;&nbsp;tauto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>apply&nbsp;NNPP;&nbsp;tauto.</I></TT><BR>
<TT><I>Peirce&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Here is one more example of propositional reasoning, in the shape of
a Scottish puzzle. A private club has the following rules:
<OL type=1><LI>
Every non-scottish member wears red socks
<LI>Every member wears a kilt or doesn't wear red socks
<LI>The married members don't go out on Sunday
<LI>A member goes out on Sunday if and only if he is Scottish
<LI>Every member who wears a kilt is Scottish and married
<LI>Every scottish member wears a kilt
</OL>
Now, we show that these rules are so strict that no one can be accepted.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;club.</TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Variables&nbsp;Scottish&nbsp;RedSocks&nbsp;WearKilt&nbsp;Married&nbsp;GoOutSunday&nbsp;:&nbsp;Prop.</TT><BR>
<TT><I>Scottish&nbsp;is&nbsp;assumed</I></TT><BR>
<TT><I>RedSocks&nbsp;is&nbsp;assumed</I></TT><BR>
<TT><I>WearKilt&nbsp;is&nbsp;assumed</I></TT><BR>
<TT><I>Married&nbsp;is&nbsp;assumed</I></TT><BR>
<TT><I>GoOutSunday&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;rule1&nbsp;:&nbsp;~&nbsp;Scottish&nbsp;-&gt;&nbsp;RedSocks.</TT><BR>
<TT><I>rule1&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;rule2&nbsp;:&nbsp;WearKilt&nbsp;\/&nbsp;~&nbsp;RedSocks.</TT><BR>
<TT><I>rule2&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;rule3&nbsp;:&nbsp;Married&nbsp;-&gt;&nbsp;~&nbsp;GoOutSunday.</TT><BR>
<TT><I>rule3&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;rule4&nbsp;:&nbsp;GoOutSunday&nbsp;&lt;-&gt;&nbsp;Scottish.</TT><BR>
<TT><I>rule4&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;rule5&nbsp;:&nbsp;WearKilt&nbsp;-&gt;&nbsp;Scottish&nbsp;/\&nbsp;Married.</TT><BR>
<TT><I>rule5&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;rule6&nbsp;:&nbsp;Scottish&nbsp;-&gt;&nbsp;WearKilt.</TT><BR>
<TT><I>rule6&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;NoMember&nbsp;:&nbsp;False.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Scottish&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;RedSocks&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;WearKilt&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Married&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;GoOutSunday&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;rule1&nbsp;:&nbsp;~&nbsp;Scottish&nbsp;-&gt;&nbsp;RedSocks</I></TT><BR>
<TT><I>&nbsp;&nbsp;rule2&nbsp;:&nbsp;WearKilt&nbsp;\/&nbsp;~&nbsp;RedSocks</I></TT><BR>
<TT><I>&nbsp;&nbsp;rule3&nbsp;:&nbsp;Married&nbsp;-&gt;&nbsp;~&nbsp;GoOutSunday</I></TT><BR>
<TT><I>&nbsp;&nbsp;rule4&nbsp;:&nbsp;GoOutSunday&nbsp;&lt;-&gt;&nbsp;Scottish</I></TT><BR>
<TT><I>&nbsp;&nbsp;rule5&nbsp;:&nbsp;WearKilt&nbsp;-&gt;&nbsp;Scottish&nbsp;/\&nbsp;Married</I></TT><BR>
<TT><I>&nbsp;&nbsp;rule6&nbsp;:&nbsp;Scottish&nbsp;-&gt;&nbsp;WearKilt</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;False</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;tauto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>tauto.</I></TT><BR>
<TT><I>NoMember&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>

At that point <CODE>NoMember</CODE> is a proof of the absurdity depending on
hypotheses.
We may end the section, in that case, the variables and hypotheses
will be discharged, and the type of <CODE>NoMember</CODE> will be
generalised.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;club.</TT><BR>
<TT><I>NoMember&nbsp;is&nbsp;discharged.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;NoMember.</TT><BR>
<TT><I>NoMember</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;Scottish&nbsp;RedSocks&nbsp;WearKilt&nbsp;Married&nbsp;GoOutSunday&nbsp;:&nbsp;Prop,</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(~&nbsp;Scottish&nbsp;-&gt;&nbsp;RedSocks)&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WearKilt&nbsp;\/&nbsp;~&nbsp;RedSocks&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Married&nbsp;-&gt;&nbsp;~&nbsp;GoOutSunday)&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(GoOutSunday&nbsp;&lt;-&gt;&nbsp;Scottish)&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WearKilt&nbsp;-&gt;&nbsp;Scottish&nbsp;/\&nbsp;Married)&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Scottish&nbsp;-&gt;&nbsp;WearKilt)&nbsp;-&gt;&nbsp;False</I></TT><BR>
</DIV>
<BR>
<!--CUT SECTION-->

<H2>

1.4&nbsp;Predicate Calculus
</H2>

Let us now move into predicate logic, and first of all into first-order
predicate calculus. The essence of predicate calculus is that to try to prove 
theorems in the most abstract possible way, without using the definitions of 
the mathematical notions, but by formal manipulations of uninterpreted 
function and predicate symbols. 

<H3>

1.4.1&nbsp;Sections and signatures
</H3>

Usually one works in some domain of discourse, over which range the individual 
variables and function symbols. In <FONT COLOR=navy>Coq</FONT>&nbsp; we speak in a language with a rich 
variety of types, so me may mix several domains of discourse, in our 
multi-sorted language. For the moment, we just do a few exercises, over a 
domain of discourse <CODE>D</CODE> axiomatised as a <CODE>Set</CODE>, and we consider two 
predicate symbols <CODE>P</CODE> and <CODE>R</CODE> over <CODE>D</CODE>, of arities 
respectively 1 and 2. Such abstract entities may be entered in the context
as global variables. But we must be careful about the pollution of our
global environment by such declarations. For instance, we have already 
polluted our <FONT COLOR=navy>Coq</FONT>&nbsp; session by declaring the variables
<CODE>n</CODE>, <CODE>Pos_n</CODE>, <CODE>A</CODE>, <CODE>B</CODE>, and <CODE>C</CODE>. If we want to revert to the clean state of
our initial session, we may use the <FONT COLOR=navy>Coq</FONT>&nbsp; <CODE>Reset</CODE> command, which returns
to the state just prior the given global notion as we did before to
remove a section, or we may return to the initial state using&nbsp;:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Reset&nbsp;Initial.</TT><BR>
</DIV>
<BR>
We shall now declare a new <CODE>Section</CODE>, which will allow us to define
notions local to a well-delimited scope. We start by assuming a domain of
discourse <CODE>D</CODE>, and a binary relation <CODE>R</CODE> over <CODE>D</CODE>: 

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;Predicate_calculus.</TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;D&nbsp;:&nbsp;Set.</TT><BR>
<TT><I>D&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop.</TT><BR>
<TT><I>R&nbsp;is&nbsp;assumed</I></TT><BR>
</DIV>
<BR>
As a simple example of predicate calculus reasoning, let us assume
that relation <CODE>R</CODE> is symmetric and transitive, and let us show that
<CODE>R</CODE> is reflexive in any point <CODE>x</CODE> which has an <CODE>R</CODE> successor.
Since we do not want to make the assumptions about <CODE>R</CODE> global axioms of 
a theory, but rather local hypotheses to a theorem, we open a specific
section to this effect.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;R_sym_trans.</TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;R_symmetric&nbsp;:&nbsp;forall&nbsp;x&nbsp;y:D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;x.</TT><BR>
<TT><I>R_symmetric&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;R_transitive&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z:D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z.</TT><BR>
<TT><I>R_transitive&nbsp;is&nbsp;assumed</I></TT><BR>
</DIV>
<BR>
Remark the syntax <CODE>forall x:D,</CODE> which stands for universal quantification
<FONT FACE=symbol>"</FONT> <I>x</I> : <I>D</I>.

<H3>

1.4.2&nbsp;Existential quantification
</H3>

We now state our lemma, and enter proof mode.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;refl_if&nbsp;:&nbsp;forall&nbsp;x:D,&nbsp;(exists&nbsp;y,&nbsp;R&nbsp;x&nbsp;y)&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_symmetric&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_transitive&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;:&nbsp;D,&nbsp;(exists&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y)&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;x</I></TT><BR>
</DIV>
<BR>
Remark that the hypotheses which are local to the currently opened sections
are listed as local hypotheses to the current goals.
The rationale is that these hypotheses are going to be discharged, as we
shall see, when we shall close the corresponding sections.<BR>
<BR>
Note the functional syntax for existential quantification. The existential
quantifier is built from the operator <CODE>ex</CODE>, which expects a 
predicate as argument:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;ex.</TT><BR>
<TT><I>ex</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;(A&nbsp;-&gt;&nbsp;Prop)&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
</DIV>

and the notation <CODE>(exists x:D, P x)</CODE> is just concrete syntax for 
<CODE>(ex D (fun x:D =&gt; P x))</CODE>. 
Existential quantification is handled in <FONT COLOR=navy>Coq</FONT>&nbsp; in a similar
fashion to the connectives <CODE>/\</CODE> and <CODE>\/</CODE> : it is introduced by
the proof combinator <CODE>ex_intro</CODE>, which is invoked by the specific 
tactic <CODE>Exists</CODE>, and its elimination provides a witness <CODE>a:D</CODE> to
<CODE>P</CODE>, together with an assumption <CODE>h:(P a)</CODE> that indeed <CODE>a</CODE>
verifies <CODE>P</CODE>. Let us see how this works on this simple example.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;x&nbsp;x_Rlinked.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_symmetric&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_transitive&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;x_Rlinked&nbsp;:&nbsp;exists&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;R&nbsp;x&nbsp;x</I></TT><BR>
</DIV>
<BR>
Remark that <CODE>intros</CODE> treats universal quantification in the same way
as the premises of implications. Renaming of bound variables occurs
when it is needed; for instance, had we started with <CODE>intro y</CODE>,
we would have obtained the goal:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;y.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_symmetric&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_transitive&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(exists&nbsp;y0&nbsp;:&nbsp;D,&nbsp;R&nbsp;y&nbsp;y0)&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;y</I></TT><BR>
</DIV>
<BR>
Let us now use the existential hypothesis <CODE>x_Rlinked</CODE> to 
exhibit an R-successor y of x. This is done in two steps, first with
<CODE>elim</CODE>, then with <CODE>intros</CODE><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;elim&nbsp;x_Rlinked.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_symmetric&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_transitive&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;x_Rlinked&nbsp;:&nbsp;exists&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;x0&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;x</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;y&nbsp;Rxy.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_symmetric&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_transitive&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;x_Rlinked&nbsp;:&nbsp;exists&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;Rxy&nbsp;:&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;R&nbsp;x&nbsp;x</I></TT><BR>
</DIV>
<BR>
Now we want to use <CODE>R_transitive</CODE>. The <CODE>apply</CODE> tactic will know
how to match <CODE>x</CODE> with <CODE>x</CODE>, and <CODE>z</CODE> with <CODE>x</CODE>, but needs
help on how to instantiate <CODE>y</CODE>, which appear in the hypotheses of
<CODE>R_transitive</CODE>, but not in its conclusion. We give the proper hint
to <CODE>apply</CODE> in a <CODE>with</CODE> clause, as follows:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;R_transitive&nbsp;with&nbsp;y.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_symmetric&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_transitive&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;x_Rlinked&nbsp;:&nbsp;exists&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;Rxy&nbsp;:&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;R&nbsp;y&nbsp;x</I></TT><BR>
</DIV>
<BR>
The rest of the proof is routine:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_symmetric&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;R_transitive&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;x_Rlinked&nbsp;:&nbsp;exists&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;Rxy&nbsp;:&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;R&nbsp;y&nbsp;x</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;R_symmetric;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
Let us now close the current section.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;R_sym_trans.</TT><BR>
<TT><I>refl_if&nbsp;is&nbsp;discharged.</I></TT><BR>
</DIV>
<BR>
Here <FONT COLOR=navy>Coq</FONT>'s printout is a warning that all local hypotheses have been 
discharged in the statement of <CODE>refl_if</CODE>, which now becomes a general
theorem in the first-order language declared in section 
<CODE>Predicate_calculus</CODE>. In this particular example, the use of section
<CODE>R_sym_trans</CODE> has not been really significant, since we could have
instead stated theorem <CODE>refl_if</CODE> in its general form, and done 
basically the same proof, obtaining <CODE>R_symmetric</CODE> and
<CODE>R_transitive</CODE> as local hypotheses by initial <CODE>intros</CODE> rather
than as global hypotheses in the context. But if we had pursued the
theory by proving more theorems about relation <CODE>R</CODE>,
we would have obtained all general statements at the closing of the section,
with minimal dependencies on the hypotheses of symmetry and transitivity.

<H3>

1.4.3&nbsp;Paradoxes of classical predicate calculus
</H3>

Let us illustrate this feature by pursuing our <CODE>Predicate_calculus</CODE>
section with an enrichment of our language: we declare a unary predicate
<CODE>P</CODE> and a constant <CODE>d</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;P&nbsp;:&nbsp;&nbsp;D&nbsp;-&gt;&nbsp;Prop.</TT><BR>
<TT><I>P&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;d&nbsp;:&nbsp;D.</TT><BR>
<TT><I>d&nbsp;is&nbsp;assumed</I></TT><BR>
</DIV>
<BR>
We shall now prove a well-known fact from first-order logic: a universal 
predicate is non-empty, or in other terms existential quantification 
follows from universal quantification.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;weird&nbsp;:&nbsp;(forall&nbsp;x:D,&nbsp;P&nbsp;x)&nbsp;-&gt;&nbsp;&nbsp;exists&nbsp;a,&nbsp;P&nbsp;a.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(forall&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x)&nbsp;-&gt;&nbsp;exists&nbsp;a&nbsp;:&nbsp;D,&nbsp;P&nbsp;a</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;intro&nbsp;UnivP.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;UnivP&nbsp;:&nbsp;forall&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;exists&nbsp;a&nbsp;:&nbsp;D,&nbsp;P&nbsp;a</I></TT><BR>
</DIV>
<BR>
First of all, notice the pair of parentheses around
<CODE>forall x:D, P x</CODE> in
the statement of lemma <CODE>weird</CODE>.
If we had omitted them, <FONT COLOR=navy>Coq</FONT>'s parser would have interpreted the
statement as a truly trivial fact, since we would 
postulate an <CODE>x</CODE> verifying <CODE>(P x)</CODE>. Here the situation is indeed
more problematic. If we have some element in <CODE>Set</CODE> <CODE>D</CODE>, we may
apply <CODE>UnivP</CODE> to it and conclude, otherwise we are stuck. Indeed
such an element <CODE>d</CODE> exists, but this is just by virtue of our
new signature. This points out a subtle difference between standard
predicate calculus and <FONT COLOR=navy>Coq</FONT>. In standard first-order logic,
the equivalent of lemma <CODE>weird</CODE> always holds, 
because such a rule is wired in the inference rules for quantifiers, the
semantic justification being that the interpretation domain is assumed to
be non-empty. Whereas in <FONT COLOR=navy>Coq</FONT>, where types are not assumed to be 
systematically inhabited, lemma <CODE>weird</CODE> only holds in signatures
which allow the explicit construction of an element in the domain of
the predicate. <BR>
<BR>
Let us conclude the proof, in order to show the use of the <CODE>Exists</CODE>
tactic:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;exists&nbsp;d;&nbsp;trivial.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intro&nbsp;UnivP.</I></TT><BR>
<TT><I>exists&nbsp;d;&nbsp;trivial.</I></TT><BR>
<TT><I>weird&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Another fact which illustrates the sometimes disconcerting rules of
classical 
predicate calculus is Smullyan's drinkers' paradox: ``In any non-empty
bar, there is a person such that if she drinks, then everyone drinks''.
We modelize the bar by Set <CODE>D</CODE>, drinking by predicate <CODE>P</CODE>.
We shall need classical reasoning. Instead of loading the <CODE>Classical</CODE>
module as we did above, we just state the law of excluded middle as a
local hypothesis schema at this point:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;EM&nbsp;:&nbsp;forall&nbsp;A:Prop,&nbsp;A&nbsp;\/&nbsp;~&nbsp;A.</TT><BR>
<TT><I>EM&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;drinker&nbsp;:&nbsp;&nbsp;exists&nbsp;x:D,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;x:D,&nbsp;P&nbsp;x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;EM&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;\/&nbsp;~&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;D,&nbsp;P&nbsp;x0</I></TT><BR>
</DIV>

The proof goes by cases on whether or not
there is someone who does not drink. Such reasoning by cases proceeds
by invoking the excluded middle principle, via <CODE>elim</CODE> of the
proper instance of <CODE>EM</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;elim&nbsp;(EM&nbsp;(exists&nbsp;x,&nbsp;~&nbsp;P&nbsp;x)).</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;EM&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;\/&nbsp;~&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x)&nbsp;-&gt;&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;D,&nbsp;P&nbsp;x0</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;~&nbsp;(exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x)&nbsp;-&gt;&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;D,&nbsp;P&nbsp;x0</I></TT><BR>
</DIV>
<BR>
We first look at the first case. Let Tom be the non-drinker:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;Non_drinker;&nbsp;elim&nbsp;Non_drinker;&nbsp;intros&nbsp;Tom&nbsp;Tom_does_not_drink.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;EM&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;\/&nbsp;~&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;Non_drinker&nbsp;:&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;Tom&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;Tom_does_not_drink&nbsp;:&nbsp;~&nbsp;P&nbsp;Tom</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;D,&nbsp;P&nbsp;x0</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;~&nbsp;(exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x)&nbsp;-&gt;&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;D,&nbsp;P&nbsp;x0</I></TT><BR>
</DIV>
<BR>
We conclude in that case by considering Tom, since his drinking leads to
a contradiction:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;exists&nbsp;Tom;&nbsp;intro&nbsp;Tom_drinks.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;EM&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;\/&nbsp;~&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;Non_drinker&nbsp;:&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;Tom&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;Tom_does_not_drink&nbsp;:&nbsp;~&nbsp;P&nbsp;Tom</I></TT><BR>
<TT><I>&nbsp;&nbsp;Tom_drinks&nbsp;:&nbsp;P&nbsp;Tom</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;~&nbsp;(exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x)&nbsp;-&gt;&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;D,&nbsp;P&nbsp;x0</I></TT><BR>
</DIV>
<BR>
There are several ways in which we may eliminate a contradictory case;
a simple one is to use the <CODE>absurd</CODE> tactic as follows:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;absurd&nbsp;(P&nbsp;Tom);&nbsp;trivial.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;EM&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;\/&nbsp;~&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;~&nbsp;(exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x)&nbsp;-&gt;&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;D,&nbsp;P&nbsp;x0</I></TT><BR>
</DIV>
<BR>
We now proceed with the second case, in which actually any person will do;
such a John Doe is given by the non-emptiness witness <CODE>d</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;No_nondrinker;&nbsp;exists&nbsp;d;&nbsp;intro&nbsp;d_drinks.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;EM&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;\/&nbsp;~&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;No_nondrinker&nbsp;:&nbsp;~&nbsp;(exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x)</I></TT><BR>
<TT><I>&nbsp;&nbsp;d_drinks&nbsp;:&nbsp;P&nbsp;d</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x</I></TT><BR>
</DIV>
<BR>
Now we consider any Dick in the bar, and reason by cases according to its
drinking or not:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;Dick;&nbsp;elim&nbsp;(EM&nbsp;(P&nbsp;Dick));&nbsp;trivial.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;EM&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;\/&nbsp;~&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;No_nondrinker&nbsp;:&nbsp;~&nbsp;(exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x)</I></TT><BR>
<TT><I>&nbsp;&nbsp;d_drinks&nbsp;:&nbsp;P&nbsp;d</I></TT><BR>
<TT><I>&nbsp;&nbsp;Dick&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;~&nbsp;P&nbsp;Dick&nbsp;-&gt;&nbsp;P&nbsp;Dick</I></TT><BR>
</DIV>
<BR>
The only non-trivial case is again treated by contradiction:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;Dick_does_not_drink;&nbsp;absurd&nbsp;(exists&nbsp;x,&nbsp;~&nbsp;P&nbsp;x);&nbsp;trivial.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Set</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;EM&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;\/&nbsp;~&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;No_nondrinker&nbsp;:&nbsp;~&nbsp;(exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x)</I></TT><BR>
<TT><I>&nbsp;&nbsp;d_drinks&nbsp;:&nbsp;P&nbsp;d</I></TT><BR>
<TT><I>&nbsp;&nbsp;Dick&nbsp;:&nbsp;D</I></TT><BR>
<TT><I>&nbsp;&nbsp;Dick_does_not_drink&nbsp;:&nbsp;~&nbsp;P&nbsp;Dick</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;~&nbsp;P&nbsp;x</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;exists&nbsp;Dick;&nbsp;trivial.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>elim&nbsp;(EM&nbsp;(exists&nbsp;x&nbsp;:&nbsp;_,&nbsp;~&nbsp;P&nbsp;x)).</I></TT><BR>
<TT><I>&nbsp;intro&nbsp;Non_drinker;&nbsp;elim&nbsp;Non_drinker;&nbsp;intros&nbsp;Tom&nbsp;Tom_does_not_drink.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;exists&nbsp;Tom;&nbsp;intro&nbsp;Tom_drinks.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;absurd&nbsp;(P&nbsp;Tom);&nbsp;trivial.</I></TT><BR>
<TT><I>&nbsp;intro&nbsp;No_nondrinker;&nbsp;exists&nbsp;d;&nbsp;intro&nbsp;d_drinks.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;intro&nbsp;Dick;&nbsp;elim&nbsp;(EM&nbsp;(P&nbsp;Dick));&nbsp;trivial.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;intro&nbsp;Dick_does_not_drink;&nbsp;absurd&nbsp;(exists&nbsp;x&nbsp;:&nbsp;_,&nbsp;~&nbsp;P&nbsp;x);&nbsp;trivial.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;exists&nbsp;Dick;&nbsp;trivial.</I></TT><BR>
<TT><I>drinker&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Now, let us close the main section and look at the complete statements
we proved:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;Predicate_calculus.</TT><BR>
<TT><I>refl_if&nbsp;is&nbsp;discharged.</I></TT><BR>
<TT><I>weird&nbsp;is&nbsp;discharged.</I></TT><BR>
<TT><I>drinker&nbsp;is&nbsp;discharged.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;refl_if.</TT><BR>
<TT><I>refl_if</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;(D&nbsp;:&nbsp;Set)&nbsp;(R&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;D&nbsp;-&gt;&nbsp;Prop),</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;x)&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z)&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;:&nbsp;D,&nbsp;(exists&nbsp;y&nbsp;:&nbsp;D,&nbsp;R&nbsp;x&nbsp;y)&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;x</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;weird.</TT><BR>
<TT><I>weird</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;(D&nbsp;:&nbsp;Set)&nbsp;(P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop),</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;-&gt;&nbsp;(forall&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x)&nbsp;-&gt;&nbsp;exists&nbsp;a&nbsp;:&nbsp;D,&nbsp;P&nbsp;a</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;drinker.</TT><BR>
<TT><I>drinker</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;(D&nbsp;:&nbsp;Set)&nbsp;(P&nbsp;:&nbsp;D&nbsp;-&gt;&nbsp;Prop),</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;A&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;\/&nbsp;~&nbsp;A)&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;x&nbsp;:&nbsp;D,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;D,&nbsp;P&nbsp;x0</I></TT><BR>
</DIV>
<BR>
Remark how the three theorems are completely generic in the most general 
fashion;
the domain <CODE>D</CODE> is discharged in all of them, <CODE>R</CODE> is discharged in
<CODE>refl_if</CODE> only, <CODE>P</CODE> is discharged only in <CODE>weird</CODE> and
<CODE>drinker</CODE>, along with the hypothesis that <CODE>D</CODE> is inhabited. 
Finally, the excluded middle hypothesis is discharged only in 
<CODE>drinker</CODE>.<BR>
<BR>
Note that the name <CODE>d</CODE> has vanished as well from
the statements of <CODE>weird</CODE> and <CODE>drinker</CODE>, 
since <FONT COLOR=navy>Coq</FONT>'s pretty-printer replaces
systematically a quantification such as <CODE>forall d:D, E</CODE>, where <CODE>d</CODE>
does not occur in <CODE>E</CODE>, by the functional notation <CODE>D-&gt;E</CODE>. 
Similarly the name <CODE>EM</CODE> does not appear in <CODE>drinker</CODE>. <BR>
<BR>
Actually, universal quantification, implication, 
as well as function formation, are
all special cases of one general construct of type theory called
<I><FONT COLOR=maroon>dependent product</FONT></I>. This is the mathematical construction 
corresponding to an indexed family of functions. A function 
<I>f</I><FONT FACE=symbol>Î</FONT> <FONT FACE=symbol>P</FONT> <I>x</I>:<I>D</I><FONT SIZE=5>·</FONT> <I>Cx</I> maps an element <I>x</I> of its domain <I>D</I> to its
(indexed) codomain <I>Cx</I>. Thus a proof of <FONT FACE=symbol>"</FONT> <I>x</I>:<I>D</I><FONT SIZE=5>·</FONT> <I>Px</I> is
a function mapping an element <I>x</I> of <I>D</I> to a proof of proposition <I>Px</I>.

<H3>

1.4.4&nbsp;Flexible use of local assumptions
</H3>

Very often during the course of a proof we want to retrieve a local
assumption and reintroduce it explicitly in the goal, for instance
in order to get a more general induction hypothesis. The tactic
<CODE>generalize</CODE> is what is needed here:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;Predicate_Calculus.</TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Variables&nbsp;P&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop.</TT><BR>
<TT><I>P&nbsp;is&nbsp;assumed</I></TT><BR>
<TT><I>Q&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;R&nbsp;:&nbsp;&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop.</TT><BR>
<TT><I>R&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;PQR&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;x&nbsp;y:nat,&nbsp;(R&nbsp;x&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;Q&nbsp;x)&nbsp;-&gt;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;Q&nbsp;x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;nat,&nbsp;(R&nbsp;x&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;Q&nbsp;x)&nbsp;-&gt;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;Q&nbsp;x</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;R&nbsp;x&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;Q&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;P&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;Q&nbsp;x</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;generalize&nbsp;H0.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;R&nbsp;x&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;Q&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;P&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;Q&nbsp;x</I></TT><BR>
</DIV>
<BR>
Sometimes it may be convenient to use a lemma, although we do not have
a direct way to appeal to such an already proven fact. The tactic <CODE>cut</CODE>
permits to use the lemma at this point, keeping the corresponding proof
obligation as a new subgoal:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;cut&nbsp;(R&nbsp;x&nbsp;x);&nbsp;trivial.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;R&nbsp;x&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;Q&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;P&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;R&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;R&nbsp;x&nbsp;x</I></TT><BR>
</DIV>

We clean the goal by doing an <CODE>Abort</CODE> command.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Abort.</TT><BR>
</DIV>


<H3>

1.4.5&nbsp;Equality
</H3>

The basic equality provided in <FONT COLOR=navy>Coq</FONT>&nbsp; is Leibniz equality, noted infix like
<CODE>x=y</CODE>, when <CODE>x</CODE> and <CODE>y</CODE> are two expressions of
type the same Set. The replacement of <CODE>x</CODE> by <CODE>y</CODE> in any
term is effected by a variety of tactics, such as <CODE>rewrite</CODE>
and <CODE>replace</CODE>. <BR>
<BR>
Let us give a few examples of equality replacement. Let us assume that
some arithmetic function <CODE>f</CODE> is null in zero:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat.</TT><BR>
<TT><I>f&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0.</TT><BR>
<TT><I>foo&nbsp;is&nbsp;assumed</I></TT><BR>
</DIV>
<BR>
We want to prove the following conditional equality:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;L1&nbsp;:&nbsp;forall&nbsp;k:nat,&nbsp;k&nbsp;=&nbsp;0&nbsp;-&gt;&nbsp;f&nbsp;k&nbsp;=&nbsp;k.</TT><BR>
</DIV>
<BR>
As usual, we first get rid of local assumptions with <CODE>intro</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;k&nbsp;E.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;k&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;E&nbsp;:&nbsp;k&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;f&nbsp;k&nbsp;=&nbsp;k</I></TT><BR>
</DIV>
<BR>
Let us now use equation <CODE>E</CODE> as a left-to-right rewriting:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;rewrite&nbsp;E.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;k&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;E&nbsp;:&nbsp;k&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
</DIV>

This replaced both occurrences of <CODE>k</CODE> by <CODE>O</CODE>. <BR>
<BR>
Now <CODE>apply foo</CODE> will finish the proof:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;foo.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros&nbsp;k&nbsp;E.</I></TT><BR>
<TT><I>rewrite&nbsp;E.</I></TT><BR>
<TT><I>apply&nbsp;foo.</I></TT><BR>
<TT><I>L1&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
When one wants to rewrite an equality in a right to left fashion, we should
use <CODE>rewrite &lt;- E</CODE> rather than <CODE>rewrite E</CODE> or the equivalent
<CODE>rewrite -&gt; E</CODE>. 
Let us now illustrate the tactic <CODE>replace</CODE>.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0.</TT><BR>
<TT><I>f10&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;L2&nbsp;:&nbsp;f&nbsp;(f&nbsp;1)&nbsp;=&nbsp;0.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;f&nbsp;(f&nbsp;1)&nbsp;=&nbsp;0</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;replace&nbsp;(f&nbsp;1)&nbsp;with&nbsp;0.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;0&nbsp;=&nbsp;f&nbsp;1</I></TT><BR>
</DIV>

What happened here is that the replacement left the first subgoal to be
proved, but another proof obligation was generated by the <CODE>replace</CODE>
tactic, as the second subgoal. The first subgoal is solved immediately
by applying lemma <CODE>foo</CODE>; the second one transitivity and then 
symmetry of equality, for instance with tactics <CODE>transitivity</CODE> and 
<CODE>symmetry</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;foo.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;f&nbsp;1</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;transitivity&nbsp;(f&nbsp;0);&nbsp;symmetry;&nbsp;trivial.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>

In case the equality <I>t</I>=<I>u</I> generated by <CODE>replace</CODE> <I>u</I> <CODE>with</CODE>
<I>t</I> is an assumption
(possibly modulo symmetry), it will be automatically proved and the
corresponding goal will not appear. For instance:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Restart.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;f&nbsp;(f&nbsp;1)&nbsp;=&nbsp;0</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;replace&nbsp;(f&nbsp;0)&nbsp;with&nbsp;0.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;f&nbsp;(f&nbsp;1)&nbsp;=&nbsp;0</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;rewrite&nbsp;f10;&nbsp;rewrite&nbsp;foo;&nbsp;trivial.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>replace&nbsp;(f&nbsp;0)&nbsp;with&nbsp;0.</I></TT><BR>
<TT><I>rewrite&nbsp;f10;&nbsp;rewrite&nbsp;foo;&nbsp;trivial.</I></TT><BR>
<TT><I>L2&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--CUT SECTION-->

<H2>

1.5&nbsp;Using definitions
</H2>

The development of mathematics does not simply proceed by logical 
argumentation from first principles: definitions are used in an essential way.
A formal development proceeds by a dual process of abstraction, where one
proves abstract statements in predicate calculus, and use of definitions, 
which in the contrary one instantiates general statements with particular 
notions in order to use the structure of mathematical values for the proof of
more specialised properties.

<H3>

1.5.1&nbsp;Unfolding definitions
</H3>

Assume that we want to develop the theory of sets represented as characteristic
predicates over some universe <CODE>U</CODE>. For instance:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;U&nbsp;:&nbsp;Type.</TT><BR>
<TT><I>U&nbsp;is&nbsp;assumed</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;set&nbsp;:=&nbsp;U&nbsp;-&gt;&nbsp;Prop.</TT><BR>
<TT><I>set&nbsp;is&nbsp;defined</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;element&nbsp;(x:U)&nbsp;(S:set)&nbsp;:=&nbsp;S&nbsp;x.</TT><BR>
<TT><I>element&nbsp;is&nbsp;defined</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;subset&nbsp;(A&nbsp;B:set)&nbsp;:=&nbsp;forall&nbsp;x:U,&nbsp;element&nbsp;x&nbsp;A&nbsp;-&gt;&nbsp;element&nbsp;x&nbsp;B.</TT><BR>
<TT><I>subset&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Now, assume that we have loaded a module of general properties about
relations over some abstract type <CODE>T</CODE>, such as transitivity:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;transitive&nbsp;(T:Type)&nbsp;(R:T&nbsp;-&gt;&nbsp;T&nbsp;-&gt;&nbsp;Prop)&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z:T,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z.</TT><BR>
<TT><I>transitive&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Now, assume that we want to prove that <CODE>subset</CODE> is a <CODE>transitive</CODE>
relation. 

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;subset_transitive&nbsp;:&nbsp;transitive&nbsp;set&nbsp;subset.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;transitive&nbsp;set&nbsp;subset</I></TT><BR>
</DIV>
<BR>
In order to make any progress, one needs to use the definition of
<CODE>transitive</CODE>. The <CODE>unfold</CODE> tactic, which replaces all
occurrences of a defined notion by its definition in the current goal,
may be used here.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;unfold&nbsp;transitive.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;set,&nbsp;subset&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;subset&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;subset&nbsp;x&nbsp;z</I></TT><BR>
</DIV>
<BR>
Now, we must unfold <CODE>subset</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;unfold&nbsp;subset.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;set,</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(forall&nbsp;x0&nbsp;:&nbsp;U,&nbsp;element&nbsp;x0&nbsp;x&nbsp;-&gt;&nbsp;element&nbsp;x0&nbsp;y)&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(forall&nbsp;x&nbsp;:&nbsp;U,&nbsp;element&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;element&nbsp;x&nbsp;z)&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;U,&nbsp;element&nbsp;x0&nbsp;x&nbsp;-&gt;&nbsp;element&nbsp;x0&nbsp;z</I></TT><BR>
</DIV>

Now, unfolding <CODE>element</CODE> would be a mistake, because indeed a simple proof
can be found by <CODE>auto</CODE>, keeping <CODE>element</CODE> an abstract predicate:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
Many variations on <CODE>unfold</CODE> are provided in <FONT COLOR=navy>Coq</FONT>. For instance,
we may selectively unfold one designated occurrence:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Undo&nbsp;2.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;set,&nbsp;subset&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;subset&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;subset&nbsp;x&nbsp;z</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;unfold&nbsp;subset&nbsp;at&nbsp;2.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;set,</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;subset&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;(forall&nbsp;x&nbsp;:&nbsp;U,&nbsp;element&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;element&nbsp;x&nbsp;z)&nbsp;-&gt;&nbsp;subset&nbsp;x&nbsp;z</I></TT><BR>
</DIV>
<BR>
One may also unfold a definition in a given local hypothesis, using the
<CODE>in</CODE> notation:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;set</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;set</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;set</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;subset&nbsp;x&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;forall&nbsp;x&nbsp;:&nbsp;U,&nbsp;element&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;element&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;subset&nbsp;x&nbsp;z</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;unfold&nbsp;subset&nbsp;in&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;set</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;set</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;set</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;forall&nbsp;x0&nbsp;:&nbsp;U,&nbsp;element&nbsp;x0&nbsp;x&nbsp;-&gt;&nbsp;element&nbsp;x0&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;forall&nbsp;x&nbsp;:&nbsp;U,&nbsp;element&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;element&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;subset&nbsp;x&nbsp;z</I></TT><BR>
</DIV>
<BR>
Finally, the tactic <CODE>red</CODE> does only unfolding of the head occurrence
of the current goal:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;red.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;set</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;set</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;set</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;forall&nbsp;x0&nbsp;:&nbsp;U,&nbsp;element&nbsp;x0&nbsp;x&nbsp;-&gt;&nbsp;element&nbsp;x0&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;forall&nbsp;x&nbsp;:&nbsp;U,&nbsp;element&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;element&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x0&nbsp;:&nbsp;U,&nbsp;element&nbsp;x0&nbsp;x&nbsp;-&gt;&nbsp;element&nbsp;x0&nbsp;z</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>unfold&nbsp;transitive&nbsp;in&nbsp;|-&nbsp;*.</I></TT><BR>
<TT><I>unfold&nbsp;subset&nbsp;at&nbsp;2&nbsp;in&nbsp;|-&nbsp;*.</I></TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>unfold&nbsp;subset&nbsp;in&nbsp;H.</I></TT><BR>
<TT><I>red&nbsp;in&nbsp;|-&nbsp;*.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>subset_transitive&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>


<H3>

1.5.2&nbsp;Principle of proof irrelevance
</H3>

Even though in principle the proof term associated with a verified lemma
corresponds to a defined value of the corresponding specification, such
definitions cannot be unfolded in <FONT COLOR=navy>Coq</FONT>: a lemma is considered an <I><FONT COLOR=maroon>opaque</FONT></I>
definition. This conforms to the mathematical tradition of <I><FONT COLOR=maroon>proof
irrelevance</FONT></I>: the proof of a logical proposition does not matter, and the
mathematical justification of a logical development relies only on
<I><FONT COLOR=maroon>provability</FONT></I> of the lemmas used in the formal proof. <BR>
<BR>
Conversely, ordinary mathematical definitions can be unfolded at will, they
are <I><FONT COLOR=maroon>transparent</FONT></I>. 
<BR>
<BR>
<!--CUT CHAPTER-->

<H1>

Chapter&nbsp;2: Induction
</H1>

<!--CUT SECTION-->

<H2>

2.1&nbsp;Data Types as Inductively Defined Mathematical Collections
</H2>

All the notions which were studied until now pertain to traditional
mathematical logic. Specifications of objects were abstract properties
used in reasoning more or less constructively; we are now entering
the realm of inductive types, which specify the existence of concrete
mathematical constructions.

<H3>

2.1.1&nbsp;Booleans
</H3>

Let us start with the collection of booleans, as they are specified
in the <FONT COLOR=navy>Coq</FONT>'s <CODE>Prelude</CODE> module: 

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;bool&nbsp;:&nbsp;&nbsp;Set&nbsp;:=&nbsp;true&nbsp;|&nbsp;false.</TT><BR>
<TT><I>bool&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>bool_rect&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>bool_ind&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>bool_rec&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Such a declaration defines several objects at once. First, a new
<CODE>Set</CODE> is declared, with name <CODE>bool</CODE>. Then the <I><FONT COLOR=maroon>constructors</FONT></I>
of this <CODE>Set</CODE> are declared, called <CODE>true</CODE> and <CODE>false</CODE>.
Those are analogous to introduction rules of the new Set <CODE>bool</CODE>.
Finally, a specific elimination rule for <CODE>bool</CODE> is now available, which
permits to reason by cases on <CODE>bool</CODE> values. Three instances are
indeed defined as new combinators in the global context: <CODE>bool_ind</CODE>,
a proof combinator corresponding to reasoning by cases,
<CODE>bool_rec</CODE>, an if-then-else programming construct,
and <CODE>bool_rect</CODE>, a similar combinator at the level of types.
Indeed:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;bool_ind.</TT><BR>
<TT><I>bool_ind</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Prop,&nbsp;P&nbsp;true&nbsp;-&gt;&nbsp;P&nbsp;false&nbsp;-&gt;&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;P&nbsp;b</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;bool_rec.</TT><BR>
<TT><I>bool_rec</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Set,&nbsp;P&nbsp;true&nbsp;-&gt;&nbsp;P&nbsp;false&nbsp;-&gt;&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;P&nbsp;b</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;bool_rect.</TT><BR>
<TT><I>bool_rect</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type,&nbsp;P&nbsp;true&nbsp;-&gt;&nbsp;P&nbsp;false&nbsp;-&gt;&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;P&nbsp;b</I></TT><BR>
</DIV>
<BR>
Let us for instance prove that every Boolean is true or false.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;duality&nbsp;:&nbsp;forall&nbsp;b:bool,&nbsp;b&nbsp;=&nbsp;true&nbsp;\/&nbsp;b&nbsp;=&nbsp;false.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;b&nbsp;=&nbsp;true&nbsp;\/&nbsp;b&nbsp;=&nbsp;false</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;b.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;bool</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;true&nbsp;\/&nbsp;b&nbsp;=&nbsp;false</I></TT><BR>
</DIV>
<BR>
We use the knowledge that <CODE>b</CODE> is a <CODE>bool</CODE> by calling tactic
<CODE>elim</CODE>, which is this case will appeal to combinator <CODE>bool_ind</CODE>
in order to split the proof according to the two cases:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;elim&nbsp;b.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;bool</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;true&nbsp;=&nbsp;true&nbsp;\/&nbsp;true&nbsp;=&nbsp;false</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;false&nbsp;=&nbsp;true&nbsp;\/&nbsp;false&nbsp;=&nbsp;false</I></TT><BR>
</DIV>
<BR>
It is easy to conclude in each case:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;left;&nbsp;trivial.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;bool</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;false&nbsp;=&nbsp;true&nbsp;\/&nbsp;false&nbsp;=&nbsp;false</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;right;&nbsp;trivial.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
Indeed, the whole proof can be done with the combination of the
<CODE>simple induction</CODE> tactic, which combines <CODE>intro</CODE> and <CODE>elim</CODE>,
with good old <CODE>auto</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Restart.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;Q&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;R&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;foo&nbsp;:&nbsp;f&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;f10&nbsp;:&nbsp;f&nbsp;1&nbsp;=&nbsp;f&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;U&nbsp;:&nbsp;Type</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;b&nbsp;=&nbsp;true&nbsp;\/&nbsp;b&nbsp;=&nbsp;false</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;simple&nbsp;induction&nbsp;b;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>simple&nbsp;induction&nbsp;b;&nbsp;auto.</I></TT><BR>
<TT><I>duality&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>


<H3>

2.1.2&nbsp;Natural numbers
</H3>

Similarly to Booleans, natural numbers are defined in the <CODE>Prelude</CODE>
module with constructors <CODE>S</CODE> and <CODE>O</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;nat&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;:&nbsp;nat</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat.</TT><BR>
<TT><I>nat&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>nat_rect&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>nat_ind&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>nat_rec&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
The elimination principles which are automatically generated are Peano's
induction principle, and a recursion operator:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;nat_ind.</TT><BR>
<TT><I>nat_ind</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;O&nbsp;-&gt;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;nat_rec.</TT><BR>
<TT><I>nat_rec</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Set,</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;O&nbsp;-&gt;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n</I></TT><BR>
</DIV>
<BR>
Let us start by showing how to program the standard primitive recursion
operator <CODE>prim_rec</CODE> from the more general <CODE>nat_rec</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;prim_rec&nbsp;:=&nbsp;nat_rec&nbsp;(fun&nbsp;i:nat&nbsp;=&gt;&nbsp;nat).</TT><BR>
<TT><I>prim_rec&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
That is, instead of computing for natural <CODE>i</CODE> an element of the indexed
<CODE>Set</CODE> <CODE>(P i)</CODE>, <CODE>prim_rec</CODE> computes uniformly an element of 
<CODE>nat</CODE>. Let us check the type of <CODE>prim_rec</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;prim_rec.</TT><BR>
<TT><I>prim_rec</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(fun&nbsp;_&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;nat)&nbsp;O&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;(fun&nbsp;_&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;nat)&nbsp;n&nbsp;-&gt;&nbsp;(fun&nbsp;_&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;nat)&nbsp;(S&nbsp;n))&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;(fun&nbsp;_&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;nat)&nbsp;n</I></TT><BR>
</DIV>
<BR>
Oops! Instead of the expected type <CODE>nat-&gt;(nat-&gt;nat-&gt;nat)-&gt;nat-&gt;nat</CODE> we
get an apparently more complicated expression. Indeed the type of
<CODE>prim_rec</CODE> is equivalent by rule <FONT FACE=symbol>b</FONT> to its expected type; this may
be checked in <FONT COLOR=navy>Coq</FONT>&nbsp; by command <CODE>Eval Cbv Beta</CODE>, which <FONT FACE=symbol>b</FONT>-reduces
an expression to its <I><FONT COLOR=maroon>normal form</FONT></I>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Eval&nbsp;cbv&nbsp;beta&nbsp;in</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;((fun&nbsp;_:nat&nbsp;=&gt;&nbsp;nat)&nbsp;O&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;y:nat,&nbsp;(fun&nbsp;_:nat&nbsp;=&gt;&nbsp;nat)&nbsp;y&nbsp;-&gt;&nbsp;(fun&nbsp;_:nat&nbsp;=&gt;&nbsp;nat)&nbsp;(S&nbsp;y))&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n:nat,&nbsp;(fun&nbsp;_:nat&nbsp;=&gt;&nbsp;nat)&nbsp;n).</TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;nat&nbsp;-&gt;&nbsp;(nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat)&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Set</I></TT><BR>
</DIV>
<BR>
Let us now show how to program addition with primitive recursion:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;addition&nbsp;(n&nbsp;m:nat)&nbsp;:=&nbsp;prim_rec&nbsp;m&nbsp;(fun&nbsp;p&nbsp;rec:nat&nbsp;=&gt;&nbsp;S&nbsp;rec)&nbsp;n.</TT><BR>
<TT><I>addition&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
That is, we specify that <CODE>(addition n m)</CODE> computes by cases on <CODE>n</CODE>
according to its main constructor; when <CODE>n = O</CODE>, we get <CODE>m</CODE>;
 when <CODE>n = S p</CODE>, we get <CODE>(S rec)</CODE>, where <CODE>rec</CODE> is the result
of the recursive computation <CODE>(addition p m)</CODE>. Let us verify it by
asking <FONT COLOR=navy>Coq</FONT>&nbsp;to compute for us say 2+3:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Eval&nbsp;compute&nbsp;in&nbsp;(addition&nbsp;(S&nbsp;(S&nbsp;O))&nbsp;(S&nbsp;(S&nbsp;(S&nbsp;O)))).</TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;S&nbsp;(S&nbsp;(S&nbsp;(S&nbsp;(S&nbsp;O))))</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(fun&nbsp;_&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;nat)&nbsp;(S&nbsp;(S&nbsp;O))</I></TT><BR>
</DIV>
<BR>
Actually, we do not have to do all explicitly. <FONT COLOR=navy>Coq</FONT> provides a
special syntax <TT>Fixpoint/match</TT> for generic primitive recursion,
and we could thus have defined directly addition as:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;plus&nbsp;(n&nbsp;m:nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;m</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;S&nbsp;(plus&nbsp;p&nbsp;m)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>plus&nbsp;is&nbsp;recursively&nbsp;defined</I></TT><BR>
</DIV>
<BR>
For the rest of the session, we shall clean up what we did so far with 
types <CODE>bool</CODE> and <CODE>nat</CODE>, in order to use the initial definitions
given in <FONT COLOR=navy>Coq</FONT>'s <CODE>Prelude</CODE> module, and not to get confusing error
messages due to our redefinitions. We thus revert to the state before
our definition of <CODE>bool</CODE> with the <CODE>Reset</CODE> command:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Reset&nbsp;bool.</TT><BR>
</DIV>


<H3>

2.1.3&nbsp;Simple proofs by induction
</H3>


Let us now show how to do proofs by structural induction. We start with easy
properties of the <CODE>plus</CODE> function we just defined. Let us first
show that <I>n</I>=<I>n</I>+0.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;plus_n_O&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;n&nbsp;=&nbsp;n&nbsp;+&nbsp;0.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;n&nbsp;=&nbsp;n&nbsp;+&nbsp;0</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;n;&nbsp;elim&nbsp;n.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;0&nbsp;+&nbsp;0</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;forall&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;n0&nbsp;=&nbsp;n0&nbsp;+&nbsp;0&nbsp;-&gt;&nbsp;S&nbsp;n0&nbsp;=&nbsp;S&nbsp;n0&nbsp;+&nbsp;0</I></TT><BR>
</DIV>
<BR>
What happened was that <CODE>elim n</CODE>, in order to construct a <CODE>Prop</CODE>
(the initial goal) from a <CODE>nat</CODE> (i.e. <CODE>n</CODE>), appealed to the
corresponding induction principle <CODE>nat_ind</CODE> which we saw was indeed
exactly Peano's induction scheme. Pattern-matching instantiated the 
corresponding predicate <CODE>P</CODE> to <CODE>fun n:nat =&gt; n = n </CODE> 0+, and we get
as subgoals the corresponding instantiations of the base case <CODE>(P O)</CODE> ,
and of the inductive step <CODE>forall y:nat, P y -&gt; P (S y)</CODE>.
In each case we get an instance of function <CODE>plus</CODE> in which its second
argument starts with a constructor, and is thus amenable to simplification
by primitive recursion. The <FONT COLOR=navy>Coq</FONT>&nbsp;tactic <CODE>simpl</CODE> can be used for
this purpose:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;simpl.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;forall&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;n0&nbsp;=&nbsp;n0&nbsp;+&nbsp;0&nbsp;-&gt;&nbsp;S&nbsp;n0&nbsp;=&nbsp;S&nbsp;n0&nbsp;+&nbsp;0</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;n0&nbsp;=&nbsp;n0&nbsp;+&nbsp;0&nbsp;-&gt;&nbsp;S&nbsp;n0&nbsp;=&nbsp;S&nbsp;n0&nbsp;+&nbsp;0</I></TT><BR>
</DIV>
<BR>
We proceed in the same way for the base step:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;simpl;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intro&nbsp;n;&nbsp;elim&nbsp;n.</I></TT><BR>
<TT><I>&nbsp;simpl&nbsp;in&nbsp;|-&nbsp;*.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;auto.</I></TT><BR>
<TT><I>&nbsp;simpl&nbsp;in&nbsp;|-&nbsp;*;&nbsp;auto.</I></TT><BR>
<TT><I>plus_n_O&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Here <CODE>auto</CODE> succeeded, because it used as a hint lemma <CODE>eq_S</CODE>,
which say that successor preserves equality:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;eq_S.</TT><BR>
<TT><I>eq_S</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;S&nbsp;x&nbsp;=&nbsp;S&nbsp;y</I></TT><BR>
</DIV>
<BR>
Actually, let us see how to declare our lemma <CODE>plus_n_O</CODE> as a hint
to be used by <CODE>auto</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Hint&nbsp;Resolve&nbsp;plus_n_O&nbsp;.</TT><BR>
</DIV>
<BR>
We now proceed to the similar property concerning the other constructor
<CODE>S</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;plus_n_S&nbsp;:&nbsp;forall&nbsp;n&nbsp;m:nat,&nbsp;S&nbsp;(n&nbsp;+&nbsp;m)&nbsp;=&nbsp;n&nbsp;+&nbsp;S&nbsp;m.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;S&nbsp;(n&nbsp;+&nbsp;m)&nbsp;=&nbsp;n&nbsp;+&nbsp;S&nbsp;m</I></TT><BR>
</DIV>
<BR>
We now go faster, remembering that tactic <CODE>simple induction</CODE> does the
necessary <CODE>intros</CODE> before applying <CODE>elim</CODE>. Factoring simplification
and automation in both cases thanks to tactic composition, we prove this
lemma in one line:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;simple&nbsp;induction&nbsp;n;&nbsp;simpl;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>simple&nbsp;induction&nbsp;n;&nbsp;simpl&nbsp;in&nbsp;|-&nbsp;*;&nbsp;auto.</I></TT><BR>
<TT><I>plus_n_S&nbsp;is&nbsp;defined</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hint&nbsp;Resolve&nbsp;plus_n_S&nbsp;.</TT><BR>
</DIV>
<BR>
Let us end this exercise with the commutativity of <CODE>plus</CODE>:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;plus_com&nbsp;:&nbsp;forall&nbsp;n&nbsp;m:nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;m&nbsp;+&nbsp;n.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;m&nbsp;+&nbsp;n</I></TT><BR>
</DIV>
<BR>
Here we have a choice on doing an induction on <CODE>n</CODE> or on <CODE>m</CODE>, the
situation being symmetric. For instance:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;simple&nbsp;induction&nbsp;m;&nbsp;simpl;&nbsp;auto.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;m&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;n0&nbsp;=&nbsp;n0&nbsp;+&nbsp;n&nbsp;-&gt;&nbsp;n&nbsp;+&nbsp;S&nbsp;n0&nbsp;=&nbsp;S&nbsp;(n0&nbsp;+&nbsp;n)</I></TT><BR>
</DIV>
<BR>
Here <CODE>auto</CODE> succeeded on the base case, thanks to our hint
<CODE>plus_n_O</CODE>, but the induction step requires rewriting, which
<CODE>auto</CODE> does not handle:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;m'&nbsp;E;&nbsp;rewrite&nbsp;&lt;-&nbsp;E;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>simple&nbsp;induction&nbsp;m;&nbsp;simpl&nbsp;in&nbsp;|-&nbsp;*;&nbsp;auto.</I></TT><BR>
<TT><I>intros&nbsp;m'&nbsp;E;&nbsp;rewrite&nbsp;&lt;-&nbsp;E;&nbsp;auto.</I></TT><BR>
<TT><I>plus_com&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>


<H3>

2.1.4&nbsp;Discriminate
</H3>

It is also possible to define new propositions by primitive recursion.
Let us for instance define the predicate which discriminates between
the constructors <CODE>O</CODE> and <CODE>S</CODE>: it computes to <CODE>False</CODE> 
when its argument is <CODE>O</CODE>, and to <CODE>True</CODE> when its argument is 
of the form <CODE>(S n)</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;Is_S&nbsp;(n:nat)&nbsp;:=&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;False</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;True</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>Is_S&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Now we may use the computational power of <CODE>Is_S</CODE> in order to prove
trivially that <CODE>(Is_S (S n))</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;S_Is_S&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;Is_S&nbsp;(S&nbsp;n).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;Is_S&nbsp;(S&nbsp;n)</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;simpl;&nbsp;trivial.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>simpl&nbsp;in&nbsp;|-&nbsp;*;&nbsp;trivial.</I></TT><BR>
<TT><I>S_Is_S&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
But we may also use it to transform a <CODE>False</CODE> goal into 
<CODE>(Is_S O)</CODE>. Let us show a particularly important use of this feature;
we want to prove that <CODE>O</CODE> and <CODE>S</CODE> construct different values, one
of Peano's axioms:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;no_confusion&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;0&nbsp;&lt;&gt;&nbsp;S&nbsp;n.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;0&nbsp;&lt;&gt;&nbsp;S&nbsp;n</I></TT><BR>
</DIV>
<BR>
First of all, we replace negation by its definition, by reducing the
goal with tactic <CODE>red</CODE>; then we get contradiction by successive
<CODE>intros</CODE>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;red;&nbsp;intros&nbsp;n&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;0&nbsp;=&nbsp;S&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;False</I></TT><BR>
</DIV>
<BR>
Now we use our trick:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;change&nbsp;(Is_S&nbsp;0).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;0&nbsp;=&nbsp;S&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;Is_S&nbsp;0</I></TT><BR>
</DIV>
<BR>
Now we use equality in order to get a subgoal which computes out to 
<CODE>True</CODE>, which finishes the proof:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;rewrite&nbsp;H;&nbsp;trivial.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;0&nbsp;=&nbsp;S&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;Is_S&nbsp;(S&nbsp;n)</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;simpl;&nbsp;trivial.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
Actually, a specific tactic <CODE>discriminate</CODE> is provided
to produce mechanically such proofs, without the need for the user to define
explicitly the relevant discrimination predicates:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Restart.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;0&nbsp;&lt;&gt;&nbsp;S&nbsp;n</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;n;&nbsp;discriminate.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intro&nbsp;n;&nbsp;discriminate.</I></TT><BR>
<TT><I>no_confusion&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--CUT SECTION-->

<H2>

2.2&nbsp;Logic programming
</H2>

In the same way as we defined standard data-types above, we
may define inductive families, and for instance inductive predicates.
Here is the definition of predicate <FONT FACE=symbol>£</FONT> over type <CODE>nat</CODE>, as
given in <FONT COLOR=navy>Coq</FONT>'s <CODE>Prelude</CODE> module:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;le&nbsp;(n:nat)&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;le_n&nbsp;:&nbsp;le&nbsp;n&nbsp;n</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;le_S&nbsp;:&nbsp;forall&nbsp;m:nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;n&nbsp;(S&nbsp;m).</TT><BR>
</DIV>
<BR>
This definition introduces a new predicate <CODE>le:nat-&gt;nat-&gt;Prop</CODE>,
and the two constructors <CODE>le_n</CODE> and <CODE>le_S</CODE>, which are the
defining clauses of <CODE>le</CODE>. That is, we get not only the ``axioms''
<CODE>le_n</CODE> and <CODE>le_S</CODE>, but also the converse property, that 
<CODE>(le n m)</CODE> if and only if this statement can be obtained as a
consequence of these defining clauses; that is, <CODE>le</CODE> is the
minimal predicate verifying clauses <CODE>le_n</CODE> and <CODE>le_S</CODE>. This is
insured, as in the case of inductive data types, by an elimination principle,
which here amounts to an induction principle <CODE>le_ind</CODE>, stating this 
minimality property:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;le.</TT><BR>
<TT><I>le</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;le_ind.</TT><BR>
<TT><I>le_ind</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop),</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;n&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;m))&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;n0</I></TT><BR>
</DIV>
<BR>
Let us show how proofs may be conducted with this principle.
First we show that <I>n</I><FONT FACE=symbol>£</FONT> <I>m</I> <FONT FACE=symbol>Þ</FONT> <I>n</I>+1<FONT FACE=symbol>£</FONT> <I>m</I>+1:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;le_n_S&nbsp;:&nbsp;forall&nbsp;n&nbsp;m:nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m)</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;n&nbsp;m&nbsp;n_le_m.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;m&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;n_le_m&nbsp;:&nbsp;le&nbsp;n&nbsp;m</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m)</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;elim&nbsp;n_le_m.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;m&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;n_le_m&nbsp;:&nbsp;le&nbsp;n&nbsp;m</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;n)</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;forall&nbsp;m0&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m0&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m0)&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;(S&nbsp;m0))</I></TT><BR>
</DIV>
<BR>
What happens here is similar to the behaviour of <CODE>elim</CODE> on natural
numbers: it appeals to the relevant induction principle, here <CODE>le_ind</CODE>,
which generates the two subgoals, which may then be solved easily
with the help of the defining clauses of <CODE>le</CODE>.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;le_n;&nbsp;trivial.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;m&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;n_le_m&nbsp;:&nbsp;le&nbsp;n&nbsp;m</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;m0&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m0&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m0)&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;(S&nbsp;m0))</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;intros;&nbsp;apply&nbsp;le_S;&nbsp;trivial.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
Now we know that it is a good idea to give the defining clauses as hints,
so that the proof may proceed with a simple combination of 
<CODE>induction</CODE> and <CODE>auto</CODE>.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Restart.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m)</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hint&nbsp;Resolve&nbsp;le_n&nbsp;le_S&nbsp;.</TT><BR>
</DIV>
<BR>
We have a slight problem however. We want to say ``Do an induction on
hypothesis <CODE>(le n m)</CODE>'', but we have no explicit name for it. What we
do in this case is to say ``Do an induction on the first unnamed hypothesis'',
as follows.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;simple&nbsp;induction&nbsp;1;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>simple&nbsp;induction&nbsp;1;&nbsp;auto.</I></TT><BR>
<TT><I>le_n_S&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Here is a more tricky problem. Assume we want to show that
<I>n</I><FONT FACE=symbol>£</FONT> 0 <FONT FACE=symbol>Þ</FONT> <I>n</I>=0. This reasoning ought to follow simply from the
fact that only the first defining clause of <CODE>le</CODE> applies.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;tricky&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;le&nbsp;n&nbsp;0&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;0.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;0&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;0</I></TT><BR>
</DIV>
<BR>
However, here trying something like <CODE>induction 1</CODE> would lead
nowhere (try it and see what happens). 
An induction on <CODE>n</CODE> would not be convenient either.
What we must do here is analyse the definition of <CODE>le</CODE> in order
to match hypothesis <CODE>(le n O)</CODE> with the defining clauses, to find
that only <CODE>le_n</CODE> applies, whence the result. 
This analysis may be performed by the ``inversion'' tactic
<CODE>inversion_clear</CODE> as follows:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;n&nbsp;H;&nbsp;inversion_clear&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;0</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;trivial.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR><BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros&nbsp;n&nbsp;H;&nbsp;inversion_clear&nbsp;H.</I></TT><BR>
<TT><I>trivial.</I></TT><BR>
<TT><I>tricky&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--CUT CHAPTER-->

<H1>

Chapter&nbsp;3: Modules
</H1>

<!--CUT SECTION-->

<H2>

3.1&nbsp;Opening library modules
</H2>

When you start <FONT COLOR=navy>Coq</FONT>&nbsp; without further requirements in the command line,
you get a bare system with few libraries loaded. As we saw, a standard
prelude module provides the standard logic connectives, and a few
arithmetic notions. If you want to load and open other modules from
the library, you have to use the <CODE>Require</CODE> command, as we saw for
classical logic above. For instance, if you want more arithmetic
constructions, you should request:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Arith.</TT><BR>
</DIV>
<BR>
Such a command looks for a (compiled) module file <CODE>Arith.vo</CODE> in
the libraries registered by <FONT COLOR=navy>Coq</FONT>. Libraries inherit the structure of
the file system of the operating system and are registered with the
command <CODE>Add LoadPath</CODE>. Physical directories are mapped to
logical directories. Especially the standard library of <FONT COLOR=navy>Coq</FONT>&nbsp; is
pre-registered as a library of name <CODE>Coq</CODE>. Modules have absolute
unique names denoting their place in <FONT COLOR=navy>Coq</FONT>&nbsp; libraries. An absolute
name is a sequence of single identifiers separated by dots. E.g. the
module <CODE>Arith</CODE> has full name <CODE>Coq.Arith.Arith</CODE> and because
it resides in eponym subdirectory <CODE>Arith</CODE> of the standard
library, it can be as well required by the command<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Coq.Arith.Arith.</TT><BR>
</DIV>
<BR>
This may be useful to avoid ambiguities if somewhere, in another branch
of the libraries known by Coq, another module is also called
<CODE>Arith</CODE>. Notice that by default, when a library is registered,
all its contents, and all the contents of its subdirectories recursively are
visible and accessible by a short (relative) name as <CODE>Arith</CODE>.
Notice also that modules or definitions not explicitly registered in
a library are put in a default library called <CODE>Top</CODE>.<BR>
<BR>
The loading of a compiled file is quick, because the corresponding
development is not type-checked again. <BR>
<BR>
<!--CUT SECTION-->

<H2>

3.2&nbsp;Creating your own modules
</H2>

You may create your own modules, by writing <FONT COLOR=navy>Coq</FONT>&nbsp; commands in a file,
say <CODE>my_module.v</CODE>. Such a module may be simply loaded in the current
context, with command <CODE>Load my_module</CODE>. It may also be compiled,
in ``batch'' mode, using the UNIX command
<CODE>coqc</CODE>. Compiling the module <CODE>my_module.v</CODE> creates a 
file <CODE>my_module.vo</CODE> that can be reloaded with command
<CODE>Require Import my_module</CODE>. <BR>
<BR>
If a required module depends on other modules then the latters are
automatically required beforehand. However their contents is not
automatically visible. If you want a module <CODE>M</CODE> required in a
module <CODE>N</CODE> to be automatically visible when <CODE>N</CODE> is required,
you should use <CODE>Require Export M</CODE> in your module <CODE>N</CODE>.<BR>
<BR>
<!--CUT SECTION-->

<H2>

3.3&nbsp;Managing the context
</H2>

It is often difficult to remember the names of all lemmas and
definitions available in the current context, especially if large
libraries have been loaded. A convenient <CODE>SearchAbout</CODE> command
is available to lookup all known facts 
concerning a given predicate. For instance, if you want to know all the
known lemmas about the less or equal relation, just ask:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;SearchAbout&nbsp;le.</TT><BR>
<TT><I>tricky:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;0&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>Top.le_n_S:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m)</I></TT><BR>
<TT><I>le_ind:</I></TT><BR>
<TT><I>&nbsp;&nbsp;forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop),</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;n&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;(forall&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;m))&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;forall&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;n0</I></TT><BR>
<TT><I>le_n:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;n</I></TT><BR>
<TT><I>le_S:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;n&nbsp;(S&nbsp;m)</I></TT><BR>
</DIV>

Another command <CODE>Search</CODE> displays only lemmas where the searched
predicate appears at the head position in the conclusion.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Search&nbsp;le.</TT><BR>
<TT><I>Top.le_n_S:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m)</I></TT><BR>
<TT><I>le_n:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;n</I></TT><BR>
<TT><I>le_S:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;n&nbsp;(S&nbsp;m)</I></TT><BR>
</DIV>
<BR>
A new and more convenient search tool is <FONT COLOR=purple>SearchPattern</FONT>
developed by Yves Bertot. It allows to find the theorems with a
conclusion matching a given pattern, where <CODE>\_</CODE> can be used in
place of an arbitrary term. We remark in this example, that <FONT COLOR=navy>Coq</FONT>
provides usual infix notations for arithmetic operators.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;SearchPattern&nbsp;(_&nbsp;+&nbsp;_&nbsp;=&nbsp;_).</TT><BR>
<TT><I>le_plus_minus_r:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=&nbsp;m&nbsp;-&gt;&nbsp;n&nbsp;+&nbsp;(m&nbsp;-&nbsp;n)&nbsp;=&nbsp;m</I></TT><BR>
<TT><I>mult_acc_aux:&nbsp;forall&nbsp;n&nbsp;m&nbsp;p&nbsp;:&nbsp;nat,&nbsp;m&nbsp;+&nbsp;n&nbsp;*&nbsp;p&nbsp;=&nbsp;mult_acc&nbsp;m&nbsp;p&nbsp;n</I></TT><BR>
<TT><I>plus_O_n:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;0&nbsp;+&nbsp;n&nbsp;=&nbsp;n</I></TT><BR>
<TT><I>plus_Sn_m:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;S&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;S&nbsp;(n&nbsp;+&nbsp;m)</I></TT><BR>
<TT><I>mult_n_Sm:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;*&nbsp;m&nbsp;+&nbsp;n&nbsp;=&nbsp;n&nbsp;*&nbsp;S&nbsp;m</I></TT><BR>
<TT><I>plus_0_l:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;0&nbsp;+&nbsp;n&nbsp;=&nbsp;n</I></TT><BR>
<TT><I>plus_0_r:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;0&nbsp;=&nbsp;n</I></TT><BR>
<TT><I>plus_comm:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;m&nbsp;+&nbsp;n</I></TT><BR>
<TT><I>plus_Snm_nSm:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;S&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;n&nbsp;+&nbsp;S&nbsp;m</I></TT><BR>
<TT><I>plus_assoc:&nbsp;forall&nbsp;n&nbsp;m&nbsp;p&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;(m&nbsp;+&nbsp;p)&nbsp;=&nbsp;n&nbsp;+&nbsp;m&nbsp;+&nbsp;p</I></TT><BR>
<TT><I>plus_permute:&nbsp;forall&nbsp;n&nbsp;m&nbsp;p&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;(m&nbsp;+&nbsp;p)&nbsp;=&nbsp;m&nbsp;+&nbsp;(n&nbsp;+&nbsp;p)</I></TT><BR>
<TT><I>plus_assoc_reverse:&nbsp;forall&nbsp;n&nbsp;m&nbsp;p&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;+&nbsp;p&nbsp;=&nbsp;n&nbsp;+&nbsp;(m&nbsp;+&nbsp;p)</I></TT><BR>
<TT><I>plus_permute_2_in_4:&nbsp;forall&nbsp;n&nbsp;m&nbsp;p&nbsp;q&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;+&nbsp;(p&nbsp;+&nbsp;q)&nbsp;=&nbsp;n&nbsp;+&nbsp;p&nbsp;+&nbsp;(m&nbsp;+&nbsp;q)</I></TT><BR>
<TT><I>plus_tail_plus:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;tail_plus&nbsp;n&nbsp;m</I></TT><BR>
<TT><I>plus_com:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;m&nbsp;+&nbsp;n</I></TT><BR>
</DIV>
<BR>
<!--CUT SECTION-->

<H2>

3.4&nbsp;Now you are on your own
</H2>

This tutorial is necessarily incomplete. If you wish to pursue serious
proving in <FONT COLOR=navy>Coq</FONT>, you should now get your hands on <FONT COLOR=navy>Coq</FONT>'s Reference Manual,
which contains a complete description of all the tactics we saw, 
plus many more.
You also should look in the library of developed theories which is distributed
with <FONT COLOR=navy>Coq</FONT>, in order to acquaint yourself with various proof techniques.<BR>
<BR>
<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL><DT><A NAME="note1" HREF="#text1"><FONT SIZE=5>1</FONT></A><DD>This research was partly supported by IST working group ``Types''
</DL>
<!--END NOTES-->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2>
<BLOCKQUOTE><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</EM></A><EM>.
</EM></BLOCKQUOTE>
</BODY>
</HTML>
