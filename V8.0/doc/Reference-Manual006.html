<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
<TITLE>
Calculus of Inductive Constructions
</TITLE>
</HEAD>
<BODY >
<A HREF="Reference-Manual005.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual007.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><A NAME="htoc82">Chapter&nbsp;4</A>&nbsp;&nbsp;Calculus of Inductive Constructions</H1>
<A NAME="Cic"></A>
<A NAME="@default276"></A>
<A NAME="@default277"></A>
<A NAME="@default278"></A>
The underlying formal language of <FONT COLOR=navy>Coq</FONT> is a <EM>Calculus of
 Constructions</EM> with <EM>Inductive Definitions</EM>. It is presented in
this chapter. 
For <FONT COLOR=navy>Coq</FONT> version V7, this Calculus was known as the
<EM>Calculus of (Co)Inductive Constructions</EM><A NAME="@default279"></A> (<FONT COLOR=navy>Cic</FONT> in short).
The underlying calculus of <FONT COLOR=navy>Coq</FONT> version V8.0 and up is a weaker
 calculus where the sort <FONT COLOR=purple>Set</FONT> satisfies predicative rules. 
We call this calculus the 
<EM>Predicative Calculus of (Co)Inductive
 Constructions</EM><A NAME="@default280"></A> (p<FONT COLOR=navy>Cic</FONT> in short).
In section&nbsp;<A HREF="#impredicativity">4.7</A> we give the extra-rules for <FONT COLOR=navy>Cic</FONT>. A
 compiling option of <FONT COLOR=navy>Coq</FONT> allows to type-check theories in this
 extended system.<BR>
<BR>
In p<FONT COLOR=navy>Cic</FONT>&nbsp; all objects have a <EM>type</EM>. There are types for functions (or
programs), there are atomic types (especially datatypes)... but also
types for proofs and types for the types themselves.
Especially, any object handled in the formalism must belong to a
type. For instance, the statement <I>``for all x, P''</I> is not
allowed in type theory; you must say instead: <I>``for all x
belonging to T, P''</I>. The expression <I>``x belonging to T''</I> is
written <I>``x:T''</I>. One also says: <I>``x has type T''</I>.
The terms of p<FONT COLOR=navy>Cic</FONT> are detailed in section <A HREF="#Terms">4.1</A>.<BR>
<BR>
In p<FONT COLOR=navy>Cic</FONT>&nbsp; there is an internal reduction mechanism. In particular, it
allows to decide if two programs are <EM>intentionally</EM> equal (one
says <EM>convertible</EM>). Convertibility is presented in section 
<A HREF="#convertibility">4.3</A>.<BR>
<BR>
The remaining sections are concerned with the type-checking of terms.
The beginner can skip them.<BR>
<BR>
The reader seeking a background on the Calculus of Inductive
Constructions may read several papers. Giménez&nbsp;[<A HREF="biblio.html#Gim98"><CITE>61</CITE></A>] provides
an introduction to inductive and coinductive definitions in Coq. In
their book&nbsp;[<A HREF="biblio.html#CoqArt"><CITE>13</CITE></A>], Bertot and Castéran give a precise
description of the p<FONT COLOR=navy>Cic</FONT> based on numerous practical examples.
Barras&nbsp;[<A HREF="biblio.html#Bar99"><CITE>9</CITE></A>], Werner&nbsp;[<A HREF="biblio.html#Wer94"><CITE>118</CITE></A>] and
Paulin-Mohring&nbsp;[<A HREF="biblio.html#Moh97"><CITE>104</CITE></A>] are the most recent theses dealing with
Inductive Definitions. Coquand-Huet&nbsp;[<A HREF="biblio.html#CoHu85a"><CITE>27</CITE></A><CITE>, </CITE><A HREF="biblio.html#CoHu85b"><CITE>28</CITE></A><CITE>, </CITE><A HREF="biblio.html#CoHu86"><CITE>29</CITE></A>]
introduces the Calculus of Constructions. Coquand-Paulin&nbsp;[<A HREF="biblio.html#CoPa89"><CITE>30</CITE></A>]
extended this calculus to inductive definitions. The p<FONT COLOR=navy>Cic</FONT> is a
formulation of type theory including the possibility of inductive
constructions, Barendregt&nbsp;[<A HREF="biblio.html#Bar91"><CITE>6</CITE></A>] studies the modern form of type
theory.<BR>
<BR>
<A NAME="toc22"></A>
<H2><A NAME="htoc83">4.1</A>&nbsp;&nbsp;The terms</H2><A NAME="Terms"></A>
In most type theories, one usually makes a syntactic distinction
between types and terms. This is not the case for p<FONT COLOR=navy>Cic</FONT> which defines
both types and terms in the same syntactical structure. This is
because the type-theory itself forces terms and types to be defined in
a mutual recursive way and also because similar constructions can be
applied to both terms and types and consequently can share the same
syntactic structure.<BR>
<BR>
Consider for instance the -&gt; constructor and assume <FONT COLOR=purple>nat</FONT> is the
type of natural numbers. Then -&gt; is used both to denote
<FONT COLOR=purple>nat</FONT>-&gt;<FONT COLOR=purple>nat</FONT> which is the type of functions from <FONT COLOR=purple>nat</FONT> to <FONT COLOR=purple>nat</FONT>, and
to denote <FONT COLOR=purple>nat</FONT> -&gt; <FONT COLOR=purple>Prop</FONT> which is the type of unary predicates over
the natural numbers. Consider abstraction which builds functions. It
serves to build ``ordinary'' functions as <FONT COLOR=purple>fun</FONT>&nbsp;<I>x</I>:<FONT COLOR=purple>nat</FONT> =&gt; (<TT><I>mult</I></TT> &nbsp;<I>x</I>&nbsp;<I>x</I>) (assuming <TT>mult</TT> is already defined) but may build also 
predicates over the natural numbers. For instance <FONT COLOR=purple>fun</FONT>&nbsp;<I>x</I>:<FONT COLOR=purple>nat</FONT> =&gt;
(<I>x</I>=<I>x</I>) will
represent a predicate <I>P</I>, informally written in mathematics
<I>P</I>(<I>x</I>)same as <I>x</I>=<I>x</I>. If <I>P</I> has type <FONT COLOR=purple>nat</FONT> -&gt; <FONT COLOR=purple>Prop</FONT>, (<I>P</I>&nbsp;<I>x</I>) is a
proposition, furthermore <FONT COLOR=purple>forall</FONT>&nbsp;<I>x</I>:<FONT COLOR=purple>nat</FONT>,(<I>P</I>&nbsp;<I>x</I>) will represent the type of
functions which associate to each natural number <I>n</I> an object of
type (<I>P</I>&nbsp;<I>n</I>) and consequently represent proofs of the formula
``for all <I>x</I>.<I>P</I>(<I>x</I>)''.<BR>
<BR>

<H3><A NAME="htoc84">4.1.1</A>&nbsp;&nbsp;Sorts</H3><A NAME="Sorts"></A>
<A NAME="@default281"></A>
Types are seen as terms of the language and then should belong to
another type. The type of a type is always a constant of the language
called a <EM>sort</EM>.<BR>
<BR>
The two basic sorts in the language of p<FONT COLOR=navy>Cic</FONT> are <FONT COLOR=purple>Set</FONT> and <FONT COLOR=purple>Prop</FONT>.<BR>
<BR>
The sort <FONT COLOR=purple>Prop</FONT> intends to be the type of logical propositions. If
<I>M</I> is a logical proposition then it denotes a class, namely the class
of terms representing proofs of <I>M</I>. An object <I>m</I> belonging to <I>M</I>
witnesses the fact that <I>M</I> is true. An object of type <FONT COLOR=purple>Prop</FONT> is
called a <EM>proposition</EM>.<BR>
<BR>
The sort <FONT COLOR=purple>Set</FONT> intends to be the type of specifications. This includes
programs and the usual sets such as booleans, naturals, lists
etc.<BR>
<BR>
These sorts themselves can be manipulated as ordinary terms.
Consequently sorts also should be given a type. Because assuming
simply that <FONT COLOR=purple>Set</FONT> has type <FONT COLOR=purple>Set</FONT> leads to an inconsistent theory, we
have infinitely many sorts in the language of p<FONT COLOR=navy>Cic</FONT>. These are, in
addition to <FONT COLOR=purple>Set</FONT> and <FONT COLOR=purple>Prop</FONT>&nbsp; a hierarchy of universes <FONT COLOR=purple>Type</FONT>(<I>i</I>)
for any integer <I>i</I>. We call <FONT COLOR=red> <I>S</I></FONT> the set of sorts
which is defined by:
<DIV ALIGN=center><FONT COLOR=red> <I>S</I></FONT> same as {<FONT COLOR=purple>Prop</FONT>,<FONT COLOR=purple>Set</FONT>,<FONT COLOR=purple>Type</FONT>(<I>i</I>)| <I>i</I> in <B><I>N</I></B>} </DIV>
<A NAME="@default282"></A>
<A NAME="@default283"></A>
<A NAME="@default284"></A>
The sorts enjoy the following properties: <FONT COLOR=purple>Prop</FONT>:<FONT COLOR=purple>Type</FONT>(0), <FONT COLOR=purple>Set</FONT>:<FONT COLOR=purple>Type</FONT>(0) and
 <FONT COLOR=purple>Type</FONT>(<I>i</I>):<FONT COLOR=purple>Type</FONT>(<I>i</I>+1).<BR>
<BR>
The user will never mention explicitly the index <I>i</I> when referring to
the universe <FONT COLOR=purple>Type</FONT>(<I>i</I>). One only writes <FONT COLOR=purple>Type</FONT>. The
system itself generates for each instance of <FONT COLOR=purple>Type</FONT> a new
index for the universe and checks that the constraints between these
indexes can be solved. From the user point of view we consequently
have <FONT COLOR=purple>Type :Type</FONT>.<BR>
<BR>
We shall make precise in the typing rules the constraints between the
indexes.<BR>
<BR>

<H3><A NAME="htoc85">4.1.2</A>&nbsp;&nbsp;Constants</H3>
Besides the sorts, the language also contains constants denoting
objects in the environment. These constants may denote previously
defined objects but also objects related to inductive definitions
(either the type itself or one of its constructors or destructors).<BR>
<BR>
<BR>
<B>Remark. </B> In other presentations of p<FONT COLOR=navy>Cic</FONT>, 
the inductive objects are not seen as
external declarations but as first-class terms. Usually the
definitions are also completely ignored. This is a nice theoretical
point of view but not so practical. An inductive definition is
specified by a possibly huge set of declarations, clearly we want to
share this specification among the various inductive objects and not
to duplicate it. So the specification should exist somewhere and the
various objects should refer to it. We choose one more level of
indirection where the objects are just represented as constants and
the environment gives the information on the kind of object the
constant refers to.<BR>
<BR>
<BR>
Our inductive objects will be manipulated as constants declared in the
environment. This roughly corresponds to the way they are actually
implemented in the <FONT COLOR=navy>Coq</FONT> system. It is simple to map this presentation
in a theory where inductive objects are represented by terms.<BR>
<BR>

<H3><A NAME="htoc86">4.1.3</A>&nbsp;&nbsp;Terms</H3>
Terms are built from variables, global names, constructors,
abstraction, application, local declarations bindings (``let-in''
expressions) and product.<BR>
<BR>
From a syntactic point of view, types cannot be distingued from terms,
except that they cannot start by an abstraction, and that if a term is
a sort or a product, it should be a type.<BR>
<BR>
More precisely the language of the <EM>Calculus of Inductive
 Constructions</EM> is built from the following rules:
<OL type=1><LI>
the sorts <FONT COLOR=purple>Set, Prop, Type</FONT> are terms.
<LI>names for global constants of the environment are terms.
<LI>variables are terms.
<LI>if <I>x</I> is a variable and <I>T</I>, <I>U</I> are terms then for all&nbsp;<I>x</I>:<I>T</I>,<I>U</I>
 (<FONT COLOR=purple>forall</FONT>&nbsp;<I>x</I>:<I>T</I>,<I>U</I> in <FONT COLOR=navy>Coq</FONT> concrete syntax) is a term. If <I>x</I>
 occurs in <I>U</I>, for all&nbsp;<I>x</I>:<I>T</I>,<I>U</I> reads as <I>``for all x of type T,
 U''</I>. As <I>U</I> depends on <I>x</I>, one says that for all&nbsp;<I>x</I>:<I>T</I>,<I>U</I> is a
 <EM>dependent product</EM>. If <I>x</I> doesn't occurs in <I>U</I> then
 for all&nbsp;<I>x</I>:<I>T</I>,<I>U</I> reads as <I>``if T then U''</I>. A non dependent
 product can be written: <I>T</I> -&gt; <I>U</I>.
<LI>if <I>x</I> is a variable and <I>T</I>, <I>U</I> are terms then lambda&nbsp;<I>x</I>:<I>T</I> , <I>U</I>
 (<FONT COLOR=purple>fun</FONT>&nbsp;<I>x</I>:<I>T</I>=&gt; <I>U</I> in <FONT COLOR=navy>Coq</FONT> concrete syntax) is a term. This is a
 notation for the lambda-abstraction of
 lambda-calculus<A NAME="@default285"></A>
 [<A HREF="biblio.html#Bar81"><CITE>8</CITE></A>]. The term lambda&nbsp;<I>x</I>:<I>T</I> , <I>U</I> is a function which maps
 elements of <I>T</I> to <I>U</I>.
<LI>if <I>T</I> and <I>U</I> are terms then (<I>T</I> <I>U</I>) is a term 
 (<I>T</I>&nbsp;<I>U</I> in <FONT COLOR=navy>Coq</FONT> concrete syntax). The term (<I>T</I> 
 <I>U</I>) reads as <I>``T applied to U''</I>.
<LI>if <I>x</I> is a variable, and <I>T</I>, <I>U</I> are terms then
 <FONT COLOR=purple>let</FONT>&nbsp;<I>x</I>:=<I>T</I>&nbsp;<FONT COLOR=purple>in</FONT>&nbsp;<I>U</I> is a
 term which denotes the term <I>U</I> where the variable <I>x</I> is locally
 bound to <I>T</I>. This stands for the common ``let-in'' construction of
 functional programs such as ML or Scheme.
</OL>

<H5>Notations.</H5> Application associates to the left such that
(<I>t</I>&nbsp;<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) represents (... (<I>t</I>&nbsp;<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>)... <I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>). The
products and arrows associate to the right such that for all&nbsp;<I>x</I>:<I>A</I>,<I>B</I>-&gt; <I>C</I>-&gt;
<I>D</I> represents for all&nbsp;<I>x</I>:<I>A</I>,(<I>B</I>-&gt; (<I>C</I>-&gt; <I>D</I>)). One uses sometimes
for all&nbsp;<I>x</I>&nbsp;<I>y</I>:<I>A</I>,<I>B</I> or
lambda&nbsp;<I>x</I>&nbsp;<I>y</I>:<I>A</I>, <I>B</I> to denote the abstraction or product of several variables
of the same type. The equivalent formulation is for all&nbsp;<I>x</I>:<I>A</I>, for all <I>y</I>:<I>A</I>,<I>B</I> or
lambda&nbsp;<I>x</I>:<I>A</I> , lambda <I>y</I>:<I>A</I> , <I>B</I><BR>
<BR>

<H5>Free variables.</H5>
The notion of free variables is defined as usual. In the expressions
lambda&nbsp;<I>x</I>:<I>T</I>, <I>U</I> and for all <I>x</I>:<I>T</I>, <I>U</I> the occurrences of <I>x</I> in <I>U</I>
are bound. They are represented by de Bruijn indexes in the internal
structure of terms.<BR>
<BR>

<H5>Substitution.</H5> <A NAME="@default286"></A>
The notion of substituting a term <I>t</I> to free occurrences of a
variable <I>x</I> in a term <I>u</I> is defined as usual. The resulting term
is written <I>u</I>{<I>x</I>/<I>t</I>}.<BR>
<BR>
<A NAME="toc23"></A>
<H2><A NAME="htoc87">4.2</A>&nbsp;&nbsp;Typed terms</H2><A NAME="Typed-terms"></A>
As objects of type theory, terms are subjected to <EM>type
discipline</EM>. The well typing of a term depends on an environment which
consists in a global environment (see below) and a local context.<BR>
<BR>

<H5>Local context.</H5>
A <EM>local context</EM> (or shortly context) is an ordered list of
declarations of variables. The declaration of some variable <I>x</I> is
either an assumption, written <I>x</I>:<I>T</I> (<I>T</I> is a type) or a definition,
written <I>x</I>:=<I>t</I>:<I>T</I>. We use brackets to write contexts. A
typical example is [<I>x</I>:<I>T</I>;<I>y</I>:=<I>u</I>:<I>U</I>;<I>z</I>:<I>V</I>]. Notice that the variables
declared in a context must be distinct. If Gamma declares some <I>x</I>,
we write <I>x</I> inGamma. By writing (<I>x</I>:<I>T</I>)inGamma we mean that
either <I>x</I>:<I>T</I> is an assumption in Gamma or that there exists some <I>t</I> such
that <I>x</I>:=<I>t</I>:<I>T</I> is a definition in Gamma. If Gamma defines some
<I>x</I>:=<I>t</I>:<I>T</I>, we also write (<I>x</I>:=<I>t</I>:<I>T</I>)inGamma. Contexts must be
themselves <EM>well formed</EM>. For the rest of the chapter, the
notation Gamma::(<I>y</I>:<I>T</I>) (resp Gamma::(<I>y</I>:=<I>t</I>:<I>T</I>)) denotes the context
Gamma enriched with the declaration <I>y</I>:<I>T</I> (resp <I>y</I>:=<I>t</I>:<I>T</I>). The
notation [] denotes the empty context. <A NAME="@default287"></A><BR>
<BR>
We define the inclusion of two contexts Gamma and Delta (written
as Gamma included in Delta) as the property, for all variable <I>x</I>,
type <I>T</I> and term <I>t</I>, if (<I>x</I>:<I>T</I>) in Gamma then (<I>x</I>:<I>T</I>)in Delta
and if (<I>x</I>:=<I>t</I>:<I>T</I>) in Gamma then (<I>x</I>:=<I>t</I>:<I>T</I>)in Delta. 
<BR>
<BR>
A variable <I>x</I> is said to be free in Gamma if Gamma contains a
declaration <I>y</I>:<I>T</I> such that <I>x</I> is free in <I>T</I>.<BR>
<BR>

<H5>Environment.</H5><A NAME="@default288"></A>
Because we are manipulating global declarations (constants and global
assumptions), we also need to consider a global environment <I>E</I>.<BR>
<BR>
An environment is an ordered list of declarations of global
names. Declarations are either assumptions or ``standard''
definitions, that is abbreviations for well-formed terms
but also definitions of inductive objects. In the latter
case, an object in the environment will define one or more constants
(that is types and constructors, see section <A HREF="#Cic-inductive-definitions">4.5</A>).<BR>
<BR>
An assumption will be represented in the environment as
<FONT COLOR=purple>Assum</FONT>(Gamma)(<I>c</I>:<I>T</I>) which means that <I>c</I> is assumed of some type <I>T</I>
well-defined in some context Gamma. An (ordinary) definition will
be represented in the environment as <FONT COLOR=purple>Def</FONT>(Gamma)(<I>c</I>:=<I>t</I>:<I>T</I>) which means
that <I>c</I> is a constant which is valid in some context Gamma whose
value is <I>t</I> and type is <I>T</I>.<BR>
<BR>
The rules for inductive definitions (see section
<A HREF="#Cic-inductive-definitions">4.5</A>) have to be considered as assumption
rules to which the following definitions apply: if the name <I>c</I> is
declared in <I>E</I>, we write <I>c</I> in <I>E</I> and if <I>c</I>:<I>T</I> or <I>c</I>:=<I>t</I>:<I>T</I> is
declared in <I>E</I>, we write (<I>c</I> : <I>T</I>) in <I>E</I>.<BR>
<BR>

<H5>Typing rules.</H5><A NAME="Typing-rules"></A><A NAME="@default289"></A>
In the following, we assume <I>E</I> is a valid environment wrt to
inductive definitions. We define simultaneously two
judgments. The first one <I>E</I>[Gamma] |- <I>t</I> : <I>T</I> means the term <I>t</I> is well-typed
and has type <I>T</I> in the environment <I>E</I> and context Gamma. The
second judgment <FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>)[Gamma] means that the environment <I>E</I> is
well-formed and the context Gamma is a valid context in this
environment. It also means a third property which makes sure that any
constant in <I>E</I> was defined in an environment which is included in
Gamma
<SUP><A NAME="text11" HREF="#note11">1</A></SUP>.<BR>
<BR>
A term <I>t</I> is well typed in an environment <I>E</I> iff there exists a
context Gamma and a term <I>T</I> such that the judgment <I>E</I>[Gamma] |- <I>t</I> : <I>T</I> can
be derived from the following rules.
<DL COMPACT=compact><DT>
<B>W-E</B><DD> <DIV ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>([])[[]]</DIV>
<DT><B>W-S</B><DD> <DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>T</I> : <I>s</I>&nbsp;&nbsp;&nbsp;&nbsp;<I>s</I>in <FONT COLOR=red> <I>S</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;<I>x</I> not in Gamma </TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>)[Gamma::(<I>x</I>:<I>T</I>)]</TD>
</TR></TABLE></TD>
<TD NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 </TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>t</I> : <I>T</I>&nbsp;&nbsp;&nbsp;&nbsp;<I>x</I> not in Gamma </TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>)[Gamma::(<I>x</I>:=<I>t</I>:<I>T</I>)]</TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
<DT><B>Def</B><DD> <DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>t</I> : <I>T</I>&nbsp;&nbsp;&nbsp;<I>c</I> not in <I>E</I>union Gamma</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>;<FONT COLOR=purple>Def</FONT>(Gamma)(<I>c</I>:=<I>t</I>:<I>T</I>))[Gamma]</TD>
</TR></TABLE></DIV>
<DT><B>Ax</B><DD> <A NAME="@default290"></A>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>)[Gamma]</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <FONT COLOR=purple>Prop</FONT> : <FONT COLOR=purple>Type</FONT>(<I>p</I>)</TD>
</TR></TABLE></TD>
<TD NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>)[Gamma]</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <FONT COLOR=purple>Set</FONT> : <FONT COLOR=purple>Type</FONT>(<I>q</I>)</TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>)[Gamma]&nbsp;&nbsp;&nbsp;&nbsp;<I>i</I>&lt;<I>j</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <FONT COLOR=purple>Type</FONT>(<I>i</I>) : <FONT COLOR=purple>Type</FONT>(<I>j</I>)</TD>
</TR></TABLE></DIV>
<DT><B>Var</B><DD><A NAME="@default291"></A>
 <DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center> <FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>)[Gamma]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<I>x</I>:<I>T</I>)inGamma&nbsp;&nbsp;or&nbsp;&nbsp;(<I>x</I>:=<I>t</I>:<I>T</I>)inGamma&nbsp;for some <I>t</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>x</I> : <I>T</I></TD>
</TR></TABLE></DIV>
<DT><B>Const</B><DD> <A NAME="@default292"></A>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>)[Gamma]&nbsp;&nbsp;&nbsp;&nbsp;(<I>c</I>:<I>T</I>) in <I>E</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>c</I> : <I>T</I></TD>
</TR></TABLE></DIV>
<DT><B>Prod</B><DD> <A NAME="@default293"></A>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>T</I> : <I>s</I>&nbsp;&nbsp;&nbsp;&nbsp;<I>s</I> in <FONT COLOR=red> <I>S</I></FONT>&nbsp;&nbsp;&nbsp;
 <I>E</I>[Gamma::(<I>x</I>:<I>T</I>)] |- <I>U</I> : <FONT COLOR=purple>Prop</FONT></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center> <I>E</I>[Gamma] |- for all&nbsp;<I>x</I>:<I>T</I>,<I>U</I> : <FONT COLOR=purple>Prop</FONT></TD>
</TR></TABLE></DIV> 
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>T</I> : <I>s</I>&nbsp;&nbsp;&nbsp;&nbsp;<I>s</I>in{<FONT COLOR=purple>Prop</FONT>, <FONT COLOR=purple>Set</FONT>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <I>E</I>[Gamma::(<I>x</I>:<I>T</I>)] |- <I>U</I> : <FONT COLOR=purple>Set</FONT></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center> <I>E</I>[Gamma] |- for all&nbsp;<I>x</I>:<I>T</I>,<I>U</I> : <FONT COLOR=purple>Set</FONT></TD>
</TR></TABLE></DIV> 
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>T</I> : <FONT COLOR=purple>Type</FONT>(<I>i</I>)&nbsp;&nbsp;&nbsp;&nbsp;<I>i</I>&lt;= <I>k</I>&nbsp;&nbsp;&nbsp;
 <I>E</I>[Gamma::(<I>x</I>:<I>T</I>)] |- <I>U</I> : <FONT COLOR=purple>Type</FONT>(<I>j</I>)&nbsp;&nbsp;&nbsp;<I>j</I> &lt;= <I>k</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- for all&nbsp;<I>x</I>:<I>T</I>,<I>U</I> : <FONT COLOR=purple>Type</FONT>(<I>k</I>)</TD>
</TR></TABLE></DIV>
<DT><B>Lam</B><DD><A NAME="@default294"></A> 
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- for all&nbsp;<I>x</I>:<I>T</I>,<I>U</I> : <I>s</I>&nbsp;&nbsp;&nbsp;&nbsp; <I>E</I>[Gamma::(<I>x</I>:<I>T</I>)] |- <I>t</I> : <I>U</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- lambda&nbsp;<I>x</I>:<I>T</I>, <I>t</I> : for all <I>x</I>:<I>T</I>, <I>U</I></TD>
</TR></TABLE></DIV>
<DT><B>App</B><DD><A NAME="@default295"></A>
 <DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>t</I> : for all&nbsp;<I>x</I>:<I>U</I>,<I>T</I>&nbsp;&nbsp;&nbsp;&nbsp;<I>E</I>[Gamma] |- <I>u</I> : <I>U</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- (<I>t</I> <I>u</I>) : <I>T</I>{<I>x</I>/<I>u</I>}</TD>
</TR></TABLE></DIV>
<DT><B>Let</B><DD><A NAME="@default296"></A> 
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>t</I> : <I>T</I>&nbsp;&nbsp;&nbsp;&nbsp; <I>E</I>[Gamma::(<I>x</I>:=<I>t</I>:<I>T</I>)] |- <I>u</I> : <I>U</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <FONT COLOR=purple>let</FONT>&nbsp;<I>x</I>:=<I>t</I>&nbsp;<FONT COLOR=purple>in</FONT>&nbsp;<I>u</I> : <I>U</I>{<I>x</I>/<I>t</I>}</TD>
</TR></TABLE></DIV>
</DL>
<BR>
<B>Remark: </B>We may have <FONT COLOR=purple>let</FONT>&nbsp;<I>x</I>:=<I>t</I>&nbsp;<FONT COLOR=purple>in</FONT>&nbsp;<I>u</I>
well-typed without having ((lambda&nbsp;<I>x</I>:<I>T</I>, <I>u</I>)&nbsp;<I>t</I>) well-typed (where
<I>T</I> is a type of <I>t</I>). This is because the value <I>t</I> associated to <I>x</I>
may be used in a conversion rule (see section <A HREF="#conv-rules">4.3</A>).<BR>
<BR>
<A NAME="toc24"></A>
<H2><A NAME="htoc88">4.3</A>&nbsp;&nbsp;Conversion rules</H2>
<A NAME="@default297"></A>
<A NAME="conv-rules"></A>

<H5>beta-reduction.</H5>
<A NAME="beta"></A><A NAME="@default298"></A>
We want to be able to identify some terms as we can identify the
application of a function to a given argument with its result. For
instance the identity function over a given type <I>T</I> can be written
lambda&nbsp;<I>x</I>:<I>T</I>, <I>x</I>. In any environment <I>E</I> and context Gamma, we want to identify any object <I>a</I> (of type <I>T</I>) with the
application ((lambda&nbsp;<I>x</I>:<I>T</I>, <I>x</I>)&nbsp;<I>a</I>). We define for this a <EM>reduction</EM> (or a
<EM>conversion</EM>) rule we call beta:
<DIV ALIGN=center> <I>E</I>[Gamma] |- ((lambda&nbsp;<I>x</I>:<I>T</I>,
 <I>t</I>)&nbsp;<I>u</I>) |&gt;<SUB><FONT SIZE=2>beta</FONT></SUB> <I>t</I>{<I>x</I>/<I>u</I>} </DIV> 
We say that <I>t</I>{<I>x</I>/<I>u</I>} is the <EM>beta-contraction</EM> of
((lambda&nbsp;<I>x</I>:<I>T</I>, <I>t</I>)&nbsp;<I>u</I>) and, conversely, that ((lambda&nbsp;<I>x</I>:<I>T</I>, <I>t</I>)&nbsp;<I>u</I>)
is the <EM>beta-expansion</EM> of <I>t</I>{<I>x</I>/<I>u</I>}.<BR>
<BR>
According to beta-reduction, terms of the <EM>Calculus of
 Inductive Constructions</EM> enjoy some fundamental properties such as
confluence, strong normalization, subject reduction. These results are
theoretically of great importance but we will not detail them here and
refer the interested reader to [<A HREF="biblio.html#Coq85"><CITE>21</CITE></A>].<BR>
<BR>

<H5>iota-reduction.</H5>
<A NAME="iota"></A><A NAME="@default299"></A>
A specific conversion rule is associated to the inductive objects in
the environment. We shall give later on (section <A HREF="#iotared">4.5.4</A>) the
precise rules but it just says that a destructor applied to an object
built from a constructor behaves as expected. This reduction is
called iota-reduction and is more precisely studied in
[<A HREF="biblio.html#Moh93"><CITE>103</CITE></A><CITE>, </CITE><A HREF="biblio.html#Wer94"><CITE>118</CITE></A>].<BR>
<BR>

<H5>delta-reduction.</H5>
<A NAME="delta"></A><A NAME="@default300"></A>
We may have defined variables in contexts or constants in the global
environment. It is legal to identify such a reference with its value,
that is to expand (or unfold) it into its value. This
reduction is called delta-reduction and shows as follows.<BR>
<DIV ALIGN=center><I>E</I>[Gamma] |- <I>x</I> |&gt;<SUB><FONT SIZE=2>delta</FONT></SUB> <I>t</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (<I>x</I>:=<I>t</I>:<I>T</I>)inGamma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>E</I>[Gamma] |- <I>c</I> |&gt;<SUB><FONT SIZE=2>delta</FONT></SUB> <I>t</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (<I>c</I>:=<I>t</I>:<I>T</I>)in <I>E</I></DIV><BR>

<H5>zeta-reduction.</H5>
<A NAME="zeta"></A><A NAME="@default301"></A>
Coq allows also to remove local definitions occurring in terms by
replacing the defined variable by its value. The declaration being
destroyed, this reduction differs from delta-reduction. It is
called zeta-reduction and shows as follows.<BR>
<DIV ALIGN=center><I>E</I>[Gamma] |- <FONT COLOR=purple>let</FONT>&nbsp;<I>x</I>:=<I>u</I>&nbsp;<FONT COLOR=purple>in</FONT>&nbsp;<I>t</I> |&gt;<SUB><FONT SIZE=2>zeta</FONT></SUB> <I>t</I>{<I>x</I>/<I>u</I>}</DIV><BR>

<H5>Convertibility.</H5>
<A NAME="convertibility"></A>
<A NAME="@default302"></A><A NAME="@default303"></A><A NAME="@default304"></A><A NAME="@default305"></A>
Let us write <I>E</I>[Gamma] |- <I>t</I> |&gt; <I>u</I> for the contextual closure of the relation <I>t</I> reduces to <I>u</I> in the environment <I>E</I> and context Gamma with one of the previous reduction beta, iota, delta or zeta.<BR>
<BR>
We say that two terms <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> are <EM>convertible</EM> (or <EM>equivalent)</EM> in the environment <I>E</I> and context Gamma iff there exists a term <I>u</I> such that <I>E</I>[Gamma] |- <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> |&gt; ... |&gt; <I>u</I>
and <I>E</I>[Gamma] |- <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> |&gt; ... |&gt; <I>u</I>.
We then write <I>E</I>[Gamma] |- <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> =<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB> <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB>.<BR>
<BR>
The convertibility relation allows to introduce a new typing rule
which says that two convertible well-formed types have the same
inhabitants.<BR>
<BR>
At the moment, we did not take into account one rule between universes
which says that any term in a universe of index <I>i</I> is also a term in
the universe of index <I>i</I>+1. This property is included into the
conversion rule by extending the equivalence relation of
convertibility into an order inductively defined by:
<OL type=1><LI>
if <I>E</I>[Gamma] |- <I>t</I> =<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB> <I>u</I> then <I>E</I>[Gamma] |- <I>t</I> &lt;=<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB> <I>u</I>,
<LI>if <I>i</I> &lt;= <I>j</I> then <I>E</I>[Gamma] |- <FONT COLOR=purple>Type</FONT>(<I>i</I>) &lt;=<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB> <FONT COLOR=purple>Type</FONT>(<I>j</I>),
<LI>for any <I>i</I>, <I>E</I>[Gamma] |- <FONT COLOR=purple>Prop</FONT> &lt;=<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB> <FONT COLOR=purple>Type</FONT>(<I>i</I>),
<LI>for any <I>i</I>, <I>E</I>[Gamma] |- <FONT COLOR=purple>Set</FONT> &lt;=<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB> <FONT COLOR=purple>Type</FONT>(<I>i</I>),
<LI>if <I>E</I>[Gamma] |- <I>T</I> =<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB> <I>U</I> and <I>E</I>[Gamma::(<I>x</I>:<I>T</I>)] |- <I>T</I>' &lt;=<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB> <I>U</I>' then <I>E</I>[Gamma] |- for all&nbsp;<I>x</I>:<I>T</I>,<I>T</I>' &lt;=<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB> for all&nbsp;<I>x</I>:<I>U</I>,<I>U</I>'.
</OL>
The conversion rule is now exactly:
<DL COMPACT=compact><DT><A NAME="Conv"></A>
<B>Conv</B><DD><A NAME="@default306"></A>
 <DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP>
 </TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>U</I> : <I>s</I>&nbsp;&nbsp;&nbsp;&nbsp;<I>E</I>[Gamma] |- <I>t</I> : <I>T</I>&nbsp;&nbsp;&nbsp;&nbsp;<I>E</I>[Gamma] |- <I>T</I> &lt;=<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB> <I>U</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>t</I> : <I>U</I></TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
 </DL>

<H5>eta-conversion.
<A NAME="eta"></A>
<A NAME="@default307"></A>
<A NAME="@default308"></A></H5>
An other important rule is the eta-conversion. It is to identify
terms over a dummy abstraction of a variable followed by an
application of this variable. Let <I>T</I> be a type, <I>t</I> be a term in
which the variable <I>x</I> doesn't occurs free. We have
<DIV ALIGN=center> <I>E</I>[Gamma] |- lambda&nbsp;<I>x</I>:<I>T</I>, (<I>t</I> <I>x</I>) |&gt; <I>t</I> </DIV>
Indeed, as <I>x</I> doesn't occur free in <I>t</I>, for any <I>u</I> one
applies to lambda&nbsp;<I>x</I>:<I>T</I>, (<I>t</I> <I>x</I>), it beta-reduces to (<I>t</I> <I>u</I>). So
lambda&nbsp;<I>x</I>:<I>T</I>, (<I>t</I> <I>x</I>) and <I>t</I> can be identified.<BR>
<BR>
<BR>
<B>Remark: </B>The eta-reduction is not taken into account in the
convertibility rule of <FONT COLOR=navy>Coq</FONT>.<BR>
<BR>

<H5>Normal form.</H5><A NAME="@default309"></A><A NAME="Normal-form"></A><A NAME="Head-normal-form"></A><A NAME="@default310"></A>
A term which cannot be any more reduced is said to be in <EM>normal
 form</EM>. There are several ways (or strategies) to apply the reduction
rule. Among them, we have to mention the <EM>head reduction</EM> which
will play an important role (see chapter <A HREF="Reference-Manual010.html#Tactics">8</A>). Any term can
be written as lambda&nbsp;<I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>T</I><SUB><FONT SIZE=2>1</FONT></SUB>, ... lambda <I>x</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>:<I>T</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB> , 
(<I>t</I><SUB><FONT SIZE=2>0</FONT></SUB> <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) where
<I>t</I><SUB><FONT SIZE=2>0</FONT></SUB> is not an application. We say then that <I>t</I><SUB><FONT SIZE=2>0</FONT></SUB> is the <EM>head
 of <I>t</I></EM>. If we assume that <I>t</I><SUB><FONT SIZE=2>0</FONT></SUB> is lambda&nbsp;<I>x</I>:<I>T</I>, <I>u</I><SUB><FONT SIZE=2>0</FONT></SUB> then one step of
beta-head reduction of <I>t</I> is:
<DIV ALIGN=center>lambda&nbsp;<I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>T</I><SUB><FONT SIZE=2>1</FONT></SUB>, ... lambda <I>x</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>:<I>T</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>, (lambda&nbsp;<I>x</I>:<I>T</I>, <I>u</I><SUB><FONT SIZE=2>0</FONT></SUB> <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) 
&nbsp;|&gt; &nbsp; lambda&nbsp;(<I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>T</I><SUB><FONT SIZE=2>1</FONT></SUB>)...(<I>x</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>:<I>T</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>), 
(<I>u</I><SUB><FONT SIZE=2>0</FONT></SUB>{<I>x</I>/<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>} <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> ... <I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>)</DIV>
Iterating the process of head reduction until the head of the reduced
term is no more an abstraction leads to the <EM>beta-head normal
 form</EM> of <I>t</I>:
<DIV ALIGN=center> <I>t</I> |&gt; ... |&gt;
lambda&nbsp;<I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>T</I><SUB><FONT SIZE=2>1</FONT></SUB>, ...lambda <I>x</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>:<I>T</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>, (<I>v</I> <I>u</I><SUB><FONT SIZE=2>1</FONT></SUB>
... <I>u</I><SUB><FONT SIZE=2><I>m</I></FONT></SUB>)</DIV>
where <I>v</I> is not an abstraction (nor an application). Note that the
head normal form must not be confused with the normal form since some
<I>u</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> can be reducible.<BR>
<BR>
Similar notions of head-normal forms involving delta, iota and zeta
reductions or any combination of those can also be defined.<BR>
<BR>
<A NAME="toc25"></A>
<H2><A NAME="htoc89">4.4</A>&nbsp;&nbsp;Derived rules for environments</H2>
From the original rules of the type system, one can derive new rules
which change the context of definition of objects in the environment.
Because these rules correspond to elementary operations in the <FONT COLOR=navy>Coq</FONT> 
engine used in the discharge mechanism at the end of a section, we
state them explicitly.<BR>
<BR>

<H5>Mechanism of substitution.</H5>
One rule which can be proved valid, is to replace a term <I>c</I> by its
value in the environment. As we defined the substitution of a term for
a variable in a term, one can define the substitution of a term for a
constant. One easily extends this substitution to contexts and
environments.<BR>
<BR>

<H5>Substitution Property:</H5> 
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>;<FONT COLOR=purple>Def</FONT>(Gamma)(<I>c</I>:=<I>t</I>:<I>T</I>); <I>F</I>)[Delta]</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>; <I>F</I>{<I>c</I>/<I>t</I>})[Delta{<I>c</I>/<I>t</I>}]</TD>
</TR></TABLE></DIV><BR>

<H5>Abstraction.</H5>
One can modify the context of definition of a constant <I>c</I> by
abstracting a constant with respect to the last variable <I>x</I> of its
defining context. For doing that, we need to check that the constants
appearing in the body of the declaration do not depend on <I>x</I>, we need
also to modify the reference to the constant <I>c</I> in the environment
and context by explicitly applying this constant to the variable <I>x</I>.
Because of the rules for building environments and terms we know the
variable <I>x</I> is available at each stage where <I>c</I> is mentioned.<BR>
<BR>

<H5>Abstracting property:</H5> 
 <DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>; <FONT COLOR=purple>Def</FONT>(Gamma::(<I>x</I>:<I>U</I>))(<I>c</I>:=<I>t</I>:<I>T</I>);
 <I>F</I>)[Delta]&nbsp;&nbsp;&nbsp;&nbsp;<FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>)[Gamma]</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>;<FONT COLOR=purple>Def</FONT>(Gamma)(<I>c</I>:=lambda&nbsp;<I>x</I>:<I>U</I>, <I>t</I>:for all&nbsp;<I>x</I>:<I>U</I>,<I>T</I>);
 <I>F</I>{<I>c</I>/(<I>c</I>&nbsp;<I>x</I>)})[Delta{<I>c</I>/(<I>c</I>&nbsp;<I>x</I>)}]</TD>
</TR></TABLE></DIV><BR>

<H5>Pruning the context.</H5> 
We said the judgment <FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>)[Gamma] means that the defining contexts of
constants in <I>E</I> are included in Gamma. If one abstracts or
substitutes the constants with the above rules then it may happen
that the context Gamma is now bigger than the one needed for
defining the constants in <I>E</I>. Because defining contexts are growing
in <I>E</I>, the minimum context needed for defining the constants in <I>E</I>
is the same as the one for the last constant. One can consequently
derive the following property.<BR>
<BR>

<H5>Pruning property:</H5>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>; <FONT COLOR=purple>Def</FONT>(Delta)(<I>c</I>:=<I>t</I>:<I>T</I>))[Gamma]</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>;<FONT COLOR=purple>Def</FONT>(Delta)(<I>c</I>:=<I>t</I>:<I>T</I>))[Delta]</TD>
</TR></TABLE></DIV><BR>
<A NAME="toc26"></A>
<H2><A NAME="htoc90">4.5</A>&nbsp;&nbsp;Inductive Definitions</H2><A NAME="Cic-inductive-definitions"></A>
A (possibly mutual) inductive definition is specified by giving the
names and the type of the inductive sets or families to be
defined and the names and types of the constructors of the inductive
predicates. An inductive declaration in the environment can
consequently be represented with two contexts (one for inductive
definitions, one for constructors).<BR>
<BR>
Stating the rules for inductive definitions in their general form
needs quite tedious definitions. We shall try to give a concrete
understanding of the rules by precising them on running examples. We
take as examples the type of natural numbers, the type of
parameterized lists over a type <I>A</I>, the relation which states that
a list has some given length and the mutual inductive definition of trees and
forests. <BR>
<BR>

<H3><A NAME="htoc91">4.5.1</A>&nbsp;&nbsp;Representing an inductive definition</H3>

<H4>Inductive definitions without parameters</H4>
As for constants, inductive definitions can be defined in a non-empty
context. <BR>
We write <FONT COLOR=purple>Ind</FONT>(Gamma)(Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;) an inductive
definition valid in a context Gamma, a
context of definitions Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB> and a context of constructors
Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>.

<H5>Examples.</H5>
The inductive declaration for the type of natural numbers will be:
<DIV ALIGN=center><FONT COLOR=purple>Ind</FONT>()(<FONT COLOR=purple>nat</FONT>:<FONT COLOR=purple>Set</FONT>:=<FONT COLOR=purple>O</FONT>:<FONT COLOR=purple>nat</FONT>,<FONT COLOR=purple>S</FONT>:<FONT COLOR=purple>nat</FONT>-&gt;<FONT COLOR=purple>nat</FONT>&nbsp;)</DIV>
In a context with a variable <I>A</I>:<FONT COLOR=purple>Set</FONT>, the lists of elements in <I>A</I> is
represented by:
<DIV ALIGN=center><FONT COLOR=purple>Ind</FONT>(<I>A</I>:<FONT COLOR=purple>Set</FONT>)(<FONT COLOR=purple>List</FONT>:<FONT COLOR=purple>Set</FONT>:=<FONT COLOR=purple>nil</FONT>:<FONT COLOR=purple>List</FONT>,<FONT COLOR=purple>cons</FONT> : <I>A</I> -&gt; <FONT COLOR=purple>List</FONT> -&gt;
 <FONT COLOR=purple>List</FONT>&nbsp;)</DIV>
 Assuming 
 Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB> is [<I>I</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>I</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>], and Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB> is
 [<I>c</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>C</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>c</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>C</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>], the general typing rules are:<BR>
<BR>
<BR>
<BR>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=purple>Ind</FONT>(Gamma)(Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;) in <I>E</I>
 &nbsp;&nbsp;<I>j</I>=1... <I>k</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center>(<I>I</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>) in <I>E</I></TD>
</TR></TABLE></DIV><BR>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=purple>Ind</FONT>(Gamma)(Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;) in <I>E</I>
 &nbsp;&nbsp;&nbsp;&nbsp;<I>i</I>=1.. <I>n</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center>(<I>c</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>:<I>C</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>)in <I>E</I></TD>
</TR></TABLE></DIV><BR>

<H4>Inductive definitions with parameters</H4>
We have to slightly complicate the representation above in order to handle
the delicate problem of parameters. 
Let us explain that on the example of <FONT COLOR=purple>List</FONT>. As they were defined
above, the type <FONT COLOR=purple>List</FONT> can only be used in an environment where we
have a variable <I>A</I>:<FONT COLOR=purple>Set</FONT>. Generally one want to consider lists of
elements in different types. For constants this is easily done by abstracting
the value over the parameter. In the case of inductive definitions we
have to handle the abstraction over several objects.<BR>
<BR>
One possible way to do that would be to define the type <FONT COLOR=purple>List</FONT>
inductively as being an inductive family of type <FONT COLOR=purple>Set</FONT>-&gt;<FONT COLOR=purple>Set</FONT>:
<DIV ALIGN=center><FONT COLOR=purple>Ind</FONT>()(<FONT COLOR=purple>List</FONT>:<FONT COLOR=purple>Set</FONT>-&gt;<FONT COLOR=purple>Set</FONT>:=<FONT COLOR=purple>nil</FONT>:(<I>A</I>:<FONT COLOR=purple>Set</FONT>)(<FONT COLOR=purple>List</FONT>&nbsp;<I>A</I>),<FONT COLOR=purple>cons</FONT> : (<I>A</I>:<FONT COLOR=purple>Set</FONT>)<I>A</I>
 -&gt; (<FONT COLOR=purple>List</FONT>&nbsp;<I>A</I>) -&gt; (<FONT COLOR=purple>List</FONT>&nbsp;<I>A</I>)&nbsp;)</DIV>
There are drawbacks to this point of view. The
information which says that (<FONT COLOR=purple>List</FONT>&nbsp;<FONT COLOR=purple>nat</FONT>) is an inductively defined
<FONT COLOR=purple>Set</FONT> has been lost.
<BR>
<BR>
In the system, we keep track in the syntax of the context of
parameters. The idea of these parameters is that they can be
instantiated and still we have an inductive definition for which we
know the specification.<BR>
<BR>
Formally the representation of an inductive declaration
will be 
<FONT COLOR=purple>Ind</FONT>(Gamma)[Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>](Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;) for an inductive
definition valid in a context Gamma with parameters Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>, a
context of definitions Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB> and a context of constructors
Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>.
The occurrences of the variables of Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB> in the contexts
Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB> and Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB> are bound.<BR>
<BR>
The definition <FONT COLOR=purple>Ind</FONT>(Gamma)[Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>](Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;) will be
well-formed exactly when <FONT COLOR=purple>Ind</FONT>(Gamma,Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>)(Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;) is.
If Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB> is [<I>p</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>P</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>p</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>:<I>P</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>], an object in 
<FONT COLOR=purple>Ind</FONT>(Gamma)[Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>](Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;) applied to <I>q</I><SUB><FONT SIZE=2>1</FONT></SUB>,...,<I>q</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>
will behave as the corresponding object of 
<FONT COLOR=purple>Ind</FONT>(Gamma)(Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>{(<I>p</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>/<I>q</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>)<SUB><FONT SIZE=2><I>i</I>=1..<I>r</I></FONT></SUB>}:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>{(<I>p</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>/<I>q</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>)<SUB><FONT SIZE=2><I>i</I>=1..<I>r</I></FONT></SUB>}&nbsp;).<BR>
<BR>

<H5>Examples</H5>
The declaration for parameterized lists is:
<DIV ALIGN=center><FONT COLOR=purple>Ind</FONT>()[<I>A</I>:<FONT COLOR=purple>Set</FONT>](<FONT COLOR=purple>List</FONT>:<FONT COLOR=purple>Set</FONT>:=<FONT COLOR=purple>nil</FONT>:<FONT COLOR=purple>List</FONT>,<FONT COLOR=purple>cons</FONT> : <I>A</I> -&gt; <FONT COLOR=purple>List</FONT> -&gt;
 <FONT COLOR=purple>List</FONT>&nbsp;)</DIV><BR>
The declaration for the length of lists is:
<DIV ALIGN=center><FONT COLOR=purple>Ind</FONT>()[<I>A</I>:<FONT COLOR=purple>Set</FONT>](<FONT COLOR=purple>Length</FONT>:(<FONT COLOR=purple>List</FONT>&nbsp;<I>A</I>)-&gt; <FONT COLOR=purple>nat</FONT>-&gt;<FONT COLOR=purple>Prop</FONT>:=<FONT COLOR=purple>Lnil</FONT>:(<FONT COLOR=purple>Length</FONT>&nbsp;(<FONT COLOR=purple>nil</FONT>&nbsp;<I>A</I>)&nbsp;<FONT COLOR=purple>O</FONT>),<BR>
<FONT COLOR=purple>Lcons</FONT> :for all <I>a</I>:<I>A</I>, for all <I>l</I>:(<FONT COLOR=purple>List</FONT>&nbsp;<I>A</I>),for all <I>n</I>:<FONT COLOR=purple>nat</FONT>, (<FONT COLOR=purple>Length</FONT>&nbsp;<I>l</I>&nbsp;<I>n</I>)-&gt; (<FONT COLOR=purple>Length</FONT>&nbsp;(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>)&nbsp;(<FONT COLOR=purple>S</FONT>&nbsp;<I>n</I>))&nbsp;)</DIV><BR>
The declaration for a mutual inductive definition of forests and trees is:
<DIV ALIGN=center><FONT COLOR=purple>Ind</FONT>()(<FONT COLOR=purple>tree</FONT>:<FONT COLOR=purple>Set</FONT>,<FONT COLOR=purple>forest</FONT>:<FONT COLOR=purple>Set</FONT>:=<BR>
&nbsp;&nbsp;<FONT COLOR=purple>node</FONT>:<FONT COLOR=purple>forest</FONT> -&gt; <FONT COLOR=purple>tree</FONT>,
 <FONT COLOR=purple>emptyf</FONT>:<FONT COLOR=purple>forest</FONT>,<FONT COLOR=purple>consf</FONT>:<FONT COLOR=purple>tree</FONT> -&gt; <FONT COLOR=purple>forest</FONT> -&gt; <FONT COLOR=purple>forest</FONT>&nbsp;)</DIV><BR>
These representations are the ones obtained as the result of the <FONT COLOR=navy>Coq</FONT> 
declaration:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;nat&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;:&nbsp;nat</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;list&nbsp;(A:Set)&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;nil&nbsp;:&nbsp;list&nbsp;A</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;cons&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;Length&nbsp;(A:Set)&nbsp;:&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;Lnil&nbsp;:&nbsp;Length&nbsp;A&nbsp;(nil&nbsp;A)&nbsp;O</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;Lcons&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(a:A)&nbsp;(l:list&nbsp;A)&nbsp;(n:nat),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Length&nbsp;A&nbsp;l&nbsp;n&nbsp;-&gt;&nbsp;Length&nbsp;A&nbsp;(cons&nbsp;A&nbsp;a&nbsp;l)&nbsp;(S&nbsp;n).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;tree&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;:&nbsp;forest&nbsp;-&gt;&nbsp;tree</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;with&nbsp;forest&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;emptyf&nbsp;:&nbsp;forest</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;consf&nbsp;:&nbsp;tree&nbsp;-&gt;&nbsp;forest&nbsp;-&gt;&nbsp;forest.</TT><BR>
</DIV>

The inductive declaration in <FONT COLOR=navy>Coq</FONT> is slightly different from the one
we described theoretically. The difference is that in the type of
constructors the inductive definition is explicitly applied to the
parameters variables. The <FONT COLOR=navy>Coq</FONT> type-checker verifies that all
parameters are applied in the correct manner in each recursive call.
In particular, the following definition will not be accepted because 
there is an occurrence of <FONT COLOR=purple>List</FONT> which is not applied to the parameter
variable:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;list'&nbsp;(A:Set)&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;nil'&nbsp;:&nbsp;list'&nbsp;A</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;cons'&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;list'&nbsp;(A&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;list'&nbsp;A.</TT><BR>
<TT><I>Coq&nbsp;&lt;&nbsp;Coq&nbsp;&lt;&nbsp;Error:&nbsp;The&nbsp;1st&nbsp;argument&nbsp;of&nbsp;"list'"&nbsp;must&nbsp;be&nbsp;"A"&nbsp;in</I></TT><BR>
<TT><I>&nbsp;A&nbsp;-&gt;&nbsp;list'&nbsp;(A&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;list'&nbsp;A</I></TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc92">4.5.2</A>&nbsp;&nbsp;Types of inductive objects</H3>
We have to give the type of constants in an environment <I>E</I> which
contains an inductive declaration.
<DL COMPACT=compact><DT>
<B>Ind-Const</B><DD> Assuming Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB> is [<I>p</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>P</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>p</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>:<I>P</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>],
 Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB> is [<I>I</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>I</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>], and Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB> is
 [<I>c</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>C</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>c</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>C</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>],<BR>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=purple>Ind</FONT>(Gamma)[Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>](Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;) in <I>E</I>
 &nbsp;&nbsp;<I>j</I>=1... <I>k</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center>(<I>I</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>:for all&nbsp;<I>p</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>P</I><SUB><FONT SIZE=2>1</FONT></SUB>,...for all <I>p</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>:<I>P</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>,<I>A</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>) in <I>E</I></TD>
</TR></TABLE></DIV><BR>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=purple>Ind</FONT>(Gamma)[Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>](Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;) in <I>E</I>
 &nbsp;&nbsp;&nbsp;&nbsp;<I>i</I>=1.. <I>n</I></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center>(<I>c</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>:for all&nbsp;<I>p</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>P</I><SUB><FONT SIZE=2>1</FONT></SUB>,... for all <I>p</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>:<I>P</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>,<I>C</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>{<I>I</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>/(<I>I</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>&nbsp;<I>p</I><SUB><FONT SIZE=2>1</FONT></SUB>...
 <I>p</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>)}<SUB><FONT SIZE=2><I>j</I>=1... <I>k</I></FONT></SUB>)in <I>E</I></TD>
</TR></TABLE></DIV>
</DL>

<H5>Example.</H5>
We have (<FONT COLOR=purple>List</FONT>:<FONT COLOR=purple>Set</FONT> -&gt; <FONT COLOR=purple>Set</FONT>), (<FONT COLOR=purple>cons</FONT>:for all&nbsp;<I>A</I>:<FONT COLOR=purple>Set</FONT>,<I>A</I>-&gt;(<FONT COLOR=purple>List</FONT>&nbsp;<I>A</I>)-&gt;
(<FONT COLOR=purple>List</FONT>&nbsp;<I>A</I>)), <BR>
(<FONT COLOR=purple>Length</FONT>:for all&nbsp;<I>A</I>:<FONT COLOR=purple>Set</FONT>, (<FONT COLOR=purple>List</FONT>&nbsp;<I>A</I>)-&gt;<FONT COLOR=purple>nat</FONT>-&gt;<FONT COLOR=purple>Prop</FONT>), <FONT COLOR=purple>tree</FONT>:<FONT COLOR=purple>Set</FONT> and <FONT COLOR=purple>forest</FONT>:<FONT COLOR=purple>Set</FONT>.<BR>
<BR>
From now on, we write <FONT COLOR=purple>List_A</FONT> instead of (<FONT COLOR=purple>List</FONT>&nbsp;<I>A</I>) and <FONT COLOR=purple>Length_A</FONT>
for (<FONT COLOR=purple>Length</FONT>&nbsp;<I>A</I>).<BR>
<BR>

<H3><A NAME="htoc93">4.5.3</A>&nbsp;&nbsp;Well-formed inductive definitions</H3>
We cannot accept any inductive declaration because some of them lead
to inconsistent systems. We restrict ourselves to definitions which
satisfy a syntactic criterion of positivity. Before giving the formal
rules, we need a few definitions:<BR>
<BR>

<H5>Definitions</H5><A NAME="@default311"></A><A NAME="Positivity"></A>
A type <I>T</I> is an <EM>arity of sort <I>s</I></EM><A NAME="@default312"></A> if it converts
to the sort <I>s</I> or to a product for all&nbsp;<I>x</I>:<I>T</I>,<I>U</I> with <I>U</I> an arity
of sort <I>s</I>. (For instance <I>A</I>-&gt; <FONT COLOR=purple>Set</FONT> or for all&nbsp;<I>A</I>:<FONT COLOR=purple>Prop</FONT>,<I>A</I>-&gt;
<FONT COLOR=purple>Prop</FONT> are arities of sort respectively <FONT COLOR=purple>Set</FONT> and <FONT COLOR=purple>Prop</FONT>). A <EM>type
 of constructor of <I>I</I></EM><A NAME="@default313"></A> is either a term
(<I>I</I>&nbsp;<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>... &nbsp;<I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) or for all <I>x</I>:<I>T</I>,<I>C</I> with <I>C</I> a <EM>type of constructor
 of <I>I</I></EM>.<BR>
<BR>
<BR>
<BR>
<BR>
The type of constructor <I>T</I> will be said to <EM>satisfy the positivity
condition</EM> for a constant <I>X</I> in the following cases:
<UL><LI>
<I>T</I>=(<I>X</I>&nbsp;<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>... &nbsp;<I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) and <I>X</I> does not occur free in
any <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>
<LI><I>T</I>=for all&nbsp;<I>x</I>:<I>U</I>,<I>V</I> and <I>X</I> occurs only strictly positively in <I>U</I> and
the type <I>V</I> satisfies the positivity condition for <I>X</I>
</UL>
The constant <I>X</I> <EM>occurs strictly positively</EM> in <I>T</I> in the
following cases:
<UL><LI>
<I>X</I> does not occur in <I>T</I>
<LI><I>T</I> converts to (<I>X</I>&nbsp;<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> ... &nbsp;<I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) and <I>X</I> does not occur in
 any of <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>
<LI><I>T</I> converts to for all&nbsp;<I>x</I>:<I>U</I>,<I>V</I> and <I>X</I> does not occur in
 type <I>U</I> but occurs strictly positively in type <I>V</I>
<LI><I>T</I> converts to (<I>I</I>&nbsp;<I>a</I><SUB><FONT SIZE=2>1</FONT></SUB> ... &nbsp;<I>a</I><SUB><FONT SIZE=2><I>m</I></FONT></SUB> &nbsp; <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> ... &nbsp;<I>t</I><SUB><FONT SIZE=2><I>p</I></FONT></SUB>) where
 <I>I</I> is the name of an inductive declaration of the form
 <FONT COLOR=purple>Ind</FONT>(Gamma)[<I>p</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>P</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>p</I><SUB><FONT SIZE=2><I>m</I></FONT></SUB>:<I>P</I><SUB><FONT SIZE=2><I>m</I></FONT></SUB>](<I>I</I>:<I>A</I>:=<I>c</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>C</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>c</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>C</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>&nbsp;)
 (in particular, it is not mutually defined and it has <I>m</I>
 parameters) and <I>X</I> does not occur in any of the <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>, and the
 types of constructor <I>C</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>{<I>p</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>/<I>a</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>}<SUB><FONT SIZE=2><I>j</I>=1... <I>m</I></FONT></SUB> of <I>I</I> satisfy
 the imbricated positivity condition for <I>X</I>
</UL>
The type of constructor <I>T</I> of <I>I</I> <EM>satisfies the imbricated
positivity condition</EM> for a constant <I>X</I> in the following
cases:
<UL><LI>
<I>T</I>=(<I>I</I>&nbsp;<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>... &nbsp;<I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) and <I>X</I> does not occur in
any <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>
<LI><I>T</I>=for all&nbsp;<I>x</I>:<I>U</I>,<I>V</I> and <I>X</I> occurs only strictly positively in <I>U</I> and
the type <I>V</I> satisfies the imbricated positivity condition for <I>X</I>
</UL>

<H5>Example</H5>
<I>X</I> occurs strictly positively in <I>A</I>-&gt; <I>X</I> or <I>X</I>*<I>A</I> or (<TT><I>list</I></TT>
<I>X</I>) but not in <I>X</I> -&gt; <I>A</I> or (<I>X</I> -&gt; <I>A</I>)-&gt; <I>A</I> nor (<TT><I>neg</I></TT>&nbsp;<I>A</I>)
assuming the notion of product and lists were already defined and <TT>neg</TT> is an inductive definition with declaration <FONT COLOR=purple>Ind</FONT>()[<I>A</I>:<FONT COLOR=purple>Set</FONT>](<TT><I>neg</I></TT>:<FONT COLOR=purple>Set</FONT>:=<TT><I>neg</I></TT>:(<I>A</I>-&gt;<TT><I>False</I></TT>) -&gt; <TT><I>neg</I></TT>&nbsp;). Assuming
<I>X</I> has arity <TT><I>nat</I> -&gt; <I>Prop</I></TT> and <TT>ex</TT> is the inductively
defined existential quantifier, the occurrence of <I>X</I> in <TT>(<I>ex</I>&nbsp;
 <I>nat</I>&nbsp; lambda&nbsp;<I>n</I>:<I>nat</I>, (<I>X</I>&nbsp; <I>n</I>))</TT> is also strictly positive.<BR>
<BR>

<H5>Correctness rules.</H5>
We shall now describe the rules allowing the introduction of a new
inductive definition.
<DL COMPACT=compact><DT>
<B>W-Ind</B><DD> Let <I>E</I> be an environment and
 Gamma,Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>,Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>,Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB> are contexts such that
 Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB> is [<I>I</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>I</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>] and Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB> is
 [<I>c</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>C</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>c</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>C</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>]. 
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP>
 </TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center>
 (<I>E</I>[Gamma;Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>] |- <I>A</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB> : <I>s</I>'<SUB><FONT SIZE=2><I>j</I></FONT></SUB>)<SUB><FONT SIZE=2><I>j</I>=1... <I>k</I></FONT></SUB>
 &nbsp;&nbsp; (<I>E</I>[Gamma;Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>;Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>] |- <I>C</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> : <I>s</I><SUB><FONT SIZE=2><I>p</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB>)<SUB><FONT SIZE=2><I>i</I>=1... <I>n</I></FONT></SUB>
</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=red> <I>W</I><I>F</I></FONT>(<I>E</I>;<FONT COLOR=purple>Ind</FONT>(Gamma)[Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>](Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;))[Gamma]</TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
providing the following side conditions hold:
<UL><LI>
<I>k</I>&gt;0, <I>I</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>, <I>c</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> are different names for <I>j</I>=1... <I>k</I> and <I>i</I>=1... <I>n</I>,
<LI>for <I>j</I>=1... <I>k</I> we have <I>A</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB> is an arity of sort <I>s</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB> and <I>I</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>
 not in Gamma union <I>E</I>,
<LI>for <I>i</I>=1... <I>n</I> we have <I>C</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> is a type of constructor of
 <I>I</I><SUB><FONT SIZE=2><I>p</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB> which satisfies the positivity condition for <I>I</I><SUB><FONT SIZE=2>1</FONT></SUB> ... <I>I</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>
 and <I>c</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> not in Gamma union <I>E</I>.
</UL>
</DL>
One can remark that there is a constraint between the sort of the
arity of the inductive type and the sort of the type of its
constructors which will always be satisfied for the impredicative sort
(<FONT COLOR=purple>Prop</FONT>) but may fail to define inductive definition 
on sort <FONT COLOR=purple>Set</FONT> and generate constraints between universes for
inductive definitions in types.<BR>
<BR>

<H5>Examples</H5>
It is well known that existential quantifier can be encoded as an
inductive definition.
The following declaration introduces the second-order existential
quantifier there exists <I>X</I>.<I>P</I>(<I>X</I>).

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;exProp&nbsp;(P:Prop-&gt;Prop)&nbsp;:&nbsp;Prop&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;:=&nbsp;exP_intro&nbsp;:&nbsp;forall&nbsp;X:Prop,&nbsp;P&nbsp;X&nbsp;-&gt;&nbsp;exProp&nbsp;P.</TT><BR>
</DIV>

The same definition on <FONT COLOR=purple>Set</FONT> is not allowed and fails&nbsp;:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;exSet&nbsp;(P:Set-&gt;Prop)&nbsp;:&nbsp;Set&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;:=&nbsp;exS_intro&nbsp;:&nbsp;forall&nbsp;X:Set,&nbsp;P&nbsp;X&nbsp;-&gt;&nbsp;exSet&nbsp;P.</TT><BR>
<TT><I>Coq&nbsp;&lt;&nbsp;Coq&nbsp;&lt;&nbsp;User&nbsp;error:&nbsp;Large&nbsp;non-propositional&nbsp;inductive&nbsp;types&nbsp;must&nbsp;be&nbsp;in&nbsp;Type</I></TT><BR>
</DIV>

It is possible to declare the same inductive definition in the
universe <FONT COLOR=purple>Type</FONT>. 
The <TT>exType</TT> inductive definition has type (<FONT COLOR=purple>Type</FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB> -&gt;<FONT COLOR=purple>Prop</FONT>)-&gt;
<FONT COLOR=purple>Type</FONT><SUB><FONT SIZE=2><I>j</I></FONT></SUB> with the constraint that the parameter <TT>X</TT> of <TT>exT_intro</TT> has type <FONT COLOR=purple>Type</FONT><SUB><FONT SIZE=2><I>k</I></FONT></SUB> with <I>k</I>&lt;<I>j</I> and <I>k</I>&lt;= <I>i</I>.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;exType&nbsp;(P:Type-&gt;Prop)&nbsp;:&nbsp;Type</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;:=&nbsp;exT_intro&nbsp;:&nbsp;forall&nbsp;X:Type,&nbsp;P&nbsp;X&nbsp;-&gt;&nbsp;exType&nbsp;P.</TT><BR>
</DIV>

<BR>

<H3><A NAME="htoc94">4.5.4</A>&nbsp;&nbsp;Destructors</H3>
The specification of inductive definitions with arities and
constructors is quite natural. But we still have to say how to use an
object in an inductive type.<BR>
<BR>
This problem is rather delicate. There are actually several different
ways to do that. Some of them are logically equivalent but not always
equivalent from the computational point of view or from the user point
of view.<BR>
<BR>
From the computational point of view, we want to be able to define a
function whose domain is an inductively defined type by using a
combination of case analysis over the possible constructors of the
object and recursion.<BR>
<BR>
Because we need to keep a consistent theory and also we prefer to keep
a strongly normalising reduction, we cannot accept any sort of
recursion (even terminating). So the basic idea is to restrict
ourselves to primitive recursive functions and functionals.<BR>
<BR>
For instance, assuming a parameter <I>A</I>:<FONT COLOR=purple>Set</FONT> exists in the context, we
want to build a function <FONT COLOR=purple>length</FONT> of type <FONT COLOR=purple>List_A</FONT>-&gt; <FONT COLOR=purple>nat</FONT> which
computes the length of the list, so such that (<FONT COLOR=purple>length</FONT>&nbsp;<FONT COLOR=purple>nil</FONT>) = <FONT COLOR=purple>O</FONT>
and (<FONT COLOR=purple>length</FONT>&nbsp;(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>)) = (<FONT COLOR=purple>S</FONT>&nbsp;(<FONT COLOR=purple>length</FONT>&nbsp;<I>l</I>)). We want these
equalities to be recognized implicitly and taken into account in the
conversion rule.<BR>
<BR>
From the logical point of view, we have built a type family by giving
a set of constructors. We want to capture the fact that we do not
have any other way to build an object in this type. So when trying to
prove a property (<I>P</I>&nbsp;<I>m</I>) for <I>m</I> in an inductive definition it is
enough to enumerate all the cases where <I>m</I> starts with a different
constructor.<BR>
<BR>
In case the inductive definition is effectively a recursive one, we
want to capture the extra property that we have built the smallest
fixed point of this recursive equation. This says that we are only
manipulating finite objects. This analysis provides induction
principles.<BR>
<BR>
For instance, in order to prove for all <I>l</I>:<FONT COLOR=purple>List_A</FONT>,(<FONT COLOR=purple>Length_A</FONT>&nbsp;<I>l</I>&nbsp;(<FONT COLOR=purple>length</FONT>&nbsp;<I>l</I>))
it is enough to prove:<BR>
<BR>
(<FONT COLOR=purple>Length_A</FONT>&nbsp;<FONT COLOR=purple>nil</FONT>&nbsp;(<FONT COLOR=purple>length</FONT>&nbsp;<FONT COLOR=purple>nil</FONT>)) and<BR>
<BR>
<BR>
for all <I>a</I>:<I>A</I>, for all <I>l</I>:<FONT COLOR=purple>List_A</FONT>, (<FONT COLOR=purple>Length_A</FONT>&nbsp;<I>l</I>&nbsp;(<FONT COLOR=purple>length</FONT>&nbsp;<I>l</I>)) -&gt;
(<FONT COLOR=purple>Length_A</FONT>&nbsp;(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>)&nbsp;(<FONT COLOR=purple>length</FONT>&nbsp;(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>))).
<BR>
<BR>
<BR>
which given the conversion equalities satisfied by <FONT COLOR=purple>length</FONT> is the
same as proving:
(<FONT COLOR=purple>Length_A</FONT>&nbsp;<FONT COLOR=purple>nil</FONT>&nbsp;<FONT COLOR=purple>O</FONT>) and for all <I>a</I>:<I>A</I>, for all <I>l</I>:<FONT COLOR=purple>List_A</FONT>, 
(<FONT COLOR=purple>Length_A</FONT>&nbsp;<I>l</I>&nbsp;(<FONT COLOR=purple>length</FONT>&nbsp;<I>l</I>)) -&gt;
(<FONT COLOR=purple>Length_A</FONT>&nbsp;(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>)&nbsp;(<FONT COLOR=purple>S</FONT>&nbsp;(<FONT COLOR=purple>length</FONT>&nbsp;<I>l</I>))).<BR>
<BR>
One conceptually simple way to do that, following the basic scheme
proposed by Martin-Löf in his Intuitionistic Type Theory, is to
introduce for each inductive definition an elimination operator. At
the logical level it is a proof of the usual induction principle and
at the computational level it implements a generic operator for doing
primitive recursion over the structure.<BR>
<BR>
But this operator is rather tedious to implement and use. We choose in
this version of Coq to factorize the operator for primitive recursion
into two more primitive operations as was first suggested by Th. Coquand
in&nbsp;[<A HREF="biblio.html#Coq92"><CITE>25</CITE></A>]. One is the definition by pattern-matching. The second one is a definition by guarded fixpoints. <BR>
<BR>

<H4>The <TT>match...with ...end</TT> construction.</H4>
<A NAME="Caseexpr"></A>
<A NAME="@default314"></A>
The basic idea of this destructor operation is that we have an object
<I>m</I> in an inductive type <I>I</I> and we want to prove a property (<I>P</I>&nbsp;<I>m</I>)
which in general depends on <I>m</I>. For this, it is enough to prove the
property for <I>m</I> = (<I>c</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>&nbsp;<I>u</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>u</I><SUB><FONT SIZE=2><I>p</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB>) for each constructor of <I>I</I>.<BR>
<BR>
The <FONT COLOR=navy>Coq</FONT> term for this proof will be written&nbsp;:
<DIV ALIGN=center><FONT COLOR=purple>match</FONT>&nbsp;<I>m</I>&nbsp;<FONT COLOR=purple>with</FONT>&nbsp; (<I>c</I><SUB><FONT SIZE=2>1</FONT></SUB>&nbsp;<I>x</I><SUB><FONT SIZE=2>11</FONT></SUB>&nbsp;...&nbsp;<I>x</I><SUB><FONT SIZE=2>1<I>p</I></FONT><SUB><FONT SIZE=2>1</FONT></SUB></SUB>) =&gt; <I>f</I><SUB><FONT SIZE=2>1</FONT></SUB> &nbsp;|&nbsp;...&nbsp;|&nbsp;
 (<I>c</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>&nbsp;<I>x</I><SUB><FONT SIZE=2><I>n</I>1</FONT></SUB>...<I>x</I><SUB><FONT SIZE=2><I>np</I></FONT><SUB><FONT SIZE=2><I>n</I></FONT></SUB></SUB>) =&gt; <I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>&nbsp; <FONT COLOR=purple>end</FONT></DIV>
In this expression, if
<I>m</I> is a term built from a constructor (<I>c</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>&nbsp;<I>u</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>u</I><SUB><FONT SIZE=2><I>p</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB>) then
the expression will behave as it is specified with <I>i</I>-th branch and
will reduce to <I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> where the <I>x</I><SUB><FONT SIZE=2><I>i</I>1</FONT></SUB>...<I>x</I><SUB><FONT SIZE=2><I>ip</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB> are replaced
by the <I>u</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>u</I><SUB><FONT SIZE=2><I>p</I></FONT></SUB> according to the iota-reduction.<BR>
<BR>
Actually, for type-checking a <FONT COLOR=purple>match...with...end</FONT>
expression we also need to know the predicate <I>P</I> to be proved by case
analysis. <FONT COLOR=navy>Coq</FONT> can sometimes infer this predicate but sometimes
not. The concrete syntax for describing this predicate uses the
<FONT COLOR=purple>as...return</FONT> construction. 
The predicate will be explicited using the syntax&nbsp;:
<DIV ALIGN=center><FONT COLOR=purple>match</FONT>&nbsp;<I>m</I>&nbsp;<FONT COLOR=purple>as</FONT>&nbsp; <I>x</I>&nbsp; <FONT COLOR=purple>return</FONT>&nbsp; (<I>P</I>&nbsp; <I>x</I>) &nbsp;<FONT COLOR=purple>with</FONT>&nbsp; (<I>c</I><SUB><FONT SIZE=2>1</FONT></SUB>&nbsp;<I>x</I><SUB><FONT SIZE=2>11</FONT></SUB>&nbsp;...&nbsp;<I>x</I><SUB><FONT SIZE=2>1<I>p</I></FONT><SUB><FONT SIZE=2>1</FONT></SUB></SUB>) =&gt; <I>f</I><SUB><FONT SIZE=2>1</FONT></SUB> &nbsp;|&nbsp;...&nbsp;|&nbsp;
 (<I>c</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>&nbsp;<I>x</I><SUB><FONT SIZE=2><I>n</I>1</FONT></SUB>...<I>x</I><SUB><FONT SIZE=2><I>np</I></FONT><SUB><FONT SIZE=2><I>n</I></FONT></SUB></SUB>) =&gt; <I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> <FONT COLOR=purple>end</FONT></DIV>
For the purpose of presenting the inference rules, we use a more
compact notation&nbsp;:
<DIV ALIGN=center> <FONT COLOR=purple>case</FONT>(<I>m</I>,(lambda <I>x</I> , <I>P</I>), lambda <I>x</I><SUB><FONT SIZE=2>11</FONT></SUB>&nbsp;...&nbsp;<I>x</I><SUB><FONT SIZE=2>1<I>p</I></FONT><SUB><FONT SIZE=2>1</FONT></SUB></SUB> , <I>f</I><SUB><FONT SIZE=2>1</FONT></SUB> &nbsp;|&nbsp;...&nbsp;|&nbsp;
 lambda <I>x</I><SUB><FONT SIZE=2><I>n</I>1</FONT></SUB>...<I>x</I><SUB><FONT SIZE=2><I>np</I></FONT><SUB><FONT SIZE=2><I>n</I></FONT></SUB></SUB> , <I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>)</DIV><BR>
This is the basic idea which is generalized to the case where <I>I</I> is
an inductively defined <I>n</I>-ary relation (in which case the property
<I>P</I> to be proved will be a <I>n</I>+1-ary relation).<BR>
<BR>

<H5>Non-dependent elimination.</H5>
When defining a function by case analysis, we build an object of type <I>I</I>
-&gt; <I>C</I> and the minimality principle on an inductively defined logical
predicate of type <I>A</I> -&gt; <FONT COLOR=purple>Prop</FONT> is often used to prove a property
for all <I>x</I>:<I>A</I>,(<I>I</I>&nbsp;<I>x</I>)-&gt; (<I>C</I>&nbsp;<I>x</I>). This is a particular case of the dependent
principle that we stated before with a predicate which does not depend
explicitly on the object in the inductive definition.<BR>
<BR>
For instance, a function testing whether a list is empty 
can be
defined as:<BR>
<DIV ALIGN=center>lambda&nbsp;<I>l</I>:<FONT COLOR=purple>List_A</FONT> ,<FONT COLOR=purple>case</FONT>(<I>l</I>,<FONT COLOR=purple>bool</FONT>,<FONT COLOR=purple>nil</FONT>&nbsp; =&gt;&nbsp;<FONT COLOR=purple>true</FONT>&nbsp; |&nbsp; (<FONT COLOR=purple>cons</FONT>&nbsp;<I>a</I>&nbsp;<I>m</I>)&nbsp; =&gt;&nbsp;<FONT COLOR=purple>false</FONT>)</DIV>
<BR>

<H5>Allowed elimination sorts.</H5>
<A NAME="@default315"></A>
An important question for building the typing rule for <FONT COLOR=purple>match</FONT> is
what can be the type of <I>P</I> with respect to the type of the inductive
definitions.<BR>
<BR>
We define now a relation [<I>I</I>:<I>A</I>|<I>B</I>] between an inductive
definition <I>I</I> of type <I>A</I>, an arity <I>B</I> which says that an object in
the inductive definition <I>I</I> can be eliminated for proving a property
<I>P</I> of type <I>B</I>.<BR>
<BR>
The case of inductive definitions in sorts <FONT COLOR=purple>Set</FONT> or <FONT COLOR=purple>Type</FONT> is simple.
There is no restriction on the sort of the predicate to be
eliminated. <BR>
<BR>

<H5>Notations.</H5>
The [<I>I</I>:<I>A</I>|<I>B</I>] is defined as the smallest relation satisfying the
following rules:
We write [<I>I</I>|<I>B</I>] for [<I>I</I>:<I>A</I>|<I>B</I>] where <I>A</I> is the type of
<I>I</I>.
<DL COMPACT=compact><DT>
<B>Prod</B><DD> <DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center>[(<I>I</I>&nbsp;<I>x</I>):<I>A</I>'|<I>B</I>']</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center>[<I>I</I>:(<I>x</I>:<I>A</I>)<I>A</I>'|(<I>x</I>:<I>A</I>)<I>B</I>']</TD>
</TR></TABLE></DIV>
<DT><B><FONT COLOR=purple>Set</FONT></B><B>&amp; <FONT COLOR=purple>Type</FONT></B><DD> <DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center>
 <I>s</I><SUB><FONT SIZE=2>1</FONT></SUB> in {<FONT COLOR=purple>Set</FONT>,<FONT COLOR=purple>Type</FONT>(<I>j</I>)}, 
 <I>s</I><SUB><FONT SIZE=2>2</FONT></SUB> in <FONT COLOR=red> <I>S</I></FONT></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center>[<I>I</I>:<I>s</I><SUB><FONT SIZE=2>1</FONT></SUB>|<I>I</I>-&gt; <I>s</I><SUB><FONT SIZE=2>2</FONT></SUB>]</TD>
</TR></TABLE></DIV>
</DL>
The case of Inductive Definitions of sort <FONT COLOR=purple>Prop</FONT> is a bit more
complicated, because of our interpretation of this sort. The only
harmless allowed elimination, is the one when predicate <I>P</I> is also of
sort <FONT COLOR=purple>Prop</FONT>.
<DL COMPACT=compact><DT>
<B><FONT COLOR=purple>Prop</FONT></B><DD> <DIV ALIGN=center>[<I>I</I>:<FONT COLOR=purple>Prop</FONT>|<I>I</I>-&gt;<FONT COLOR=purple>Prop</FONT>]</DIV>
</DL>
<FONT COLOR=purple>Prop</FONT> is the type of logical propositions, the proofs of properties
<I>P</I> in <FONT COLOR=purple>Prop</FONT> could not be used for computation and are consequentely
ignored by the extraction mechanism.
Assume <I>A</I> and <I>B</I> are two propositions, and the logical disjunction
<I>A</I>\/ <I>B</I> is defined inductively by&nbsp;:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;or&nbsp;(A&nbsp;B:Prop)&nbsp;:&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;lintro&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;or&nbsp;A&nbsp;B&nbsp;|&nbsp;rintro&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;or&nbsp;A&nbsp;B.</TT><BR>
</DIV>

The following definition which computes a boolean value by case over
the proof of <TT>or A B</TT> is not accepted&nbsp;:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;choice&nbsp;(A&nbsp;B:&nbsp;Prop)&nbsp;(x:or&nbsp;A&nbsp;B)&nbsp;:=&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;x&nbsp;with&nbsp;lintro&nbsp;a&nbsp;=&gt;&nbsp;true&nbsp;|&nbsp;rintro&nbsp;b&nbsp;=&gt;&nbsp;false&nbsp;end.</TT><BR>
<TT><I>Coq&nbsp;&lt;&nbsp;Coq&nbsp;&lt;&nbsp;Error:</I></TT><BR>
<TT><I>Incorrect&nbsp;elimination&nbsp;of&nbsp;"x"&nbsp;in&nbsp;the&nbsp;inductive&nbsp;type&nbsp;&nbsp;</I></TT><BR>
<TT><I>"or",&nbsp;the&nbsp;return&nbsp;type&nbsp;has&nbsp;sort&nbsp;"Set"&nbsp;while&nbsp;it&nbsp;should&nbsp;be&nbsp;</I></TT><BR>
<TT><I>"Prop"</I></TT><BR>
<TT><I>Elimination&nbsp;of&nbsp;an&nbsp;inductive&nbsp;object&nbsp;of&nbsp;sort&nbsp;"Prop"</I></TT><BR>
<TT><I>is&nbsp;not&nbsp;allowed&nbsp;on&nbsp;a&nbsp;predicate&nbsp;in&nbsp;sort&nbsp;"Set"</I></TT><BR>
<TT><I>because&nbsp;proofs&nbsp;can&nbsp;be&nbsp;eliminated&nbsp;only&nbsp;to&nbsp;build&nbsp;proofs</I></TT><BR>
</DIV>

From the computational point of view, the structure of the proof of
<TT>(or A B)</TT> in this term is needed for computing the boolean
value.<BR>
<BR>
In general, if <I>I</I> has type <FONT COLOR=purple>Prop</FONT> then <I>P</I> cannot have type <I>I</I>-&gt;
<FONT COLOR=purple>Set</FONT>, because it will mean to build an informative proof of type
(<I>P</I>&nbsp;<I>m</I>) doing a case analysis over a non-computational object that
will disappear in the extracted program. But the other way is safe
with respect to our interpretation we can have <I>I</I> a computational
object and <I>P</I> a non-computational one, it just corresponds to proving
a logical property of a computational object.<BR>
<BR>
In the same spirit, elimination on <I>P</I> of type <I>I</I>-&gt;
<FONT COLOR=purple>Type</FONT> cannot be allowed because it trivially implies the elimination
on <I>P</I> of type <I>I</I>-&gt; <FONT COLOR=purple>Set</FONT> by cumulativity. It also implies that there
is two proofs of the same property which are provably different,
contradicting the proof-irrelevance property which is sometimes a
useful axiom&nbsp;:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Axiom&nbsp;proof_irrelevance&nbsp;:&nbsp;forall&nbsp;(P&nbsp;:&nbsp;Prop)&nbsp;(x&nbsp;y&nbsp;:&nbsp;P),&nbsp;x=y.</TT><BR>
<TT><I>proof_irrelevance&nbsp;is&nbsp;assumed</I></TT><BR>
</DIV>

The elimination of an inductive definition of type <FONT COLOR=purple>Prop</FONT> on a
predicate <I>P</I> of type <I>I</I>-&gt; <FONT COLOR=purple>Type</FONT> leads to a paradox when applied to 
impredicative inductive definition like the second-order existential
quantifier <TT>exProp</TT> defined above, because it give access to
the two projections on this type.<BR>
<BR>

<H5>Empty and singleton elimination</H5>
<A NAME="@default316"></A>
<A NAME="@default317"></A>
There are special inductive definitions in <FONT COLOR=purple>Prop</FONT> for which more
eliminations are allowed. 
<DL COMPACT=compact><DT>
<B><FONT COLOR=purple>Prop</FONT></B><B>-extended</B><DD> 
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP>
 </TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>I</I> &nbsp;is an empty or singleton
 definition&nbsp;&nbsp;&nbsp;<I>s</I>in<FONT COLOR=red> <I>S</I></FONT></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center>[<I>I</I>:<FONT COLOR=purple>Prop</FONT>|<I>I</I>-&gt; <I>s</I>]</TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
</DL>
A <EM>singleton
definition</EM> has only one constructor and all the arguments of this
constructor have type <FONT COLOR=purple>Prop</FONT>. In that case, there is a canonical
way to interpret the informative extraction on an object in that type,
such that the elimination on any sort <I>s</I> is legal. Typical examples are
the conjunction of non-informative propositions and the equality. 
If there is an hypothesis <I>h</I>:<I>a</I>=<I>b</I> in the context, it can be used for
rewriting not only in logical propositions but also in any type.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;eq_rec.</TT><BR>
<TT><I>eq_rec&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fun&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Set)&nbsp;=&gt;&nbsp;eq_rect&nbsp;x&nbsp;P</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Set),</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y&nbsp;:&nbsp;A,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;P&nbsp;y</I></TT><BR>
<TT><I>Argument&nbsp;A&nbsp;is&nbsp;implicit</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[type_scope&nbsp;_&nbsp;_&nbsp;_&nbsp;_&nbsp;_]</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Extraction&nbsp;eq_rec.</TT><BR>
<TT><I>(**&nbsp;val&nbsp;eq_rec&nbsp;:&nbsp;'a1&nbsp;-&gt;&nbsp;'a2&nbsp;-&gt;&nbsp;'a1&nbsp;-&gt;&nbsp;'a2&nbsp;**)</I></TT><BR>
<TT><I>let&nbsp;eq_rec&nbsp;x&nbsp;f&nbsp;y&nbsp;=</I></TT><BR>
<TT><I>&nbsp;&nbsp;f</I></TT><BR>
</DIV>

An empty definition has no constructors, in that case also,
elimination on any sort is allowed.<BR>
<BR>

<H5>Type of branches.</H5>
Let <I>c</I> be a term of type <I>C</I>, we assume <I>C</I> is a type of constructor
for an inductive definition <I>I</I>. Let <I>P</I> be a term that represents the
property to be proved.
We assume <I>r</I> is the number of parameters.<BR>
<BR>
We define a new type {<I>c</I>:<I>C</I>}<SUP><FONT SIZE=2><I>P</I></FONT></SUP> which represents the type of the
branch corresponding to the <I>c</I>:<I>C</I> constructor.
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP>
</TD>
<TD NOWRAP><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP>{<I>c</I>:(<I>I</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>&nbsp;<I>p</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>p</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB> <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> ... <I>t</I><SUB><FONT SIZE=2><I>p</I></FONT></SUB>)}<SUP><FONT SIZE=2><I>P</I></FONT></SUP></TD>
<TD ALIGN=left NOWRAP>same as (<I>P</I>&nbsp;<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>... &nbsp;<I>t</I><SUB><FONT SIZE=2><I>p</I></FONT></SUB>&nbsp;<I>c</I>)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>{<I>c</I>:for all&nbsp;<I>x</I>:<I>T</I>,<I>C</I>}<SUP><FONT SIZE=2><I>P</I></FONT></SUP></TD>
<TD ALIGN=left NOWRAP>same as for all&nbsp;<I>x</I>:<I>T</I>,{(<I>c</I>&nbsp;<I>x</I>):<I>C</I>}<SUP><FONT SIZE=2><I>P</I></FONT></SUP></TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
We write {<I>c</I>}<SUP><FONT SIZE=2><I>P</I></FONT></SUP> for {<I>c</I>:<I>C</I>}<SUP><FONT SIZE=2><I>P</I></FONT></SUP> with <I>C</I> the type of <I>c</I>.<BR>
<BR>

<H5>Examples.</H5>
For <FONT COLOR=purple>List_A</FONT> the type of <I>P</I> will be <FONT COLOR=purple>List_A</FONT>-&gt; <I>s</I> for <I>s</I> in <FONT COLOR=red> <I>S</I></FONT>. <BR>
{(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>)}<SUP><FONT SIZE=2><I>P</I></FONT></SUP> same as
for all <I>a</I>:<I>A</I>, for all <I>l</I>:<FONT COLOR=purple>List_A</FONT>,(<I>P</I>&nbsp;(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>)).<BR>
<BR>
For <FONT COLOR=purple>Length_A</FONT>, the type of <I>P</I> will be
for all <I>l</I>:<FONT COLOR=purple>List_A</FONT>,for all <I>n</I>:<FONT COLOR=purple>nat</FONT>, (<FONT COLOR=purple>Length_A</FONT>&nbsp;<I>l</I>&nbsp;<I>n</I>)-&gt; <FONT COLOR=purple>Prop</FONT> and the expression
{(<FONT COLOR=purple>Lcons</FONT>&nbsp;<I>A</I>)}<SUP><FONT SIZE=2><I>P</I></FONT></SUP> is defined as:<BR>
for all <I>a</I>:<I>A</I>, for all <I>l</I>:<FONT COLOR=purple>List_A</FONT>, for all <I>n</I>:<FONT COLOR=purple>nat</FONT>, for all
<I>h</I>:(<FONT COLOR=purple>Length_A</FONT>&nbsp;<I>l</I>&nbsp;<I>n</I>), (<I>P</I>&nbsp;(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>)&nbsp;(<FONT COLOR=purple>S</FONT>&nbsp;<I>n</I>)&nbsp;(<FONT COLOR=purple>Lcons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>&nbsp;<I>n</I>&nbsp;<I>l</I>)).<BR>
If <I>P</I> does not depend on its third argument, we find the more natural
expression:<BR>
for all <I>a</I>:<I>A</I>, for all <I>l</I>:<FONT COLOR=purple>List_A</FONT>, for all <I>n</I>:<FONT COLOR=purple>nat</FONT>,
(<FONT COLOR=purple>Length_A</FONT>&nbsp;<I>l</I>&nbsp;<I>n</I>)-&gt;(<I>P</I>&nbsp;(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>)&nbsp;(<FONT COLOR=purple>S</FONT>&nbsp;<I>n</I>)).<BR>
<BR>

<H5>Typing rule.</H5>
Our very general destructor for inductive definition enjoys the
following typing rule

<DL COMPACT=compact><DT>
<B>match</B><DD> <A NAME="elimdep"></A> <A NAME="@default318"></A>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP>
</TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>c</I> : (<I>I</I>&nbsp;<I>q</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>q</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>&nbsp;<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>t</I><SUB><FONT SIZE=2><I>s</I></FONT></SUB>)&nbsp;&nbsp;
 <I>E</I>[Gamma] |- <I>P</I> : <I>B</I>&nbsp;&nbsp;[(<I>I</I>&nbsp;<I>q</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>q</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>)|<I>B</I>]
 &nbsp;&nbsp;
(<I>E</I>[Gamma] |- <I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> : {(<I>c</I><SUB><FONT SIZE=2><I>p</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB>&nbsp;<I>q</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>q</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>)}<SUP><FONT SIZE=2><I>P</I></FONT></SUP>)<SUB><FONT SIZE=2><I>i</I>=1... <I>l</I></FONT></SUB></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <FONT COLOR=purple>case</FONT>(<I>c</I>,<I>P</I>,<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>f</I><SUB><FONT SIZE=2><I>l</I></FONT></SUB>) : (<I>P</I> <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>t</I><SUB><FONT SIZE=2><I>s</I></FONT></SUB> <I>c</I>)</TD>
</TR></TABLE></TD>
</TR></TABLE></DIV><BR>
provided <I>I</I> is an inductive type in a declaration
<FONT COLOR=purple>Ind</FONT>(Delta)[Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>](Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;) with |Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>| = <I>r</I>,
Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB> = [<I>c</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>C</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>c</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>C</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>] and <I>c</I><SUB><FONT SIZE=2><I>p</I></FONT><SUB><FONT SIZE=2>1</FONT></SUB></SUB>... <I>c</I><SUB><FONT SIZE=2><I>p</I></FONT><SUB><FONT SIZE=2><I>l</I></FONT></SUB></SUB> are the
only constructors of <I>I</I>.
</DL>

<H5>Example.</H5>
For <FONT COLOR=purple>List</FONT> and <FONT COLOR=purple>Length</FONT> the typing rules for the <TT>match</TT> expression
are (writing just <I>t</I>:<I>M</I> instead of <I>E</I>[Gamma] |- <I>t</I> : <I>M</I>, the environment and
context being the same in all the judgments).<BR>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>l</I>:<FONT COLOR=purple>List_A</FONT>&nbsp;&nbsp;<I>P</I>:<FONT COLOR=purple>List_A</FONT>-&gt; <I>s</I>&nbsp;&nbsp;&nbsp;<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>:(<I>P</I>&nbsp;(<FONT COLOR=purple>nil</FONT>&nbsp;<I>A</I>))&nbsp;&nbsp;
 <I>f</I><SUB><FONT SIZE=2>2</FONT></SUB>:for all <I>a</I>:<I>A</I>, for all <I>l</I>:<FONT COLOR=purple>List_A</FONT>, (<I>P</I>&nbsp;(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>))</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=purple>case</FONT>(<I>l</I>,<I>P</I>,<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>&nbsp;<I>f</I><SUB><FONT SIZE=2>2</FONT></SUB>):(<I>P</I>&nbsp;<I>l</I>)</TD>
</TR></TABLE></DIV><BR>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP>
 </TD>
<TD NOWRAP><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=center NOWRAP><I>H</I>:(<FONT COLOR=purple>Length_A</FONT>&nbsp;<I>L</I>&nbsp;<I>N</I>)</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><I>P</I>:for all <I>l</I>:<FONT COLOR=purple>List_A</FONT>, for all <I>n</I>:<FONT COLOR=purple>nat</FONT>, (<FONT COLOR=purple>Length_A</FONT>&nbsp;<I>l</I>&nbsp;<I>n</I>)-&gt;
 <FONT COLOR=purple>Prop</FONT></TD>
</TR>
<TR><TD ALIGN=center NOWRAP><I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>:(<I>P</I>&nbsp;(<FONT COLOR=purple>nil</FONT>&nbsp;<I>A</I>)&nbsp;<FONT COLOR=purple>O</FONT>&nbsp;<FONT COLOR=purple>Lnil</FONT>)</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><I>f</I><SUB><FONT SIZE=2>2</FONT></SUB>:for all <I>a</I>:<I>A</I>, for all <I>l</I>:<FONT COLOR=purple>List_A</FONT>, for all <I>n</I>:<FONT COLOR=purple>nat</FONT>, for all
 <I>h</I>:(<FONT COLOR=purple>Length_A</FONT>&nbsp;<I>l</I>&nbsp;<I>n</I>), (<I>P</I>&nbsp;(<FONT COLOR=purple>cons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>n</I>)&nbsp;(<FONT COLOR=purple>S</FONT>&nbsp;<I>n</I>)&nbsp;(<FONT COLOR=purple>Lcons</FONT>&nbsp;<I>A</I>&nbsp;<I>a</I>&nbsp;<I>l</I>&nbsp;<I>n</I>&nbsp;<I>h</I>))</TD>
</TR></TABLE></TD>
</TR></TABLE></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT COLOR=purple>case</FONT>(<I>H</I>,<I>P</I>,<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>&nbsp;<I>f</I><SUB><FONT SIZE=2>2</FONT></SUB>):(<I>P</I>&nbsp;<I>L</I>&nbsp;<I>N</I>&nbsp;<I>H</I>)</TD>
</TR></TABLE></DIV><BR>

<H5>Definition of iota-reduction.</H5><A NAME="iotared"></A>
<A NAME="@default319"></A>
We still have to define the iota-reduction in the general case.<BR>
<BR>
A iota-redex is a term of the following form:
<DIV ALIGN=center><FONT COLOR=purple>case</FONT>((<I>c</I><SUB><FONT SIZE=2><I>p</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB>&nbsp;<I>q</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>q</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>&nbsp;<I>a</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>a</I><SUB><FONT SIZE=2><I>m</I></FONT></SUB>),<I>P</I>,<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>... 
 <I>f</I><SUB><FONT SIZE=2><I>l</I></FONT></SUB>)</DIV>
with <I>c</I><SUB><FONT SIZE=2><I>p</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB> the <I>i</I>-th constructor of the inductive type <I>I</I> with <I>r</I>
parameters.<BR>
<BR>
The iota-contraction of this term is (<I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>&nbsp;<I>a</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>a</I><SUB><FONT SIZE=2><I>m</I></FONT></SUB>) leading
to the general reduction rule:
<DIV ALIGN=center> <FONT COLOR=purple>case</FONT>((<I>c</I><SUB><FONT SIZE=2><I>p</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB>&nbsp;<I>q</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>q</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>&nbsp;<I>a</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>a</I><SUB><FONT SIZE=2><I>m</I></FONT></SUB>),<I>P</I>,<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>... 
 <I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) |&gt;<SUB><FONT SIZE=2>iota</FONT></SUB> (<I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>&nbsp;<I>a</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>a</I><SUB><FONT SIZE=2><I>m</I></FONT></SUB>) </DIV><BR>

<H3><A NAME="htoc95">4.5.5</A>&nbsp;&nbsp;Fixpoint definitions</H3>
<A NAME="Fix-term"></A> <A NAME="@default320"></A>
The second operator for elimination is fixpoint definition. 
This fixpoint may involve several mutually recursive definitions.
The basic concrete syntax for a recursive set of mutually recursive 
declarations is (with Gamma<SUB><FONT SIZE=2><I>i</I></FONT></SUB> contexts)&nbsp;: 
<DIV ALIGN=center><FONT COLOR=purple>fix</FONT>&nbsp;<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB> (Gamma<SUB><FONT SIZE=2>1</FONT></SUB>) :<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>:=<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>&nbsp;<FONT COLOR=purple>with</FONT> ... <FONT COLOR=purple>with</FONT>&nbsp; <I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>
(Gamma<SUB><FONT SIZE=2><I>n</I></FONT></SUB>) :<I>A</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:=<I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB></DIV>
The terms are obtained by projections from this set of declarations
and are written 
<DIV ALIGN=center><FONT COLOR=purple>fix</FONT>&nbsp;<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB> (Gamma<SUB><FONT SIZE=2>1</FONT></SUB>) :<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>:=<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>&nbsp;<FONT COLOR=purple>with</FONT> ... <FONT COLOR=purple>with</FONT>&nbsp; <I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>
(Gamma<SUB><FONT SIZE=2><I>n</I></FONT></SUB>) :<I>A</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:=<I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>&nbsp;<FONT COLOR=purple>for</FONT>&nbsp;<I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB></DIV>
In the inference rules, we represent such a
term by 
<DIV ALIGN=center><TT>Fix</TT>&nbsp;<I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>{<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>':=<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>' ... <I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>':=<I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>'}</DIV>
with <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>' (resp. <I>A</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>') representing the term <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> abstracted
(resp. generalised) with
respect to the bindings in the context Gamma<SUB><FONT SIZE=2><I>i</I></FONT></SUB>, namely
<I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>'=lambda Gamma<SUB><FONT SIZE=2><I>i</I></FONT></SUB> , <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> and <I>A</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>'=for all Gamma<SUB><FONT SIZE=2><I>i</I></FONT></SUB>, <I>A</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>.<BR>
<BR>

<H4>Typing rule</H4>
The typing rule is the expected one for a fixpoint.
<DL COMPACT=compact><DT>
<B>Fix</B><DD> <A NAME="@default321"></A>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center>(<I>E</I>[Gamma] |- <I>A</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> : <I>s</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>)<SUB><FONT SIZE=2><I>i</I>=1... <I>n</I></FONT></SUB>&nbsp;&nbsp;&nbsp;&nbsp;
 (<I>E</I>[Gamma,<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>,...,<I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>] |- <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> : <I>A</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>)<SUB><FONT SIZE=2><I>i</I>=1... <I>n</I></FONT></SUB></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <TT>Fix</TT>&nbsp;<I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>{<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>:=<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> ... <I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:=<I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>} : <I>A</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB></TD>
</TR></TABLE></DIV>
</DL>
Any fixpoint definition cannot be accepted because non-normalizing terms
will lead to proofs of absurdity.<BR>
<BR>
The basic scheme of recursion that should be allowed is the one needed for 
defining primitive
recursive functionals. In that case the fixpoint enjoys a special
syntactic restriction, namely one of the arguments belongs to an
inductive type, the function starts with a case analysis and recursive
calls are done on variables coming from patterns and representing subterms.<BR>
<BR>
For instance in the case of natural numbers, a proof of the induction
principle of type 
<DIV ALIGN=center>for all <I>P</I>:<FONT COLOR=purple>nat</FONT>-&gt;<FONT COLOR=purple>Prop</FONT>, (<I>P</I>&nbsp;<FONT COLOR=purple>O</FONT>)-&gt;((<I>n</I>:<FONT COLOR=purple>nat</FONT>)(<I>P</I>&nbsp;<I>n</I>)-&gt;(<I>P</I>&nbsp;(<FONT COLOR=purple>S</FONT>&nbsp;<I>n</I>)))-&gt;
for all <I>n</I>:<FONT COLOR=purple>nat</FONT>, (<I>P</I>&nbsp;<I>n</I>)</DIV>
can be represented by the term:
<DIV ALIGN=center><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP>lambda <I>P</I>:<FONT COLOR=purple>nat</FONT>-&gt;<FONT COLOR=purple>Prop</FONT>,lambda <I>f</I>:(<I>P</I>&nbsp;<FONT COLOR=purple>O</FONT>), lambda <I>g</I>:(for all <I>n</I>:<FONT COLOR=purple>nat</FONT>,
(<I>P</I>&nbsp;<I>n</I>)-&gt;(<I>P</I>&nbsp;(<FONT COLOR=purple>S</FONT>&nbsp;<I>n</I>))) ,</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>Fix</TT>&nbsp;<I>h</I>{<I>h</I>:for all <I>n</I>:<FONT COLOR=purple>nat</FONT>, (<I>P</I>&nbsp;<I>n</I>):=lambda <I>n</I>:<FONT COLOR=purple>nat</FONT>, <FONT COLOR=purple>case</FONT>(<I>n</I>,<I>P</I>,<I>f</I>&nbsp;lambda
 <I>p</I>:<FONT COLOR=purple>nat</FONT>, (<I>g</I>&nbsp;<I>p</I>&nbsp;(<I>h</I>&nbsp;<I>p</I>)))}</TD>
</TR></TABLE></DIV><BR>
Before accepting a fixpoint definition as being correctly typed, we
check that the definition is ``guarded''. A precise analysis of this
notion can be found in&nbsp;[<A HREF="biblio.html#Gim94"><CITE>59</CITE></A>].<BR>
<BR>
The first stage is to precise on which argument the fixpoint will be
decreasing. The type of this argument should be an inductive
definition.<BR>
<BR>
For doing this the syntax of fixpoints is extended and becomes 
 <DIV ALIGN=center><TT>Fix</TT>&nbsp;<I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>{<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>/<I>k</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>:=<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> ... <I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>/<I>k</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:=<I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>}</DIV>
where <I>k</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> are positive integers.
Each <I>A</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> should be a type (reducible to a term) starting with at least
<I>k</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> products for all <I>y</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>B</I><SUB><FONT SIZE=2>1</FONT></SUB>,... for all <I>y</I><SUB><FONT SIZE=2><I>k</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB>:<I>B</I><SUB><FONT SIZE=2><I>k</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB>, <I>A</I>'<SUB><FONT SIZE=2><I>i</I></FONT></SUB> 
and <I>B</I><SUB><FONT SIZE=2><I>k</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB>
being an instance of an inductive definition.<BR>
<BR>
Now in the definition <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>, if <I>f</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB> occurs then it should be applied
to at least <I>k</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB> arguments and the <I>k</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>-th argument should be
syntactically recognized as structurally smaller than <I>y</I><SUB><FONT SIZE=2><I>k</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB><BR>
<BR>
The definition of being structurally smaller is a bit technical.
One needs first to define the notion of 
<EM>recursive arguments of a constructor</EM><A NAME="@default322"></A>.
For an inductive definition <FONT COLOR=purple>Ind</FONT>(Gamma)[Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>](Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;),
the type of a constructor <I>c</I> have the form
for all <I>p</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>P</I><SUB><FONT SIZE=2>1</FONT></SUB>,... for all <I>p</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>:<I>P</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>, 
for all <I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>T</I><SUB><FONT SIZE=2>1</FONT></SUB>, ... for all <I>x</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>:<I>T</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>, (<I>I</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB>&nbsp;<I>p</I><SUB><FONT SIZE=2>1</FONT></SUB>... 
<I>p</I><SUB><FONT SIZE=2><I>r</I></FONT></SUB>&nbsp;<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>t</I><SUB><FONT SIZE=2><I>s</I></FONT></SUB>) the recursive arguments will correspond to <I>T</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> in
which one of the <I>I</I><SUB><FONT SIZE=2><I>l</I></FONT></SUB> occurs.<BR>
<BR>
The main rules for being structurally smaller are the following:<BR>
Given a variable <I>y</I> of type an inductive
definition in a declaration 
<FONT COLOR=purple>Ind</FONT>(Gamma)[Gamma<SUB><FONT SIZE=2><I>P</I></FONT></SUB>](Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB>:=Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB>&nbsp;)
where Gamma<SUB><FONT SIZE=2><I>I</I></FONT></SUB> is [<I>I</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>I</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>], and Gamma<SUB><FONT SIZE=2><I>C</I></FONT></SUB> is
 [<I>c</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>C</I><SUB><FONT SIZE=2>1</FONT></SUB>;...;<I>c</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>C</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>].
The terms structurally smaller than <I>y</I> are:
<UL><LI>
(<I>t</I>&nbsp;<I>u</I>), lambda <I>x</I>:<I>u</I> , <I>t</I> when <I>t</I> is structurally smaller than <I>y</I> .
<LI><FONT COLOR=purple>case</FONT>(<I>c</I>,<I>P</I>,<I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) when each <I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> is structurally
 smaller than <I>y</I>.<BR>
If <I>c</I> is <I>y</I> or is structurally smaller than <I>y</I>, its type is an inductive
 definition <I>I</I><SUB><FONT SIZE=2><I>p</I></FONT></SUB> part of the inductive
 declaration corresponding to <I>y</I>. 
 Each <I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> corresponds to a type of constructor <I>C</I><SUB><FONT SIZE=2><I>q</I></FONT></SUB> same as
 for all <I>y</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>B</I><SUB><FONT SIZE=2>1</FONT></SUB>, ... for all <I>y</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>:<I>B</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>, (<I>I</I>&nbsp;<I>a</I><SUB><FONT SIZE=2>1</FONT></SUB>... <I>a</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>) 
 and can consequently be
 written lambda <I>y</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>B</I>'<SUB><FONT SIZE=2>1</FONT></SUB>, ... lambda <I>y</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>:<I>B</I>'<SUB><FONT SIZE=2><I>k</I></FONT></SUB>, <I>g</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>.
 (<I>B</I>'<SUB><FONT SIZE=2><I>i</I></FONT></SUB> is obtained from <I>B</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> by substituting parameters variables)
 the variables <I>y</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB> occurring
 in <I>g</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> corresponding to recursive arguments <I>B</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> (the ones in
 which one of the <I>I</I><SUB><FONT SIZE=2><I>l</I></FONT></SUB> occurs) are structurally smaller than <I>y</I>.
</UL>
The following definitions are correct, we enter them using the
<TT>Fixpoint</TT> command as described in section&nbsp;<A HREF="Reference-Manual003.html#Fixpoint">1.3.4</A> and show
the internal representation.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;plus&nbsp;(n&nbsp;m:nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;m</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;S&nbsp;(plus&nbsp;p&nbsp;m)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>plus&nbsp;is&nbsp;recursively&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;plus.</TT><BR>
<TT><I>plus&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fix&nbsp;plus&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</I></TT><BR>
<TT><I>&nbsp;&nbsp;match&nbsp;n&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;m</I></TT><BR>
<TT><I>&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;S&nbsp;(plus&nbsp;p&nbsp;m)</I></TT><BR>
<TT><I>&nbsp;&nbsp;end</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;lgth&nbsp;(A:Set)&nbsp;(l:list&nbsp;A)&nbsp;{struct&nbsp;l}&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;l&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;nil&nbsp;=&gt;&nbsp;O</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;cons&nbsp;a&nbsp;l'&nbsp;=&gt;&nbsp;S&nbsp;(lgth&nbsp;A&nbsp;l')</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>lgth&nbsp;is&nbsp;recursively&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;lgth.</TT><BR>
<TT><I>lgth&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fix&nbsp;lgth&nbsp;(A&nbsp;:&nbsp;Set)&nbsp;(l&nbsp;:&nbsp;list&nbsp;A)&nbsp;{struct&nbsp;l}&nbsp;:&nbsp;nat&nbsp;:=</I></TT><BR>
<TT><I>&nbsp;&nbsp;match&nbsp;l&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;|&nbsp;nil&nbsp;=&gt;&nbsp;O</I></TT><BR>
<TT><I>&nbsp;&nbsp;|&nbsp;cons&nbsp;_&nbsp;l'&nbsp;=&gt;&nbsp;S&nbsp;(lgth&nbsp;A&nbsp;l')</I></TT><BR>
<TT><I>&nbsp;&nbsp;end</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Set,&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[type_scope&nbsp;_]</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;sizet&nbsp;(t:tree)&nbsp;:&nbsp;nat&nbsp;:=&nbsp;let&nbsp;(f)&nbsp;:=&nbsp;t&nbsp;in&nbsp;S&nbsp;(sizef&nbsp;f)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;with&nbsp;sizef&nbsp;(f:forest)&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;f&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;emptyf&nbsp;=&gt;&nbsp;O</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;consf&nbsp;t&nbsp;f&nbsp;=&gt;&nbsp;plus&nbsp;(sizet&nbsp;t)&nbsp;(sizef&nbsp;f)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>sizet,&nbsp;sizef&nbsp;are&nbsp;recursively&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;sizet.</TT><BR>
<TT><I>sizet&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fix&nbsp;sizet&nbsp;(t&nbsp;:&nbsp;tree)&nbsp;:&nbsp;nat&nbsp;:=</I></TT><BR>
<TT><I>&nbsp;&nbsp;let&nbsp;(f)&nbsp;:=&nbsp;t&nbsp;in&nbsp;S&nbsp;(sizef&nbsp;f)</I></TT><BR>
<TT><I>with&nbsp;sizef&nbsp;(f&nbsp;:&nbsp;forest)&nbsp;:&nbsp;nat&nbsp;:=</I></TT><BR>
<TT><I>&nbsp;&nbsp;match&nbsp;f&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;|&nbsp;emptyf&nbsp;=&gt;&nbsp;O</I></TT><BR>
<TT><I>&nbsp;&nbsp;|&nbsp;consf&nbsp;t&nbsp;f0&nbsp;=&gt;&nbsp;plus&nbsp;(sizet&nbsp;t)&nbsp;(sizef&nbsp;f0)</I></TT><BR>
<TT><I>&nbsp;&nbsp;end</I></TT><BR>
<TT><I>for&nbsp;sizet</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;tree&nbsp;-&gt;&nbsp;nat</I></TT><BR>
</DIV>
<BR>

<H4>Reduction rule</H4>
<A NAME="@default323"></A>
Let <I>F</I> be the set of declarations: <I>f</I><SUB><FONT SIZE=2>1</FONT></SUB>/<I>k</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>:=<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> ...
<I>f</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>/<I>k</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:=<I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>.
The reduction for fixpoints is:
<DIV ALIGN=center> (<TT>Fix</TT>&nbsp;<I>f</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>{<I>F</I>}&nbsp;<I>a</I><SUB><FONT SIZE=2>1</FONT></SUB>...
<I>a</I><SUB><FONT SIZE=2><I>k</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB>) |&gt;<SUB><FONT SIZE=2>iota</FONT></SUB> <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>{(<I>f</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>/<TT>Fix</TT>&nbsp;<I>f</I><SUB><FONT SIZE=2><I>k</I></FONT></SUB>{<I>F</I>})<SUB><FONT SIZE=2><I>k</I>=1... <I>n</I></FONT></SUB>}</DIV>
when <I>a</I><SUB><FONT SIZE=2><I>k</I></FONT><SUB><FONT SIZE=2><I>i</I></FONT></SUB></SUB> starts with a constructor.
This last restriction is needed in order to keep strong normalization
and corresponds to the reduction for primitive recursive operators.<BR>
<BR>
We can illustrate this behavior on examples.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;n&nbsp;m:nat,&nbsp;plus&nbsp;(S&nbsp;n)&nbsp;m&nbsp;=&nbsp;S&nbsp;(plus&nbsp;n&nbsp;m).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;plus&nbsp;(S&nbsp;n)&nbsp;m&nbsp;=&nbsp;S&nbsp;(plus&nbsp;n&nbsp;m)</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;reflexivity.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Abort.</TT><BR>
<TT><I>Current&nbsp;goal&nbsp;aborted</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;f:forest,&nbsp;sizet&nbsp;(node&nbsp;f)&nbsp;=&nbsp;S&nbsp;(sizef&nbsp;f).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;f&nbsp;:&nbsp;forest,&nbsp;sizet&nbsp;(node&nbsp;f)&nbsp;=&nbsp;S&nbsp;(sizef&nbsp;f)</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;reflexivity.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Abort.</TT><BR>
<TT><I>Current&nbsp;goal&nbsp;aborted</I></TT><BR>
</DIV>

But assuming the definition of a son function from <FONT COLOR=purple>tree</FONT> to <FONT COLOR=purple>forest</FONT>:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;sont&nbsp;(t:tree)&nbsp;:&nbsp;forest&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;let&nbsp;(f)&nbsp;:=&nbsp;t&nbsp;in&nbsp;f.</TT><BR>
<TT><I>sont&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>

The following is not a conversion but can be proved after a case analysis.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;t:tree,&nbsp;sizet&nbsp;t&nbsp;=&nbsp;S&nbsp;(sizef&nbsp;(sont&nbsp;t)).</TT><BR>
<TT><I>Coq&nbsp;&lt;&nbsp;Coq&nbsp;&lt;&nbsp;1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;t&nbsp;:&nbsp;tree,&nbsp;sizet&nbsp;t&nbsp;=&nbsp;S&nbsp;(sizef&nbsp;(sont&nbsp;t))</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;reflexivity.&nbsp;(**&nbsp;this&nbsp;one&nbsp;fails&nbsp;**)</TT><BR>
<TT><I>Toplevel&nbsp;input,&nbsp;characters&nbsp;2398-2409</I></TT><BR>
<TT><I>&gt;&nbsp;reflexivity.</I></TT><BR>
<TT><I>&gt;&nbsp;^^^^^^^^^^^</I></TT><BR>
<TT><I>Error:&nbsp;Impossible&nbsp;to&nbsp;unify&nbsp;"S&nbsp;(sizef&nbsp;(sont&nbsp;t))"&nbsp;with&nbsp;"sizet&nbsp;t"</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;destruct&nbsp;t.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;f&nbsp;:&nbsp;forest</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;sizet&nbsp;(node&nbsp;f)&nbsp;=&nbsp;S&nbsp;(sizef&nbsp;(sont&nbsp;(node&nbsp;f)))</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;reflexivity.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>

<H4>Mutual induction</H4>
The principles of mutual induction can be automatically generated 
using the <TT>Scheme</TT> command described in section&nbsp;<A HREF="Reference-Manual010.html#Scheme">8.13</A>.<BR>
<BR>
<A NAME="toc27"></A>
<H2><A NAME="htoc96">4.6</A>&nbsp;&nbsp;Coinductive types</H2>
The implementation contains also coinductive definitions, which are
types inhabited by infinite objects. 
More information on coinductive definitions can be found
in&nbsp;[<A HREF="biblio.html#Gimenez95b"><CITE>60</CITE></A><CITE>, </CITE><A HREF="biblio.html#Gim98"><CITE>61</CITE></A>].
<BR>
<BR>
<A NAME="toc28"></A>
<H2><A NAME="htoc97">4.7</A>&nbsp;&nbsp;<FONT COLOR=navy>Cic</FONT>: the Calculus of Inductive Construction with
 impredicative <FONT COLOR=purple>Set</FONT></H2><A NAME="impredicativity"></A>
<FONT COLOR=navy>Coq</FONT> can be used as a type-checker for <FONT COLOR=navy>Cic</FONT>, the original 
Calculus of Inductive Constructions with an impredicative sort <FONT COLOR=purple>Set</FONT>
by using the compiler option <TT>-impredicative-set</TT>.<BR>
<BR>
For example, using the ordinary <TT>coqtop</TT> command, the following
is rejected.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;id:&nbsp;Set&nbsp;:=&nbsp;forall&nbsp;X:Set,X-&gt;X.</TT><BR>
<TT><I>Coq&nbsp;&lt;&nbsp;Coq&nbsp;&lt;&nbsp;Coq&nbsp;&lt;&nbsp;Coq&nbsp;&lt;&nbsp;Toplevel&nbsp;input,&nbsp;characters&nbsp;2658-2668</I></TT><BR>
<TT><I>&gt;&nbsp;Definition&nbsp;id:&nbsp;Set&nbsp;:=&nbsp;forall&nbsp;X:Set,X-&gt;X.</I></TT><BR>
<TT><I>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^^^^^^^^^</I></TT><BR>
<TT><I>Error:&nbsp;The&nbsp;term&nbsp;"forall&nbsp;X&nbsp;:&nbsp;Set,&nbsp;X&nbsp;-&gt;&nbsp;X"&nbsp;has&nbsp;type&nbsp;"Type"</I></TT><BR>
<TT><I>&nbsp;while&nbsp;it&nbsp;is&nbsp;expected&nbsp;to&nbsp;have&nbsp;type&nbsp;"Set"</I></TT><BR>
</DIV>

while it will type-check, if one use instead the <TT>coqtop
 -impredicative-set</TT> command.<BR>
<BR>
The major change in the theory concerns the rule for product formation
in the sort <FONT COLOR=purple>Set</FONT>, which is extended to a domain in any sort&nbsp;:
<DL COMPACT=compact><DT>
<B>Prod</B><DD> <A NAME="@default324"></A>
<DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>E</I>[Gamma] |- <I>T</I> : <I>s</I>&nbsp;&nbsp;&nbsp;&nbsp;<I>s</I>in<FONT COLOR=red> <I>S</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <I>E</I>[Gamma::(<I>x</I>:<I>T</I>)] |- <I>U</I> : <FONT COLOR=purple>Set</FONT></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center> <I>E</I>[Gamma] |- for all&nbsp;<I>x</I>:<I>T</I>,<I>U</I> : <FONT COLOR=purple>Set</FONT></TD>
</TR></TABLE></DIV> 
</DL>
This extension has consequences on the inductive definitions which are
allowed. 
In the impredicative system, one can build so-called <EM>large inductive
 definitions</EM> like the example of second-order existential
quantifier (<TT>exSet</TT>).<BR>
<BR>
There should be restrictions on the eliminations which can be
performed on such definitions. The eliminations rules in the
impredicative system for sort <FONT COLOR=purple>Set</FONT> become&nbsp;:
<DL COMPACT=compact><DT>
<B><FONT COLOR=purple>Set</FONT></B><DD> <DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>s</I> in
 {<FONT COLOR=purple>Prop</FONT>, <FONT COLOR=purple>Set</FONT>}</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center>[<I>I</I>:<FONT COLOR=purple>Set</FONT>|<I>I</I>-&gt; <I>s</I>]</TD>
</TR></TABLE></TD>
<TD NOWRAP>
&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><I>I</I> &nbsp;is a small inductive definition&nbsp;&nbsp;&nbsp;&nbsp;<I>s</I> in
 {<FONT COLOR=purple>Type</FONT>(<I>i</I>)}</TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center>[<I>I</I>:<FONT COLOR=purple>Set</FONT>|<I>I</I>-&gt; <I>s</I>]</TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
</DL>
<HR WIDTH="50%" SIZE=1><DL><DT><A NAME="note11" HREF="#text11"><FONT SIZE=5>1</FONT></A><DD>This requirement could be relaxed if we instead introduced
 an explicit mechanism for instantiating constants. At the external
 level, the Coq engine works accordingly to this view that all the
 definitions in the environment were built in a sub-context of the
 current context.
</DL>
<HR>
<A HREF="Reference-Manual005.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual007.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
