<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
<TITLE>
Utilities
</TITLE>
</HEAD>
<BODY >
<A HREF="Reference-Manual014.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual016.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><A NAME="htoc304">Chapter&nbsp;13</A>&nbsp;&nbsp;Utilities</H1><A NAME="Utilities"></A>
The distribution provides utilities to simplify some tedious works
beside proof development, tactics writing or documentation.<BR>
<BR>
<A NAME="toc77"></A>
<H2><A NAME="htoc305">13.1</A>&nbsp;&nbsp;Building a toplevel extended with user tactics</H2>
<A NAME="Coqmktop"></A><A NAME="@default662"></A>
The native-code version of <FONT COLOR=navy>Coq</FONT> cannot dynamically load user tactics
using Objective Caml code. It is possible to build a toplevel of <FONT COLOR=navy>Coq</FONT>,
with Objective Caml code statically linked, with the tool <TT>coqmktop</TT>.<BR>
<BR>
For example, one can build a native-code <FONT COLOR=navy>Coq</FONT> toplevel extended with a tactic
which source is in <TT>tactic.ml</TT> with the command 
<PRE>
     % coqmktop -opt -o mytop.out tactic.cmx
</PRE>where <TT>tactic.ml</TT> has been compiled with the native-code
compiler <TT>ocamlopt</TT>. This command generates an executable
called <TT>mytop.out</TT>. To use this executable to compile your <FONT COLOR=navy>Coq</FONT>
files, use <TT>coqc -image mytop.out</TT>.<BR>
<BR>
A basic example is the native-code version of <FONT COLOR=navy>Coq</FONT> (<TT>coqtop.opt</TT>),
which can be generated by <TT>coqmktop -opt -o coqopt.opt</TT>.<BR>
<BR>

<H5>Application: how to use the Objective Caml debugger with Coq.</H5>
<A NAME="@default663"></A>
One useful application of <TT>coqmktop</TT> is to build a <FONT COLOR=navy>Coq</FONT> toplevel in
order to debug your tactics with the Objective Caml debugger.
You need to have configured and compiled <FONT COLOR=navy>Coq</FONT> for debugging
(see the file <TT>INSTALL</TT> included in the distribution).
Then, you must compile the Caml modules of your tactic with the
option <TT>-g</TT> (with the bytecode compiler) and build a stand-alone
bytecode toplevel with the following command:
<BLOCKQUOTE>
<TT>% coqmktop -g -o coq-debug</TT>&nbsp;<EM>&lt;your <TT>.cmo</TT></EM><EM> files&gt;</EM>
</BLOCKQUOTE>
To launch the <FONT COLOR=navy>Objective Caml</FONT> debugger with the image you need to execute it in
an environment which correctly sets the <TT>COQLIB</TT> variable.
Moreover, you have to indicate the directories in which
<TT>ocamldebug</TT> should search for Caml modules.<BR>
<BR>
A possible solution is to use a wrapper around <TT>ocamldebug</TT>
which detects the executables containing the word <TT>coq</TT>. In
this case, the debugger is called with the required additional
arguments. In other cases, the debugger is simply called without additional
arguments. Such a wrapper can be found in the <TT>dev/</TT>
subdirectory of the sources. <BR>
<BR>
<A NAME="toc78"></A>
<H2><A NAME="htoc306">13.2</A>&nbsp;&nbsp;Modules dependencies</H2><A NAME="Dependencies"></A><A NAME="@default664"></A>
 <A NAME="@default665"></A>
In order to compute modules dependencies (so to use <TT>make</TT>),
<FONT COLOR=navy>Coq</FONT> comes with an appropriate tool, <TT>coqdep</TT>.<BR>
<BR>
<TT>coqdep</TT> computes inter-module dependencies for <FONT COLOR=navy>Coq</FONT> and
<FONT COLOR=navy>Objective Caml</FONT> programs, and prints the dependencies on the standard
output in a format readable by make. When a directory is given as
argument, it is recursively looked at.<BR>
<BR>
Dependencies of <FONT COLOR=navy>Coq</FONT> modules are computed by looking at <TT>Require</TT>
commands (<TT>Require</TT>, <TT>Require Export</TT>, <TT>Require Import</TT>,
<TT>Require Implementation</TT>), but also at the command <TT>Declare ML Module</TT>.<BR>
<BR>
Dependencies of <FONT COLOR=navy>Objective Caml</FONT> modules are computed by looking at
<CODE>open</CODE> commands and the dot notation <EM>module.value</EM>. However,
this is done approximatively and you are advised to use <TT>ocamldep</TT>
instead for the <FONT COLOR=navy>Objective Caml</FONT> modules dependencies.<BR>
<BR>
See the man page of <TT>coqdep</TT> for more details and options.<BR>
<BR>
<A NAME="toc79"></A>
<H2><A NAME="htoc307">13.3</A>&nbsp;&nbsp;Creating a <TT>Makefile</TT> for <FONT COLOR=navy>Coq</FONT> modules</H2>
<A NAME="Makefile"></A>
<A NAME="@default666"></A>
<A NAME="@default667"></A>
When a proof development becomes large and is split into several files,
it becomes crucial to use a tool like <TT>make</TT> to compile <FONT COLOR=navy>Coq</FONT>
modules.<BR>
<BR>
The writing of a generic and complete <TT>Makefile</TT> may be a tedious work
and that's why <FONT COLOR=navy>Coq</FONT> provides a tool to automate its creation,
<TT>coq_makefile</TT>. Given the files to compile, the command <TT>coq_makefile</TT> prints a 
<TT>Makefile</TT> on the standard output. So one has just to run the
command:
<BLOCKQUOTE>
<TT>% coq_makefile</TT> <EM>file</EM><SUB><EM><FONT SIZE=2>1</FONT></EM></SUB><EM>.v ... file</EM><SUB><EM><FONT SIZE=2><I>n</I></FONT></EM></SUB><EM>.v</EM> <TT>&gt; Makefile</TT>
</BLOCKQUOTE>
The resulted <TT>Makefile</TT> has a target <TT>depend</TT> which computes the
dependencies and puts them in a separate file <TT>.depend</TT>, which is
included by the <TT>Makefile</TT>. 
Therefore, you should create such a file before the first invocation
of make. You can for instance use the command 
<BLOCKQUOTE>
<TT>% touch .depend</TT>
</BLOCKQUOTE>
Then, to initialize or update the modules dependencies, type in:
<BLOCKQUOTE>
<TT>% make depend</TT>
</BLOCKQUOTE>
There is a target <TT>all</TT> to compile all the files <EM>file</EM><SUB><EM><FONT SIZE=2>1</FONT></EM></SUB><EM>
... file</EM><SUB><EM><FONT SIZE=2><I>n</I></FONT></EM></SUB>, and a generic target to produce a <TT>.vo</TT> file from
the corresponding <TT>.v</TT> file (so you can do <TT>make</TT> <EM>file</EM><TT>.vo</TT>
to compile the file <EM>file</EM><TT>.v</TT>).<BR>
<BR>
<TT>coq_makefile</TT> can also handle the case of ML files and
subdirectories. For more options type
<BLOCKQUOTE>
<TT>% coq_makefile --help</TT>
</BLOCKQUOTE>
<BR>
<B>Warning: </B>To compile a project containing <FONT COLOR=navy>Objective Caml</FONT> files you must keep
the sources of <FONT COLOR=navy>Coq</FONT> somewhere and have an environment variable named
<TT>COQTOP</TT> that points to that directory.<BR>
<BR>
<A NAME="toc80"></A>
<H2><A NAME="htoc308">13.4</A>&nbsp;&nbsp;Documenting <FONT COLOR=navy>Coq</FONT> files with coqdoc</H2>
<A NAME="coqdoc"></A>
<A NAME="@default668"></A>











<FONT COLOR=purple>coqdoc</FONT> is a documentation tool for the proof assistant
<FONT COLOR=navy>Coq</FONT>, similar to <FONT COLOR=purple>javadoc</FONT> or <FONT COLOR=purple>ocamldoc</FONT>. 
The task of <FONT COLOR=purple>coqdoc</FONT> is
<OL type=1><LI>
to produce a nice L<sup>A</sup>T<sub>E</sub>X and/or HTML document from the <FONT COLOR=navy>Coq</FONT> 
 sources, readable for a human and not only for the proof assistant;
<LI>to help the user navigating in his own (or third-party) sources.
</OL>

<H3><A NAME="htoc309">13.4.1</A>&nbsp;&nbsp;Principles</H3>
Documentation is inserted into <FONT COLOR=navy>Coq</FONT> files as <EM>special comments</EM>. 
Thus your files will compile as usual, whether you use <FONT COLOR=purple>coqdoc</FONT> or not.
<FONT COLOR=purple>coqdoc</FONT> presupposes that the given <FONT COLOR=navy>Coq</FONT> files are well-formed (at
least lexically). Documentation starts with
<TT>(**</TT>, followed by a space, and ends with the pending <TT>*)</TT>. 
The documentation format is inspired
 by Todd&nbsp;A.&nbsp;Coram's <EM>Almost Free Text (AFT)</EM> tool: it is mainly
ASCII text with some syntax-light controls, described below.
<FONT COLOR=purple>coqdoc</FONT> is robust: it shouldn't fail, whatever the input is. But
remember: ``garbage in, garbage out''.<BR>
<BR>

<H5><FONT COLOR=navy>Coq</FONT> material inside documentation.</H5>
<FONT COLOR=navy>Coq</FONT> material is quoted between the
delimiters <TT>[</TT> and <TT>]</TT>. Square brackets may be nested,
the inner ones being understood as being part of the quoted code (thus
you can quote a term like [<I>x</I>:<I>T</I>]<I>u</I> by writing
<TT>[[x:T]u]</TT>). Inside quotations, the code is pretty-printed in
the same way as it is in code parts.<BR>
<BR>
Pre-formatted vernacular is enclosed by <TT>[[</TT> and
<TT>]]</TT>. The former must be followed by a newline and the latter
must follow a newline.<BR>
<BR>

<H5>Pretty-printing.</H5>
<FONT COLOR=purple>coqdoc</FONT> uses different faces for identifiers and keywords. 
The pretty-printing of <FONT COLOR=navy>Coq</FONT> tokens (identifiers or symbols) can be
controlled using one of the following commands:
<PRE>
(** printing <EM>token</EM> %...L<sup>A</sup>T<sub>E</sub>X...% #...HTML...# *)
</PRE>
or
<PRE>
(** printing <EM>token</EM> $...L<sup>A</sup>T<sub>E</sub>X math...$ #...HTML...# *)
</PRE>
It gives the L<sup>A</sup>T<sub>E</sub>X and HTML texts to be produced for the given <FONT COLOR=navy>Coq</FONT>
token. One of the L<sup>A</sup>T<sub>E</sub>X or HTML text may be ommitted, causing the
default pretty-printing to be used for this token.<BR>
<BR>
The printing for one token can be removed with
<PRE>
(** remove printing <EM>token</EM> *)
</PRE>
Initially, the pretty-printing table contains the following mapping:
<DIV ALIGN=center>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><CODE>-&gt;</CODE></TD>
<TD ALIGN=left NOWRAP>-&gt;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>&lt;-</CODE></TD>
<TD ALIGN=left NOWRAP>&lt;-</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>*</CODE></TD>
<TD ALIGN=left NOWRAP>×</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>&lt;=</CODE></TD>
<TD ALIGN=left NOWRAP>&lt;=</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>&gt;=</CODE></TD>
<TD ALIGN=left NOWRAP>&gt;=</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>=&gt;</CODE></TD>
<TD ALIGN=left NOWRAP>=&gt;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>&lt;&gt;</CODE></TD>
<TD ALIGN=left NOWRAP>!=</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>&lt;-&gt;</CODE></TD>
<TD ALIGN=left NOWRAP>&lt;-&gt;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>|-</CODE></TD>
<TD ALIGN=left NOWRAP>|-</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>\/</CODE></TD>
<TD ALIGN=left NOWRAP>\/</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>/\</CODE></TD>
<TD ALIGN=left NOWRAP>/\</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>~</CODE></TD>
<TD ALIGN=left NOWRAP><I>not</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR></TABLE>
</DIV>
Any of these can be overwritten or suppressed using the
<TT>printing</TT> commands.<BR>
<BR>
Important note: the recognition of tokens is done by a (ocaml)lex
automaton and thus applies the longest-match rule. For instance,
<CODE>-&gt;~</CODE> is recognized as a single token, where <FONT COLOR=navy>Coq</FONT> sees two
tokens. It is the responsability of the user to insert space between
tokens <EM>or</EM> to give pretty-printing rules for the possible
combinations, e.g. 
<PRE>
(** printing -&gt;~ %\ensuremath{\rightarrow\lnot}% *)
</PRE>

<H5>Sections.</H5>
Sections are introduced by 1 to 4 leading stars (i.e. at the beginning of the
line). One star is a section, two stars a sub-section, etc.
The section title is given on the remaining of the line.
Example:
<PRE>
    (** * Well-founded relations
  
        In this section, we introduce...  *)
</PRE>

<H5>Lists.</H5>
List items are introduced by 1 to 4 leading dashes.
Deepness of the list is indicated by the number of dashes.
List ends with a blank line.
Example:
<PRE>
    This module defines
        - the predecessor [pred]
        - the addition [plus]
        - order relations:
          -- less or equal [le]
          -- less [lt]
</PRE>

<H5>Rules.</H5>
More than 4 leading dashes produce an horizontal rule.<BR>
<BR>

<H5>Escapings to L<sup>A</sup>T<sub>E</sub>X and HTML.</H5>
Pure L<sup>A</sup>T<sub>E</sub>X or HTML material can be inserted using the following
escape sequences:
<UL><LI>
<CODE>$...LaTeX stuff...$</CODE> inserts some L<sup>A</sup>T<sub>E</sub>X material in math mode.
 Simply discarded in HTML output.<BR>
<BR>
<LI><CODE>%...LaTeX stuff...%</CODE> inserts some L<sup>A</sup>T<sub>E</sub>X material.
 Simply discarded in HTML output.<BR>
<BR>
<LI><CODE>#...HTML stuff...#</CODE> inserts some HTML material. Simply
 discarded in L<sup>A</sup>T<sub>E</sub>X output.
</UL>

<H5>Verbatim.</H5> 
Verbatim material is introduced by a leading <CODE>&lt;&lt;</CODE> and closed by
<CODE>&gt;&gt;</CODE>. Example:
<PRE>
Here is the corresponding caml code:
&lt;&lt;
  let rec fact n = 
    if n &lt;= 1 then 1 else n * fact (n-1)
&gt;&gt;
</PRE>

<H5>Hyperlinks.</H5>
Hyperlinks can be inserted into the HTML output, so that any
identifier is linked to the place of its definition.<BR>
<BR>
In order to get hyperlinks you need to first compile your <FONT COLOR=navy>Coq</FONT> file
using <TT>coqc --dump-glob <EM>file</EM></TT>; this appends 
<FONT COLOR=navy>Coq</FONT> names resolutions done during the compilation to file
<TT><EM>file</EM></TT>. Take care of erasing this file, if any, when
starting the whole compilation process.<BR>
<BR>
Then invoke <TT>coqdoc --glob-from <EM>file</EM></TT> to tell
<FONT COLOR=purple>coqdoc</FONT> to look for name resolutions into the file <TT><EM>file</EM></TT>.<BR>
<BR>
Identifiers from the <FONT COLOR=navy>Coq</FONT> standard library are linked to the <FONT COLOR=navy>Coq</FONT>
web site at <TT>http://coq.inria.fr/library/</TT>. This behavior can be
changed using command line options <TT>--no-externals</TT> and
<TT>--coqlib</TT>; see below.<BR>
<BR>

<H5>Hiding / Showing parts of the source.</H5>
Some parts of the source can be hidden using command line options
<TT>-g</TT> and <TT>-l</TT> (see below), or using such comments:
<PRE>
(* begin hide *)
<EM>some Coq material</EM>
(* end hide *)
</PRE>
Conversely, some parts of the source which would be hidden can be
shown using such comments: 
<PRE>
(* begin show *)
<EM>some Coq material</EM>
(* end show *)
</PRE>
The latter cannot be used around some inner parts of a proof, but can
be used around a whole proof.<BR>
<BR>

<H3><A NAME="htoc310">13.4.2</A>&nbsp;&nbsp;Usage</H3>
<FONT COLOR=purple>coqdoc</FONT> is invoked on a shell command line as follows:
<DIV ALIGN=center>
 <TT>coqdoc </TT>&lt;<I>options and files</I>&gt;
</DIV>
Any command line argument which is not an option is considered to be a
file (even if it starts with a <CODE>-</CODE>). <FONT COLOR=navy>Coq</FONT> files are identified
by the suffixes <CODE>.v</CODE> and <CODE>.g</CODE> and L<sup>A</sup>T<sub>E</sub>X files by the
suffix <CODE>.tex</CODE>. 
<DL COMPACT=compact><DT>
<B>HTML output</B><DD> &nbsp;<BR>
<BR>
This is the default output.
 One HTML file is created for each <FONT COLOR=navy>Coq</FONT> file given on the command line,
 together with a file <TT>index.html</TT> (unless option
 <TT>-no-index</TT> is passed). The HTML pages use a style sheet
 named <TT>style.css</TT>. Such a file is distributed with <FONT COLOR=purple>coqdoc</FONT>.<BR>
<BR>
<DT><B>L<sup>A</sup>T<sub>E</sub>X output</B><DD> &nbsp;<BR>
<BR>
A single L<sup>A</sup>T<sub>E</sub>X file is created, on standard output. It can be
 redirected to a file with option <TT>-o</TT>. 
 The order of files on the command line is kept in the final
 document. L<sup>A</sup>T<sub>E</sub>X files given on the command line are copied `as is'
 in the final document .
 DVI and PostScript can be produced directly with the options
 <TT>-dvi</TT> and <TT>-ps</TT> respectively.<BR>
<BR>
<DT><B>TeXmacs output</B><DD> &nbsp;<BR>
<BR>
To translate the input files to TeXmacs format, to be used by
 the TeXmacs Coq interface 
 (see <TT>http://www-sop.inria.fr/lemme/Philippe.Audebaud/tmcoq/</TT>).
</DL>

<H4>Command line options</H4>

<H5>Overall options</H5>
<DL COMPACT=compact><DT><B><TT>--html</TT></B><DD> &nbsp;<BR>
<BR>
Select a HTML output.<BR>
<BR>
<DT><B><TT>--latex</TT></B><DD> &nbsp;<BR>
<BR>
Select a L<sup>A</sup>T<sub>E</sub>X output.<BR>
<BR>
<DT><B><TT>--dvi</TT></B><DD> &nbsp;<BR>
<BR>
Select a DVI output.<BR>
<BR>
<DT><B><TT>--ps</TT></B><DD> &nbsp;<BR>
<BR>
Select a PostScript output.<BR>
<BR>
<DT><B><TT>--texmacs</TT></B><DD> &nbsp;<BR>
<BR>
Select a TeXmacs output.<BR>
<BR>
<DT><B><TT>-o </TT></B><B><I>file</I></B><B>, <TT>--output </TT></B><B><I>file</I></B><DD> &nbsp;<BR>
<BR>
Redirect the output into the file `<I>file</I>' (meaningless with
 <TT>-html</TT>).<BR>
<BR>
<DT><B><TT>-d </TT></B><B><I>dir</I></B><B>, <TT>--directory </TT></B><B><I>dir</I></B><DD> &nbsp;<BR>
<BR>
 Output files into directory `<I>dir</I>' instead of current
 directory (option <TT>-d</TT> does not change the filename specified
 with option <TT>-o</TT>, if any).<BR>
<BR>
<DT><B><TT>-s </TT></B><B>, <TT>--short</TT></B><DD> &nbsp;<BR>
<BR>
Do not insert titles for the files. The default behavior is to
 insert a title like ``Library Foo'' for each file.<BR>
<BR>
<DT><B><TT>-t </TT></B><B><I>string</I></B><B>, 
 <TT>--title </TT></B><B><I>string</I></B><DD> &nbsp;<BR>
<BR>
Set the document title. <BR>
<BR>
<DT><B><TT>--body-only</TT></B><DD> &nbsp;<BR>
<BR>
 Suppress the header and trailer of the final document. Thus, you can
 insert the resulting document into a larger one.<BR>
<BR>
<DT><B><TT>-p</TT></B><B> <I>string</I></B><B>, <TT>--preamble</TT></B><B> <I>string</I></B><DD>&nbsp;<BR>
<BR>
 Insert some material in the L<sup>A</sup>T<sub>E</sub>X preamble, right before
 <CODE>\begin{document}</CODE> (meaningless with <TT>-html</TT>).<BR>
<BR>
<DT><B><TT>--vernac-file </TT></B><B><I>file</I></B><B>,
 <TT>--tex-file </TT></B><B><I>file</I></B><DD> &nbsp;<BR>
<BR>
Considers the file `<I>file</I>' respectively as a <CODE>.v</CODE>
 (or <CODE>.g</CODE>) file or a <CODE>.tex</CODE> file.<BR>
<BR>
<DT><B><TT>--files-from </TT></B><B><I>file</I></B><DD> &nbsp;<BR>
<BR>
 Read file names to process in file `<I>file</I>' as if they were
 given on the command line. Useful for program sources splitted in
 several directories.<BR>
<BR>
<DT><B><TT>-q</TT></B><B>, <TT>--quiet</TT></B><DD> &nbsp;<BR>
<BR>
 Be quiet. Do not print anything except errors.<BR>
<BR>
<DT><B><TT>-h</TT></B><B>, <TT>--help</TT></B><DD> &nbsp;<BR>
<BR>
 Give a short summary of the options and exit.<BR>
<BR>
<DT><B><TT>-v</TT></B><B>, <TT>--version</TT></B><DD> &nbsp;<BR>
<BR>
 Print the version and exit.</DL>

<H5>Index options</H5> &nbsp;<BR>
<BR>
Default behavior is to build an index, for the HTML output only, into
<TT>index.html</TT>.
<DL COMPACT=compact><DT><B><TT>--no-index</TT></B><DD> &nbsp;<BR>
<BR>
Do not output the index.<BR>
<BR>
<DT><B><TT>--multi-index</TT></B><DD> &nbsp;<BR>
<BR>
Generate one page for each category and each letter in the index,
 together with a top page <TT>index.html</TT>.</DL>

<H5>Table of contents option</H5> &nbsp;
<DL COMPACT=compact><DT><B><TT>-toc</TT></B><B>, <TT>--table-of-contents</TT></B><DD> &nbsp;<BR>
<BR>
 Insert a table of contents.
 For a L<sup>A</sup>T<sub>E</sub>X output, it inserts a <CODE>\tableofcontents</CODE> at the
 beginning of the document. For a HTML output, it builds a table of
 contents into <TT>toc.html</TT>.</DL>

<H5>Hyperlinks options</H5>
<DL COMPACT=compact><DT><B><TT>--glob-from </TT></B><B><I>file</I></B><DD> &nbsp;<BR>
<BR>
Make references using <FONT COLOR=navy>Coq</FONT> globalizations from file <I>file</I>. 
 (Such globalizations are obtained with <FONT COLOR=navy>Coq</FONT> option <TT>-dump-glob</TT>).<BR>
<BR>
<DT><B><TT>--no-externals</TT></B><DD> &nbsp;<BR>
<BR>
Do not insert links to the <FONT COLOR=navy>Coq</FONT> standard library.<BR>
<BR>
<DT><B><TT>--coqlib </TT></B><B><I>url</I></B><DD> &nbsp;<BR>
<BR>
 Set base URL for the <FONT COLOR=navy>Coq</FONT> standard library (default is 
 <TT>http://coq.inria.fr/library/</TT>).<BR>
<BR>
<DT><B><TT>-R </TT></B><B><I>dir </I></B><B><I>coqdir</I></B><DD> &nbsp;<BR>
<BR>
 Map physical directory <I>dir</I> to <FONT COLOR=navy>Coq</FONT> logical directory
 <I>coqdir</I> (similarly to <FONT COLOR=navy>Coq</FONT> option <TT>-R</TT>).<BR>
<BR>
Note: option <TT>-R</TT> only has effect on the files
 <EM>following</EM> it on the command line, so you will probably need
 to put this option first.</DL>

<H5>Contents options</H5>
<DL COMPACT=compact><DT><B><TT>-g</TT></B><B>, <TT>--gallina</TT></B><DD> &nbsp;<BR>
<BR>
 Do not print proofs.<BR>
<BR>
<DT><B><TT>-l</TT></B><B>, <TT>--light</TT></B><DD> &nbsp;<BR>
<BR>
Light mode. Suppress proofs (as with <TT>-g</TT>) and the following commands:
 <UL><LI>
 [<TT>Recursive</TT>] <TT>Tactic Definition</TT>
 <LI><TT>Hint / Hints</TT> 
 <LI><TT>Require</TT>
 <LI><TT>Transparent / Opaque</TT>
 <LI><TT>Implicit Argument / Implicits</TT>
 <LI><TT>Section / Variable / Hypothesis / End</TT>
 </UL></DL>

The behavior of options <TT>-g</TT> and <TT>-l</TT> can be locally
overridden using the <TT>(* begin show *)</TT> ... <TT>(* end
 show *)</TT> environment (see above).<BR>
<BR>

<H5>Language options</H5> &nbsp;<BR>
<BR>
Default behavior is to assume ASCII 7 bits input files.
<DL COMPACT=compact><DT><B><TT>-latin1</TT></B><B>, <TT>--latin1</TT></B><DD> &nbsp;<BR>
<BR>
 Select ISO-8859-1 input files. It is equivalent to
 <TT>--inputenc latin1 --charset iso-8859-1</TT>.<BR>
<BR>
<DT><B><TT>-utf8</TT></B><B>, <TT>--utf8</TT></B><DD> &nbsp;<BR>
<BR>
 Select UTF-8 (Unicode) input files. It is equivalent to
 <TT>--inputenc utf8 --charset utf-8</TT>.
 L<sup>A</sup>T<sub>E</sub>X UTF-8 support can be found at
 <TT>http://www.ctan.org/tex-archive/macros/latex/contrib/supported/unicode/</TT>.<BR>
<BR>
<DT><B><TT>--inputenc</TT></B><B> <I>string</I></B><DD> &nbsp;<BR>
<BR>
 Give a L<sup>A</sup>T<sub>E</sub>X input encoding, as an option to L<sup>A</sup>T<sub>E</sub>X package
 <TT>inputenc</TT>. <BR>
<BR>
<DT><B><TT>--charset</TT></B><B> <I>string</I></B><DD> &nbsp;<BR>
<BR>
 Specify the HTML character set, to be inserted in the HTML header.</DL>

<H3><A NAME="htoc311">13.4.3</A>&nbsp;&nbsp;The coqdoc L<sup>A</sup>T<sub>E</sub>X style file</H3>
<A NAME="section:coqdoc.sty"></A>
In case you choose to produce a document without the default L<sup>A</sup>T<sub>E</sub>X
preamble (by using option <CODE>--no-preamble</CODE>), then you must insert
into your own preamble the command
<BLOCKQUOTE>
 <CODE>\usepackage{coqdoc}</CODE>
</BLOCKQUOTE>
Then you may alter the rendering of the document by
redefining some macros:
<DL COMPACT=compact><DT><B><TT>coqdockw</TT></B><B>, <TT>coqdocid</TT></B><DD> &nbsp; <BR>
<BR>
The one-argument macros for typesetting keywords and identifiers.
 Defaults are sans-serif for keywords and italic for identifiers.<BR>
<BR>
For example, if you would like a slanted font for keywords, you
 may insert 
<PRE>
     \renewcommand{\coqdockw}[1]{\textsl{#1}}
</PRE>anywhere between <CODE>\usepackage{coqdoc}</CODE> and
 <CODE>\begin{document}</CODE>. <BR>
<BR>
<DT><B><TT>coqdocmodule</TT></B><DD> &nbsp; <BR>
<BR>
One-argument macro for typesetting the title of a <CODE>.v</CODE> file.
 Default is
<PRE>
\newcommand{\coqdocmodule}[1]{\section*{Module #1}}
</PRE>and you may redefine it using <CODE>\renewcommand</CODE>.</DL>
<A NAME="toc81"></A>
<H2><A NAME="htoc312">13.5</A>&nbsp;&nbsp;Exporting <FONT COLOR=navy>Coq</FONT> theories to XML</H2>
<A NAME="Helm"></A>
<A NAME="@default669"></A>
<A NAME="@default670"></A>
This section describes the exportation of <FONT COLOR=navy>Coq</FONT> theories to XML that
has been contributed by Claudio Sacerdoti Coen. Currently, the main
applications are the rendering and searching tool
developed within the HELM<SUP><A NAME="text20" HREF="#note20">1</A></SUP> and MoWGLI<SUP><A NAME="text21" HREF="#note21">2</A></SUP> projects mainly at the University of Bologna and
partly at INRIA-Sophia Antipolis.<BR>
<BR>

<H3><A NAME="htoc313">13.5.1</A>&nbsp;&nbsp;Practical use of the XML exportation tool</H3>
The basic way to export the logical content of a file into XML format
is to use <TT>coqc</TT> with option <TT>-xml</TT>. 
When the <TT>-xml</TT> flag is set, every definition or declaration is
immediately exported to XML once concluded.
The system environment variable <TT>COQ_XML_LIBRARY_ROOT</TT> must be
previously set to a directory in which the logical structure of the
exported objects is reflected.<BR>
<BR>
For <TT>Makefile</TT> files generated by <CODE>coq_makefile</CODE> (see section
 <A HREF="#Makefile">13.3</A>), it is sufficient to compile the files using
 <BLOCKQUOTE>
 <CODE>make COQ_XML=-xml</CODE>
 </BLOCKQUOTE>
 (or, equivalently, setting the environment variable <CODE>COQ_XML</CODE>)<BR>
<BR>
To export a development to XML, the suggested procedure is then:
<OL type=1><LI>
 add to your own contribution a valid <CODE>Make</CODE> file and use
 <CODE>coq_makefile</CODE> to generate the <CODE>Makefile</CODE> from the <CODE>Make</CODE>
 file.<BR>
<BR>
<BR>
<B>Warning: </B>Since logical names are used to structure the XML
 hierarchy, always add to the <CODE>Make</CODE> file at least one <CODE>"-R"</CODE>
 option to map physical file names to logical module paths.
 <LI>set the <CODE>COQ_XML_LIBRARY_ROOT</CODE> environment variable to
 the directory where the XML file hierarchy must be physically
 rooted.
 <LI>compile your contribution with <CODE>"make COQ_XML=-xml"</CODE>
 </OL>
<BR>
<B>Remark: </B>In case the system variable <TT>COQ_XML_LIBRARY_ROOT</TT> is not set,
the output is done on the standard output. Also, the files are
compressed using <TT>gzip</TT> after creation. This is to save disk space
since the XML format is very verbose.<BR>
<BR>

<H3><A NAME="htoc314">13.5.2</A>&nbsp;&nbsp;Reflection of the logical structure into the file system</H3>
For each <FONT COLOR=navy>Coq</FONT> logical object, several independent files associated
to this object are created. The structure of the long name of the
object is reflected in the directory structure of the file system.
E.g. an object of long name <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>.....</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I> is exported to files in the
subdirectory <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB>/.../<I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> of the directory 
bound to the environment variable <TT>COQ_XML_LIBRARY_ROOT</TT>.<BR>
<BR>

<H3><A NAME="htoc315">13.5.3</A>&nbsp;&nbsp;What is exported?</H3>
The XML exportation tool exports the logical content of <FONT COLOR=navy>Coq</FONT>
theories. This covers global definitions (including lemmas, theorems,
...), global assumptions (parameters and axioms), local assumptions or
definitions, and inductive definitions.<BR>
<BR>
Vernacular files are exported to <TT>.theory.xml</TT> files. 
Comments are pre-processed with <FONT COLOR=purple>coqdoc</FONT> (see section
<A HREF="#coqdoc">13.4</A>). Especially, they have to be enclosed within <TT>(**</TT>
and <TT>*)</TT> to be exported.<BR>
<BR>
For each inductive definition of name
<I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB>.....<I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>.<I><FONT COLOR=maroon>ident</FONT></I>, a file named <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.ind.xml</TT> is created in the subdirectory <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>/.../</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB> of the xml library root
directory. It contains the arities and constructors of the type. For mutual inductive definitions, the file is named after the
name of the first inductive type of the block.<BR>
<BR>
For each global definition of base name <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>.....</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I>, files named
<TT></TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.con.body.xml</TT> and <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.con.xml</TT> are created in the
subdirectory <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>/.../</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB>. They
respectively contain the body and the type of the definition.<BR>
<BR>
For each global assumption of base name <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB><TT>.....</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I>, a file
named <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.con.xml</TT> is created in the subdirectory <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>/.../</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB>. It contains the type of the
global assumption.<BR>
<BR>
For each local assumption or definition of base name <I><FONT COLOR=maroon>ident</FONT></I> located
in sections <I><FONT COLOR=maroon>ident</FONT></I>'<SUB><FONT SIZE=2>1</FONT></SUB>, ..., <I><FONT COLOR=maroon>ident</FONT></I>'<SUB><FONT SIZE=2><I>p</I></FONT></SUB> of the module <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB><TT>.....</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I>, a file
named <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.var.xml</TT> is created in the subdirectory <TT></TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>/.../</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>/</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>/.../</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><SUB><TT><FONT SIZE=2><I>p</I></FONT></TT></SUB>.
It contains its type and, if a definition, its body.<BR>
<BR>
In order to do proof-rendering (for example in natural language), some
redundant typing information is required, i.e. the type of at least
some of the subterms of the bodies and types of the CIC objects. These
types are called inner types and are exported to files of suffix <TT>.types.xml</TT> by the exportation tool.<BR>
<BR>

<H3><A NAME="htoc316">13.5.4</A>&nbsp;&nbsp;Inner types</H3>
<A NAME="inner-types"></A>
The type of a subterm of a construction is called an <EM>inner type</EM>
if it respects the following conditions.
<OL type=1><LI>
 Its sort is <CODE>Prop</CODE><SUP><A NAME="text22" HREF="#note22">3</A></SUP>.
 <LI>It is not a type cast nor an atomic term (variable, constructor or constant).
 <LI>If it's root is an abstraction, then the root's parent node is
 not an abstraction, i.e. only the type of the outer abstraction of
 a block of nested abstractions is printed.
</OL>
The rationale for the 3<SUP><FONT SIZE=2><I>rd</I></FONT></SUP> condition is that the type of the inner
abstractions could be easily computed starting from the type of the
outer ones; moreover, the types of the inner abstractions requires a
lot of disk/memory space: removing the 3<SUP><FONT SIZE=2><I>rd</I></FONT></SUP> condition leads to XML
file that are two times as big as the ones exported applying the 3<SUP><FONT SIZE=2><I>rd</I></FONT></SUP>
condition.<BR>
<BR>

<H3><A NAME="htoc317">13.5.5</A>&nbsp;&nbsp;Interactive exportation commands</H3>
There are also commands to be used interactively in <TT>coqtop</TT>.<BR>
<BR>

<H4><TT>Print XML </TT><I><FONT COLOR=maroon>qualid</FONT></I></H4>
<A NAME="@default671"></A><A NAME="@command189"></A>
If the variable <TT>COQ_XML_LIBRARY_ROOT</TT> is set, this command creates
files containing the logical content in XML format of <I><FONT COLOR=maroon>qualid</FONT></I>. If
the variable is not set, the result is displayed on the standard
output.<BR>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI>
<TT>Print XML File </TT><I><FONT COLOR=maroon>string</FONT></I><TT> </TT><I><FONT COLOR=maroon>qualid</FONT></I><BR>
This writes the logical content of <I><FONT COLOR=maroon>qualid</FONT></I> in XML format to files
whose prefix is <I><FONT COLOR=maroon>string</FONT></I>.
</OL>

<H4><TT>Show XML Proof</TT></H4>
<A NAME="@default672"></A><A NAME="@command190"></A>
If the variable <TT>COQ_XML_LIBRARY_ROOT</TT> is set, this command creates
files containing the current proof in progress in XML format. It
writes also an XML file made of inner types. If the variable is not
set, the result is displayed on the standard output.<BR>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI>
<TT>Show XML File </TT><I><FONT COLOR=maroon>string</FONT></I><TT> Proof</TT><BR>
This writes the
logical content of <I><FONT COLOR=maroon>qualid</FONT></I> in XML format to files whose prefix is
<I><FONT COLOR=maroon>string</FONT></I>. 
</OL>

<H3><A NAME="htoc318">13.5.6</A>&nbsp;&nbsp;Applications: rendering, searching and publishing</H3>
The HELM team at the University of Bologna has developed tools
exploiting the XML exportation of <FONT COLOR=navy>Coq</FONT> libraries. This covers
rendering, searching and publishing tools.<BR>
<BR>
All these tools require a running http server and, if possible, a
MathML compliant browser. The procedure to install the suite of tools
ultimately allowing rendering and searching can be found on the HELM
web site <TT>http://helm.cs.unibo.it/library.html</TT>.<BR>
<BR>
It may be easier though to upload your developments on the HELM http
server and to re-use the infrastructure running on it. This requires
publishing your development. To this aim, follow the instructions on
<TT>http://mowgli.cs.unibo.it</TT>.<BR>
<BR>
Notice that the HELM server already hosts a copy of the standard
library of <FONT COLOR=navy>Coq</FONT> and of the <FONT COLOR=navy>Coq</FONT> user contributions.<BR>
<BR>

<H3><A NAME="htoc319">13.5.7</A>&nbsp;&nbsp;Technical informations</H3>

<H4>CIC with Explicit Named Substitutions</H4>
The exported files are XML encoding of the lambda-terms used by the
<FONT COLOR=navy>Coq</FONT> system. The implementative details of the <FONT COLOR=navy>Coq</FONT> system are hidden as much
as possible, so that the XML DTD is a straightforward encoding of the
Calculus of (Co)Inductive Constructions.<BR>
<BR>
Nevertheless, there is a feature of the <FONT COLOR=navy>Coq</FONT> system that can not be
hidden in a completely satisfactory way: discharging (see Sect.<A HREF="Reference-Manual004.html#Section">2.3</A>).
In <FONT COLOR=navy>Coq</FONT> it is possible
to open a section, declare variables and use them in the rest of the section
as if they were axiom declarations. Once the section is closed, every definition and theorem in the section is discharged by abstracting it over the section
variables. Variable declarations as well as section declarations are entirely
dropped. Since we are interested in an XML encoding of definitions and
theorems as close as possible to those directly provided the user, we
do not want to export discharged forms. Exporting non-discharged theorem
and definitions together with theorems that rely on the discharged forms
obliges the tools that work on the XML encoding to implement discharging to
achieve logical consistency. Moreover, the rendering of the files can be
misleading, since hyperlinks can be shown between occurrences of the discharge
form of a definition and the non-discharged definition, that are different
objects.<BR>
<BR>
To overcome the previous limitations, Claudio Sacerdoti Coen developed in his
PhD. thesis an extension of CIC, called Calculus of (Co)Inductive Constructions
with Explicit Named Substitutions, that is a slight extension of CIC where
discharging is not necessary. The DTD of the exported XML files describes
constants, inductive types and variables of the Calculus of (Co)Inductive
Constructions with Explicit Named Substitutions. The conversion to the new
calculus is performed during the exportation phase.<BR>
<BR>
The following example shows a very small <FONT COLOR=navy>Coq</FONT> development together with its
version in CIC with Explicit Named Substitutions.
<PRE>
# CIC version: #
Section S.
 Variable A : Prop.

 Definition impl := A -&gt; A.

 Theorem t : impl.           (* uses the undischarged form of impl *)
  Proof.
   exact (fun (a:A) =&gt; a).
  Qed.

End S.

Theorem t' : (impl False).   (* uses the discharged form of impl *)
 Proof.
  exact (t False).           (* uses the discharged form of t *)
 Qed.
</PRE><PRE>
# Corresponding CIC with Explicit Named Substitutions version: #
Section S.
 Variable A : Prop.
 
 Definition impl(A) := A -&gt; A. (* theorems and definitions are
                                  explicitly abstracted over the
                                  variables. The name is sufficient to
                                  completely describe the abstraction *)
 
 Theorem t(A) : impl.          (* impl where A is not instantiated *)
  Proof.
   exact (fun (a:A) =&gt; a).
  Qed.
 
End S.
 
Theorem t'() : impl{False/A}. (* impl where A is instantiated with False
                                 Notice that t' does not depend on A     *)
 Proof.
  exact t{False/A}.           (* t where A is instantiated with False *)
 Qed.
</PRE>Further details on the typing and reduction rules of the calculus can be
found in Claudio Sacerdoti Coen PhD. dissertation, where the consistency
of the calculus is also proved.<BR>
<BR>

<H4>The CIC with Explicit Named Substitutions XML DTD</H4>
A copy of the DTD can be found in the file ``<CODE>cic.dtd</CODE>'' in the
<CODE>contrib/xml</CODE> source directory of <FONT COLOR=navy>Coq</FONT>.
The following is a very brief overview of the elements described in the DTD.
<DL COMPACT=compact><DT><DD><TT>&lt;ConstantType&gt;</TT>
 is the root element of the files that correspond to constant types.
 <DT><DD><TT>&lt;ConstantBody&gt;</TT>
 is the root element of the files that correspond to constant bodies.
 It is used only for closed definitions and theorems (i.e. when no
 metavariable occurs in the body or type of the constant)
 <DT><DD><TT>&lt;CurrentProof&gt;</TT>
 is the root element of the file that correspond to the body of a constant
 that depends on metavariables (e.g. unfinished proofs)
 <DT><DD><TT>&lt;Variable&gt;</TT>
 is the root element of the files that correspond to variables
 <DT><DD><TT>&lt;InductiveTypes&gt;</TT>
 is the root element of the files that correspond to blocks
 of mutually defined inductive definitions
</DL>
The elements
 <CODE>&lt;LAMBDA&gt;</CODE>, <CODE>&lt;CAST&gt;</CODE>, <CODE>&lt;PROD&gt;</CODE>, <CODE>&lt;REL&gt;</CODE>, <CODE>&lt;SORT&gt;</CODE>,
 <CODE>&lt;APPLY&gt;</CODE>, <CODE>&lt;VAR&gt;</CODE>, <CODE>&lt;META&gt;</CODE>, <CODE>&lt;IMPLICIT&gt;</CODE>, <CODE>&lt;CONST&gt;</CODE>, <CODE>&lt;LETIN&gt;</CODE>, <CODE>&lt;MUTIND&gt;</CODE>, <CODE>&lt;MUTCONSTRUCT&gt;</CODE>, <CODE>&lt;MUTCASE&gt;</CODE>,
 <CODE>&lt;FIX&gt;</CODE> and <CODE>&lt;COFIX&gt;</CODE> are used to encode the constructors of CIC.
 The <CODE>sort</CODE> or <CODE>type</CODE> attribute of the element, if present, is
 respectively the sort or the type of the term, that is a sort because of the
 typing rules of CIC.<BR>
<BR>
The element <CODE>&lt;instantiate&gt;</CODE> correspond to the application of an explicit
named substitution to its first argument, that is a reference to a definition
or declaration in the environment.<BR>
<BR>
All the other elements are just syntactic sugar.<BR>
<BR>
<A NAME="toc82"></A>
<H2><A NAME="htoc320">13.6</A>&nbsp;&nbsp;Embedded <FONT COLOR=navy>Coq</FONT> phrases inside L<sup>A</sup>T<sub>E</sub>X documents</H2><A NAME="Latex"></A>
 <A NAME="@default673"></A><A NAME="@default674"></A>
When writing a documentation about a proof development, one may want
to insert <FONT COLOR=navy>Coq</FONT> phrases inside a L<sup>A</sup>T<sub>E</sub>X document, possibly together with
the corresponding answers of the system. We provide a
mechanical way to process such <FONT COLOR=navy>Coq</FONT> phrases embedded in L<sup>A</sup>T<sub>E</sub>X files: the
<TT>coq-tex</TT> filter. This filter extracts Coq phrases embedded in
LaTeX files, evaluates them, and insert the outcome of the evaluation
after each phrase.<BR>
<BR>
Starting with a file <EM>file</EM><TT>.tex</TT> containing <FONT COLOR=navy>Coq</FONT> phrases,
the <TT>coq-tex</TT> filter produces a file named <EM>file</EM><TT>.v.tex</TT> with
the <FONT COLOR=navy>Coq</FONT> outcome. <BR>
<BR>
There are options to produce the <FONT COLOR=navy>Coq</FONT> parts in smaller font, italic,
between horizontal rules, etc.
See the man page of <TT>coq-tex</TT> for more details.<BR>
<BR>
<BR>
<B>Remark.</B> This Reference Manual and the Tutorial
have been completely produced with <TT>coq-tex</TT>.<BR>
<BR>
<A NAME="toc83"></A>
<H2><A NAME="htoc321">13.7</A>&nbsp;&nbsp;<FONT COLOR=navy>Coq</FONT> and <FONT COLOR=navy>GNU Emacs</FONT></H2><A NAME="Emacs"></A><A NAME="@default675"></A>

<H3><A NAME="htoc322">13.7.1</A>&nbsp;&nbsp;The <FONT COLOR=navy>Coq</FONT> Emacs mode</H3>
<FONT COLOR=navy>Coq</FONT> comes with a Major mode for <FONT COLOR=navy>GNU Emacs</FONT>, <TT>coq.el</TT>. This mode provides
syntax highlighting (assuming your <FONT COLOR=navy>GNU Emacs</FONT> library provides
<TT>hilit19.el</TT>) and also a rudimentary indentation facility
in the style of the Caml <FONT COLOR=navy>GNU Emacs</FONT> mode.<BR>
<BR>
Add the following lines to your <CODE>.emacs</CODE> file:
<PRE>
  (setq auto-mode-alist (cons '("\\.v$" . coq-mode) auto-mode-alist))
  (autoload 'coq-mode "coq" "Major mode for editing Coq vernacular." t)
</PRE>
The <FONT COLOR=navy>Coq</FONT> major mode is triggered by visiting a file with extension <TT>.v</TT>,
or manually with the command <CODE>M-x coq-mode</CODE>.
It gives you the correct syntax table for
the <FONT COLOR=navy>Coq</FONT> language, and also a rudimentary indentation facility:
<UL><LI>
 pressing <FONT COLOR=navy>Tab</FONT> at the beginning of a line indents the line like
 the line above;<BR>
<BR>
<LI>extra <FONT COLOR=navy>Tab</FONT>s increase the indentation level
 (by 2 spaces by default);<BR>
<BR>
<LI>M-<FONT COLOR=navy>Tab</FONT> decreases the indentation level.
</UL>
An inferior mode to run <FONT COLOR=navy>Coq</FONT> under Emacs, by Marco Maggesi, is also
included in the distribution, in file <TT>coq-inferior.el</TT>.
Instructions to use it are contained in this file.<BR>
<BR>

<H3><A NAME="htoc323">13.7.2</A>&nbsp;&nbsp;Proof General</H3><A NAME="@default676"></A>
Proof General is a generic interface for proof assistants based on
Emacs (or XEmacs). The main idea is that the <FONT COLOR=navy>Coq</FONT> commands you are
editing are sent to a <FONT COLOR=navy>Coq</FONT> toplevel running behind Emacs and the
answers of the system automatically inserted into other Emacs buffers. 
Thus you don't need to copy-paste the <FONT COLOR=navy>Coq</FONT> material from your files
to the <FONT COLOR=navy>Coq</FONT> toplevel or conversely from the <FONT COLOR=navy>Coq</FONT> toplevel to some
files. <BR>
<BR>
Proof General is developped and distributed independently of the
system <FONT COLOR=navy>Coq</FONT>. It is freely available at <CODE>proofgeneral.inf.ed.ac.uk</CODE>.<BR>
<BR>
<A NAME="toc84"></A>
<H2><A NAME="htoc324">13.8</A>&nbsp;&nbsp;Module specification</H2><A NAME="gallina"></A><A NAME="@default677"></A>
Given a <FONT COLOR=navy>Coq</FONT> vernacular file, the <TT>gallina</TT> filter extracts its
specification (inductive types declarations, definitions, type of
lemmas and theorems), removing the proofs parts of the file. The <FONT COLOR=navy>Coq</FONT>
file <EM>file</EM><TT>.v</TT> gives birth to the specification file
<EM>file</EM><TT>.g</TT> (where the suffix <TT>.g</TT> stands for <FONT COLOR=navy>Gallina</FONT>).<BR>
<BR>
See the man page of <TT>gallina</TT> for more details and options.<BR>
<BR>
<A NAME="toc85"></A>
<H2><A NAME="htoc325">13.9</A>&nbsp;&nbsp;Man pages</H2><A NAME="ManPages"></A><A NAME="@default678"></A>
There are man pages for the commands <TT>coqdep</TT>, <TT>gallina</TT> and
<TT>coq-tex</TT>. Man pages are installed at installation time
(see installation instructions in file <TT>INSTALL</TT>, step 6).<BR>
<BR>

<BR>
<BR>
<HR WIDTH="50%" SIZE=1><DL><DT><A NAME="note20" HREF="#text20"><FONT SIZE=5>1</FONT></A><DD>Hypertextual Electronic Library of
Mathematics
<DT><A NAME="note21" HREF="#text21"><FONT SIZE=5>2</FONT></A><DD>Mathematics on the Web, Get it by
Logic and Interfaces
<DT><A NAME="note22" HREF="#text22"><FONT SIZE=5>3</FONT></A><DD>or <TT>CProp</TT> which is the
 "sort"-like definition used in C-CoRN (see
 <TT>http://vacuumcleaner.cs.kun.nl/c-corn</TT>) to type
 computationally relevant predicative propositions.
</DL>
<HR>
<A HREF="Reference-Manual014.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual016.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
