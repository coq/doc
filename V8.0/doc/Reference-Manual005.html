<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
<TITLE>
The Coq library
</TITLE>
</HEAD>
<BODY >
<A HREF="Reference-Manual004.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual006.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><A NAME="htoc66">Chapter&nbsp;3</A>&nbsp;&nbsp;The <FONT COLOR=navy>Coq</FONT> library</H1>
<A NAME="@default116"></A><A NAME="Theories"></A>
The <FONT COLOR=navy>Coq</FONT> library is structured into three parts:
<DL COMPACT=compact><DT>
<B>The initial library:</B><DD> it contains
 elementary logical notions and datatypes. It constitutes the
 basic state of the system directly available when running
 <FONT COLOR=navy>Coq</FONT>;<BR>
<BR>
<DT><B>The standard library:</B><DD> general-purpose libraries containing
 various developments of <FONT COLOR=navy>Coq</FONT> axiomatizations about sets, lists,
 sorting, arithmetic, etc. This library comes with the system and its
 modules are directly accessible through the <CODE>Require</CODE> command
 (see section&nbsp;<A HREF="Reference-Manual008.html#Require">6.4.1</A>);<BR>
<BR>
<DT><B>User contributions:</B><DD> Other specification and proof developments
 coming from the <FONT COLOR=navy>Coq</FONT> users' community. These libraries are no
 longer distributed with the system. They are available by anonymous
 FTP (see section&nbsp;<A HREF="#Contributions">3.3</A>).
</DL>
This chapter briefly reviews these libraries.<BR>
<BR>
<A NAME="toc19"></A>
<H2><A NAME="htoc67">3.1</A>&nbsp;&nbsp;The basic library</H2>
<A NAME="Prelude"></A>
This section lists the basic notions and results which are directly
available in the standard <FONT COLOR=navy>Coq</FONT> system
<SUP><A NAME="text3" HREF="#note3">1</A></SUP>.<BR>
<BR>

<H3><A NAME="htoc68">3.1.1</A>&nbsp;&nbsp;Notations</H3> <A NAME="Notations"></A>
This module defines the parsing and pretty-printing of many symbols
(infixes, prefixes, etc.). However, it does not assign a meaning to these
notations. The purpose of this is to define precedence and
associativity of very common notations, and avoid users to use them
with other precedence, which may be confusing.
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=center NOWRAP>Notation</TD>
<TD ALIGN=left NOWRAP>Precedence</TD>
<TD ALIGN=left NOWRAP>Associativity</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;-&gt; _</CODE></TD>
<TD ALIGN=left NOWRAP>95</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ \/ _</CODE></TD>
<TD ALIGN=left NOWRAP>85</TD>
<TD ALIGN=left NOWRAP>right</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ /\ _</CODE></TD>
<TD ALIGN=left NOWRAP>80</TD>
<TD ALIGN=left NOWRAP>right</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>~ _</CODE></TD>
<TD ALIGN=left NOWRAP>75</TD>
<TD ALIGN=left NOWRAP>right</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ = _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ = _ = _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ = _ :&gt; _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;&gt; _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;&gt; _ :&gt; _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt; _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &gt; _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;= _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &gt;= _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt; _ &lt; _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt; _ &lt;= _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;= _ &lt; _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;= _ &lt;= _</CODE></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ + _</CODE></TD>
<TD ALIGN=left NOWRAP>50</TD>
<TD ALIGN=left NOWRAP>left</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ - _</CODE></TD>
<TD ALIGN=left NOWRAP>50</TD>
<TD ALIGN=left NOWRAP>left</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ * _</CODE></TD>
<TD ALIGN=left NOWRAP>40</TD>
<TD ALIGN=left NOWRAP>left</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ / _</CODE></TD>
<TD ALIGN=left NOWRAP>40</TD>
<TD ALIGN=left NOWRAP>left</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>- _</CODE></TD>
<TD ALIGN=left NOWRAP>35</TD>
<TD ALIGN=left NOWRAP>right</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>/ _</CODE></TD>
<TD ALIGN=left NOWRAP>35</TD>
<TD ALIGN=left NOWRAP>right</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ ^ _</CODE></TD>
<TD ALIGN=left NOWRAP>30</TD>
<TD ALIGN=left NOWRAP>right</TD>
</TR></TABLE>
</DIV>
<BR>
<DIV ALIGN=center>Figure 3.1: Notations in the initial state</DIV><BR>

<A NAME="init-notations"></A>
<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>

<H3><A NAME="htoc69">3.1.2</A>&nbsp;&nbsp;Logic</H3> 
<A NAME="Logic"></A>
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>form</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><TT>True</TT></TD>
<TD ALIGN=right NOWRAP>(<TT>True</TT>)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>False</TT></TD>
<TD ALIGN=right NOWRAP>(<TT>False</TT>)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>~</TT> <I><FONT COLOR=maroon>form</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<TT>not</TT>)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>form</FONT></I> <TT>/\</TT> <I><FONT COLOR=maroon>form</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<TT>and</TT>)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>form</FONT></I> <TT>\/</TT> <I><FONT COLOR=maroon>form</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<TT>or</TT>)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>form</FONT></I> <TT>-&gt;</TT> <I><FONT COLOR=maroon>form</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<EM>primitive implication)</EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>form</FONT></I> <TT>&lt;-&gt;</TT> <I><FONT COLOR=maroon>form</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<TT>iff</TT>)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>forall</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>type</FONT></I> <TT>,</TT>
 <I><FONT COLOR=maroon>form</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<EM>primitive for all)</EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>exists</TT> <I><FONT COLOR=maroon>ident</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>,</TT> <I><FONT COLOR=maroon>form</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<TT>ex</TT>)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>exists2</TT> <I><FONT COLOR=maroon>ident</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>,</TT> <I><FONT COLOR=maroon>form</FONT></I> <TT>&amp;</TT> <I><FONT COLOR=maroon>form</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<TT>ex2</TT>)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I> <TT>=</TT> <I><FONT COLOR=maroon>term</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<TT>eq</TT>)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I> <TT>=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>:&gt;</TT> <I><FONT COLOR=maroon>specif</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<TT>eq</TT>)</TD>
</TR></TABLE>
</DIV>
<BR>
<DIV ALIGN=center>Figure 3.2: Syntax of formulas</DIV><BR>

<A NAME="formulas-syntax"></A>
<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
The basic library of <FONT COLOR=navy>Coq</FONT> comes with the definitions of standard
(intuitionistic) logical connectives (they are defined as inductive
constructions). They are equipped with an appealing syntax enriching the
(subclass <I><FONT COLOR=maroon>form</FONT></I>) of the syntactic class <I><FONT COLOR=maroon>term</FONT></I>. The syntax
extension is shown on figure <A HREF="#formulas-syntax">3.2</A>.<BR>
<BR>
<BR>
<B>Remark: </B>Implication is not defined but primitive (it is a non-dependent
product of a proposition over another proposition). There is also a
primitive universal quantification (it is a dependent product over a
proposition). The primitive universal quantification allows both
first-order and higher-order quantification.<BR>
<BR>

<H4>Propositional Connectives</H4> <A NAME="Connectives"></A>
<A NAME="@default117"></A>
First, we find propositional calculus connectives:
<A NAME="@default118"></A>
<A NAME="@default119"></A>
<A NAME="@default120"></A>
<A NAME="@default121"></A>
<A NAME="@default122"></A>
<A NAME="@default123"></A>
<A NAME="@default124"></A>
<A NAME="@default125"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;True&nbsp;:&nbsp;Prop&nbsp;:=&nbsp;I.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;False&nbsp;:&nbsp;&nbsp;Prop&nbsp;:=&nbsp;.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;not&nbsp;(A:&nbsp;Prop)&nbsp;:=&nbsp;A&nbsp;-&gt;&nbsp;False.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;and&nbsp;(A&nbsp;B:Prop)&nbsp;:&nbsp;Prop&nbsp;:=&nbsp;conj&nbsp;(_:A)&nbsp;(_:B).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;Projections.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variables&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;proj1&nbsp;:&nbsp;A&nbsp;/\&nbsp;B&nbsp;-&gt;&nbsp;A.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;proj2&nbsp;:&nbsp;A&nbsp;/\&nbsp;B&nbsp;-&gt;&nbsp;B.</TT><BR>
</DIV>

<A NAME="@default126"></A>
<A NAME="@default127"></A>
<A NAME="@default128"></A>
<A NAME="@default129"></A>
<A NAME="@default130"></A>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;Projections.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;or&nbsp;(A&nbsp;B:Prop)&nbsp;:&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;or_introl&nbsp;(_:A)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;or_intror&nbsp;(_:B).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;iff&nbsp;(P&nbsp;Q:Prop)&nbsp;:=&nbsp;(P&nbsp;-&gt;&nbsp;Q)&nbsp;/\&nbsp;(Q&nbsp;-&gt;&nbsp;P).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;IF_then_else&nbsp;(P&nbsp;Q&nbsp;R:Prop)&nbsp;:=&nbsp;P&nbsp;/\&nbsp;Q&nbsp;\/&nbsp;~&nbsp;P&nbsp;/\&nbsp;R.</TT><BR>
</DIV>
<BR>

<H4>Quantifiers</H4> <A NAME="Quantifiers"></A>
<A NAME="@default131"></A>
Then we find first-order quantifiers:
<A NAME="@default132"></A>
<A NAME="@default133"></A>
<A NAME="@default134"></A>
<A NAME="@default135"></A>
<A NAME="@default136"></A>
<A NAME="@default137"></A>
<A NAME="@default138"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;all&nbsp;(A:Set)&nbsp;(P:A&nbsp;-&gt;&nbsp;Prop)&nbsp;:=&nbsp;forall&nbsp;x:A,&nbsp;P&nbsp;x.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;ex&nbsp;(A:&nbsp;Set)&nbsp;(P:A&nbsp;-&gt;&nbsp;Prop)&nbsp;:&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex_intro&nbsp;(x:A)&nbsp;(_:P&nbsp;x).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;ex2&nbsp;(A:Set)&nbsp;(P&nbsp;Q:A&nbsp;-&gt;&nbsp;Prop)&nbsp;:&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex_intro2&nbsp;(x:A)&nbsp;(_:P&nbsp;x)&nbsp;(_:Q&nbsp;x).</TT><BR>
</DIV>
<BR>
The following abbreviations are allowed:
<DIV ALIGN=center>
 <TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP><CODE>exists x:A, P</CODE></TD>
<TD ALIGN=left NOWRAP><CODE>ex A (fun x:A =&gt; P)</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>exists x, P</CODE></TD>
<TD ALIGN=left NOWRAP><CODE>ex _ (fun x =&gt; P)</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>exists2 x:A, P &amp; Q</CODE></TD>
<TD ALIGN=left NOWRAP><CODE>ex2 A (fun x:A =&gt; P) (fun x:A =&gt; Q)</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>exists2 x, P &amp; Q</CODE></TD>
<TD ALIGN=left NOWRAP><CODE>ex2 _ (fun x =&gt; P) (fun x =&gt; Q)</CODE></TD>
</TR></TABLE>
</DIV><BR>
The type annotation <TT>:A</TT> can be omitted when <TT>A</TT> can be
synthesized by the system.<BR>
<BR>

<H4>Equality</H4> <A NAME="Equality"></A>
<A NAME="@default139"></A>
Then, we find equality, defined as an inductive relation. That is,
given a <CODE>Type</CODE> <CODE>A</CODE> and an <CODE>x</CODE> of type <CODE>A</CODE>, the
predicate <CODE>(eq A x)</CODE> is the smallest one which contains <CODE>x</CODE>.
This definition, due to Christine Paulin-Mohring, is equivalent to
define <CODE>eq</CODE> as the smallest reflexive relation, and it is also
equivalent to Leibniz' equality.<BR>
<BR>
<A NAME="@default140"></A>
<A NAME="@default141"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;eq&nbsp;(A:Type)&nbsp;(x:A)&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refl_equal&nbsp;:&nbsp;eq&nbsp;A&nbsp;x&nbsp;x.</TT><BR>
</DIV>
<BR>

<H4>Lemmas</H4> 
<A NAME="PreludeLemmas"></A>
Finally, a few easy lemmas are provided.<BR>
<BR>
<A NAME="@default142"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;absurd&nbsp;:&nbsp;forall&nbsp;A&nbsp;C:Prop,&nbsp;A&nbsp;-&gt;&nbsp;~&nbsp;A&nbsp;-&gt;&nbsp;C.</TT><BR>
</DIV>

<A NAME="@default143"></A>
<A NAME="@default144"></A>
<A NAME="@default145"></A>
<A NAME="@default146"></A>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;equality.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variables&nbsp;A&nbsp;B&nbsp;:&nbsp;Type.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;f&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variables&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;A.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;sym_eq&nbsp;:&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;x.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;trans_eq&nbsp;:&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;f_equal&nbsp;:&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;f&nbsp;x&nbsp;=&nbsp;f&nbsp;y.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;sym_not_eq&nbsp;:&nbsp;x&nbsp;&lt;&gt;&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;&lt;&gt;&nbsp;x.</TT><BR>
</DIV>

<A NAME="@default147"></A>
<A NAME="@default148"></A>
<A NAME="@default149"></A>
<A NAME="@default150"></A>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;equality.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;eq_ind_r&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(A:Type)&nbsp;(x:A)&nbsp;(P:A&nbsp;-&gt;&nbsp;Prop),&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y:A,&nbsp;y&nbsp;=&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;eq_rec_r&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(A:Type)&nbsp;(x:A)&nbsp;(P:A&nbsp;-&gt;&nbsp;Set),&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y:A,&nbsp;y&nbsp;=&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;eq_rect_r&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(A:Type)&nbsp;(x:A)&nbsp;(P:A&nbsp;-&gt;&nbsp;Type),&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y:A,&nbsp;y&nbsp;=&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y.</TT><BR>
</DIV>


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Hint&nbsp;Immediate&nbsp;sym_eq&nbsp;sym_not_eq&nbsp;:&nbsp;core.</TT><BR>
</DIV>

<A NAME="@default151"></A><BR>
The theorem <TT>f_equal</TT> is extended to functions with two to five
arguments. The theorem are names <TT>f_equal2</TT>, <TT>f_equal3</TT>, 
<TT>f_equal4</TT> and <TT>f_equal5</TT>.
For instance <TT>f_equal3</TT> is defined the following way.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;f_equal3&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;(A1&nbsp;A2&nbsp;A3&nbsp;B:Type)&nbsp;(f:A1&nbsp;-&gt;&nbsp;A2&nbsp;-&gt;&nbsp;A3&nbsp;-&gt;&nbsp;B)&nbsp;(x1&nbsp;y1:A1)&nbsp;(x2&nbsp;y2:A2)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(x3&nbsp;y3:A3),&nbsp;x1&nbsp;=&nbsp;y1&nbsp;-&gt;&nbsp;x2&nbsp;=&nbsp;y2&nbsp;-&gt;&nbsp;x3&nbsp;=&nbsp;y3&nbsp;-&gt;&nbsp;f&nbsp;x1&nbsp;x2&nbsp;x3&nbsp;=&nbsp;f&nbsp;y1&nbsp;y2&nbsp;y3.</TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc70">3.1.3</A>&nbsp;&nbsp;Datatypes</H3>
<A NAME="Datatypes"></A>
<A NAME="@default152"></A>
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP><I><FONT COLOR=maroon>specif</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>specif</FONT></I> <TT>*</TT> <I><FONT COLOR=maroon>specif</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<TT>prod</TT>)</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>specif</FONT></I> <TT>+</TT> <I><FONT COLOR=maroon>specif</FONT></I></TD>
<TD ALIGN=right NOWRAP>(<TT>sum</TT>)</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>specif</FONT></I> <TT>+ {</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>}</TT></TD>
<TD ALIGN=right NOWRAP>(<TT>sumor</TT>)</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>{</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>} + {</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>}</TT></TD>
<TD ALIGN=right NOWRAP>(<TT>sumbool</TT>)</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>{</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>|</TT> <I><FONT COLOR=maroon>form</FONT></I> <TT>}</TT></TD>
<TD ALIGN=right NOWRAP>(<TT>sig</TT>)</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>{</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>|</TT> <I><FONT COLOR=maroon>form</FONT></I> <TT>&amp;</TT>
 <I><FONT COLOR=maroon>form</FONT></I> <TT>}</TT></TD>
<TD ALIGN=right NOWRAP>(<TT>sig2</TT>)</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>{</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>&amp;</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>}</TT></TD>
<TD ALIGN=right NOWRAP>(<TT>sigS</TT>)</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>{</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>&amp;</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>&amp;</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>}</TT></TD>
<TD ALIGN=right NOWRAP>(<TT>sigS2</TT>)</TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I><FONT COLOR=maroon>term</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><TT>(</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>,</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT></TD>
<TD ALIGN=right NOWRAP>(<TT>pair</TT>)</TD>
</TR></TABLE>
</DIV>
<BR>
<DIV ALIGN=center>Figure 3.3: Syntax of datatypes and specifications</DIV><BR>

<A NAME="specif-syntax"></A>
<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
In the basic library, we find the definition<SUP><A NAME="text4" HREF="#note4">2</A></SUP> of the basic data-types of programming, again
defined as inductive constructions over the sort <CODE>Set</CODE>. Some of
them come with a special syntax shown on Figure&nbsp;<A HREF="#specif-syntax">3.3</A>.<BR>
<BR>

<H4>Programming</H4> 
<A NAME="Programming"></A>
<A NAME="@default153"></A>
<A NAME="libnats"></A>
<A NAME="@default154"></A>
<A NAME="@default155"></A>
<A NAME="@default156"></A>
<A NAME="@default157"></A>
<A NAME="@default158"></A>
<A NAME="@default159"></A>
<A NAME="@default160"></A>
<A NAME="@default161"></A>
<A NAME="@default162"></A>
<A NAME="@default163"></A>
<A NAME="@default164"></A>
<A NAME="@default165"></A>
<A NAME="@default166"></A>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;unit&nbsp;:&nbsp;Set&nbsp;:=&nbsp;tt.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;bool&nbsp;:&nbsp;Set&nbsp;:=&nbsp;true&nbsp;|&nbsp;false.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;nat&nbsp;:&nbsp;Set&nbsp;:=&nbsp;O&nbsp;|&nbsp;S&nbsp;(n:nat).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;option&nbsp;(A:Set)&nbsp;:&nbsp;Set&nbsp;:=&nbsp;Some&nbsp;(_:A)&nbsp;|&nbsp;None.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;identity&nbsp;(A:Type)&nbsp;(a:A)&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Type&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refl_identity&nbsp;:&nbsp;identity&nbsp;A&nbsp;a&nbsp;a.</TT><BR>
</DIV>
<BR>
Note that zero is the letter <CODE>O</CODE>, and <I><FONT COLOR=maroon>not</FONT></I> the numeral
<CODE>0</CODE>.<BR>
<BR>
<TT>identity</TT> is logically equivalent to equality but it lives in
sort <TT>Set</TT>. Computationaly, it behaves like <TT>unit</TT>.<BR>
<BR>
We then define the disjoint sum of <CODE>A+B</CODE> of two sets <CODE>A</CODE> and
<CODE>B</CODE>, and their product <CODE>A*B</CODE>.
<A NAME="@default167"></A>
<A NAME="@default168"></A>
<A NAME="@default169"></A>
<A NAME="@default170"></A>
<A NAME="@default171"></A>
<A NAME="@default172"></A>
<A NAME="@default173"></A>
<A NAME="@default174"></A>
<A NAME="@default175"></A>
<A NAME="@default176"></A>
<A NAME="@default177"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;sum&nbsp;(A&nbsp;B:Set)&nbsp;:&nbsp;Set&nbsp;:=&nbsp;inl&nbsp;(_:A)&nbsp;|&nbsp;inr&nbsp;(_:B).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;prod&nbsp;(A&nbsp;B:Set)&nbsp;:&nbsp;Set&nbsp;:=&nbsp;pair&nbsp;(_:A)&nbsp;(_:B).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;projections.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variables&nbsp;A&nbsp;B&nbsp;:&nbsp;Set.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;fst&nbsp;(H:&nbsp;prod&nbsp;A&nbsp;B)&nbsp;:=&nbsp;match&nbsp;H&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;pair&nbsp;x&nbsp;y&nbsp;=&gt;&nbsp;x</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;snd&nbsp;(H:&nbsp;prod&nbsp;A&nbsp;B)&nbsp;:=&nbsp;match&nbsp;H&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;pair&nbsp;x&nbsp;y&nbsp;=&gt;&nbsp;y</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;projections.</TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc71">3.1.4</A>&nbsp;&nbsp;Specification</H3>
The following notions<SUP><A NAME="text5" HREF="#note5">3</A></SUP> allows to build new datatypes and specifications. 
They are available with the syntax shown on
Figure&nbsp;<A HREF="#specif-syntax">3.3</A><SUP><A NAME="text6" HREF="#note6">4</A></SUP>.<BR>
<BR>
For instance, given <CODE>A:Set</CODE> and <CODE>P:A-&gt;Prop</CODE>, the construct
<CODE>{x:A | P x}</CODE> (in abstract syntax <CODE>(sig A P)</CODE>) is a
<CODE>Set</CODE>. We may build elements of this set as <CODE>(exist x p)</CODE>
whenever we have a witness <CODE>x:A</CODE> with its justification
<CODE>p:P x</CODE>.<BR>
<BR>
From such a <CODE>(exist x p)</CODE> we may in turn extract its witness
<CODE>x:A</CODE> (using an elimination construct such as <CODE>match</CODE>) but
<I><FONT COLOR=maroon>not</FONT></I> its justification, which stays hidden, like in an abstract
data type. In technical terms, one says that <CODE>sig</CODE> is a ``weak
(dependent) sum''. A variant <CODE>sig2</CODE> with two predicates is also
provided.<BR>
<BR>
<A NAME="@default178"></A>
<A NAME="@default179"></A>
<A NAME="@default180"></A>
<A NAME="@default181"></A>
<A NAME="@default182"></A>
<A NAME="@default183"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;sig&nbsp;(A:Set)&nbsp;(P:A&nbsp;-&gt;&nbsp;Prop)&nbsp;:&nbsp;Set&nbsp;:=&nbsp;exist&nbsp;(x:A)&nbsp;(_:P&nbsp;x).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;sig2&nbsp;(A:Set)&nbsp;(P&nbsp;Q:A&nbsp;-&gt;&nbsp;Prop)&nbsp;:&nbsp;Set&nbsp;:=&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;exist2&nbsp;(x:A)&nbsp;(_:P&nbsp;x)&nbsp;(_:Q&nbsp;x).</TT><BR>
</DIV>
<BR>
A ``strong (dependent) sum'' <CODE>{x:A &amp; (P x)}</CODE> may be also defined,
when the predicate <CODE>P</CODE> is now defined as a <CODE>Set</CODE>
constructor.<BR>
<BR>
<A NAME="@default184"></A>
<A NAME="@default185"></A>
<A NAME="@default186"></A>
<A NAME="@default187"></A>
<A NAME="@default188"></A>
<A NAME="@default189"></A>
<A NAME="@default190"></A>
<A NAME="@default191"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;sigS&nbsp;(A:Set)&nbsp;(P:A&nbsp;-&gt;&nbsp;Set)&nbsp;:&nbsp;Set&nbsp;:=&nbsp;existS&nbsp;(x:A)&nbsp;(_:P&nbsp;x).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;sigSprojections.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;A&nbsp;:&nbsp;Set.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Set.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;projS1&nbsp;(H:sigS&nbsp;A&nbsp;P)&nbsp;:=&nbsp;let&nbsp;(x,&nbsp;h)&nbsp;:=&nbsp;H&nbsp;in&nbsp;x.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;projS2&nbsp;(H:sigS&nbsp;A&nbsp;P)&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;H&nbsp;return&nbsp;P&nbsp;(projS1&nbsp;H)&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;existS&nbsp;x&nbsp;h&nbsp;=&gt;&nbsp;h</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;sigSprojections.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;sigS2&nbsp;(A:&nbsp;Set)&nbsp;(P&nbsp;Q:A&nbsp;-&gt;&nbsp;Set)&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;existS2&nbsp;(x:A)&nbsp;(_:P&nbsp;x)&nbsp;(_:Q&nbsp;x).</TT><BR>
</DIV>
<BR>
A related non-dependent construct is the constructive sum
<CODE>{A}+{B}</CODE> of two propositions <CODE>A</CODE> and <CODE>B</CODE>.
<A NAME="sumbool"></A>
<A NAME="@default192"></A>
<A NAME="@default193"></A>
<A NAME="@default194"></A>
<A NAME="@default195"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;sumbool&nbsp;(A&nbsp;B:Prop)&nbsp;:&nbsp;Set&nbsp;:=&nbsp;left&nbsp;(_:A)&nbsp;|&nbsp;right&nbsp;(_:B).</TT><BR>
</DIV>
<BR>
This <CODE>sumbool</CODE> construct may be used as a kind of indexed boolean
data type. An intermediate between <CODE>sumbool</CODE> and <CODE>sum</CODE> is
the mixed <CODE>sumor</CODE> which combines <CODE>A:Set</CODE> and <CODE>B:Prop</CODE>
in the <CODE>Set</CODE> <CODE>A+{B}</CODE>.
<A NAME="@default196"></A>
<A NAME="@default197"></A>
<A NAME="@default198"></A>
<A NAME="@default199"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;sumor&nbsp;(A:Set)&nbsp;(B:Prop)&nbsp;:&nbsp;Set&nbsp;:=&nbsp;inleft&nbsp;(_:A)&nbsp;|&nbsp;inright&nbsp;(_:B).</TT><BR>
</DIV>
<BR>
We may define variants of the axiom of choice, like in Martin-Löf's
Intuitionistic Type Theory.
<A NAME="@default200"></A>
<A NAME="@default201"></A>
<A NAME="@default202"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Choice&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;(S&nbsp;S':Set)&nbsp;(R:S&nbsp;-&gt;&nbsp;S'&nbsp;-&gt;&nbsp;Prop),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x:S,&nbsp;{y&nbsp;:&nbsp;S'&nbsp;|&nbsp;R&nbsp;x&nbsp;y})&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;{f&nbsp;:&nbsp;S&nbsp;-&gt;&nbsp;S'&nbsp;|&nbsp;forall&nbsp;z:S,&nbsp;R&nbsp;z&nbsp;(f&nbsp;z)}.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Choice2&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;(S&nbsp;S':Set)&nbsp;(R:S&nbsp;-&gt;&nbsp;S'&nbsp;-&gt;&nbsp;Set),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x:S,&nbsp;{y&nbsp;:&nbsp;S'&nbsp;&amp;&nbsp;&nbsp;R&nbsp;x&nbsp;y})&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;{f&nbsp;:&nbsp;S&nbsp;-&gt;&nbsp;S'&nbsp;&amp;&nbsp;&nbsp;forall&nbsp;z:S,&nbsp;R&nbsp;z&nbsp;(f&nbsp;z)}.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;bool_choice&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;(S:Set)&nbsp;(R1&nbsp;R2:S&nbsp;-&gt;&nbsp;Prop),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x:S,&nbsp;{R1&nbsp;x}&nbsp;+&nbsp;{R2&nbsp;x})&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;{f&nbsp;:&nbsp;S&nbsp;-&gt;&nbsp;bool&nbsp;|</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;x:S,&nbsp;f&nbsp;x&nbsp;=&nbsp;true&nbsp;/\&nbsp;R1&nbsp;x&nbsp;\/&nbsp;f&nbsp;x&nbsp;=&nbsp;false&nbsp;/\&nbsp;R2&nbsp;x}.</TT><BR>
</DIV>
<BR>
The next constructs builds a sum between a data type <CODE>A:Set</CODE> and
an exceptional value encoding errors:<BR>
<BR>
<A NAME="@default203"></A>
<A NAME="@default204"></A>
<A NAME="@default205"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;Exc&nbsp;:=&nbsp;option.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;value&nbsp;:=&nbsp;Some.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;error&nbsp;:=&nbsp;None.</TT><BR>
</DIV>
<BR>
This module ends with theorems, 
relating the sorts <CODE>Set</CODE> and
<CODE>Prop</CODE> in a way which is consistent with the realizability
interpretation.
<A NAME="@default206"></A>
<A NAME="@default207"></A>
<A NAME="@default208"></A>
<A NAME="@default209"></A>
<A NAME="@default210"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;except&nbsp;:=&nbsp;False_rec.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;Except&nbsp;:=&nbsp;(except&nbsp;_).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;absurd_set&nbsp;:&nbsp;forall&nbsp;(A:Prop)&nbsp;(C:Set),&nbsp;A&nbsp;-&gt;&nbsp;~&nbsp;A&nbsp;-&gt;&nbsp;C.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;and_rec&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;(A&nbsp;B:Prop)&nbsp;(P:Set),&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;P)&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B&nbsp;-&gt;&nbsp;P.</TT><BR>
</DIV>

<BR>

<H3><A NAME="htoc72">3.1.5</A>&nbsp;&nbsp;Basic Arithmetics</H3>
The basic library includes a few elementary properties of natural
numbers, together with the definitions of predecessor, addition and
multiplication<SUP><A NAME="text7" HREF="#note7">5</A></SUP>. It also
provides a scope <TT>nat_scope</TT> gathering standard notations for
common operations (+,*) and a decimal notation for numbers. That is he
can write <TT>3</TT> for <TT>(S (S (S O)))</TT>. This also works on
the left hand side of a <TT>match</TT> expression (see for example
section&nbsp;<A HREF="Reference-Manual012.html#refine-example">10.1</A>). This scope is opened by default.<BR>
<BR>
The following example is not part of the standard library, but it
shows the usage of the notations:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;even&nbsp;(n:nat)&nbsp;:&nbsp;bool&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;true</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;1&nbsp;=&gt;&nbsp;false</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;(S&nbsp;n)&nbsp;=&gt;&nbsp;even&nbsp;n</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
</DIV>
<BR>
<A NAME="@default211"></A>
<A NAME="@default212"></A>
<A NAME="@default213"></A>
<A NAME="@default214"></A>
<A NAME="@default215"></A>
<A NAME="@default216"></A>
<A NAME="@default217"></A>
<A NAME="@default218"></A>
<A NAME="@default219"></A>
<A NAME="@default220"></A>
<A NAME="@default221"></A>
<A NAME="@default222"></A>
<A NAME="@default223"></A>
<A NAME="@default224"></A><BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;eq_S&nbsp;:&nbsp;forall&nbsp;x&nbsp;y:nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;S&nbsp;x&nbsp;=&nbsp;S&nbsp;y.</TT><BR>
</DIV>


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;pred&nbsp;(n:nat)&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;0</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;u&nbsp;=&gt;&nbsp;u</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;pred_Sn&nbsp;:&nbsp;forall&nbsp;m:nat,&nbsp;m&nbsp;=&nbsp;pred&nbsp;(S&nbsp;m).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;eq_add_S&nbsp;:&nbsp;forall&nbsp;n&nbsp;m:nat,&nbsp;S&nbsp;n&nbsp;=&nbsp;S&nbsp;m&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;m.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Hint&nbsp;Immediate&nbsp;eq_add_S&nbsp;:&nbsp;core.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;not_eq_S&nbsp;:&nbsp;forall&nbsp;n&nbsp;m:nat,&nbsp;n&nbsp;&lt;&gt;&nbsp;m&nbsp;-&gt;&nbsp;S&nbsp;n&nbsp;&lt;&gt;&nbsp;S&nbsp;m.</TT><BR>
</DIV>


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;IsSucc&nbsp;(n:nat)&nbsp;:&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;False</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;True</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;O_S&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;0&nbsp;&lt;&gt;&nbsp;S&nbsp;n.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;n_Sn&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;n&nbsp;&lt;&gt;&nbsp;S&nbsp;n.</TT><BR>
</DIV>


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;plus&nbsp;(n&nbsp;m:nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;m</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;S&nbsp;(plus&nbsp;p&nbsp;m)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;plus_n_O&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;n&nbsp;=&nbsp;plus&nbsp;n&nbsp;0.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;plus_n_Sm&nbsp;:&nbsp;forall&nbsp;n&nbsp;m:nat,&nbsp;S&nbsp;(plus&nbsp;n&nbsp;m)&nbsp;=&nbsp;plus&nbsp;n&nbsp;(S&nbsp;m).</TT><BR>
</DIV>


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;mult&nbsp;(n&nbsp;m:nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;0</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;m&nbsp;+&nbsp;mult&nbsp;p&nbsp;m</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;mult_n_O&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;0&nbsp;=&nbsp;mult&nbsp;n&nbsp;0.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;mult_n_Sm&nbsp;:&nbsp;forall&nbsp;n&nbsp;m:nat,&nbsp;plus&nbsp;(mult&nbsp;n&nbsp;m)&nbsp;n&nbsp;=&nbsp;mult&nbsp;n&nbsp;(S&nbsp;m).</TT><BR>
</DIV>
<BR>
Finally, it gives the definition of the usual orderings <CODE>le</CODE>,
<CODE>lt</CODE>, <CODE>ge</CODE>, and <CODE>gt</CODE>.
<A NAME="@default225"></A>
<A NAME="@default226"></A>
<A NAME="@default227"></A>
<A NAME="@default228"></A>
<A NAME="@default229"></A>
<A NAME="@default230"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;le&nbsp;(n:nat)&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;le_n&nbsp;:&nbsp;le&nbsp;n&nbsp;n</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;le_S&nbsp;:&nbsp;forall&nbsp;m:nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;n&nbsp;(S&nbsp;m).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Infix&nbsp;"+"&nbsp;:=&nbsp;plus&nbsp;:&nbsp;nat_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;lt&nbsp;(n&nbsp;m:nat)&nbsp;:=&nbsp;S&nbsp;n&nbsp;&lt;=&nbsp;m.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;ge&nbsp;(n&nbsp;m:nat)&nbsp;:=&nbsp;m&nbsp;&lt;=&nbsp;n.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;gt&nbsp;(n&nbsp;m:nat)&nbsp;:=&nbsp;m&nbsp;&lt;&nbsp;n.</TT><BR>
</DIV>
<BR>
Properties of these relations are not initially known, but may be
required by the user from modules <CODE>Le</CODE> and <CODE>Lt</CODE>. Finally,
<CODE>Peano</CODE> gives some lemmas allowing pattern-matching, and a double
induction principle.<BR>
<BR>
<A NAME="@default231"></A>
<A NAME="@default232"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;nat_case&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;(n:nat)&nbsp;(P:nat&nbsp;-&gt;&nbsp;Prop),&nbsp;P&nbsp;0&nbsp;-&gt;&nbsp;(forall&nbsp;m:nat,&nbsp;P&nbsp;(S&nbsp;m))&nbsp;-&gt;&nbsp;P&nbsp;n.</TT><BR>
</DIV>


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;nat_double_ind&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;R:nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n:nat,&nbsp;R&nbsp;0&nbsp;n)&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n:nat,&nbsp;R&nbsp;(S&nbsp;n)&nbsp;0)&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;m:nat,&nbsp;R&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;R&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m))&nbsp;-&gt;&nbsp;forall&nbsp;n&nbsp;m:nat,&nbsp;R&nbsp;n&nbsp;m.</TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc73">3.1.6</A>&nbsp;&nbsp;Well-founded recursion</H3>
The basic library contains the basics of well-founded recursion and 
well-founded induction<SUP><A NAME="text8" HREF="#note8">6</A></SUP>.
<A NAME="@default233"></A>
<A NAME="@default234"></A>
<A NAME="@default235"></A>
<A NAME="@default236"></A>
<A NAME="@default237"></A>
<A NAME="@default238"></A>
<A NAME="@default239"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;Well_founded.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;A&nbsp;:&nbsp;Set.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;Prop.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;Acc&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acc_intro&nbsp;:&nbsp;forall&nbsp;x:A,&nbsp;(forall&nbsp;y:A,&nbsp;R&nbsp;y&nbsp;x&nbsp;-&gt;&nbsp;Acc&nbsp;y)&nbsp;-&gt;&nbsp;Acc&nbsp;x.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Acc_inv&nbsp;:&nbsp;forall&nbsp;x:A,&nbsp;Acc&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y:A,&nbsp;R&nbsp;y&nbsp;x&nbsp;-&gt;&nbsp;Acc&nbsp;y.</TT><BR>
</DIV>


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;AccRec.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Set.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;F&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;x:A,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;y:A,&nbsp;R&nbsp;y&nbsp;x&nbsp;-&gt;&nbsp;Acc&nbsp;y)&nbsp;-&gt;&nbsp;(forall&nbsp;y:A,&nbsp;R&nbsp;y&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y)&nbsp;-&gt;&nbsp;P&nbsp;x.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;Acc_rec&nbsp;(x:A)&nbsp;(a:Acc&nbsp;x)&nbsp;{struct&nbsp;a}&nbsp;:&nbsp;P&nbsp;x&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;F&nbsp;x&nbsp;(Acc_inv&nbsp;x&nbsp;a)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fun&nbsp;(y:A)&nbsp;(h:R&nbsp;y&nbsp;x)&nbsp;=&gt;&nbsp;Acc_rec&nbsp;y&nbsp;(Acc_inv&nbsp;x&nbsp;a&nbsp;y&nbsp;h)).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;AccRec.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;well_founded&nbsp;:=&nbsp;forall&nbsp;a:A,&nbsp;Acc&nbsp;a.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;Rwf&nbsp;:&nbsp;well_founded.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;well_founded_induction&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;P:A&nbsp;-&gt;&nbsp;Set,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x:A,&nbsp;(forall&nbsp;y:A,&nbsp;R&nbsp;y&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y)&nbsp;-&gt;&nbsp;P&nbsp;x)&nbsp;-&gt;&nbsp;forall&nbsp;a:A,&nbsp;P&nbsp;a.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;well_founded_ind&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;P:A&nbsp;-&gt;&nbsp;Prop,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x:A,&nbsp;(forall&nbsp;y:A,&nbsp;R&nbsp;y&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y)&nbsp;-&gt;&nbsp;P&nbsp;x)&nbsp;-&gt;&nbsp;forall&nbsp;a:A,&nbsp;P&nbsp;a.</TT><BR>
</DIV>

<TT>Acc_rec</TT> can be used to define functions by fixpoints using
well-founded relations to justify termination. Assuming
extensionality of the functional used for the recursive call, the
fixpoint equation can be proved.
<A NAME="@default240"></A>
<A NAME="@default241"></A>
<A NAME="@default242"></A>
<A NAME="@default243"></A>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;FixPoint.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Set.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;F&nbsp;:&nbsp;forall&nbsp;x:A,&nbsp;(forall&nbsp;y:A,&nbsp;R&nbsp;y&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y)&nbsp;-&gt;&nbsp;P&nbsp;x.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;Fix_F&nbsp;(x:A)&nbsp;(r:Acc&nbsp;x)&nbsp;{struct&nbsp;r}&nbsp;:&nbsp;P&nbsp;x&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;F&nbsp;x&nbsp;(fun&nbsp;(y:A)&nbsp;(p:R&nbsp;y&nbsp;x)&nbsp;=&gt;&nbsp;Fix_F&nbsp;y&nbsp;(Acc_inv&nbsp;x&nbsp;r&nbsp;y&nbsp;p)).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;Fix&nbsp;(x:A)&nbsp;:=&nbsp;Fix_F&nbsp;x&nbsp;(Rwf&nbsp;x).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Hypothesis&nbsp;F_ext&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(x:A)&nbsp;(f&nbsp;g:forall&nbsp;y:A,&nbsp;R&nbsp;y&nbsp;x&nbsp;-&gt;&nbsp;P&nbsp;y),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(y:A)&nbsp;(p:R&nbsp;y&nbsp;x),&nbsp;f&nbsp;y&nbsp;p&nbsp;=&nbsp;g&nbsp;y&nbsp;p)&nbsp;-&gt;&nbsp;F&nbsp;x&nbsp;f&nbsp;=&nbsp;F&nbsp;x&nbsp;g.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Fix_F_eq&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;(x:A)&nbsp;(r:Acc&nbsp;x),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;F&nbsp;x&nbsp;(fun&nbsp;(y:A)&nbsp;(p:R&nbsp;y&nbsp;x)&nbsp;=&gt;&nbsp;Fix_F&nbsp;y&nbsp;(Acc_inv&nbsp;x&nbsp;r&nbsp;y&nbsp;p))&nbsp;=&nbsp;Fix_F&nbsp;x&nbsp;r.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Fix_F_inv&nbsp;:&nbsp;forall&nbsp;(x:A)&nbsp;(r&nbsp;s:Acc&nbsp;x),&nbsp;Fix_F&nbsp;x&nbsp;r&nbsp;=&nbsp;Fix_F&nbsp;x&nbsp;s.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;fix_eq&nbsp;:&nbsp;forall&nbsp;x:A,&nbsp;Fix&nbsp;x&nbsp;=&nbsp;F&nbsp;x&nbsp;(fun&nbsp;(y:A)&nbsp;(p:R&nbsp;y&nbsp;x)&nbsp;=&gt;&nbsp;Fix&nbsp;y).</TT><BR>
</DIV>


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;FixPoint.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;Well_founded.</TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc74">3.1.7</A>&nbsp;&nbsp;Accessing the <FONT COLOR=purple>Type</FONT> level</H3>
The basic library includes the definitions<SUP><A NAME="text9" HREF="#note9">7</A></SUP> of the counterparts of some datatypes and logical
quantifiers at the <CODE>Type</CODE> level: negation, pair, and properties
of <TT>identity</TT>.<BR>
<BR>
<A NAME="@default244"></A>
<A NAME="@default245"></A>
<A NAME="@default246"></A>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;notT&nbsp;(A:Type)&nbsp;:=&nbsp;A&nbsp;-&gt;&nbsp;False.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;prodT&nbsp;(A&nbsp;B:Type)&nbsp;:&nbsp;Type&nbsp;:=&nbsp;pairT&nbsp;(_:A)&nbsp;(_:B).</TT><BR>
</DIV>
<BR>
At the end, it defines datatypes at the <FONT COLOR=purple>Type</FONT> level.<BR>
<BR>
<A NAME="toc20"></A>
<H2><A NAME="htoc75">3.2</A>&nbsp;&nbsp;The standard library</H2>

<H3><A NAME="htoc76">3.2.1</A>&nbsp;&nbsp;Survey</H3>
The rest of the standard library is structured into the following 
subdirectories:<BR>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>Logic</B></TD>
<TD VALIGN=top ALIGN=left>Classical logic and dependent equality</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>Arith</B></TD>
<TD VALIGN=top ALIGN=left>Basic Peano arithmetic</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>ZArith</B></TD>
<TD VALIGN=top ALIGN=left>Basic integer arithmetic</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>Bool</B></TD>
<TD VALIGN=top ALIGN=left>Booleans (basic functions and results)</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>Lists</B></TD>
<TD VALIGN=top ALIGN=left>Monomorphic and polymorphic lists (basic functions and
 results), Streams (infinite sequences defined with co-inductive
 types)</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>Sets</B></TD>
<TD VALIGN=top ALIGN=left>Sets (classical, constructive, finite, infinite, power set,
 etc.)</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>IntMap</B></TD>
<TD VALIGN=top ALIGN=left>Representation of finite sets by an efficient
 structure of map (trees indexed by binary integers).</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>Reals</B></TD>
<TD VALIGN=top ALIGN=left>Axiomatization of Real Numbers (classical, basic functions, 
 integer part, fractional part, limit, derivative, Cauchy 
 series, power series and results,... Requires the 
 <B>ZArith</B> library).</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>Relations</B></TD>
<TD VALIGN=top ALIGN=left>Relations (definitions and basic results).</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>Sorting</B></TD>
<TD VALIGN=top ALIGN=left>Sorted list (basic definitions and heapsort correctness).</TD>
</TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B>Wellfounded</B></TD>
<TD VALIGN=top ALIGN=left>Well-founded relations (basic results).</TD>
</TR></TABLE>
<BR>
<BR>
<BR>
These directories belong to the initial load path of the system, and
the modules they provide are compiled at installation time. So they
are directly accessible with the command <CODE>Require</CODE> (see
chapter&nbsp;<A HREF="Reference-Manual008.html#Other-commands">6</A>). <BR>
<BR>
The different modules of the <FONT COLOR=navy>Coq</FONT> standard library are described in the
additional document <CODE>Library.dvi</CODE>. They are also accessible on the WWW
through the <FONT COLOR=navy>Coq</FONT> homepage
<SUP><A NAME="text10" HREF="#note10">8</A></SUP>.<BR>
<BR>

<H3><A NAME="htoc77">3.2.2</A>&nbsp;&nbsp;Notations for integer arithmetics</H3>
<A NAME="@default247"></A>
On figure <A HREF="#zarith-syntax">3.2.2</A> is described the syntax of expressions
for integer arithmetics. It is provided by requiring and opening the
module <TT>ZArith</TT> and opening scope <TT>Z_scope</TT>.<BR>
<BR>
<A NAME="@default248"></A>
<A NAME="@default249"></A>
<A NAME="@default250"></A>
<A NAME="@default251"></A>
<A NAME="@default252"></A>
<A NAME="@default253"></A>
<A NAME="@default254"></A>
<A NAME="@default255"></A>
<A NAME="@default256"></A>
<A NAME="@default257"></A>
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP>Notation</TD>
<TD ALIGN=left NOWRAP>Interpretation</TD>
<TD ALIGN=left NOWRAP>Precedence</TD>
<TD ALIGN=left NOWRAP>Associativity</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &lt; _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zlt</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zle</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &gt; _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zgt</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &gt;= y</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zge</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt; z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt;= z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt; z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt;= z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ ?= _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zcompare</TT></TD>
<TD ALIGN=left NOWRAP>70</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ + _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zplus</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ - _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zminus</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ * _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zmult</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ / _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zdiv</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ mod _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zmod</TT></TD>
<TD ALIGN=left NOWRAP>40</TD>
<TD ALIGN=left NOWRAP>no</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>- _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zopp</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ ^ _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Zpower</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE>
</DIV>
<A NAME="zarith-syntax"></A>
<BR>
<DIV ALIGN=center>Figure 3.4: Definition of the scope for integer arithmetics (<TT>Z_scope</TT>)</DIV><BR>

<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
Figure&nbsp;<A HREF="#zarith-syntax">3.2.2</A> shows the notations provided by <TT>Z_scope</TT>. It specifies how notations are interpreted and, when not
already reserved, the precedence and associativity.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;ZArith.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;&nbsp;(2&nbsp;+&nbsp;3)%Z.</TT><BR>
<TT><I>(2&nbsp;+&nbsp;3)%Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Scope&nbsp;Z_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;2&nbsp;+&nbsp;3.</TT><BR>
<TT><I>2&nbsp;+&nbsp;3</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Z</I></TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc78">3.2.3</A>&nbsp;&nbsp;Peano's arithmetic (<TT>nat</TT>)</H3>
<A NAME="@default258"></A>
<A NAME="@default259"></A>
While in the initial state, many operations and predicates of Peano's
arithmetic are defined, further operations and results belong to other
modules. For instance, the decidability of the basic predicates are
defined here. This is provided by requiring the module <TT>Arith</TT>.<BR>
<BR>
Figure&nbsp;<A HREF="#nat-syntax">3.2.3</A> describes notation available in scope <TT>nat_scope</TT>.
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP>Notation</TD>
<TD ALIGN=left NOWRAP>Interpretation</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &lt; _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>lt</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y</CODE></TD>
<TD ALIGN=left NOWRAP><TT>le</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &gt; _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>gt</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &gt;= y</CODE></TD>
<TD ALIGN=left NOWRAP><TT>ge</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt; z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt;= z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt; z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt;= z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ + _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>plus</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ - _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>minus</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ * _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>mult</TT></TD>
</TR></TABLE>
</DIV>
<A NAME="nat-syntax"></A>
<BR>
<DIV ALIGN=center>Figure 3.5: Definition of the scope for natural numbers (<TT>nat_scope</TT>)</DIV><BR>

<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>

<H3><A NAME="htoc79">3.2.4</A>&nbsp;&nbsp;Real numbers library</H3>

<H4>Notations for real numbers</H4>
<A NAME="@default260"></A>
This is provided by requiring and opening the module <TT>Reals</TT> and
opening scope <TT>R_scope</TT>. This set of notations is very similar to
the notation for integer arithmetics. The inverse function was added.
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP>Notation</TD>
<TD ALIGN=left NOWRAP>Interpretation</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &lt; _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Rlt</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Rle</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &gt; _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Rgt</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &gt;= y</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Rge</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt; z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt;= z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt; z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt;= z</CODE></TD>
<TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ + _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Rplus</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ - _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Rminus</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ * _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Rmult</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ / _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Rdiv</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>- _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Ropp</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>/ _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>Rinv</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ ^ _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>pow</TT></TD>
</TR></TABLE>
</DIV>
<A NAME="reals-syntax"></A>
<BR>
<DIV ALIGN=center>Figure 3.6: Definition of the scope for real arithmetics (<TT>R_scope</TT>)</DIV><BR>

<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Reals.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;&nbsp;(2&nbsp;+&nbsp;3)%R.</TT><BR>
<TT><I>(2&nbsp;+&nbsp;3)%R</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;R</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Scope&nbsp;R_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;2&nbsp;+&nbsp;3.</TT><BR>
<TT><I>2&nbsp;+&nbsp;3</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;R</I></TT><BR>
</DIV>
<BR>

<H4>Some tactics</H4>
In addition to the <CODE>ring</CODE>, <CODE>field</CODE> and <CODE>fourier</CODE>
tactics (see Chapter&nbsp;<A HREF="Reference-Manual010.html#Tactics">8</A>) there are:
<UL><LI>
<TT>discrR</TT> <A NAME="@default261"></A><A NAME="@tactic0"></A><BR>
<BR>
Proves that a real integer constant <I>c</I><SUB><FONT SIZE=2>1</FONT></SUB> is different from another
 real integer constant <I>c</I><SUB><FONT SIZE=2>2</FONT></SUB>. <BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;DiscrR.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;5&nbsp;&lt;&gt;&nbsp;0.</TT><BR>
</DIV>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;discrR.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
<BR>
<LI><TT>split_Rabs</TT> allows to unfold <TT>Rabs</TT> constant and splits 
corresponding conjonctions.
<A NAME="@default262"></A><A NAME="@tactic1"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;SplitAbsolu.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x:R,&nbsp;x&nbsp;&lt;=&nbsp;Rabs&nbsp;x.</TT><BR>
</DIV>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intro;&nbsp;split_Rabs.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;r&nbsp;:&nbsp;x&nbsp;&lt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;&lt;=&nbsp;-&nbsp;x</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;x&nbsp;&lt;=&nbsp;x</I></TT><BR>
</DIV>
<BR>
<BR>
<LI><TT>split_Rmult</TT> allows to split a condition that a product is
 non null into subgoals corresponding to the condition on each
 operand of the product. 
<A NAME="@default263"></A><A NAME="@tactic2"></A><BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;SplitRmult.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;z:R,&nbsp;x&nbsp;*&nbsp;y&nbsp;*&nbsp;z&nbsp;&lt;&gt;&nbsp;0.</TT><BR>
</DIV>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;intros;&nbsp;split_Rmult.</TT><BR>
<TT><I>3&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;&lt;&gt;&nbsp;0</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;y&nbsp;&lt;&gt;&nbsp;0</I></TT><BR>
<TT><I>subgoal&nbsp;3&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;z&nbsp;&lt;&gt;&nbsp;0</I></TT><BR>
</DIV>
</UL>
All this tactics has been written with the tactic language Ltac
described in Chapter&nbsp;<A HREF="Reference-Manual011.html#TacticLanguage">9</A>. More details are available
in document <TT>http://coq.inria.fr/~desmettr/Reals.ps</TT>.<BR>
<BR>

<H3><A NAME="htoc80">3.2.5</A>&nbsp;&nbsp;List library</H3>
<A NAME="@default264"></A>
<A NAME="@default265"></A>
<A NAME="@default266"></A>
<A NAME="@default267"></A>
<A NAME="@default268"></A>
<A NAME="@default269"></A>
<A NAME="@default270"></A>
<A NAME="@default271"></A>
<A NAME="@default272"></A>
<A NAME="@default273"></A>
<A NAME="@default274"></A>
Some elementary operations on polymorphic lists are defined here. They
can be accessed by requiring module <TT>List</TT>.<BR>
<BR>
It defines the following notions:
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP><TT>length</TT></TD>
<TD ALIGN=left NOWRAP>length</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>head</TT></TD>
<TD ALIGN=left NOWRAP>first element (with default)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>tail</TT></TD>
<TD ALIGN=left NOWRAP>all but first element</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>app</TT></TD>
<TD ALIGN=left NOWRAP>concatenation</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>rev</TT></TD>
<TD ALIGN=left NOWRAP>reverse</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>nth</TT></TD>
<TD ALIGN=left NOWRAP>accessing <I>n</I>-th element (with default)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>map</TT></TD>
<TD ALIGN=left NOWRAP>applying a function</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>flat_map</TT></TD>
<TD ALIGN=left NOWRAP>applying a function returning lists</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>fold_left</TT></TD>
<TD ALIGN=left NOWRAP>iterator (from head to tail)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>fold_right</TT></TD>
<TD ALIGN=left NOWRAP>iterator (from tail to head)</TD>
</TR></TABLE>
</DIV><BR>
Table show notations available when opening scope <TT>list_scope</TT>.
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP>Notation</TD>
<TD ALIGN=left NOWRAP>Interpretation</TD>
<TD ALIGN=left NOWRAP>Precedence</TD>
<TD ALIGN=left NOWRAP>Associativity</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ ++ _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>app</TT></TD>
<TD ALIGN=left NOWRAP>60</TD>
<TD ALIGN=left NOWRAP>right</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ :: _</CODE></TD>
<TD ALIGN=left NOWRAP><TT>cons</TT></TD>
<TD ALIGN=left NOWRAP>60</TD>
<TD ALIGN=left NOWRAP>right</TD>
</TR></TABLE>
</DIV>
<A NAME="list-syntax"></A>
<BR>
<DIV ALIGN=center>Figure 3.7: Definition of the scope for lists (<TT>list_scope</TT>)</DIV><BR>

<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
<A NAME="toc21"></A>
<H2><A NAME="htoc81">3.3</A>&nbsp;&nbsp;Users' contributions</H2>
<A NAME="@default275"></A>
<A NAME="Contributions"></A>
Numerous users' contributions have been collected and are available at
URL <TT>coq.inria.fr/contribs/</TT>. On this web page, you have a list
of all contributions with informations (author, institution, quick
description, etc.) and the possibility to download them one by one.
There is a small search engine to look for keywords in all
contributions. You will also find informations on how to submit a new
contribution.<BR>
<BR>
The users' contributions may also be obtained by anonymous FTP from site
<CODE>ftp.inria.fr</CODE>, in directory <CODE>INRIA/coq/</CODE> and
searchable on-line at <TT>http://coq.inria.fr/contribs-eng.html</TT><BR>
<BR>
<HR WIDTH="50%" SIZE=1><DL><DT><A NAME="note3" HREF="#text3"><FONT SIZE=5>1</FONT></A><DD>Most of these constructions are defined in the
<TT>Prelude</TT> module in directory <TT>theories/Init</TT> at the <FONT COLOR=navy>Coq</FONT>
root directory; this includes the modules
<TT>Notations</TT>,
<TT>Logic</TT>,
<TT>Datatypes</TT>,
<TT>Specif</TT>,
<TT>Peano</TT>,
and <TT>Wf</TT>.
Module <TT>Logic_Type</TT> also makes it in the initial state
<DT><A NAME="note4" HREF="#text4"><FONT SIZE=5>2</FONT></A><DD>They are in <TT>Datatypes.v</TT>
<DT><A NAME="note5" HREF="#text5"><FONT SIZE=5>3</FONT></A><DD>They are defined in module <TT>Specif.v</TT>
<DT><A NAME="note6" HREF="#text6"><FONT SIZE=5>4</FONT></A><DD>This syntax can be found in the module
<TT>SpecifSyntax.v</TT>
<DT><A NAME="note7" HREF="#text7"><FONT SIZE=5>5</FONT></A><DD>This is in module <TT>Peano.v</TT>
<DT><A NAME="note8" HREF="#text8"><FONT SIZE=5>6</FONT></A><DD>This is defined in module <TT>Wf.v</TT>
<DT><A NAME="note9" HREF="#text9"><FONT SIZE=5>7</FONT></A><DD>This is in module
<TT>Logic_Type.v</TT>
<DT><A NAME="note10" HREF="#text10"><FONT SIZE=5>8</FONT></A><DD><TT>http://coq.inria.fr</TT>
</DL>
<HR>
<A HREF="Reference-Manual004.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual006.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
