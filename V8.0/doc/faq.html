<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD><TITLE></TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -fix -nosymb main.v.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF section 1 -->



<BR>
<BR>



<H1 ALIGN=center>Coq Version 8.0 for the Clueless<BR>
<FONT SIZE=4>(</FONT><A HREF="#lastquestion"><FONT SIZE=4>174</FONT></A><FONT SIZE=4>
  Hints)
</FONT></H1>

<H3 ALIGN=center>Hugo Herbelin &nbsp;&nbsp;Florent Kirchner &nbsp;&nbsp;Benjamin Monate &nbsp;&nbsp;Julien Narboux</H3>

<BLOCKQUOTE><B>Abstract: </B>
This note intends to provide an easy way to get acquainted with the
<FONT COLOR=navy>Coq</FONT> theorem prover. It tries to formulate appropriate answers
to some of the questions any newcomers will face, and to give
pointers to other references when possible.
</BLOCKQUOTE>

<BLOCKQUOTE>
<FONT SIZE=4>V8.0 ©INRIA 2004-2006</FONT><BR>
This material may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at <A HREF="http://www.opencontent.org/openpub">http://www.opencontent.org/openpub</A>).
</BLOCKQUOTE>

<!--TOC section Table of Contents-->

<H2>Table of Contents</H2><!--SEC END -->

<UL><LI>
<A HREF="#htoc1">1&nbsp;&nbsp;Introduction</A>
<LI><A HREF="#htoc2">2&nbsp;&nbsp;Presentation</A>
<UL>
<UL><LI>
<A HREF="#htoc3">1&nbsp;&nbsp;What is <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc4">2&nbsp;&nbsp;Did you really need to name it like that?</A>
<LI><A HREF="#htoc5">3&nbsp;&nbsp;Is <FONT COLOR=navy>Coq</FONT> a theorem prover?</A>
<LI><A HREF="#htoc6">4&nbsp;&nbsp;What are the other theorem provers?</A>
<LI><A HREF="#htoc7">5&nbsp;&nbsp;Who do I have to trust when I see a proof checked by Coq?</A>
<LI><A HREF="#htoc8">6&nbsp;&nbsp;Where can I find information about the theory behind <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc9">7&nbsp;&nbsp;How can I use <FONT COLOR=navy>Coq</FONT> to prove programs?</A>
<LI><A HREF="#htoc10">8&nbsp;&nbsp;How many <FONT COLOR=navy>Coq</FONT> users are there?</A>
<LI><A HREF="#htoc11">9&nbsp;&nbsp;How old is <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc12">10&nbsp;&nbsp;What are the <FONT COLOR=navy>Coq</FONT>-related tools?</A>
<LI><A HREF="#htoc13">11&nbsp;&nbsp;What are the high-level tactics of <FONT COLOR=navy>Coq</FONT></A>
<LI><A HREF="#htoc14">12&nbsp;&nbsp;What are the main libraries available for <FONT COLOR=navy>Coq</FONT></A>
<LI><A HREF="#htoc15">13&nbsp;&nbsp;What are the academic applications for <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc16">14&nbsp;&nbsp;What are the industrial applications for <FONT COLOR=navy>Coq</FONT>?</A>
</UL>
</UL>
<LI><A HREF="#htoc17">3&nbsp;&nbsp;Documentation</A>
<UL>
<UL><LI>
<A HREF="#htoc18">15&nbsp;&nbsp;Where can I find documentation about <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc19">16&nbsp;&nbsp;Where can I find this FAQ on the web?</A>
<LI><A HREF="#htoc20">17&nbsp;&nbsp;How can I submit suggestions / improvements / additions for this FAQ?</A>
<LI><A HREF="#htoc21">18&nbsp;&nbsp;Is there any mailing list about <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc22">19&nbsp;&nbsp;Where can I find an archive of the list?</A>
<LI><A HREF="#htoc23">20&nbsp;&nbsp;How can I be kept informed of new releases of <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc24">21&nbsp;&nbsp;Is there any book about <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc25">22&nbsp;&nbsp;Where can I find some <FONT COLOR=navy>Coq</FONT> examples?</A>
<LI><A HREF="#htoc26">23&nbsp;&nbsp;How can I report a bug?</A>
</UL>
</UL>
<LI><A HREF="#htoc27">4&nbsp;&nbsp;Installation</A>
<UL>
<UL><LI>
<A HREF="#htoc28">24&nbsp;&nbsp;What is the license of <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc29">25&nbsp;&nbsp;Where can I find the sources of <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc30">26&nbsp;&nbsp;On which platform is <FONT COLOR=navy>Coq</FONT> available?</A>
</UL>
</UL>
<LI><A HREF="#htoc31">5&nbsp;&nbsp;The logic of <FONT COLOR=navy>Coq</FONT></A>
<UL><LI>
<A HREF="#htoc32">5.1&nbsp;&nbsp;General</A>
<UL><LI>
<A HREF="#htoc33">27&nbsp;&nbsp;What is the logic of <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc34">28&nbsp;&nbsp;Is <FONT COLOR=navy>Coq</FONT>'s logic intuitionistic or classical?</A>
<LI><A HREF="#htoc35">29&nbsp;&nbsp;Can I define non-terminating programs in <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc36">30&nbsp;&nbsp;How is equational reasoning working in <FONT COLOR=navy>Coq</FONT>?</A>
</UL>
<LI><A HREF="#htoc37">5.2&nbsp;&nbsp;Axioms</A>
<UL><LI>
<A HREF="#htoc38">31&nbsp;&nbsp;What axioms can be safely added to <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc39">32&nbsp;&nbsp;What standard axioms are inconsistent with <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc40">33&nbsp;&nbsp;What is Streicher's axiom <I>K</I></A>
<LI><A HREF="#htoc41">34&nbsp;&nbsp;What is proof-irrelevance</A>
<LI><A HREF="#htoc42">35&nbsp;&nbsp;What about functional extensionality?</A>
<LI><A HREF="#htoc43">36&nbsp;&nbsp;Is <TT>Prop</TT> impredicative?</A>
<LI><A HREF="#htoc44">37&nbsp;&nbsp;Is <TT>Set</TT> impredicative?</A>
<LI><A HREF="#htoc45">38&nbsp;&nbsp;Is <TT>Type</TT> impredicative?</A>
<LI><A HREF="#htoc46">39&nbsp;&nbsp;I have two proofs of the same proposition. Can I prove they are equal?</A>
<LI><A HREF="#htoc47">40&nbsp;&nbsp;I have two proofs of an equality statement. Can I prove they are 
equal?</A>
<LI><A HREF="#htoc48">41&nbsp;&nbsp;Can I prove that the second components of equal dependent
pairs are equal?</A>
</UL>
<LI><A HREF="#htoc49">5.3&nbsp;&nbsp;Impredicativity</A>
<UL><LI>
<A HREF="#htoc50">42&nbsp;&nbsp;Why <TT>injection</TT> does not work on impredicative <TT>Set</TT>?</A>
<LI><A HREF="#htoc51">43&nbsp;&nbsp;What is a "large inductive definition"?</A>
</UL>
</UL>
<LI><A HREF="#htoc52">6&nbsp;&nbsp;Talkin' with the Rooster</A>
<UL><LI>
<A HREF="#htoc53">6.1&nbsp;&nbsp;My goal is ..., how can I prove it?</A>
<UL><LI>
<A HREF="#htoc54">44&nbsp;&nbsp;My goal is a conjunction, how can I prove it?</A>
<LI><A HREF="#htoc55">45&nbsp;&nbsp;My goal contains a conjunction as an hypothesis, how can I use it?</A>
<LI><A HREF="#htoc56">46&nbsp;&nbsp;My goal is a disjunction, how can I prove it?</A>
<LI><A HREF="#htoc57">47&nbsp;&nbsp;My goal is an universally quantified statement, how can I prove it?</A>
<LI><A HREF="#htoc58">48&nbsp;&nbsp;My goal is an existential, how can I prove it?</A>
<LI><A HREF="#htoc59">49&nbsp;&nbsp;My goal is solvable by some lemma, how can I prove it?</A>
<LI><A HREF="#htoc60">50&nbsp;&nbsp;My goal contains False as an hypotheses, how can I prove it?</A>
<LI><A HREF="#htoc61">51&nbsp;&nbsp;My goal is an equality of two convertible terms, how can I prove it?</A>
<LI><A HREF="#htoc62">52&nbsp;&nbsp;My goal is a <TT>let x := a in ...</TT>, how can I prove it?</A>
<LI><A HREF="#htoc63">53&nbsp;&nbsp;My goal is a <TT>let (a, ..., b) := c in</TT>, how can I prove it?</A>
<LI><A HREF="#htoc64">54&nbsp;&nbsp;My goal contains some existential hypotheses, how can I use it?</A>
<LI><A HREF="#htoc65">55&nbsp;&nbsp;My goal contains some existential hypotheses, how can I use it and decompose my knowledge about this new thing into different hypotheses?</A>
<LI><A HREF="#htoc66">56&nbsp;&nbsp;My goal is an equality, how can I swap the left and right hand terms?</A>
<LI><A HREF="#htoc67">57&nbsp;&nbsp;My hypothesis is an equality, how can I swap the left and right hand terms?</A>
<LI><A HREF="#htoc68">58&nbsp;&nbsp;My goal is an equality, how can I prove it by transitivity?</A>
<LI><A HREF="#htoc69">59&nbsp;&nbsp;My goal would be solvable using <TT>apply;assumption</TT> if it would not create meta-variables, how can I prove it?</A>
<LI><A HREF="#htoc70">60&nbsp;&nbsp;My goal is solvable by some lemma within a set of lemmas and I don't want to remember which one, how can I prove it?</A>
<LI><A HREF="#htoc71">61&nbsp;&nbsp;My goal is one of the hypotheses, how can I prove it?</A>
<LI><A HREF="#htoc72">62&nbsp;&nbsp;My goal appears twice in the hypotheses and I want to choose which one is used, how can I do it?</A>
<LI><A HREF="#htoc73">63&nbsp;&nbsp;What can be the difference between applying one hypothesis or another in the context of the last question?</A>
<LI><A HREF="#htoc74">64&nbsp;&nbsp;My goal is a propositional tautology, how can I prove it?</A>
<LI><A HREF="#htoc75">65&nbsp;&nbsp;My goal is a first order formula, how can I prove it?</A>
<LI><A HREF="#htoc76">66&nbsp;&nbsp;My goal is solvable by a sequence of rewrites, how can I prove it?</A>
<LI><A HREF="#htoc77">67&nbsp;&nbsp;My goal is a disequality solvable by a sequence of rewrites, how can I prove it?</A>
<LI><A HREF="#htoc78">68&nbsp;&nbsp;My goal is an equality on some ring (e.g. natural numbers), how can I prove it?</A>
<LI><A HREF="#htoc79">69&nbsp;&nbsp;My goal is an equality on some field (e.g. real numbers), how can I prove it?</A>
<LI><A HREF="#htoc80">70&nbsp;&nbsp;My goal is an inequality on integers in Presburger's arithmetic (an expression build from +,-,constants and variables), how can I prove it?</A>
<LI><A HREF="#htoc81">71&nbsp;&nbsp;My goal is an equation solvable using equational hypothesis on some ring (e.g. natural numbers), how can I prove it?</A>
</UL>
<LI><A HREF="#htoc82">6.2&nbsp;&nbsp;Tactics usage</A>
<UL><LI>
<A HREF="#htoc83">72&nbsp;&nbsp;I want to state a fact that I will use later as an hypothesis, how can I do it?</A>
<LI><A HREF="#htoc84">73&nbsp;&nbsp;I want to state a fact that I will use later as an hypothesis and prove it later, how can I do it?</A>
<LI><A HREF="#htoc85">74&nbsp;&nbsp;What is the difference between <TT>Qed</TT> and <TT>Defined</TT>?</A>
<LI><A HREF="#htoc86">75&nbsp;&nbsp;How can I know what a tactic does?</A>
<LI><A HREF="#htoc87">76&nbsp;&nbsp;Why <TT>auto</TT> does not work? How can I fix it?</A>
<LI><A HREF="#htoc88">77&nbsp;&nbsp;What is <TT>eauto</TT>?</A>
<LI><A HREF="#htoc89">78&nbsp;&nbsp;How can I speed up <TT>auto</TT>?</A>
<LI><A HREF="#htoc90">79&nbsp;&nbsp;What is the equivalent of <TT>tauto</TT> for classical logic?</A>
<LI><A HREF="#htoc91">80&nbsp;&nbsp;I want to replace some term with another in the goal, how can I do it?</A>
<LI><A HREF="#htoc92">81&nbsp;&nbsp;I want to replace some term with another in an hypothesis, how can I do it?</A>
<LI><A HREF="#htoc93">82&nbsp;&nbsp;I want to replace some symbol with its definition, how can I do it?</A>
<LI><A HREF="#htoc94">83&nbsp;&nbsp;How can I reduce some term?</A>
<LI><A HREF="#htoc95">84&nbsp;&nbsp;How can I declare a shortcut for some term?</A>
<LI><A HREF="#htoc96">85&nbsp;&nbsp;How can I perform case analysis?</A>
<LI><A HREF="#htoc97">86&nbsp;&nbsp;Why should I name my intros?</A>
<LI><A HREF="#htoc98">87&nbsp;&nbsp;How can I automatize the naming?</A>
<LI><A HREF="#htoc99">88&nbsp;&nbsp;I want to automatize the use of some tactic, how can I do it?</A>
<LI><A HREF="#htoc100">89&nbsp;&nbsp;I want to execute the <TT>p</TT>roof with tactic only if it solves the goal, how can I do it?</A>
<LI><A HREF="#htoc101">90&nbsp;&nbsp;How can I do the opposite of the <TT>intro</TT> tactic?</A>
<LI><A HREF="#htoc102">91&nbsp;&nbsp;One of the hypothesis is an equality between a variable and some term, I want to get rid of this variable, how can I do it?</A>
<LI><A HREF="#htoc103">92&nbsp;&nbsp;What can I do if I get ``<TT>generated subgoal term has metavariables in it </TT>''?</A>
<LI><A HREF="#htoc104">93&nbsp;&nbsp;How can I instantiate some metavariable?</A>
<LI><A HREF="#htoc105">94&nbsp;&nbsp;What is the use of the <TT>pattern</TT> tactic?</A>
<LI><A HREF="#htoc106">95&nbsp;&nbsp;What is the difference between assert, cut and generalize?</A>
<LI><A HREF="#htoc107">96&nbsp;&nbsp;What can I do if <FONT COLOR=navy>Coq</FONT>can not infer some implicit argument ?</A>
<LI><A HREF="#htoc108">97&nbsp;&nbsp;How can I explicit some implicit argument ?</A>
</UL>
<LI><A HREF="#htoc109">6.3&nbsp;&nbsp;Proof management</A>
<UL><LI>
<A HREF="#htoc110">98&nbsp;&nbsp;How can I change the order of the subgoals?</A>
<LI><A HREF="#htoc111">99&nbsp;&nbsp;How can I change the order of the hypothesis?</A>
<LI><A HREF="#htoc112">100&nbsp;&nbsp;How can I change the name of an hypothesis?</A>
<LI><A HREF="#htoc113">101&nbsp;&nbsp;How can I delete some hypothesis?</A>
<LI><A HREF="#htoc114">102&nbsp;&nbsp;How can use a proof which is not finished?</A>
<LI><A HREF="#htoc115">103&nbsp;&nbsp;How can I state a conjecture?</A>
<LI><A HREF="#htoc116">104&nbsp;&nbsp;What is the difference between a lemma, a fact and a theorem?</A>
<LI><A HREF="#htoc117">105&nbsp;&nbsp;How can I organize my proofs?</A>
</UL>
</UL>
<LI><A HREF="#htoc118">7&nbsp;&nbsp;Inductive and Co-inductive types</A>
<UL><LI>
<A HREF="#htoc119">7.1&nbsp;&nbsp;General</A>
<UL><LI>
<A HREF="#htoc120">106&nbsp;&nbsp;How can I prove that two constructors are different?</A>
<LI><A HREF="#htoc121">107&nbsp;&nbsp;During an inductive proof, how to get rid of impossible cases of an inductive definition?</A>
<LI><A HREF="#htoc122">108&nbsp;&nbsp;How can I prove that 2 terms in an inductive set are equal? Or different?</A>
<LI><A HREF="#htoc123">109&nbsp;&nbsp;Why is the proof of <TT>0+n=n</TT> on natural numbers
trivial but the proof of <TT>n+0=n</TT> is not?</A>
<LI><A HREF="#htoc124">110&nbsp;&nbsp;Why is dependent elimination in Prop not
available by default?</A>
</UL>
<LI><A HREF="#htoc125">7.2&nbsp;&nbsp;Recursion</A>
<UL><LI>
<A HREF="#htoc126">111&nbsp;&nbsp;Why can't I define a non terminating program?</A>
<LI><A HREF="#htoc127">112&nbsp;&nbsp;Why only structurally well-founded loops are allowed?</A>
<LI><A HREF="#htoc128">113&nbsp;&nbsp;How to define loops based on non structurally smaller
recursive calls?</A>
<LI><A HREF="#htoc129">114&nbsp;&nbsp;What is behind the accessibility and well-foundedness proofs?</A>
<LI><A HREF="#htoc130">115&nbsp;&nbsp;How to perform double induction?</A>
<LI><A HREF="#htoc131">116&nbsp;&nbsp;How to define a function by double recursion?</A>
<LI><A HREF="#htoc132">117&nbsp;&nbsp;How to perform nested induction?</A>
<LI><A HREF="#htoc133">118&nbsp;&nbsp;How to define a function by nested recursion?</A>
</UL>
<LI><A HREF="#htoc134">7.3&nbsp;&nbsp;Co-inductive types</A>
<UL><LI>
<A HREF="#htoc135">119&nbsp;&nbsp;I have a cofixpoint <I>t</I>:=<I>F</I>(<I>t</I>) and I want to prove <I>t</I>=<I>F</I>(<I>t</I>). How to do it?</A>
</UL>
</UL>
<LI><A HREF="#htoc136">8&nbsp;&nbsp;Syntax and notations</A>
<UL>
<UL><LI>
<A HREF="#htoc137">120&nbsp;&nbsp;I do not want to type ``forall'' because it is too long, what can I do?</A>
<LI><A HREF="#htoc138">121&nbsp;&nbsp;How can I define a notation for square?</A>
<LI><A HREF="#htoc139">122&nbsp;&nbsp;Why ``no associativity'' and ``left associativity'' at the same level does not work?</A>
<LI><A HREF="#htoc140">123&nbsp;&nbsp;How can I know the associativity associated with a level?</A>
</UL>
</UL>
<LI><A HREF="#htoc141">9&nbsp;&nbsp;Modules</A>
<LI><A HREF="#htoc142">10&nbsp;&nbsp;<FONT COLOR=navy>Ltac</FONT></A>
<UL>
<UL><LI>
<A HREF="#htoc143">124&nbsp;&nbsp;What is <FONT COLOR=navy>Ltac</FONT>?</A>
<LI><A HREF="#htoc144">125&nbsp;&nbsp;Why do I always get the same error message?</A>
<LI><A HREF="#htoc145">126&nbsp;&nbsp;Is there any printing command in <FONT COLOR=navy>Ltac</FONT>?</A>
<LI><A HREF="#htoc146">127&nbsp;&nbsp;What is the syntax for let in <FONT COLOR=navy>Ltac</FONT>?</A>
<LI><A HREF="#htoc147">128&nbsp;&nbsp;What is the syntax for pattern matching in <FONT COLOR=navy>Ltac</FONT>?</A>
<LI><A HREF="#htoc148">129&nbsp;&nbsp;What is the semantics for match goal?</A>
<LI><A HREF="#htoc149">130&nbsp;&nbsp;How can I generate a new name?</A>
<LI><A HREF="#htoc150">131&nbsp;&nbsp;How can I define static and dynamic code?</A>
</UL>
</UL>
<LI><A HREF="#htoc151">11&nbsp;&nbsp;Tactics written in Ocaml</A>
<UL>
<UL><LI>
<A HREF="#htoc152">132&nbsp;&nbsp;Can you show me an example of a tactic written in OCaml?</A>
</UL>
</UL>
<LI><A HREF="#htoc153">12&nbsp;&nbsp;Case studies</A>
<UL>
<UL><LI>
<A HREF="#htoc154">133&nbsp;&nbsp;How can I define vectors or lists of size n?</A>
<LI><A HREF="#htoc155">134&nbsp;&nbsp;How to prove that 2 sets are different?</A>
<LI><A HREF="#htoc156">135&nbsp;&nbsp;Is there an axiom-free proof of Streicher's axiom <I>K</I> for
the equality on <TT>nat</TT>?</A>
<LI><A HREF="#htoc157">136&nbsp;&nbsp;How to prove that two proofs of <TT>n&lt;=m</TT> on <TT>nat</TT> are equal?</A>
<LI><A HREF="#htoc158">137&nbsp;&nbsp;How to exploit equalities on sets</A>
<LI><A HREF="#htoc159">138&nbsp;&nbsp;I have a problem of dependent elimination on
proofs, how to solve it?</A>
<LI><A HREF="#htoc160">139&nbsp;&nbsp;And what if I want to prove the following?</A>
</UL>
</UL>
<LI><A HREF="#htoc161">13&nbsp;&nbsp;Publishing tools</A>
<UL>
<UL><LI>
<A HREF="#htoc162">140&nbsp;&nbsp;How can I generate some latex from my development?</A>
<LI><A HREF="#htoc163">141&nbsp;&nbsp;How can I generate some HTML from my development?</A>
<LI><A HREF="#htoc164">142&nbsp;&nbsp;How can I generate some dependency graph from my development?</A>
<LI><A HREF="#htoc165">143&nbsp;&nbsp;How can I cite some <FONT COLOR=navy>Coq</FONT> in my latex document?</A>
<LI><A HREF="#htoc166">144&nbsp;&nbsp;How can I cite the <FONT COLOR=navy>Coq</FONT> reference manual?</A>
<LI><A HREF="#htoc167">145&nbsp;&nbsp;Where can I publish my developments in <FONT COLOR=navy>Coq</FONT>?</A>
<LI><A HREF="#htoc168">146&nbsp;&nbsp;How can I read my proof in natural language?</A>
</UL>
</UL>
<LI><A HREF="#htoc169">14&nbsp;&nbsp;<FONT COLOR=navy>CoqIde</FONT></A>
<UL>
<UL><LI>
<A HREF="#htoc170">147&nbsp;&nbsp;What is <FONT COLOR=navy>CoqIde</FONT>?</A>
<LI><A HREF="#htoc171">148&nbsp;&nbsp;How to enable Emacs keybindings?</A>
<LI><A HREF="#htoc172">149&nbsp;&nbsp;How to enable antialiased fonts?</A>
<LI><A HREF="#htoc173">150&nbsp;&nbsp;How to use those Forall and Exists pretty symbols?</A>
<LI><A HREF="#htoc174">151&nbsp;&nbsp;How to define an input method for non ASCII symbols?</A>
<LI><A HREF="#htoc175">152&nbsp;&nbsp;How to build a custom <FONT COLOR=navy>CoqIde</FONT> with user ml code?</A>
<LI><A HREF="#htoc176">153&nbsp;&nbsp;How to customize the shortcuts for menus?</A>
<LI><A HREF="#htoc177">154&nbsp;&nbsp;What encoding should I use? What is this \x{iiii} in my file?</A>
</UL>
</UL>
<LI><A HREF="#htoc178">15&nbsp;&nbsp;Extraction</A>
<UL>
<UL><LI>
<A HREF="#htoc179">155&nbsp;&nbsp;What is program extraction?</A>
<LI><A HREF="#htoc180">156&nbsp;&nbsp;Which language can I extract to?</A>
<LI><A HREF="#htoc181">157&nbsp;&nbsp;How can I extract an incomplete proof?</A>
</UL>
</UL>
<LI><A HREF="#htoc182">16&nbsp;&nbsp;Glossary</A>
<UL>
<UL><LI>
<A HREF="#htoc183">158&nbsp;&nbsp;Can you explain me what an evaluable constant is?</A>
<LI><A HREF="#htoc184">159&nbsp;&nbsp;What is a goal?</A>
<LI><A HREF="#htoc185">160&nbsp;&nbsp;What is a meta variable?</A>
<LI><A HREF="#htoc186">161&nbsp;&nbsp;What is Gallina?</A>
<LI><A HREF="#htoc187">162&nbsp;&nbsp;What is The Vernacular?</A>
<LI><A HREF="#htoc188">163&nbsp;&nbsp;What is a dependent type?</A>
<LI><A HREF="#htoc189">164&nbsp;&nbsp;What is a proof by reflection?</A>
<LI><A HREF="#htoc190">165&nbsp;&nbsp;What is intuitionistic logic?</A>
<LI><A HREF="#htoc191">166&nbsp;&nbsp;What is proof-irrelevance?</A>
<LI><A HREF="#htoc192">167&nbsp;&nbsp;What is the difference between opaque and transparent?</A>
</UL>
</UL>
<LI><A HREF="#htoc193">17&nbsp;&nbsp;Troubleshooting</A>
<UL>
<UL><LI>
<A HREF="#htoc194">168&nbsp;&nbsp;What can I do when <TT>Qed.</TT> is slow?</A>
<LI><A HREF="#htoc195">169&nbsp;&nbsp;Why <TT>Reset Initial.</TT> does not work when using <TT>coqc</TT>?</A>
<LI><A HREF="#htoc196">170&nbsp;&nbsp;What can I do if I get ``No more subgoals but non-instantiated existential variables''?</A>
<LI><A HREF="#htoc197">171&nbsp;&nbsp;What can I do if I get ``Cannot solve a second-order unification problem''?</A>
<LI><A HREF="#htoc198">172&nbsp;&nbsp;Why does <FONT COLOR=navy>Coq</FONT> tell me that <TT>{x:A|(P x)}</TT> is not convertible with <TT>(sig A P)</TT>?</A>
<LI><A HREF="#htoc199">173&nbsp;&nbsp;I copy-paste a term and <FONT COLOR=navy>Coq</FONT> says it is not convertible
 to the original term. Sometimes it even says the copied term is not
well-typed.</A>
</UL>
</UL>
<LI><A HREF="#htoc200">18&nbsp;&nbsp;Conclusion and Farewell.</A>
<UL>
<UL><LI>
<A HREF="#htoc201">174&nbsp;&nbsp;What if my question isn't answered here?</A>
</UL>
</UL>
</UL>

<!--TOC section Introduction-->

<H2><A NAME="htoc1">1</A>&nbsp;&nbsp;Introduction</H2><!--SEC END -->

This FAQ is the sum of the questions that came to mind as we developed
proofs in <FONT COLOR=navy>Coq</FONT>. Since we are singularly short-minded, we wrote the
answers we found on bits of papers to have them at hand whenever the
situation occurs again. This is pretty much the result of that: a
collection of tips one can refer to when proofs become intricate. Yes,
this means we won't take the blame for the shortcomings of this
FAQ. But if you want to contribute and send in your own question and
answers, feel free to write to us...<BR>
<BR>
<!--TOC section Presentation-->

<H2><A NAME="htoc2">2</A>&nbsp;&nbsp;Presentation</H2><!--SEC END -->

<!--TOC subsubsection What is <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc3">1</A>&nbsp;&nbsp;What is <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->
<A NAME="whatiscoq"></A> 
The <FONT COLOR=navy>Coq</FONT> tool is a formal proof management system: a proof done with <FONT COLOR=navy>Coq</FONT> is mechanically checked by the machine. 
In particular, <FONT COLOR=navy>Coq</FONT> allows:
<UL><LI>
 the definition of functions or predicates,
 <LI>to state mathematical theorems and software specifications,
 <LI>to develop interactively formal proofs of these theorems,
 <LI>to check these proofs by a small certification "kernel".
</UL>
<FONT COLOR=navy>Coq</FONT> is based on a logical framework called "Calculus of Inductive Constructions" extended by a modular development system for theories.<BR>
<BR>
<!--TOC subsubsection Did you really need to name it like that?-->

<H4><A NAME="htoc4">2</A>&nbsp;&nbsp;Did you really need to name it like that?</H4><!--SEC END -->

Some French computer scientists have a tradition of naming their
software as animal species: Caml, Elan, Foc or Phox are examples
of this tacit convention. In French, ``coq'' means rooster, and it
sounds like the initials of the Calculus of Constructions CoC on which
it is based.<BR>
<BR>
<!--TOC subsubsection Is <FONT COLOR=navy>Coq</FONT> a theorem prover?-->

<H4><A NAME="htoc5">3</A>&nbsp;&nbsp;Is <FONT COLOR=navy>Coq</FONT> a theorem prover?</H4><!--SEC END -->

<FONT COLOR=navy>Coq</FONT> comes with a few decision procedures (on propositional
calculus, Presburger's arithmetic, ring and field simplification,
resolution, ...) but the main style for proving theorems is
interactively by using LCF-style tactics.<BR>
<BR>
<!--TOC subsubsection What are the other theorem provers?-->

<H4><A NAME="htoc6">4</A>&nbsp;&nbsp;What are the other theorem provers?</H4><!--SEC END -->
 
Many other theorem provers are available for use nowadays. 
Isabelle, HOL, HOL Light, Lego, Nuprl, PVS are examples of provers that are fairly similar
to <FONT COLOR=navy>Coq</FONT> by the way they interact with the user. Other relatives of
<FONT COLOR=navy>Coq</FONT> are ACL2, Alfa, Elf, Kiv, Mizar, NqThm, 
Omega...
<BR>
<BR>
<!--TOC subsubsection Who do I have to trust when I see a proof checked by Coq?-->

<H4><A NAME="htoc7">5</A>&nbsp;&nbsp;Who do I have to trust when I see a proof checked by Coq?</H4><!--SEC END -->

You have to trust:
<DL COMPACT=compact><DT>
<B>The theory behind Coq</B><DD> The theory of <FONT COLOR=navy>Coq</FONT> version 8.0 is
generally admitted to be consistent wrt Zermelo-Fraenkel set theory +
inaccessibles cardinals. Proofs of consistency of subsystems of the
theory of Coq can be found in the literature.
<DT><B>The Coq kernel implementation</B><DD> You have to trust that the
implementation of the <FONT COLOR=navy>Coq</FONT> kernel mirrors the theory behind <FONT COLOR=navy>Coq</FONT>. The
kernel is intentionally small to limit the risk of conceptual or
accidental implementation bugs.
<DT><B>The Objective Caml compiler</B><DD> The <FONT COLOR=navy>Coq</FONT> kernel is written using the
Objective Caml language but it uses only the most standard features
(no object, no label ...), so that it is highly unprobable that an
Objective Caml bug breaks the consistency of <FONT COLOR=navy>Coq</FONT> without breaking all
other kinds of features of <FONT COLOR=navy>Coq</FONT> or of other software compiled with
Objective Caml.
<DT><B>Your hardware</B><DD> In theory, if your hardware does not work
properly, it can accidentally be the case that False becomes
provable. But it is more likely the case that the whole <FONT COLOR=navy>Coq</FONT> system
will be unusable. You can check your proof using different computers
if you feel the need to.
<DT><B>Your axioms</B><DD> Your axioms must be consistent with the theory
behind <FONT COLOR=navy>Coq</FONT>.
</DL>
<!--TOC subsubsection Where can I find information about the theory behind <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc8">6</A>&nbsp;&nbsp;Where can I find information about the theory behind <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

<DL COMPACT=compact><DT>
<B>The Calculus of Inductive Constructions</B><DD> The
<A HREF="http://coq.inria.fr/doc/Reference-Manual006.html">corresponding</A>
chapter and the chapter on
<A HREF="http://coq.inria.fr/doc/Reference-Manual007.html">modules</A> in
the <FONT COLOR=navy>Coq</FONT> Reference Manual.
<DT><B>Type theory</B><DD> A book&nbsp;[<A HREF="#ProofsTypes"><CITE>10</CITE></A>] or some lecture
notes&nbsp;[<A HREF="#Types:Dowek"><CITE>7</CITE></A>].
<DT><B>Inductive types</B><DD>
Christine Paulin-Mohring's habilitation thesis&nbsp;[<A HREF="#Pau96b"><CITE>17</CITE></A>].
<DT><B>Co-Inductive types</B><DD>
Eduardo Giménez' thesis&nbsp;[<A HREF="#EGThese"><CITE>8</CITE></A>].
<DT><B>Miscellaneous</B><DD> A
<A HREF="http://coq.inria.fr/doc/biblio.html">bibliography</A> about Coq
</DL>
<!--TOC subsubsection How can I use <FONT COLOR=navy>Coq</FONT> to prove programs?-->

<H4><A NAME="htoc9">7</A>&nbsp;&nbsp;How can I use <FONT COLOR=navy>Coq</FONT> to prove programs?</H4><!--SEC END -->

You can either extract a program from a proof by using the extraction
mechanism or use dedicated tools, such as
<A HREF="http://why.lri.fr"><FONT COLOR=navy>Why</FONT></A>,
<A HREF="http://krakatoa.lri.fr"><FONT COLOR=navy>Krakatoa</FONT></A>,
<A HREF="http://why.lri.fr/caduceus/index.en.html"><FONT COLOR=navy>Caduceus</FONT></A>, to prove
annotated programs written in other languages.<BR>
<BR>
<!--TOC subsubsection How many <FONT COLOR=navy>Coq</FONT> users are there?-->

<H4><A NAME="htoc10">8</A>&nbsp;&nbsp;How many <FONT COLOR=navy>Coq</FONT> users are there?</H4><!--SEC END -->

An estimation is about 100 regular users.<BR>
<BR>
<!--TOC subsubsection How old is <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc11">9</A>&nbsp;&nbsp;How old is <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

The first implementation is from 1985 (it was named <FONT COLOR=purple>CoC</FONT> which is
the acronym of the name of the logic it implemented: the Calculus of
Constructions). The first official release of <FONT COLOR=navy>Coq</FONT> (version 4.10)
was distributed in 1989.<BR>
<BR>
<!--TOC subsubsection What are the <FONT COLOR=navy>Coq</FONT>-related tools?-->

<H4><A NAME="htoc12">10</A>&nbsp;&nbsp;What are the <FONT COLOR=navy>Coq</FONT>-related tools?</H4><!--SEC END -->

<DL COMPACT=compact><DT>
<B>Coqide</B><DD> A GTK based GUI for <FONT COLOR=navy>Coq</FONT>.
<DT><B>Pcoq</B><DD> A GUI for <FONT COLOR=navy>Coq</FONT> with proof by pointing and pretty printing.
<DT><B>Helm/Mowgli</B><DD> A rendering, searching and publishing tool.
<DT><B>Why</B><DD> A back-end generator of verification conditions.
<DT><B>Krakatoa</B><DD> A Java code certification tool that uses both <FONT COLOR=navy>Coq</FONT> and <FONT COLOR=navy>Why</FONT> to verify the soundness of implementations with regards to the specifications.
<DT><B>Caduceus</B><DD> A C code certification tool that uses both <FONT COLOR=navy>Coq</FONT> and <FONT COLOR=navy>Why</FONT>.
<DT><B>coqwc</B><DD> A tool similar to <TT>wc</TT> to count lines in <FONT COLOR=navy>Coq</FONT> files.
<DT><B>coq-tex</B><DD> A tool to insert <FONT COLOR=navy>Coq</FONT> examples within .tex files. 
<DT><B>coqdoc</B><DD> A documentation tool for <FONT COLOR=navy>Coq</FONT>.
<DT><B>Proof General</B><DD> A emacs mode for <FONT COLOR=navy>Coq</FONT> and many other proof assistants.
<DT><B>Foc</B><DD> The <A HREF="http://www-spi.lip6.fr/foc/index-en.html">Foc</A> project aims at building an environment to develop certified computer algebra libraries. 
</DL>
<!--TOC subsubsection What are the high-level tactics of <FONT COLOR=navy>Coq</FONT>-->

<H4><A NAME="htoc13">11</A>&nbsp;&nbsp;What are the high-level tactics of <FONT COLOR=navy>Coq</FONT></H4><!--SEC END -->

<UL><LI>
Decision of quantifier-free Presburger's Arithmetic
<LI>Simplification of expressions on rings and fields
<LI>Decision of closed systems of equations
<LI>Semi-decision of first-order logic
<LI>Prolog-style proof search, possibly involving equalities
</UL>
<!--TOC subsubsection What are the main libraries available for <FONT COLOR=navy>Coq</FONT>-->

<H4><A NAME="htoc14">12</A>&nbsp;&nbsp;What are the main libraries available for <FONT COLOR=navy>Coq</FONT></H4><!--SEC END -->

<UL><LI>
Basic Peano's arithmetic, binary integer numbers, rational numbers,
<LI>Real analysis,
<LI>Libraries for lists, boolean, maps, floating-point numbers,
<LI>Libraries for relations, sets and constructive algebra,
<LI>Geometry
</UL>
<!--TOC subsubsection What are the academic applications for <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc15">13</A>&nbsp;&nbsp;What are the academic applications for <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

<FONT COLOR=navy>Coq</FONT> is used for formalizing mathematical theories, for teaching,
and for proving properties of algorithms or programs libraries.<BR>
<BR>
The largest mathematical formalization has been done at the University
of Nijmegen (see the
<A HREF="http://c-corn.cs.ru.nl/">Constructive Coq
Repository at Nijmegen</A>).<BR>
<BR>
<!--TOC subsubsection What are the industrial applications for <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc16">14</A>&nbsp;&nbsp;What are the industrial applications for <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

<FONT COLOR=navy>Coq</FONT> is used e.g. to prove properties of the JavaCard system
(especially by the companies Schlumberger and Trusted Logic). It has
also been used to formalize the semantics of the Lucid-Synchrone
data-flow synchronous calculus used by Esterel-Technologies.<BR>
<BR>
<!--TOC section Documentation-->

<H2><A NAME="htoc17">3</A>&nbsp;&nbsp;Documentation</H2><!--SEC END -->

<!--TOC subsubsection Where can I find documentation about <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc18">15</A>&nbsp;&nbsp;Where can I find documentation about <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->
 
All the documentation about <FONT COLOR=navy>Coq</FONT>, from the reference manual&nbsp;[<A HREF="#Coq:manual"><CITE>15</CITE></A>] to
friendly tutorials&nbsp;[<A HREF="#Coq:Tutorial"><CITE>14</CITE></A>] and documentation of the standard library, is available 
<A HREF="http://coq.inria.fr/doc-eng.html">online</A>.
All these documents are viewable either in browsable HTML, or as
downloadable postscripts.<BR>
<BR>
<!--TOC subsubsection Where can I find this FAQ on the web?-->

<H4><A NAME="htoc19">16</A>&nbsp;&nbsp;Where can I find this FAQ on the web?</H4><!--SEC END -->

This FAQ is available online at <A HREF="http://coq.inria.fr/doc/faq.html"><TT>http://coq.inria.fr/doc/faq.html</TT></A>.<BR>
<BR>
<!--TOC subsubsection How can I submit suggestions / improvements / additions for this FAQ?-->

<H4><A NAME="htoc20">17</A>&nbsp;&nbsp;How can I submit suggestions / improvements / additions for this FAQ?</H4><!--SEC END -->

This FAQ is unfinished (in the sense that there are some obvious
sections that are missing). Please send contributions to <TT>Florent.Kirchner at lix.polytechnique.fr</TT> and <TT>Julien.Narboux at inria.fr</TT>.<BR>
<BR>
<!--TOC subsubsection Is there any mailing list about <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc21">18</A>&nbsp;&nbsp;Is there any mailing list about <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->
 
The main <FONT COLOR=navy>Coq</FONT> mailing list is <TT>coq-club@coq.inria.fr</TT>, which
broadcasts questions and suggestions about the implementation, the
logical formalism or proof developments. See
<A HREF="http://coq.inria.fr/mailman/listinfo/coq-club"><TT>http://coq.inria.fr/mailman/listinfo/coq-club</TT></A> for
subscription. For bugs reports see question <A HREF="#coqbug">23</A>.<BR>
<BR>
<!--TOC subsubsection Where can I find an archive of the list?-->

<H4><A NAME="htoc22">19</A>&nbsp;&nbsp;Where can I find an archive of the list?</H4><!--SEC END -->

The archives of the <FONT COLOR=navy>Coq</FONT> mailing list are available at
<A HREF="http://coq.inria.fr/pipermail/coq-club"><TT>http://coq.inria.fr/pipermail/coq-club</TT></A>.<BR>
<BR>
<!--TOC subsubsection How can I be kept informed of new releases of <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc23">20</A>&nbsp;&nbsp;How can I be kept informed of new releases of <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

New versions of <FONT COLOR=navy>Coq</FONT> are announced on the coq-club mailing list. If you only want to receive information about new releases, you can subscribe to <FONT COLOR=navy>Coq</FONT> on <A HREF="http://freshmeat.net/projects/coq/"><TT>http://freshmeat.net/projects/coq/</TT></A>.<BR>
<BR>
<!--TOC subsubsection Is there any book about <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc24">21</A>&nbsp;&nbsp;Is there any book about <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

The first book on <FONT COLOR=navy>Coq</FONT>, Yves Bertot and Pierre Castéran's Coq'Art has been published by Springer-Verlag in 2004:
<BLOCKQUOTE>
``This book provides a pragmatic introduction to the development of
proofs and certified programs using <FONT COLOR=navy>Coq</FONT>. With its large collection of
examples and exercises it is an invaluable tool for researchers,
students, and engineers interested in formal methods and the
development of zero-default software.''
</BLOCKQUOTE>
<!--TOC subsubsection Where can I find some <FONT COLOR=navy>Coq</FONT> examples?-->

<H4><A NAME="htoc25">22</A>&nbsp;&nbsp;Where can I find some <FONT COLOR=navy>Coq</FONT> examples?</H4><!--SEC END -->
 
There are examples in the manual&nbsp;[<A HREF="#Coq:manual"><CITE>15</CITE></A>] and in the
Coq'Art&nbsp;[<A HREF="#Coq:coqart"><CITE>1</CITE></A>] exercises <A HREF="http://www.labri.fr/Perso/~casteran/CoqArt/index.html"><TT>http://www.labri.fr/Perso/~casteran/CoqArt/index.html</TT></A>.
You can also find large developments using
<FONT COLOR=navy>Coq</FONT> in the <FONT COLOR=navy>Coq</FONT> user contributions:
<A HREF="http://coq.inria.fr/contrib-eng.html"><TT>http://coq.inria.fr/contrib-eng.html</TT></A>.<BR>
<BR>
<!--TOC subsubsection How can I report a bug?-->

<H4><A NAME="htoc26">23</A>&nbsp;&nbsp;How can I report a bug?</H4><!--SEC END -->
<A NAME="coqbug"></A>
You can use the web interface at <A HREF="http://coq.inria.fr/bin/coq-bugs"><TT>http://coq.inria.fr/bin/coq-bugs</TT></A>.<BR>
<BR>
<!--TOC section Installation-->

<H2><A NAME="htoc27">4</A>&nbsp;&nbsp;Installation</H2><!--SEC END -->

<!--TOC subsubsection What is the license of <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc28">24</A>&nbsp;&nbsp;What is the license of <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

The main files are distributed under the GNU Lesser General License
(LGPL). A few contributions are GPL.<BR>
<BR>
<!--TOC subsubsection Where can I find the sources of <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc29">25</A>&nbsp;&nbsp;Where can I find the sources of <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

The sources of <FONT COLOR=navy>Coq</FONT> can be found online in the tar.gz'ed packages
(<A HREF="http://coq.inria.fr/distrib-eng.html"><TT>http://coq.inria.fr/distrib-eng.html</TT></A>). Development sources can
be accessed via anonymous CVS: <A HREF="http://coqcvs.inria.fr/"><TT>http://coqcvs.inria.fr/</TT></A><BR>
<BR>
<!--TOC subsubsection On which platform is <FONT COLOR=navy>Coq</FONT> available?-->

<H4><A NAME="htoc30">26</A>&nbsp;&nbsp;On which platform is <FONT COLOR=navy>Coq</FONT> available?</H4><!--SEC END -->

Compiled binaries are available for Linux, MacOS X, Solaris, and
Windows. The sources can be easily compiled on all platforms supporting Objective Caml.<BR>
<BR>
<!--TOC section The logic of <FONT COLOR=navy>Coq</FONT>-->

<H2><A NAME="htoc31">5</A>&nbsp;&nbsp;The logic of <FONT COLOR=navy>Coq</FONT></H2><!--SEC END -->

<!--TOC subsection General-->

<H3><A NAME="htoc32">5.1</A>&nbsp;&nbsp;General</H3><!--SEC END -->

<!--TOC subsubsection What is the logic of <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc33">27</A>&nbsp;&nbsp;What is the logic of <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

<FONT COLOR=navy>Coq</FONT> is based on an axiom-free type theory called
the Calculus of Inductive Constructions (see Coquand [<A HREF="#CoHu86"><CITE>5</CITE></A>]
and Coquand--Paulin-Mohring [<A HREF="#CoPa89"><CITE>6</CITE></A>]). It includes higher-order
functions and predicates, inductive and co-inductive datatypes and
predicates, and a stratified hierarchy of sets.<BR>
<BR>
<!--TOC subsubsection Is <FONT COLOR=navy>Coq</FONT>'s logic intuitionistic or classical?-->

<H4><A NAME="htoc34">28</A>&nbsp;&nbsp;Is <FONT COLOR=navy>Coq</FONT>'s logic intuitionistic or classical?</H4><!--SEC END -->

<FONT COLOR=navy>Coq</FONT> theory is basically intuitionistic
(i.e. excluded-middle <I>A</I>\/¬ <I>A</I> is not granted by default) with
the possibility to reason classically on demand by requiring an
optional axiom stating <I>A</I>\/¬ <I>A</I>.<BR>
<BR>
<!--TOC subsubsection Can I define non-terminating programs in <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc35">29</A>&nbsp;&nbsp;Can I define non-terminating programs in <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

No, all programs in <FONT COLOR=navy>Coq</FONT> are terminating. Especially, loops
must come with an evidence of their termination.<BR>
<BR>
<!--TOC subsubsection How is equational reasoning working in <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc36">30</A>&nbsp;&nbsp;How is equational reasoning working in <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

<FONT COLOR=navy>Coq</FONT> comes with an internal notion of computation called
<EM>conversion</EM> (e.g. (<I>x</I>+1)+<I>y</I> is internally equivalent to
(<I>x</I>+<I>y</I>)+1; similarly applying argument <I>a</I> to a function mapping <I>x</I>
to some expression <I>t</I> converts to the expression <I>t</I> where <I>x</I> is
replaced by <I>a</I>). This notion of conversion (which is decidable
because <FONT COLOR=navy>Coq</FONT> programs are terminating) covers a certain part of
equational reasoning but is limited to sequential evaluation of
expressions of (not necessarily closed) programs. Besides conversion,
equations have to be treated by hand or using specialised tactics.<BR>
<BR>
<!--TOC subsection Axioms-->

<H3><A NAME="htoc37">5.2</A>&nbsp;&nbsp;Axioms</H3><!--SEC END -->

<!--TOC subsubsection What axioms can be safely added to <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc38">31</A>&nbsp;&nbsp;What axioms can be safely added to <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

There are a few typical useful axioms that are independent from the
Calculus of Inductive Constructions and that can be safely added to
<FONT COLOR=navy>Coq</FONT>. These axioms are stated in the directory <TT>Logic</TT> of the
standard library of <FONT COLOR=navy>Coq</FONT>. The most interesting ones are
<UL><LI>
Excluded-middle: for all <I>A</I>:<I>Prop</I>, <I>A</I> \/ ¬ <I>A</I>
<LI>Proof-irrelevance: for all <I>A</I>:<I>Prop</I>, for all <I>p</I><SUB><FONT SIZE=2>1</FONT></SUB> <I>p</I><SUB><FONT SIZE=2>2</FONT></SUB>:<I>A</I>, <I>p</I><SUB><FONT SIZE=2>1</FONT></SUB>=<I>p</I><SUB><FONT SIZE=2>2</FONT></SUB>
<LI>Unicity of equality proofs (or equivalently Streicher's axiom <I>K</I>)
<LI>The principle of description: for all <I>x</I>, there exists! <I>y</I>, <I>R</I>(<I>x</I>,<I>y</I>) -&gt; there exists <I>f</I>, for all <I>x</I>, <I>R</I>(<I>x</I>,<I>f</I>(<I>x</I>))
<LI>The functional axiom of choice: for all <I>x</I>, there exists <I>y</I>, <I>R</I>(<I>x</I>,<I>y</I>) -&gt; there exists <I>f</I>, for all <I>x</I>, <I>R</I>(<I>x</I>,<I>f</I>(<I>x</I>))
<LI>Extensionality of predicates: for all <I>P</I> <I>Q</I>:<I>A</I>-&gt; <I>Prop</I>, (for all <I>x</I>, <I>P</I>(<I>x</I>) &lt;-&gt; <I>Q</I>(<I>x</I>)) -&gt; <I>P</I>=<I>Q</I>
<LI>Extensionality of functions: for all <I>f</I> <I>g</I>:<I>A</I>-&gt; <I>B</I>, (for all <I>x</I>, <I>f</I>(<I>x</I>)=<I>g</I>(<I>x</I>)) -&gt; <I>f</I>=<I>g</I>
</UL>
Here is a summary of the relative strength of these axioms, most
proofs can be found in directory <TT>Logic</TT> of the standard library.<BR>
<BR>
<IMG SRC="main.v001.gif"><BR>
<BR>
<!--TOC subsubsection What standard axioms are inconsistent with <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc39">32</A>&nbsp;&nbsp;What standard axioms are inconsistent with <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

The axiom of description together with classical logic
(e.g. excluded-middle) are inconsistent in the variant of the Calculus
of Inductive Constructions where <TT>Set</TT> is impredicative.<BR>
<BR>
As a consequence, the functional form of the axiom of choice and
excluded-middle, or any form of the axiom of choice together with
predicate extensionality are inconsistent in the <TT>Set</TT>-impredicative
version of the Calculus of Inductive Constructions.<BR>
<BR>
The main purpose of the <TT>Set</TT>-predicative restriction of the Calculus
of Inductive Constructions is precisely to accommodate these axioms
which are quite standard in mathematical usage.<BR>
<BR>
The <TT><I>Set</I></TT>-predicative system is commonly considered consistent by
interpreting it in a standard set-theoretic boolean model, even with
classical logic, axiom of choice and predicate extensionality added.<BR>
<BR>
<!--TOC subsubsection What is Streicher's axiom <I>K</I>-->

<H4><A NAME="htoc40">33</A>&nbsp;&nbsp;What is Streicher's axiom <I>K</I></H4><!--SEC END -->

<A NAME="Streicher"></A>
Streicher's axiom <I>K</I> [<A HREF="#HofStr98"><CITE>12</CITE></A>] asserts dependent
elimination of reflexive equality proofs.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Axiom&nbsp;Streicher_K&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(A:Type)&nbsp;(x:A)&nbsp;(P:&nbsp;x=x&nbsp;-&gt;&nbsp;Prop),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;(refl_equal&nbsp;x)&nbsp;-&gt;&nbsp;forall&nbsp;p:&nbsp;x=x,&nbsp;P&nbsp;p.</TT><BR>
</DIV>
<BR>
In the general case, axiom <I>K</I> is an independent statement of the
Calculus of Inductive Constructions. However, it is true on decidable
domains (see file <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep_dec.html
"><TT>Eqdep_dec.v</TT></A>). It is also
trivially a consequence of proof-irrelevance (see
<A HREF="#proof-irrelevance">34</A>) hence of classical logic.<BR>
<BR>
Axiom <I>K</I> is equivalent to <EM>Uniqueness of Identity Proofs</EM> [<A HREF="#HofStr98"><CITE>12</CITE></A>]<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Axiom&nbsp;UIP&nbsp;:&nbsp;forall&nbsp;(A:Set)&nbsp;(x&nbsp;y:A)&nbsp;(p1&nbsp;p2:&nbsp;x=y),&nbsp;p1&nbsp;=&nbsp;p2.</TT><BR>
</DIV>
<BR>
Axiom <I>K</I> is also equivalent to <EM>Uniqueness of Reflexive Identity Proofs</EM> [<A HREF="#HofStr98"><CITE>12</CITE></A>]<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Axiom&nbsp;UIP_refl&nbsp;:&nbsp;forall&nbsp;(A:Set)&nbsp;(x:A)&nbsp;(p:&nbsp;x=x),&nbsp;p&nbsp;=&nbsp;refl_equal&nbsp;x.</TT><BR>
</DIV>
<BR>
Axiom <I>K</I> is also equivalent to <BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Axiom</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;eq_rec_eq&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A:Set)&nbsp;(x:A)&nbsp;(P:&nbsp;A-&gt;Set)&nbsp;(p:P&nbsp;x)&nbsp;(h:&nbsp;x=x),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;eq_rect&nbsp;x&nbsp;P&nbsp;p&nbsp;x&nbsp;h.</TT><BR>
</DIV>
<BR>
It is also equivalent to the injectivity of dependent equality (dependent equality is itself equivalent to equality of dependent pairs).<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;eq_dep&nbsp;(U:Set)&nbsp;(P:U&nbsp;-&gt;&nbsp;Set)&nbsp;(p:U)&nbsp;(x:P&nbsp;p)&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;forall&nbsp;q:U,&nbsp;P&nbsp;q&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq_dep_intro&nbsp;:&nbsp;eq_dep&nbsp;U&nbsp;P&nbsp;p&nbsp;x&nbsp;p&nbsp;x.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Axiom</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;eq_dep_eq&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(U:Set)&nbsp;(u:U)&nbsp;(P:U&nbsp;-&gt;&nbsp;Set)&nbsp;(p1&nbsp;p2:P&nbsp;u),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq_dep&nbsp;U&nbsp;P&nbsp;u&nbsp;p1&nbsp;u&nbsp;p2&nbsp;-&gt;&nbsp;p1&nbsp;=&nbsp;p2.</TT><BR>
</DIV>
<BR>
<!--TOC subsubsection What is proof-irrelevance-->

<H4><A NAME="htoc41">34</A>&nbsp;&nbsp;What is proof-irrelevance</H4><!--SEC END -->

<A NAME="proof-irrelevance"></A>
A specificity of the Calculus of Inductive Constructions is to permit
statements about proofs. This leads to the question of comparing two
proofs of the same proposition. Identifying all proofs of the same
proposition is called <EM>proof-irrelevance</EM>:
<DIV ALIGN=center>for all <I>A</I>:<TT><I>Prop</I></TT>, for all <I>p</I> <I>q</I>:<I>A</I>, <I>p</I>=<I>q</I>
</DIV> <BR>
Proof-irrelevance (in <TT>Prop</TT>) can be assumed without contradiction in
<FONT COLOR=navy>Coq</FONT>. It corresponds to a model where provability, whatever the
proof is, is more important than the computational content of the
proof. This is in harmony with the common purely logical
interpretation of <TT>Prop</TT>. Contrastingly, proof-irrelevance is
inconsistent in <TT>Set</TT> in harmony with the computational meaning of
the sort <TT>Set</TT>.<BR>
<BR>
Proof-irrelevance (in <TT>Prop</TT>) is a consequence of classical logic
(see proofs in file <A HREF="http://coq.inria.fr/library/Coq.Logic.Classical.html
"><TT>Classical.v</TT></A> and
<A HREF="http://coq.inria.fr/library/Coq.Logic.Berardi.html
"><TT>Berardi.v</TT></A>). Proof-irrelevance is also a
consequence of propositional extensionality (i.e. <TT>(A &lt;-&gt; B)
-&gt; A=B</TT>, see the proof in file
<A HREF="http://coq.inria.fr/library/Coq.Logic.ClassicalFacts.html
"><TT>ClassicalFacts.v</TT></A>).<BR>
<BR>
Conversely, proof-irrelevance directly implies Streicher's axiom <I>K</I>.<BR>
<BR>
<!--TOC subsubsection What about functional extensionality?-->

<H4><A NAME="htoc42">35</A>&nbsp;&nbsp;What about functional extensionality?</H4><!--SEC END -->

Extensionality of functions is an axiom in, say set theory, but from a
programing point of view, extensionality cannot be <EM>a priori</EM>
accepted since it would identify, say programs such as mergesort and
quicksort.<BR>
<BR>
Let <TT>A</TT>, <TT>B</TT> be types. To deal with extensionality on 
<CODE>A-&gt;B</CODE>, the recommended approach is to define one's
own extensional equality on <CODE>A-&gt;B</CODE>.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;ext_eq&nbsp;(f&nbsp;g:&nbsp;A-&gt;B)&nbsp;:=&nbsp;forall&nbsp;x:A,&nbsp;f&nbsp;x&nbsp;=&nbsp;g&nbsp;x.</TT><BR>
</DIV>
<BR>
and to reason on <CODE>A-&gt;B</CODE> as a setoid (see the Chapter on
Setoids in the Reference Manual).<BR>
<BR>
<!--TOC subsubsection Is <TT>Prop</TT> impredicative?-->

<H4><A NAME="htoc43">36</A>&nbsp;&nbsp;Is <TT>Prop</TT> impredicative?</H4><!--SEC END -->

Yes, the sort <TT>Prop</TT> of propositions is <EM>impredicative</EM>. Otherwise said, a statement of the form for all
<I>A</I>:<I>Prop</I>, <I>P</I>(<I>A</I>) can be instantiated by itself: if for all <I>A</I>:<TT><I>Prop</I></TT>, <I>P</I>(<I>A</I>)
is provable, then <I>P</I>(for all <I>A</I>:<TT><I>Prop</I></TT>, <I>P</I>(<I>A</I>)) is.<BR>
<BR>
<!--TOC subsubsection Is <TT>Set</TT> impredicative?-->

<H4><A NAME="htoc44">37</A>&nbsp;&nbsp;Is <TT>Set</TT> impredicative?</H4><!--SEC END -->

No, the sort <TT>Set</TT> lying at the bottom of the hierarchy of
computational types is <EM>predicative</EM> in the basic <FONT COLOR=navy>Coq</FONT> system.
This means that a family of types in <TT>Set</TT>, e.g. for all <I>A</I>:<TT><I>Set</I></TT>, <I>A</I>
-&gt; <I>A</I>, is not a type in <TT>Set</TT> and it cannot be applied on
itself.<BR>
<BR>
However, the sort <TT>Set</TT> was impredicative in the original versions of
<FONT COLOR=navy>Coq</FONT>. For backward compatibility, or for experiments by
knowledgeable users, the logic of <FONT COLOR=navy>Coq</FONT> can be set impredicative for
<TT>Set</TT> by calling <FONT COLOR=navy>Coq</FONT> with the option <TT>-impredicative-set</TT>.<BR>
<BR>
<TT>Set</TT> has been made predicative from version 8.0 of <FONT COLOR=navy>Coq</FONT>. The main
reason is to interact smoothly with a classical mathematical world
where both excluded-middle and the axiom of description are valid (see
file <A HREF="http://coq.inria.fr/library/Coq.Logic.ClassicalDescription.html
"><TT>ClassicalDescription.v</TT></A> for a
proof that excluded-middle and description implies the double negation
of excluded-middle in <TT>Set</TT> and file <TT>Hurkens_Set.v</TT> from the
user contribution <TT>Rocq/PARADOXES</TT> for a proof that
impredicativity of <TT>Set</TT> implies the simple negation of
excluded-middle in <TT>Set</TT>).<BR>
<BR>
<!--TOC subsubsection Is <TT>Type</TT> impredicative?-->

<H4><A NAME="htoc45">38</A>&nbsp;&nbsp;Is <TT>Type</TT> impredicative?</H4><!--SEC END -->

No, <TT>Type</TT> is stratified. This is hidden for the
user, but <FONT COLOR=navy>Coq</FONT> internally maintains a set of constraints ensuring
stratification.<BR>
<BR>
If <TT>Type</TT> were impredicative then it would be possible to encode
Girard's systems <I>U</I>- and <I>U</I> in <FONT COLOR=navy>Coq</FONT> and it is known from Girard,
Coquand, Hurkens and Miquel that systems <I>U</I>- and <I>U</I> are inconsistent
[Girard 1972, Coquand 1991, Hurkens 1993, Miquel 2001]. This encoding
can be found in file <TT>Logic/Hurkens.v</TT> of <FONT COLOR=navy>Coq</FONT> standard library.<BR>
<BR>
For instance, when the user see <TT>for all X:Type, X-&gt;X : Type</TT>, each
occurrence of <TT>Type</TT> is implicitly bound to a different level, say
alpha and beta and the actual statement is <TT>forall X:Type(alpha), X-&gt;X : Type(beta)</TT> with the constraint
alpha&lt;beta.<BR>
<BR>
When a statement violates a constraint, the message <TT>Universe
inconsistency</TT> appears. Example: <TT>fun (x:Type) (y:for all X:Type, X
-&gt; X) =&gt; y x x</TT>.<BR>
<BR>
<!--TOC subsubsection I have two proofs of the same proposition. Can I prove they are equal?-->

<H4><A NAME="htoc46">39</A>&nbsp;&nbsp;I have two proofs of the same proposition. Can I prove they are equal?</H4><!--SEC END -->

In the base <FONT COLOR=navy>Coq</FONT> system, the answer is generally no. However, if
classical logic is set, the answer is yes for propositions in <TT>Prop</TT>.
The answer is also yes if proof irrelevance holds (see question
<A HREF="#proof-irrelevance">34</A>).<BR>
<BR>
There are also ``simple enough'' propositions for which you can prove
the equality without requiring any extra axioms. This is typically
the case for propositions defined deterministically as a first-order
inductive predicate on decidable sets. See for instance in question
<A HREF="#le-uniqueness">136</A> an axiom-free proof of the unicity of the proofs of
the proposition <TT>le m n</TT> (less or equal on <TT>nat</TT>).<BR>
<BR>
<!--TOC subsubsection I have two proofs of an equality statement. Can I prove they are 
equal?-->

<H4><A NAME="htoc47">40</A>&nbsp;&nbsp;I have two proofs of an equality statement. Can I prove they are 
equal?</H4><!--SEC END -->

Yes, if equality is decidable on the domain considered (which
is the case for <TT>nat</TT>, <TT>bool</TT>, etc): see <FONT COLOR=navy>Coq</FONT> file
<CODE>Eqdep_dec.v</CODE>). No otherwise, unless
assuming Streicher's axiom <I>K</I> (see [<A HREF="#HofStr98"><CITE>12</CITE></A>]) or a more general
assumption such as proof-irrelevance (see <A HREF="#proof-irrelevance">34</A>) or
classical logic.<BR>
<BR>
All of these statements can be found in file <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep.html
"><TT>Eqdep.v</TT></A>.<BR>
<BR>
<!--TOC subsubsection Can I prove that the second components of equal dependent
pairs are equal?-->

<H4><A NAME="htoc48">41</A>&nbsp;&nbsp;Can I prove that the second components of equal dependent
pairs are equal?</H4><!--SEC END -->

The answer is the same as for proofs of equality
statements. It is provable if equality on the domain of the first
component is decidable (look at <CODE>inj_right_pair</CODE> from file
<A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep_dec.html
"><TT>Eqdep_dec.v</TT></A>), but not provable in the general
case. However, it is consistent (with the Calculus of Constructions)
to assume it is true. The file <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep.html
"><TT>Eqdep.v</TT></A> actually
provides an axiom (equivalent to Streicher's axiom <I>K</I>) which entails
the result (look at <CODE>inj_pair2</CODE> in <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep.html
"><TT>Eqdep.v</TT></A>).<BR>
<BR>
<!--TOC subsection Impredicativity-->

<H3><A NAME="htoc49">5.3</A>&nbsp;&nbsp;Impredicativity</H3><!--SEC END -->

<!--TOC subsubsection Why <TT>injection</TT> does not work on impredicative <TT>Set</TT>?-->

<H4><A NAME="htoc50">42</A>&nbsp;&nbsp;Why <TT>injection</TT> does not work on impredicative <TT>Set</TT>?</H4><!--SEC END -->

E.g. in this case (this occurs only in the <TT>Set</TT>-impredicative
 variant of <FONT COLOR=navy>Coq</FONT>):<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;I&nbsp;:&nbsp;Type&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;intro&nbsp;:&nbsp;forall&nbsp;k:Set,&nbsp;k&nbsp;-&gt;&nbsp;I.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;eq_jdef&nbsp;:&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y:nat,&nbsp;intro&nbsp;_&nbsp;x&nbsp;=&nbsp;intro&nbsp;_&nbsp;y&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;y.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;x&nbsp;y&nbsp;H;&nbsp;injection&nbsp;H.</TT><BR>
</DIV>
<BR>
Injectivity of constructors is restricted to predicative types. If
injectivity on large inductive types were not restricted, we would be
allowed to derive an inconsistency (e.g. following the lines of
Burali-Forti paradox). The question remains open whether injectivity
is consistent on some large inductive types not expressive enough to
encode known paradoxes (such as type I above).<BR>
<BR>
<!--TOC subsubsection What is a "large inductive definition"?-->

<H4><A NAME="htoc51">43</A>&nbsp;&nbsp;What is a "large inductive definition"?</H4><!--SEC END -->

An inductive definition in <TT>Prop</TT> pr <TT>Set</TT> is called large
if its constructors embed sets or propositions. As an example, here is
a large inductive type:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;sigST&nbsp;(P:Set&nbsp;-&gt;&nbsp;Set)&nbsp;:&nbsp;Type&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;existST&nbsp;:&nbsp;forall&nbsp;X:Set,&nbsp;P&nbsp;X&nbsp;-&gt;&nbsp;sigST&nbsp;P.</TT><BR>
</DIV>
<BR>
In the <TT>Set</TT> impredicative variant of <FONT COLOR=navy>Coq</FONT>, large inductive
definitions in <TT>Set</TT> have restricted elimination schemes to
prevent inconsistencies. Especially, projecting the set or the
proposition content of a large inductive definition is forbidden. If
it were allowed, it would be possible to encode e.g. Burali-Forti
paradox [<A HREF="#Gir70"><CITE>9</CITE></A><CITE>, </CITE><A HREF="#Coq85"><CITE>4</CITE></A>].<BR>
<BR>
<!--TOC section Talkin' with the Rooster-->

<H2><A NAME="htoc52">6</A>&nbsp;&nbsp;Talkin' with the Rooster</H2><!--SEC END -->

<!--TOC subsection My goal is ..., how can I prove it?-->

<H3><A NAME="htoc53">6.1</A>&nbsp;&nbsp;My goal is ..., how can I prove it?</H3><!--SEC END -->

<!--TOC subsubsection My goal is a conjunction, how can I prove it?-->

<H4><A NAME="htoc54">44</A>&nbsp;&nbsp;My goal is a conjunction, how can I prove it?</H4><!--SEC END -->

Use some theorem or assumption or use the <TT>split</TT> tactic.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B:Prop,&nbsp;A-&gt;B-&gt;&nbsp;A/\B.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;split.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>split.</I></TT><BR>
<TT><I>&nbsp;assumption.</I></TT><BR>
<TT><I>&nbsp;assumption.</I></TT><BR>
<TT><I>Unnamed_thm&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal contains a conjunction as an hypothesis, how can I use it?-->

<H4><A NAME="htoc55">45</A>&nbsp;&nbsp;My goal contains a conjunction as an hypothesis, how can I use it?</H4><!--SEC END -->

If you want to decompose your hypothesis into other hypothesis you can use the <TT>decompose</TT> tactic:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B:Prop,&nbsp;A/\B-&gt;&nbsp;B.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;/\&nbsp;B&nbsp;-&gt;&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;decompose&nbsp;[and]&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>decompose&nbsp;[and]&nbsp;H.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm0&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is a disjunction, how can I prove it?-->

<H4><A NAME="htoc56">46</A>&nbsp;&nbsp;My goal is a disjunction, how can I prove it?</H4><!--SEC END -->

You can prove the left part or the right part of the disjunction using
<TT>left</TT> or <TT>right</TT> tactics. If you want to do a classical
reasoning step, use the <TT>classic</TT> axiom to prove the right part with the assumption
that the left part of the disjunction is false.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B:Prop,&nbsp;A-&gt;&nbsp;A\/B.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;left.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>left.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm1&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
An example using classical reasoning:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Classical.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Ltac&nbsp;classical_right&nbsp;:=&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;match&nbsp;goal&nbsp;with&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;|&nbsp;_:_&nbsp;|-?X1&nbsp;\/&nbsp;_&nbsp;=&gt;&nbsp;(elim&nbsp;(classic&nbsp;X1);intro;[left;trivial|right])</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;end.</TT><BR>
<TT><I>classical_right&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Ltac&nbsp;classical_left&nbsp;:=&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;match&nbsp;goal&nbsp;with&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;|&nbsp;_:_&nbsp;|-&nbsp;_&nbsp;\/?X1&nbsp;=&gt;&nbsp;(elim&nbsp;(classic&nbsp;X1);intro;[right;trivial|left])</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;end.</TT><BR>
<TT><I>classical_left&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B:Prop,&nbsp;(~A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A\/B.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;(~&nbsp;A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;~&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;classical_right.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;~&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;~&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>classical_right.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>Unnamed_thm2&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is an universally quantified statement, how can I prove it?-->

<H4><A NAME="htoc57">47</A>&nbsp;&nbsp;My goal is an universally quantified statement, how can I prove it?</H4><!--SEC END -->

Use some theorem or assumption or introduce the quantified variable in
the context using the <TT>intro</TT> tactic. If there are several
variables you can use the <TT>intros</TT> tactic. A good habit is to
provide names for these variables: <FONT COLOR=navy>Coq</FONT> will do it anyway, but such
automatic naming decreases legibility and robustness.<BR>
<BR>
<!--TOC subsubsection My goal is an existential, how can I prove it?-->

<H4><A NAME="htoc58">48</A>&nbsp;&nbsp;My goal is an existential, how can I prove it?</H4><!--SEC END -->

Use some theorem or assumption or exhibit the witness using the <TT>exists</TT> tactic.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;exists&nbsp;x:nat,&nbsp;forall&nbsp;y,&nbsp;x+y=y.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;exists&nbsp;x&nbsp;:&nbsp;nat,&nbsp;(forall&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x&nbsp;+&nbsp;y&nbsp;=&nbsp;y)</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;exists&nbsp;0.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;y&nbsp;:&nbsp;nat,&nbsp;0&nbsp;+&nbsp;y&nbsp;=&nbsp;y</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;0&nbsp;+&nbsp;y&nbsp;=&nbsp;y</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>exists&nbsp;0.</I></TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>Unnamed_thm3&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is solvable by some lemma, how can I prove it?-->

<H4><A NAME="htoc59">49</A>&nbsp;&nbsp;My goal is solvable by some lemma, how can I prove it?</H4><!--SEC END -->

Just use the <TT>apply</TT> tactic.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;mylemma&nbsp;:&nbsp;forall&nbsp;x,&nbsp;x+0&nbsp;=&nbsp;x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;:&nbsp;nat,&nbsp;x&nbsp;+&nbsp;0&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>mylemma&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;3+0&nbsp;=&nbsp;3.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;3&nbsp;+&nbsp;0&nbsp;=&nbsp;3</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;mylemma.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>apply&nbsp;mylemma.</I></TT><BR>
<TT><I>Unnamed_thm&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal contains False as an hypotheses, how can I prove it?-->

<H4><A NAME="htoc60">50</A>&nbsp;&nbsp;My goal contains False as an hypotheses, how can I prove it?</H4><!--SEC END -->

You can use the <TT>contradiction</TT> or <TT>intuition</TT> tactics.<BR>
<BR>
<!--TOC subsubsection My goal is an equality of two convertible terms, how can I prove it?-->

<H4><A NAME="htoc61">51</A>&nbsp;&nbsp;My goal is an equality of two convertible terms, how can I prove it?</H4><!--SEC END -->

Just use the <TT>reflexivity</TT> tactic.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x,&nbsp;0+x&nbsp;=&nbsp;x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;:&nbsp;nat,&nbsp;0&nbsp;+&nbsp;x&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;0&nbsp;+&nbsp;x&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;reflexivity.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>reflexivity.</I></TT><BR>
<TT><I>Unnamed_thm0&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is a <TT>let x := a in ...</TT>, how can I prove it?-->

<H4><A NAME="htoc62">52</A>&nbsp;&nbsp;My goal is a <TT>let x := a in ...</TT>, how can I prove it?</H4><!--SEC END -->

Just use the <TT>intro</TT> tactic.<BR>
<BR>
<!--TOC subsubsection My goal is a <TT>let (a, ..., b) := c in</TT>, how can I prove it?-->

<H4><A NAME="htoc63">53</A>&nbsp;&nbsp;My goal is a <TT>let (a, ..., b) := c in</TT>, how can I prove it?</H4><!--SEC END -->

Just use the <TT>destruct</TT> c as (a,...,b) tactic.<BR>
<BR>
<!--TOC subsubsection My goal contains some existential hypotheses, how can I use it?-->

<H4><A NAME="htoc64">54</A>&nbsp;&nbsp;My goal contains some existential hypotheses, how can I use it?</H4><!--SEC END -->

You can use the tactic <TT>elim</TT> with you hypotheses as an argument.<BR>
<BR>
<!--TOC subsubsection My goal contains some existential hypotheses, how can I use it and decompose my knowledge about this new thing into different hypotheses?-->

<H4><A NAME="htoc65">55</A>&nbsp;&nbsp;My goal contains some existential hypotheses, how can I use it and decompose my knowledge about this new thing into different hypotheses?</H4><!--SEC END -->

<PRE>
Ltac DecompEx H P := elim H;intro P;intro TO;decompose [and] TO;clear TO;clear H.
</PRE>
<!--TOC subsubsection My goal is an equality, how can I swap the left and right hand terms?-->

<H4><A NAME="htoc66">56</A>&nbsp;&nbsp;My goal is an equality, how can I swap the left and right hand terms?</H4><!--SEC END -->

Just use the <TT>symmetry</TT> tactic.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;y=x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;symmetry.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>symmetry&nbsp;&nbsp;in&nbsp;|-&nbsp;*.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm1&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My hypothesis is an equality, how can I swap the left and right hand terms?-->

<H4><A NAME="htoc67">57</A>&nbsp;&nbsp;My hypothesis is an equality, how can I swap the left and right hand terms?</H4><!--SEC END -->

Just use the <TT>symmetryin</TT> tactic.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;y=x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;symmetry&nbsp;in&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>symmetry&nbsp;&nbsp;in&nbsp;H.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm2&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is an equality, how can I prove it by transitivity?-->

<H4><A NAME="htoc68">58</A>&nbsp;&nbsp;My goal is an equality, how can I prove it by transitivity?</H4><!--SEC END -->

Just use the <TT>transitivity</TT> tactic.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;y=z&nbsp;-&gt;&nbsp;x=z.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;transitivity&nbsp;y.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>transitivity&nbsp;y.</I></TT><BR>
<TT><I>&nbsp;assumption.</I></TT><BR>
<TT><I>&nbsp;assumption.</I></TT><BR>
<TT><I>Unnamed_thm3&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal would be solvable using <TT>apply;assumption</TT> if it would not create meta-variables, how can I prove it?-->

<H4><A NAME="htoc69">59</A>&nbsp;&nbsp;My goal would be solvable using <TT>apply;assumption</TT> if it would not create meta-variables, how can I prove it?</H4><!--SEC END -->

You can use <TT>eapply yourtheorem;eauto</TT> but it won't work in all cases ! (for example if more than one hypothesis match one of the subgoals generated by <TT>eapply</TT>) so you should rather use <TT>try solve [eapply yourtheorem;eauto]</TT>, otherwise some metavariables may be incorrectly instantiated.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;trans&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;y=z&nbsp;-&gt;&nbsp;x=z.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;transitivity&nbsp;y;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>transitivity&nbsp;y;&nbsp;assumption.</I></TT><BR>
<TT><I>trans&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;y=z&nbsp;-&gt;&nbsp;x=z.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;eapply&nbsp;trans;eauto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>eapply&nbsp;trans;&nbsp;eauto.</I></TT><BR>
<TT><I>Unnamed_thm4&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;t&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;x=t&nbsp;-&gt;&nbsp;y=z&nbsp;-&gt;&nbsp;x=z.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;t&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;t&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;eapply&nbsp;trans;eauto.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Undo.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;eapply&nbsp;trans.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;?47</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;?47&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>eapply&nbsp;trans.</I></TT><BR>
<TT><I>&nbsp;apply&nbsp;H.</I></TT><BR>
<TT><I>&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;auto.</I></TT><BR>
<TT><I>Unnamed_thm5&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;t&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;x=t&nbsp;-&gt;&nbsp;y=z&nbsp;-&gt;&nbsp;x=z.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;t&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;t&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;eapply&nbsp;trans;eauto.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Undo.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;try&nbsp;solve&nbsp;[eapply&nbsp;trans;eauto].</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;eapply&nbsp;trans.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;?54</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;?54&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>try&nbsp;solve&nbsp;[&nbsp;eapply&nbsp;trans;&nbsp;eauto&nbsp;].</I></TT><BR>
<TT><I>eapply&nbsp;trans.</I></TT><BR>
<TT><I>&nbsp;apply&nbsp;H.</I></TT><BR>
<TT><I>&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;auto.</I></TT><BR>
<TT><I>Unnamed_thm6&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is solvable by some lemma within a set of lemmas and I don't want to remember which one, how can I prove it?-->

<H4><A NAME="htoc70">60</A>&nbsp;&nbsp;My goal is solvable by some lemma within a set of lemmas and I don't want to remember which one, how can I prove it?</H4><!--SEC END -->

You can use a what is called a hints' base.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;ZArith.</TT><BR>
<TT><I>Coq&nbsp;&lt;&nbsp;</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Ring.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Local&nbsp;Scope&nbsp;Z_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;toto1&nbsp;:&nbsp;1+1&nbsp;=&nbsp;2.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;1&nbsp;+&nbsp;1&nbsp;=&nbsp;2</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;ring.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>ring.</I></TT><BR>
<TT><I>toto1&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;toto2&nbsp;:&nbsp;2+2&nbsp;=&nbsp;4.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;2&nbsp;+&nbsp;2&nbsp;=&nbsp;4</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;ring.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>ring.</I></TT><BR>
<TT><I>toto2&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;toto3&nbsp;:&nbsp;2+1&nbsp;=&nbsp;3.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;2&nbsp;+&nbsp;1&nbsp;=&nbsp;3</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;ring.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>ring.</I></TT><BR>
<TT><I>toto3&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hint&nbsp;Resolve&nbsp;toto1&nbsp;toto2&nbsp;toto3&nbsp;:&nbsp;mybase.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;2+(1+1)=4.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;2&nbsp;+&nbsp;(1&nbsp;+&nbsp;1)&nbsp;=&nbsp;4</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto&nbsp;with&nbsp;mybase.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>auto&nbsp;with&nbsp;mybase.</I></TT><BR>
<TT><I>Unnamed_thm7&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is one of the hypotheses, how can I prove it?-->

<H4><A NAME="htoc71">61</A>&nbsp;&nbsp;My goal is one of the hypotheses, how can I prove it?</H4><!--SEC END -->

Use the <TT>assumption</TT> tactic.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;1=1&nbsp;-&gt;&nbsp;1=1.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;1&nbsp;-&gt;&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intro.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intro.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm8&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal appears twice in the hypotheses and I want to choose which one is used, how can I do it?-->

<H4><A NAME="htoc72">62</A>&nbsp;&nbsp;My goal appears twice in the hypotheses and I want to choose which one is used, how can I do it?</H4><!--SEC END -->

Use the <TT>exact</TT> tactic.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;1=1&nbsp;-&gt;&nbsp;1=1&nbsp;-&gt;&nbsp;1=1.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;1&nbsp;-&gt;&nbsp;1&nbsp;=&nbsp;1&nbsp;-&gt;&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;exact&nbsp;H0.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>exact&nbsp;H0.</I></TT><BR>
<TT><I>Unnamed_thm9&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection What can be the difference between applying one hypothesis or another in the context of the last question?-->

<H4><A NAME="htoc73">63</A>&nbsp;&nbsp;What can be the difference between applying one hypothesis or another in the context of the last question?</H4><!--SEC END -->

From a proof point of view it is equivalent but if you want to extract
a program from your proof, the two hypotheses can lead to different
programs.<BR>
<BR>
<!--TOC subsubsection My goal is a propositional tautology, how can I prove it?-->

<H4><A NAME="htoc74">64</A>&nbsp;&nbsp;My goal is a propositional tautology, how can I prove it?</H4><!--SEC END -->

Just use the <TT>tauto</TT> tactic.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B:Prop,&nbsp;A-&gt;&nbsp;(A\/B)&nbsp;/\&nbsp;A.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;(A&nbsp;\/&nbsp;B)&nbsp;/\&nbsp;A</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(A&nbsp;\/&nbsp;B)&nbsp;/\&nbsp;A</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;tauto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>tauto.</I></TT><BR>
<TT><I>Unnamed_thm10&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is a first order formula, how can I prove it?-->

<H4><A NAME="htoc75">65</A>&nbsp;&nbsp;My goal is a first order formula, how can I prove it?</H4><!--SEC END -->

Just use the semi-decision tactic: <TT>firstorder</TT>.<BR>
<BR>
<!--TOC subsubsection My goal is solvable by a sequence of rewrites, how can I prove it?-->

<H4><A NAME="htoc76">66</A>&nbsp;&nbsp;My goal is solvable by a sequence of rewrites, how can I prove it?</H4><!--SEC END -->

Just use the <TT>congruence</TT> tactic.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;b&nbsp;c&nbsp;d&nbsp;e,&nbsp;a=d&nbsp;-&gt;&nbsp;b=e&nbsp;-&gt;&nbsp;c+b=d&nbsp;-&gt;&nbsp;c+e=a.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;b&nbsp;c&nbsp;d&nbsp;e&nbsp;:&nbsp;Z,&nbsp;a&nbsp;=&nbsp;d&nbsp;-&gt;&nbsp;b&nbsp;=&nbsp;e&nbsp;-&gt;&nbsp;c&nbsp;+&nbsp;b&nbsp;=&nbsp;d&nbsp;-&gt;&nbsp;c&nbsp;+&nbsp;e&nbsp;=&nbsp;a</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;c&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;e&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;a&nbsp;=&nbsp;d</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;b&nbsp;=&nbsp;e</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;c&nbsp;+&nbsp;b&nbsp;=&nbsp;d</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;c&nbsp;+&nbsp;e&nbsp;=&nbsp;a</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;congruence.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>congruence.</I></TT><BR>
<TT><I>Unnamed_thm11&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is a disequality solvable by a sequence of rewrites, how can I prove it?-->

<H4><A NAME="htoc77">67</A>&nbsp;&nbsp;My goal is a disequality solvable by a sequence of rewrites, how can I prove it?</H4><!--SEC END -->

Just use the <TT>congruence</TT> tactic.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;b&nbsp;c&nbsp;d,&nbsp;a&lt;&gt;d&nbsp;-&gt;&nbsp;b=a&nbsp;-&gt;&nbsp;d=c+b&nbsp;-&gt;&nbsp;b&lt;&gt;c+b.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;b&nbsp;c&nbsp;d&nbsp;:&nbsp;Z,&nbsp;a&nbsp;&lt;&gt;&nbsp;d&nbsp;-&gt;&nbsp;b&nbsp;=&nbsp;a&nbsp;-&gt;&nbsp;d&nbsp;=&nbsp;c&nbsp;+&nbsp;b&nbsp;-&gt;&nbsp;b&nbsp;&lt;&gt;&nbsp;c&nbsp;+&nbsp;b</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;c&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;a&nbsp;&lt;&gt;&nbsp;d</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;b&nbsp;=&nbsp;a</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;d&nbsp;=&nbsp;c&nbsp;+&nbsp;b</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;b&nbsp;&lt;&gt;&nbsp;c&nbsp;+&nbsp;b</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;congruence.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>congruence.</I></TT><BR>
<TT><I>Unnamed_thm12&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is an equality on some ring (e.g. natural numbers), how can I prove it?-->

<H4><A NAME="htoc78">68</A>&nbsp;&nbsp;My goal is an equality on some ring (e.g. natural numbers), how can I prove it?</H4><!--SEC END -->

Just use the <TT>ring</TT> tactic.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;ZArith.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Ring.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Local&nbsp;Scope&nbsp;Z_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;b&nbsp;:&nbsp;Z,&nbsp;(a+b)*(a+b)&nbsp;=&nbsp;a*a&nbsp;+&nbsp;2*a*b&nbsp;+&nbsp;b*b.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;b&nbsp;:&nbsp;Z,&nbsp;(a&nbsp;+&nbsp;b)&nbsp;*&nbsp;(a&nbsp;+&nbsp;b)&nbsp;=&nbsp;a&nbsp;*&nbsp;a&nbsp;+&nbsp;2&nbsp;*&nbsp;a&nbsp;*&nbsp;b&nbsp;+&nbsp;b&nbsp;*&nbsp;b</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(a&nbsp;+&nbsp;b)&nbsp;*&nbsp;(a&nbsp;+&nbsp;b)&nbsp;=&nbsp;a&nbsp;*&nbsp;a&nbsp;+&nbsp;2&nbsp;*&nbsp;a&nbsp;*&nbsp;b&nbsp;+&nbsp;b&nbsp;*&nbsp;b</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;ring.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>ring.</I></TT><BR>
<TT><I>Unnamed_thm13&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is an equality on some field (e.g. real numbers), how can I prove it?-->

<H4><A NAME="htoc79">69</A>&nbsp;&nbsp;My goal is an equality on some field (e.g. real numbers), how can I prove it?</H4><!--SEC END -->

Just use the <TT>field</TT> tactic.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Reals.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Ring.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Local&nbsp;Scope&nbsp;R_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;b&nbsp;:&nbsp;R,&nbsp;b*a&lt;&gt;0&nbsp;-&gt;&nbsp;(a/b)&nbsp;*&nbsp;(b/a)&nbsp;=&nbsp;1.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;b&nbsp;:&nbsp;R,&nbsp;b&nbsp;*&nbsp;a&nbsp;&lt;&gt;&nbsp;0&nbsp;-&gt;&nbsp;a&nbsp;/&nbsp;b&nbsp;*&nbsp;(b&nbsp;/&nbsp;a)&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;b&nbsp;*&nbsp;a&nbsp;&lt;&gt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;a&nbsp;/&nbsp;b&nbsp;*&nbsp;(b&nbsp;/&nbsp;a)&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;field.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;b&nbsp;*&nbsp;a&nbsp;&lt;&gt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;b&nbsp;*&nbsp;a&nbsp;&lt;&gt;&nbsp;0</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>field.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm14&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is an inequality on integers in Presburger's arithmetic (an expression build from +,-,constants and variables), how can I prove it?-->

<H4><A NAME="htoc80">70</A>&nbsp;&nbsp;My goal is an inequality on integers in Presburger's arithmetic (an expression build from +,-,constants and variables), how can I prove it?</H4><!--SEC END -->


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;ZArith.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Omega.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Local&nbsp;Scope&nbsp;Z_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;:&nbsp;Z,&nbsp;a&gt;0&nbsp;-&gt;&nbsp;a+a&nbsp;&gt;&nbsp;a.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;:&nbsp;Z,&nbsp;a&nbsp;&gt;&nbsp;0&nbsp;-&gt;&nbsp;a&nbsp;+&nbsp;a&nbsp;&gt;&nbsp;a</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;a&nbsp;+&nbsp;a&nbsp;&gt;&nbsp;a</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;omega.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>omega.</I></TT><BR>
<TT><I>Unnamed_thm15&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection My goal is an equation solvable using equational hypothesis on some ring (e.g. natural numbers), how can I prove it?-->

<H4><A NAME="htoc81">71</A>&nbsp;&nbsp;My goal is an equation solvable using equational hypothesis on some ring (e.g. natural numbers), how can I prove it?</H4><!--SEC END -->

You need the <TT>gb</TT> tactic (see Loïc Pottier's homepage).<BR>
<BR>
<!--TOC subsection Tactics usage-->

<H3><A NAME="htoc82">6.2</A>&nbsp;&nbsp;Tactics usage</H3><!--SEC END -->

<!--TOC subsubsection I want to state a fact that I will use later as an hypothesis, how can I do it?-->

<H4><A NAME="htoc83">72</A>&nbsp;&nbsp;I want to state a fact that I will use later as an hypothesis, how can I do it?</H4><!--SEC END -->

If you want to use forward reasoning (first proving the fact and then
using it) you just need to use the <TT>assert</TT> tactic. If you want to use
backward reasoning (proving your goal using an assumption and then
proving the assumption) use the <TT>cut</TT> tactic.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;D&nbsp;:&nbsp;Prop,&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;(B-&gt;C)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;Prop&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;(B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assert&nbsp;(A-&gt;C).</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intro;apply&nbsp;H0;apply&nbsp;H;assumption.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H2&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H2.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H2&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>assert&nbsp;(A&nbsp;-&gt;&nbsp;C).</I></TT><BR>
<TT><I>&nbsp;intro;&nbsp;apply&nbsp;H0;&nbsp;apply&nbsp;H;&nbsp;assumption.</I></TT><BR>
<TT><I>&nbsp;apply&nbsp;H2.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;assumption.</I></TT><BR>
<TT><I>Unnamed_thm16&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;D&nbsp;:&nbsp;Prop,&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;(B-&gt;C)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;Prop&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;(B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;cut&nbsp;(A-&gt;C).</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(A&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intro.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H2&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H2;assumption.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intro;apply&nbsp;H0;apply&nbsp;H;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>cut&nbsp;(A&nbsp;-&gt;&nbsp;C).</I></TT><BR>
<TT><I>&nbsp;intro.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;apply&nbsp;H2;&nbsp;assumption.</I></TT><BR>
<TT><I>&nbsp;intro;&nbsp;apply&nbsp;H0;&nbsp;apply&nbsp;H;&nbsp;assumption.</I></TT><BR>
<TT><I>Unnamed_thm17&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection I want to state a fact that I will use later as an hypothesis and prove it later, how can I do it?-->

<H4><A NAME="htoc84">73</A>&nbsp;&nbsp;I want to state a fact that I will use later as an hypothesis and prove it later, how can I do it?</H4><!--SEC END -->

You can use <TT>cut</TT> followed by <TT>intro</TT> or you can use the following <FONT COLOR=navy>Ltac</FONT> command:
<PRE>
Ltac assert_later t := cut t;[intro|idtac]. 
</PRE>
<!--TOC subsubsection What is the difference between <TT>Qed</TT> and <TT>Defined</TT>?-->

<H4><A NAME="htoc85">74</A>&nbsp;&nbsp;What is the difference between <TT>Qed</TT> and <TT>Defined</TT>?</H4><!--SEC END -->

These two commands perform type checking, but when <TT>Defined</TT> is used the new definition is set as transparent, otherwise it is defined as opaque (see <A HREF="#opaque">167</A>).<BR>
<BR>
<!--TOC subsubsection How can I know what a tactic does?-->

<H4><A NAME="htoc86">75</A>&nbsp;&nbsp;How can I know what a tactic does?</H4><!--SEC END -->

You can use the <TT>info</TT> command.<BR>
<BR>
<!--TOC subsubsection Why <TT>auto</TT> does not work? How can I fix it?-->

<H4><A NAME="htoc87">76</A>&nbsp;&nbsp;Why <TT>auto</TT> does not work? How can I fix it?</H4><!--SEC END -->

You can increase the depth of the proof search or add some lemmas in the base of hints.
Perhaps you may need to use <TT>eauto</TT>.<BR>
<BR>
<!--TOC subsubsection What is <TT>eauto</TT>?-->

<H4><A NAME="htoc88">77</A>&nbsp;&nbsp;What is <TT>eauto</TT>?</H4><!--SEC END -->

This is the same tactic as <TT>auto</TT>, but it relies on <TT>eapply</TT> instead of <TT>apply</TT>.<BR>
<BR>
<!--TOC subsubsection How can I speed up <TT>auto</TT>?-->

<H4><A NAME="htoc89">78</A>&nbsp;&nbsp;How can I speed up <TT>auto</TT>?</H4><!--SEC END -->

You can use <TT>info </TT><TT>auto</TT>to replace <TT>auto</TT> by the tactics it generates.
You can split your hint bases into smaller ones.<BR>
<BR>
<!--TOC subsubsection What is the equivalent of <TT>tauto</TT> for classical logic?-->

<H4><A NAME="htoc90">79</A>&nbsp;&nbsp;What is the equivalent of <TT>tauto</TT> for classical logic?</H4><!--SEC END -->

Currently there are no equivalent tactic for classical logic. You can use Gödel's ``not not'' translation.<BR>
<BR>
<!--TOC subsubsection I want to replace some term with another in the goal, how can I do it?-->

<H4><A NAME="htoc91">80</A>&nbsp;&nbsp;I want to replace some term with another in the goal, how can I do it?</H4><!--SEC END -->

If one of your hypothesis (say <TT>H</TT>) states that the terms are equal you can use the <TT>rewrite</TT> tactic. Otherwise you can use the <TT>replace</TT> <TT>with</TT> tactic. <BR>
<BR>
<!--TOC subsubsection I want to replace some term with another in an hypothesis, how can I do it?-->

<H4><A NAME="htoc92">81</A>&nbsp;&nbsp;I want to replace some term with another in an hypothesis, how can I do it?</H4><!--SEC END -->

You can use the <TT>rewrite</TT> <TT>in</TT> tactic.<BR>
<BR>
<!--TOC subsubsection I want to replace some symbol with its definition, how can I do it?-->

<H4><A NAME="htoc93">82</A>&nbsp;&nbsp;I want to replace some symbol with its definition, how can I do it?</H4><!--SEC END -->

You can use the <TT>unfold</TT> tactic.<BR>
<BR>
<!--TOC subsubsection How can I reduce some term?-->

<H4><A NAME="htoc94">83</A>&nbsp;&nbsp;How can I reduce some term?</H4><!--SEC END -->

You can use the <TT>simpl</TT> tactic.<BR>
<BR>
<!--TOC subsubsection How can I declare a shortcut for some term?-->

<H4><A NAME="htoc95">84</A>&nbsp;&nbsp;How can I declare a shortcut for some term?</H4><!--SEC END -->

You can use the <TT>set</TT> or <TT>pose</TT> tactics.<BR>
<BR>
<!--TOC subsubsection How can I perform case analysis?-->

<H4><A NAME="htoc96">85</A>&nbsp;&nbsp;How can I perform case analysis?</H4><!--SEC END -->

You can use the <TT>case</TT> or <TT>destruct</TT> tactics.<BR>
<BR>
<!--TOC subsubsection Why should I name my intros?-->

<H4><A NAME="htoc97">86</A>&nbsp;&nbsp;Why should I name my intros?</H4><!--SEC END -->

When you use the <TT>intro</TT> tactic you don't have to give a name to your
hypothesis. If you do so the name will be generated by <FONT COLOR=navy>Coq</FONT> but your
scripts may be less robust. If you add some hypothesis to your theorem
(or change their order), you will have to change your proof to adapt
to the new names.<BR>
<BR>
<!--TOC subsubsection How can I automatize the naming?-->

<H4><A NAME="htoc98">87</A>&nbsp;&nbsp;How can I automatize the naming?</H4><!--SEC END -->

You can use the <TT>Show Intro.</TT> or <TT>Show Intros.</TT> commands to generate the names and use your editor to generate a fully named <TT>intro</TT> tactic. 
This can be automatized within <TT>xemacs</TT>.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C&nbsp;-&gt;&nbsp;A/\B/\C.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B&nbsp;/\&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Show&nbsp;Intros.</TT><BR>
<TT><I>A&nbsp;B&nbsp;C&nbsp;H&nbsp;H0</I></TT><BR>
<TT><I>H1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;(*</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;A&nbsp;B&nbsp;C&nbsp;H&nbsp;H0</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;H1</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;*)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;A&nbsp;B&nbsp;C&nbsp;H&nbsp;H0&nbsp;H1.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B&nbsp;/\&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;repeat&nbsp;split;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros&nbsp;A&nbsp;B&nbsp;C&nbsp;H&nbsp;H0&nbsp;H1.</I></TT><BR>
<TT><I>repeat&nbsp;split;&nbsp;assumption.</I></TT><BR>
<TT><I>Unnamed_thm18&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection I want to automatize the use of some tactic, how can I do it?-->

<H4><A NAME="htoc99">88</A>&nbsp;&nbsp;I want to automatize the use of some tactic, how can I do it?</H4><!--SEC END -->

You need to use the <TT>proof with T</TT> command and add ... at the
end of your sentences.<BR>
<BR>
For instance:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B/\C&nbsp;-&gt;&nbsp;A/\B/\C.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;/\&nbsp;C&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B&nbsp;/\&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof&nbsp;with&nbsp;assumption.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;/\&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B&nbsp;/\&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;split...</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>split.</I></TT><BR>
<TT><I>Unnamed_thm19&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection I want to execute the <TT>p</TT>roof with tactic only if it solves the goal, how can I do it?-->

<H4><A NAME="htoc100">89</A>&nbsp;&nbsp;I want to execute the <TT>p</TT>roof with tactic only if it solves the goal, how can I do it?</H4><!--SEC END -->

You need to use the <TT>try</TT> and <TT>solve</TT> tactics. For instance:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;ZArith.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Ring.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Local&nbsp;Scope&nbsp;Z_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;b&nbsp;c&nbsp;:&nbsp;Z,&nbsp;a+b=b+a.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;b&nbsp;:&nbsp;Z,&nbsp;Z&nbsp;-&gt;&nbsp;a&nbsp;+&nbsp;b&nbsp;=&nbsp;b&nbsp;+&nbsp;a</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof&nbsp;with&nbsp;try&nbsp;solve&nbsp;[ring].</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros...</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>Unnamed_thm20&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection How can I do the opposite of the <TT>intro</TT> tactic?-->

<H4><A NAME="htoc101">90</A>&nbsp;&nbsp;How can I do the opposite of the <TT>intro</TT> tactic?</H4><!--SEC END -->

You can use the <TT>generalize</TT> tactic.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A-&gt;B-&gt;&nbsp;A/\B.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;generalize&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intro.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>generalize&nbsp;H.</I></TT><BR>
<TT><I>intro.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>Unnamed_thm21&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection One of the hypothesis is an equality between a variable and some term, I want to get rid of this variable, how can I do it?-->

<H4><A NAME="htoc102">91</A>&nbsp;&nbsp;One of the hypothesis is an equality between a variable and some term, I want to get rid of this variable, how can I do it?</H4><!--SEC END -->

You can use the <TT>subst</TT> tactic. This will rewrite the equality everywhere and clear the assumption.<BR>
<BR>
<!--TOC subsubsection What can I do if I get ``<TT>generated subgoal term has metavariables in it </TT>''?-->

<H4><A NAME="htoc103">92</A>&nbsp;&nbsp;What can I do if I get ``<TT>generated subgoal term has metavariables in it </TT>''?</H4><!--SEC END -->

You should use the <TT>eapply</TT> tactic, this will generate some goals containing metavariables. <BR>
<BR>
<!--TOC subsubsection How can I instantiate some metavariable?-->

<H4><A NAME="htoc104">93</A>&nbsp;&nbsp;How can I instantiate some metavariable?</H4><!--SEC END -->

Just use the <TT>instantiate</TT> tactic.<BR>
<BR>
<!--TOC subsubsection What is the use of the <TT>pattern</TT> tactic?-->

<H4><A NAME="htoc105">94</A>&nbsp;&nbsp;What is the use of the <TT>pattern</TT> tactic?</H4><!--SEC END -->

The <TT>pattern</TT> tactic transforms the current goal, performing
beta-expansion on all the applications featuring this tactic's
argument. For instance, if the current goal includes a subterm <TT>phi(t)</TT>, then <TT>pattern t</TT> transforms the subterm into <TT>(fun
x:A =&gt; phi(x)) t</TT>. This can be useful when <TT>apply</TT> fails on matching,
to abstract the appropriate terms.<BR>
<BR>
<!--TOC subsubsection What is the difference between assert, cut and generalize?-->

<H4><A NAME="htoc106">95</A>&nbsp;&nbsp;What is the difference between assert, cut and generalize?</H4><!--SEC END -->

PS: Notice for people that are interested in proof rendering that <TT>assert</TT>and <TT>pose</TT> (and <TT>cut</TT>) are not rendered the same as <TT>generalize</TT> (see the
HELM experimental rendering tool at <A HREF="http://helm.cs.unibo.it/library.html"><TT>http://helm.cs.unibo.it</TT></A>, link
HELM, link COQ Online). Indeed <TT>generalize</TT> builds a beta-expanded term
while <TT>assert</TT>, <TT>pose</TT> and <TT>cut</TT> uses a let-in.
<PRE>
  (* Goal is T *)
  generalize (H1 H2).
  (* Goal is A-&gt;T *)
  ... a proof of A-&gt;T ...
</PRE>
is rendered into something like
<PRE>
  (h) ... the proof of A-&gt;T ...
      we proved A-&gt;T
  (h0) by (H1 H2) we proved A
  by (h h0) we proved T
</PRE>while 
<PRE>
  (* Goal is T *)
  assert q := (H1 H2).
  (* Goal is A *)
  ... a proof of A ...
  (* Goal is A |- T *)
  ... a proof of T ...
</PRE>is rendered into something like
<PRE>
  (q) ... the proof of A ...
      we proved A
  ... the proof of T ...
  we proved T
</PRE>Otherwise said, <TT>generalize</TT> is not rendered in a forward-reasoning way,
while <TT>assert</TT> is.<BR>
<BR>
<!--TOC subsubsection What can I do if <FONT COLOR=navy>Coq</FONT>can not infer some implicit argument ?-->

<H4><A NAME="htoc107">96</A>&nbsp;&nbsp;What can I do if <FONT COLOR=navy>Coq</FONT>can not infer some implicit argument ?</H4><!--SEC END -->

You can state explicitely what this implicit argument is. See <A HREF="#implicit">97</A>.<BR>
<BR>
<!--TOC subsubsection How can I explicit some implicit argument ?-->

<H4><A NAME="htoc108">97</A>&nbsp;&nbsp;How can I explicit some implicit argument ?</H4><!--SEC END -->
<A NAME="implicit"></A>
Just use <TT>A:=term</TT> where <TT>A</TT> is the argument.<BR>
<BR>
For instance if you want to use the existence of ``nil'' on nat*nat lists:
<PRE>
exists (nil (A:=(nat*nat))).
</PRE>
<!--TOC subsection Proof management-->

<H3><A NAME="htoc109">6.3</A>&nbsp;&nbsp;Proof management</H3><!--SEC END -->

<!--TOC subsubsection How can I change the order of the subgoals?-->

<H4><A NAME="htoc110">98</A>&nbsp;&nbsp;How can I change the order of the subgoals?</H4><!--SEC END -->

You can use the <TT>Focus</TT> command to concentrate on some goal. When the goal is proved you will see the remaining goals.<BR>
<BR>
<!--TOC subsubsection How can I change the order of the hypothesis?-->

<H4><A NAME="htoc111">99</A>&nbsp;&nbsp;How can I change the order of the hypothesis?</H4><!--SEC END -->

You can use the <TT>Move ... after</TT> command.<BR>
<BR>
<!--TOC subsubsection How can I change the name of an hypothesis?-->

<H4><A NAME="htoc112">100</A>&nbsp;&nbsp;How can I change the name of an hypothesis?</H4><!--SEC END -->

You can use the <TT>Rename ... into</TT> command.<BR>
<BR>
<!--TOC subsubsection How can I delete some hypothesis?-->

<H4><A NAME="htoc113">101</A>&nbsp;&nbsp;How can I delete some hypothesis?</H4><!--SEC END -->

You can use the <TT>Clear</TT> command.<BR>
<BR>
<!--TOC subsubsection How can use a proof which is not finished?-->

<H4><A NAME="htoc114">102</A>&nbsp;&nbsp;How can use a proof which is not finished?</H4><!--SEC END -->

You can use the <TT>Admitted</TT> command to state your current proof as an axiom.<BR>
<BR>
<!--TOC subsubsection How can I state a conjecture?-->

<H4><A NAME="htoc115">103</A>&nbsp;&nbsp;How can I state a conjecture?</H4><!--SEC END -->

You can use the <TT>Admitted</TT> command to state your current proof as an axiom.<BR>
<BR>
<!--TOC subsubsection What is the difference between a lemma, a fact and a theorem?-->

<H4><A NAME="htoc116">104</A>&nbsp;&nbsp;What is the difference between a lemma, a fact and a theorem?</H4><!--SEC END -->

From <FONT COLOR=navy>Coq</FONT> point of view there are no difference. But some tools can
have a different behavior when you use a lemma rather than a
theorem. For instance <TT>coqdoc</TT> will not generate documentation for
the lemmas within your development.<BR>
<BR>
<!--TOC subsubsection How can I organize my proofs?-->

<H4><A NAME="htoc117">105</A>&nbsp;&nbsp;How can I organize my proofs?</H4><!--SEC END -->

You can organize your proofs using the section mechanism of <FONT COLOR=navy>Coq</FONT>. Have
a look at the manual for further information.<BR>
<BR>
<!--TOC section Inductive and Co-inductive types-->

<H2><A NAME="htoc118">7</A>&nbsp;&nbsp;Inductive and Co-inductive types</H2><!--SEC END -->

<!--TOC subsection General-->

<H3><A NAME="htoc119">7.1</A>&nbsp;&nbsp;General</H3><!--SEC END -->

<!--TOC subsubsection How can I prove that two constructors are different?-->

<H4><A NAME="htoc120">106</A>&nbsp;&nbsp;How can I prove that two constructors are different?</H4><!--SEC END -->

You can use the <TT>discriminate</TT> tactic.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;toto&nbsp;:&nbsp;Set&nbsp;:=&nbsp;|&nbsp;C1&nbsp;:&nbsp;toto&nbsp;|&nbsp;C2&nbsp;:&nbsp;toto.</TT><BR>
<TT><I>toto&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>toto_rect&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>toto_ind&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>toto_rec&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;C1&nbsp;&lt;&gt;&nbsp;C2.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C1&nbsp;&lt;&gt;&nbsp;C2</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;discriminate.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>discriminate.</I></TT><BR>
<TT><I>Unnamed_thm22&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection During an inductive proof, how to get rid of impossible cases of an inductive definition?-->

<H4><A NAME="htoc121">107</A>&nbsp;&nbsp;During an inductive proof, how to get rid of impossible cases of an inductive definition?</H4><!--SEC END -->

Use the <TT>inversion</TT> tactic.<BR>
<BR>
<!--TOC subsubsection How can I prove that 2 terms in an inductive set are equal? Or different?-->

<H4><A NAME="htoc122">108</A>&nbsp;&nbsp;How can I prove that 2 terms in an inductive set are equal? Or different?</H4><!--SEC END -->

Have a look at "decide equality" and "discriminate" in the <A HREF="http://coq.inria.fr/doc/main.html">Reference Manual</A>.<BR>
<BR>
<!--TOC subsubsection Why is the proof of <TT>0+n=n</TT> on natural numbers
trivial but the proof of <TT>n+0=n</TT> is not?-->

<H4><A NAME="htoc123">109</A>&nbsp;&nbsp;Why is the proof of <TT>0+n=n</TT> on natural numbers
trivial but the proof of <TT>n+0=n</TT> is not?</H4><!--SEC END -->

Since <TT>+</TT> (<TT>plus</TT>) on natural numbers is defined by analysis on its first argument<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;plus.</TT><BR>
<TT><I>plus&nbsp;=&nbsp;</I></TT><BR>
<TT><I>(fix&nbsp;plus&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;m</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;S&nbsp;(plus&nbsp;p&nbsp;m)</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;end)</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[nat_scope&nbsp;nat_scope]</I></TT><BR>
</DIV>
<BR>
 The expression <TT>0+n</TT> evaluates to <TT>n</TT>. As <FONT COLOR=navy>Coq</FONT> reasons
modulo evaluation of expressions, <TT>0+n</TT> and <TT>n</TT> are
considered equal and the theorem <TT>0+n=n</TT> is an instance of the
reflexivity of equality. On the other side, <TT>n+0</TT> does not
evaluate to <TT>n</TT> and a proof by induction on <TT>n</TT> is
necessary to trigger the evaluation of <TT>+</TT>.<BR>
<BR>
<!--TOC subsubsection Why is dependent elimination in Prop not
available by default?-->

<H4><A NAME="htoc124">110</A>&nbsp;&nbsp;Why is dependent elimination in Prop not
available by default?</H4><!--SEC END -->

This is just because most of the time it is not needed. To derive a
dependent elimination principle in <TT>Prop</TT>, use the command <TT>Scheme</TT> and
apply the elimination scheme using the <CODE>using</CODE> option of
<CODE>elim</CODE>, <CODE>destruct</CODE> or <CODE>induction</CODE>.<BR>
<BR>
<!--TOC subsection Recursion-->

<H3><A NAME="htoc125">7.2</A>&nbsp;&nbsp;Recursion</H3><!--SEC END -->

<!--TOC subsubsection Why can't I define a non terminating program?-->

<H4><A NAME="htoc126">111</A>&nbsp;&nbsp;Why can't I define a non terminating program?</H4><!--SEC END -->

Because otherwise the decidability of the type-checking
algorithm (which involves evaluation of programs) is not ensured. On
another side, if non terminating proofs were allowed, we could get a
proof of <TT>False</TT>:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;(*&nbsp;This&nbsp;is&nbsp;fortunately&nbsp;not&nbsp;allowed!&nbsp;*)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;InfiniteProof&nbsp;(n:nat)&nbsp;:&nbsp;False&nbsp;:=&nbsp;InfiniteProof&nbsp;n.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;Paradox&nbsp;:&nbsp;False.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof&nbsp;(InfiniteProof&nbsp;O).</TT><BR>
</DIV>
<BR>
<!--TOC subsubsection Why only structurally well-founded loops are allowed?-->

<H4><A NAME="htoc127">112</A>&nbsp;&nbsp;Why only structurally well-founded loops are allowed?</H4><!--SEC END -->

The structural order on inductive types is a simple and
powerful notion of termination. The consistency of the Calculus of
Inductive Constructions relies on it and another consistency proof
would have to be made for stronger termination arguments (such
as the termination of the evaluation of CIC programs themselves!).<BR>
<BR>
In spite of this, all non-pathological termination orders can be mapped
to a structural order. Tools to do this are provided in the file 
<A HREF="http://coq.inria.fr/library/Coq.Init.Wf.html
"><TT>Wf.v</TT></A> of the standard library of <FONT COLOR=navy>Coq</FONT>.<BR>
<BR>
<!--TOC subsubsection How to define loops based on non structurally smaller
recursive calls?-->

<H4><A NAME="htoc128">113</A>&nbsp;&nbsp;How to define loops based on non structurally smaller
recursive calls?</H4><!--SEC END -->

The procedure is as follows (we consider the definition of <TT>mergesort</TT> as an example).
<UL><LI>Define the termination order, say <TT>R</TT> on the type <TT>A</TT> of
the arguments of the loop.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;R&nbsp;(a&nbsp;b:list&nbsp;nat)&nbsp;:=&nbsp;length&nbsp;a&nbsp;&lt;&nbsp;length&nbsp;b.</TT><BR>
</DIV>
<BR>
<BR>
<LI>Prove that this order is well-founded (in fact that all elements in <TT>A</TT> are accessible along <TT>R</TT>).<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Rwf&nbsp;:&nbsp;well_founded&nbsp;(A:=R).</TT><BR>
</DIV>
<BR>
<BR>
<LI>Define the step function (which needs proofs that recursive
calls are on smaller arguments).<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;split&nbsp;(l&nbsp;:&nbsp;list&nbsp;nat)&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;{l1:&nbsp;list&nbsp;nat&nbsp;|&nbsp;R&nbsp;l1&nbsp;l}&nbsp;*&nbsp;{l2&nbsp;:&nbsp;list&nbsp;nat&nbsp;|&nbsp;R&nbsp;l2&nbsp;l}</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;(*&nbsp;...&nbsp;*)&nbsp;.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;concat&nbsp;(l1&nbsp;l2&nbsp;:&nbsp;list&nbsp;nat)&nbsp;:&nbsp;list&nbsp;nat&nbsp;:=&nbsp;(*&nbsp;...&nbsp;*)&nbsp;.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;merge_step&nbsp;(l&nbsp;:&nbsp;list&nbsp;nat)&nbsp;(f:&nbsp;forall&nbsp;l':list&nbsp;nat,&nbsp;R&nbsp;l'&nbsp;l&nbsp;-&gt;&nbsp;list&nbsp;nat)&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;let&nbsp;(lH1,lH2)&nbsp;:=&nbsp;(split&nbsp;l)&nbsp;in</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;let&nbsp;(l1,H1)&nbsp;:=&nbsp;lH1&nbsp;in</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;let&nbsp;(l2,H2)&nbsp;:=&nbsp;lH2&nbsp;in</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;concat&nbsp;(f&nbsp;l1&nbsp;H1)&nbsp;(f&nbsp;l2&nbsp;H2).</TT><BR>
</DIV>
<BR>
<BR>
<LI>Define the recursive function by fixpoint on the step function.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;merge&nbsp;:=&nbsp;Fix&nbsp;Rwf&nbsp;(fun&nbsp;_&nbsp;=&gt;&nbsp;list&nbsp;nat)&nbsp;merge_step.</TT><BR>
</DIV>
</UL>
<!--TOC subsubsection What is behind the accessibility and well-foundedness proofs?-->

<H4><A NAME="htoc129">114</A>&nbsp;&nbsp;What is behind the accessibility and well-foundedness proofs?</H4><!--SEC END -->

Well-foundedness of some relation <TT>R</TT> on some type <TT>A</TT>
is defined as the accessibility of all elements of <TT>A</TT> along <TT>R</TT>.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;well_founded.</TT><BR>
<TT><I>well_founded&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fun&nbsp;(A&nbsp;:&nbsp;Set)&nbsp;(R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;Prop)&nbsp;=&gt;&nbsp;forall&nbsp;a&nbsp;:&nbsp;A,&nbsp;Acc&nbsp;R&nbsp;a</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Set,&nbsp;(A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;Prop)&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>Argument&nbsp;A&nbsp;is&nbsp;implicit</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[type_scope&nbsp;_]</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;Acc.</TT><BR>
<TT><I>Inductive&nbsp;Acc&nbsp;(A&nbsp;:&nbsp;Set)&nbsp;(R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;Prop)&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;:=</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;Acc_intro&nbsp;:&nbsp;forall&nbsp;x&nbsp;:&nbsp;A,&nbsp;(forall&nbsp;y&nbsp;:&nbsp;A,&nbsp;R&nbsp;y&nbsp;x&nbsp;-&gt;&nbsp;Acc&nbsp;R&nbsp;y)&nbsp;-&gt;&nbsp;Acc&nbsp;R&nbsp;x</I></TT><BR>
<TT><I>For&nbsp;Acc:&nbsp;Argument&nbsp;A&nbsp;is&nbsp;implicit</I></TT><BR>
<TT><I>For&nbsp;Acc_intro:&nbsp;Arguments&nbsp;A,&nbsp;R&nbsp;are&nbsp;implicit</I></TT><BR>
<TT><I>For&nbsp;Acc:&nbsp;Argument&nbsp;scopes&nbsp;are&nbsp;[type_scope&nbsp;_&nbsp;_]</I></TT><BR>
<TT><I>For&nbsp;Acc_intro:&nbsp;Argument&nbsp;scopes&nbsp;are&nbsp;[type_scope&nbsp;_&nbsp;_&nbsp;_]</I></TT><BR>
</DIV>
<BR>
The structure of the accessibility predicate is a well-founded tree
branching at each node <TT>x</TT> in <TT>A</TT> along all the nodes <TT>x'</TT>
less than <TT>x</TT> along <TT>R</TT>. Any sequence of elements of <TT>A</TT>
decreasing along the order <TT>R</TT> are branches in the accessibility
tree. Hence any decreasing along <TT>R</TT> is mapped into a structural
decreasing in the accessibility tree of <TT>R</TT>. This is emphasised in
the definition of <TT>fix</TT> which recurs not on its argument <TT>x:A</TT>
but on the accessibility of this argument along <TT>R</TT>.<BR>
<BR>
See file <A HREF="http://coq.inria.fr/library/Coq.Init.Wf.html
"><TT>Wf.v</TT></A>.<BR>
<BR>
<!--TOC subsubsection How to perform double induction?-->

<H4><A NAME="htoc130">115</A>&nbsp;&nbsp;How to perform double induction?</H4><!--SEC END -->

In general a double induction is simply solved by an induction on the
first hypothesis followed by an inversion over the second
hypothesis. Here is an example<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;even&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;even_O&nbsp;:&nbsp;even&nbsp;0</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;even_S&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;even&nbsp;n&nbsp;-&gt;&nbsp;even&nbsp;(S&nbsp;(S&nbsp;n)).</TT><BR>
<TT><I>even&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>even_ind&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;odd&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;odd_SO&nbsp;:&nbsp;odd&nbsp;1</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;odd_S&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;odd&nbsp;(S&nbsp;(S&nbsp;n)).</TT><BR>
<TT><I>odd&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>odd_ind&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;n:nat,&nbsp;even&nbsp;n&nbsp;-&gt;&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;False.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;even&nbsp;n&nbsp;-&gt;&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;False</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;1.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;odd&nbsp;0&nbsp;-&gt;&nbsp;False</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;odd&nbsp;(S&nbsp;(S&nbsp;n))&nbsp;-&gt;&nbsp;False</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;inversion&nbsp;1.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;even&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;IHeven&nbsp;:&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;False</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;odd&nbsp;(S&nbsp;(S&nbsp;n))&nbsp;-&gt;&nbsp;False</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;inversion&nbsp;1.&nbsp;apply&nbsp;IHeven;&nbsp;trivial.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;even&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;IHeven&nbsp;:&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;False</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;odd&nbsp;(S&nbsp;(S&nbsp;n))</I></TT><BR>
<TT><I>&nbsp;&nbsp;n0&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H2&nbsp;:&nbsp;odd&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;n0&nbsp;=&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;False</I></TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>induction&nbsp;1.</I></TT><BR>
<TT><I>&nbsp;inversion&nbsp;1.</I></TT><BR>
<TT><I>&nbsp;inversion&nbsp;1.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;apply&nbsp;IHeven;&nbsp;trivial.</I></TT><BR>
<TT><I>Unnamed_thm&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
In case the type of the second induction hypothesis is not
dependent, <TT>inversion</TT> can just be replaced by <TT>destruct</TT>.<BR>
<BR>
<!--TOC subsubsection How to define a function by double recursion?-->

<H4><A NAME="htoc131">116</A>&nbsp;&nbsp;How to define a function by double recursion?</H4><!--SEC END -->

The same trick applies, you can even use the pattern-matching
compilation algorithm to do the work for you. Here is an example:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;minus&nbsp;(n&nbsp;m:nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n,&nbsp;m&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;O,&nbsp;_&nbsp;=&gt;&nbsp;0</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;k,&nbsp;O&nbsp;=&gt;&nbsp;S&nbsp;k</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;k,&nbsp;S&nbsp;l&nbsp;=&gt;&nbsp;minus&nbsp;k&nbsp;l</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>minus&nbsp;is&nbsp;recursively&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;&nbsp;minus.</TT><BR>
<TT><I>minus&nbsp;=&nbsp;</I></TT><BR>
<TT><I>(fix&nbsp;minus&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;k&nbsp;=&gt;&nbsp;match&nbsp;m&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;S&nbsp;k</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;l&nbsp;=&gt;&nbsp;minus&nbsp;k&nbsp;l</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;end)</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[nat_scope&nbsp;nat_scope]</I></TT><BR>
</DIV>
<BR>
In case of dependencies in the type of the induction objects
<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB>, an extra argument stating <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB>=<I>t</I><SUB><FONT SIZE=2>2</FONT></SUB> must be given to
the fixpoint definition<BR>
<BR>
<!--TOC subsubsection How to perform nested induction?-->

<H4><A NAME="htoc132">117</A>&nbsp;&nbsp;How to perform nested induction?</H4><!--SEC END -->

To reason by nested induction, just reason by induction on the
successive components.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Infix&nbsp;"&lt;"&nbsp;:=&nbsp;lt&nbsp;(at&nbsp;level&nbsp;70,&nbsp;no&nbsp;associativity).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Infix&nbsp;"&lt;="&nbsp;:=&nbsp;le&nbsp;(at&nbsp;level&nbsp;70,&nbsp;no&nbsp;associativity).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;le_or_lt&nbsp;:&nbsp;forall&nbsp;n&nbsp;n0:nat,&nbsp;n0&nbsp;&lt;&nbsp;n&nbsp;\/&nbsp;n&nbsp;&lt;=&nbsp;n0.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;n0&nbsp;&lt;&nbsp;n&nbsp;\/&nbsp;n&nbsp;&lt;=&nbsp;n0</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;n;&nbsp;destruct&nbsp;n0;&nbsp;auto&nbsp;with&nbsp;arith.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;IHn&nbsp;:&nbsp;forall&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;n0&nbsp;&lt;&nbsp;n&nbsp;\/&nbsp;n&nbsp;&lt;=&nbsp;n0</I></TT><BR>
<TT><I>&nbsp;&nbsp;n0&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;S&nbsp;n0&nbsp;&lt;&nbsp;S&nbsp;n&nbsp;\/&nbsp;S&nbsp;n&nbsp;&lt;=&nbsp;S&nbsp;n0</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;destruct&nbsp;(IHn&nbsp;n0);&nbsp;auto&nbsp;with&nbsp;arith.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection How to define a function by nested recursion?-->

<H4><A NAME="htoc133">118</A>&nbsp;&nbsp;How to define a function by nested recursion?</H4><!--SEC END -->

The same trick applies. Here is the example of Ackermann
function.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;ack&nbsp;(n:nat)&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;S</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;n'&nbsp;=&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fix&nbsp;ack'&nbsp;(m:nat)&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;m&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;ack&nbsp;n'&nbsp;1</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;m'&nbsp;=&gt;&nbsp;ack&nbsp;n'&nbsp;(ack'&nbsp;m')</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>ack&nbsp;is&nbsp;recursively&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsection Co-inductive types-->

<H3><A NAME="htoc134">7.3</A>&nbsp;&nbsp;Co-inductive types</H3><!--SEC END -->

<!--TOC subsubsection I have a cofixpoint <I>t</I>:=<I>F</I>(<I>t</I>) and I want to prove <I>t</I>=<I>F</I>(<I>t</I>). How to do it?-->

<H4><A NAME="htoc135">119</A>&nbsp;&nbsp;I have a cofixpoint <I>t</I>:=<I>F</I>(<I>t</I>) and I want to prove <I>t</I>=<I>F</I>(<I>t</I>). How to do it?</H4><!--SEC END -->

Just case-expand <I>F</I>(<TT><I>t</I></TT>) then complete by a trivial case analysis.
Here is what it gives on e.g. the type of streams on naturals<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;CoInductive&nbsp;Stream&nbsp;(A:Set)&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Cons&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Stream&nbsp;A&nbsp;-&gt;&nbsp;Stream&nbsp;A.</TT><BR>
<TT><I>Stream&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;CoFixpoint&nbsp;nats&nbsp;(n:nat)&nbsp;:&nbsp;Stream&nbsp;nat&nbsp;:=&nbsp;Cons&nbsp;n&nbsp;(nats&nbsp;(S&nbsp;n)).</TT><BR>
<TT><I>nats&nbsp;is&nbsp;corecursively&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Stream_unfold&nbsp;:&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n:nat,&nbsp;nats&nbsp;n&nbsp;=&nbsp;Cons&nbsp;n&nbsp;(nats&nbsp;(S&nbsp;n)).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;nats&nbsp;n&nbsp;=&nbsp;Cons&nbsp;n&nbsp;(nats&nbsp;(S&nbsp;n))</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;intro;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;change&nbsp;(nats&nbsp;n&nbsp;=&nbsp;match&nbsp;nats&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Cons&nbsp;x&nbsp;s&nbsp;=&gt;&nbsp;Cons&nbsp;x&nbsp;s</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;nats&nbsp;n&nbsp;=&nbsp;match&nbsp;nats&nbsp;n&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Cons&nbsp;x&nbsp;s&nbsp;=&gt;&nbsp;Cons&nbsp;x&nbsp;s</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;case&nbsp;(nats&nbsp;n);&nbsp;reflexivity.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intro;&nbsp;change&nbsp;(nats&nbsp;n&nbsp;=&nbsp;match&nbsp;nats&nbsp;n&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Cons&nbsp;x&nbsp;s&nbsp;=&gt;&nbsp;Cons&nbsp;x&nbsp;s</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)&nbsp;in&nbsp;|-&nbsp;*.</I></TT><BR>
<TT><I>case&nbsp;(nats&nbsp;n);&nbsp;reflexivity.</I></TT><BR>
<TT><I>Stream_unfold&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC section Syntax and notations-->

<H2><A NAME="htoc136">8</A>&nbsp;&nbsp;Syntax and notations</H2><!--SEC END -->

<!--TOC subsubsection I do not want to type ``forall'' because it is too long, what can I do?-->

<H4><A NAME="htoc137">120</A>&nbsp;&nbsp;I do not want to type ``forall'' because it is too long, what can I do?</H4><!--SEC END -->

You can define your own notation for forall:
<PRE>
Notation "fa x : t, P" := (forall x:t, P) (at level 200, x ident).
</PRE>or if your are using <FONT COLOR=navy>CoqIde</FONT> you can define a pretty symbol for for all and an input method (see <A HREF="#forallcoqide">150</A>).<BR>
<BR>
<!--TOC subsubsection How can I define a notation for square?-->

<H4><A NAME="htoc138">121</A>&nbsp;&nbsp;How can I define a notation for square?</H4><!--SEC END -->

You can use for instance:
<PRE>
Notation "x ^2" := (Rmult x x) (at level 20).
</PRE>Note that you can not use:
<TT>N</TT>otation "x <SUP><FONT SIZE=2>²</FONT></SUP>" := (Rmult x x) (at level 20).

because ``<SUP><FONT SIZE=2>2</FONT></SUP>'' is an iso-latin character. If you really want this kind of notation you should use UTF-8.<BR>
<BR>
<!--TOC subsubsection Why ``no associativity'' and ``left associativity'' at the same level does not work?-->

<H4><A NAME="htoc139">122</A>&nbsp;&nbsp;Why ``no associativity'' and ``left associativity'' at the same level does not work?</H4><!--SEC END -->

Because we relie on camlp4 for syntactical analysis and camlp4 does not really implement no associativity. By default, non associative operators are defined as right associative.<BR>
<BR>
<!--TOC subsubsection How can I know the associativity associated with a level?-->

<H4><A NAME="htoc140">123</A>&nbsp;&nbsp;How can I know the associativity associated with a level?</H4><!--SEC END -->

You can do ``Print Grammar constr'', and decode the output from camlp4, good luck !<BR>
<BR>
<!--TOC section Modules-->

<H2><A NAME="htoc141">9</A>&nbsp;&nbsp;Modules</H2><!--SEC END -->

<!--TOC section <FONT COLOR=navy>Ltac</FONT>-->

<H2><A NAME="htoc142">10</A>&nbsp;&nbsp;<FONT COLOR=navy>Ltac</FONT></H2><!--SEC END -->

<!--TOC subsubsection What is <FONT COLOR=navy>Ltac</FONT>?-->

<H4><A NAME="htoc143">124</A>&nbsp;&nbsp;What is <FONT COLOR=navy>Ltac</FONT>?</H4><!--SEC END -->

<FONT COLOR=navy>Ltac</FONT> is the tactic language for <FONT COLOR=navy>Coq</FONT>. It provides the user with a
high-level ``toolbox'' for tactic creation.<BR>
<BR>
<!--TOC subsubsection Why do I always get the same error message?-->

<H4><A NAME="htoc144">125</A>&nbsp;&nbsp;Why do I always get the same error message?</H4><!--SEC END -->

<!--TOC subsubsection Is there any printing command in <FONT COLOR=navy>Ltac</FONT>?-->

<H4><A NAME="htoc145">126</A>&nbsp;&nbsp;Is there any printing command in <FONT COLOR=navy>Ltac</FONT>?</H4><!--SEC END -->

You can use the <TT>idtac</TT> tactic with a string argument. This string
will be printed out. The same applies to the <TT>fail</TT> tactic<BR>
<BR>
<!--TOC subsubsection What is the syntax for let in <FONT COLOR=navy>Ltac</FONT>?-->

<H4><A NAME="htoc146">127</A>&nbsp;&nbsp;What is the syntax for let in <FONT COLOR=navy>Ltac</FONT>?</H4><!--SEC END -->

If <I>x</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> are identifiers and <I>e</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> and <I>expr</I> are tactic expressions, then let reads:
<DIV ALIGN=center>
<TT>let <I>x</I></TT><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>:=<I>e</I></TT><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT> with <I>x</I></TT><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB><TT>:=<I>e</I></TT><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB><TT>...with <I>x</I></TT><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>:=<I>e</I></TT><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT> in
<I>expr</I></TT>.
</DIV>
Beware that if <I>expr</I> is complex (i.e. features at least a sequence) parenthesis
should be added around it. For example: 

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Ltac&nbsp;twoIntro&nbsp;:=&nbsp;let&nbsp;x:=intro&nbsp;in&nbsp;(x;x).</TT><BR>
<TT><I>twoIntro&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection What is the syntax for pattern matching in <FONT COLOR=navy>Ltac</FONT>?-->

<H4><A NAME="htoc147">128</A>&nbsp;&nbsp;What is the syntax for pattern matching in <FONT COLOR=navy>Ltac</FONT>?</H4><!--SEC END -->

Pattern matching on a term <I>expr</I> (non-linear first order unification)
with patterns <I>p</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> and tactic expressions <I>e</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> reads:
<DIV ALIGN=center>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT>match <I>expr</I> with
&nbsp;&nbsp;<I>p</I></TT><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT> =&gt; <I>e</I></TT><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>
&nbsp;|<I>p</I></TT><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB><TT> =&gt; <I>e</I></TT><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB><TT>
&nbsp;...&nbsp;|<I>p</I></TT><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT> =&gt; <I>e</I></TT><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>
&nbsp;| _ =&gt; <I>e</I></TT><SUB><TT><FONT SIZE=2><I>n</I>+1</FONT></TT></SUB><TT>
end.
</TT>
</DIV>
Underscore matches all terms.<BR>
<BR>
<!--TOC subsubsection What is the semantics for match goal?-->

<H4><A NAME="htoc148">129</A>&nbsp;&nbsp;What is the semantics for match goal?</H4><!--SEC END -->

<TT>match goal</TT> matches the current goal against a series of
patterns: <I>hyp</I><SUB><FONT SIZE=2>1</FONT></SUB> ... <I>hyp</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> |- <I>ccl</I>. It uses a
first-order unification algorithm, and tries all the possible
combinations of <I>hyp</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> before dropping the branch and moving to the
next one. Underscore matches all terms.<BR>
<BR>
<!--TOC subsubsection How can I generate a new name?-->

<H4><A NAME="htoc149">130</A>&nbsp;&nbsp;How can I generate a new name?</H4><!--SEC END -->

You can use the following syntax:
<TT>let id:=fresh in ...</TT><BR>
For example:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Ltac&nbsp;introIdGen&nbsp;:=&nbsp;let&nbsp;id:=fresh&nbsp;in&nbsp;intro&nbsp;id.</TT><BR>
<TT><I>introIdGen&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<!--TOC subsubsection How can I define static and dynamic code?-->

<H4><A NAME="htoc150">131</A>&nbsp;&nbsp;How can I define static and dynamic code?</H4><!--SEC END -->

<!--TOC section Tactics written in Ocaml-->

<H2><A NAME="htoc151">11</A>&nbsp;&nbsp;Tactics written in Ocaml</H2><!--SEC END -->

<!--TOC subsubsection Can you show me an example of a tactic written in OCaml?-->

<H4><A NAME="htoc152">132</A>&nbsp;&nbsp;Can you show me an example of a tactic written in OCaml?</H4><!--SEC END -->

You have some examples of tactics written in Ocaml in the ``contrib'' directory of <FONT COLOR=navy>Coq</FONT> sources. <BR>
<BR>
<!--TOC section Case studies-->

<H2><A NAME="htoc153">12</A>&nbsp;&nbsp;Case studies</H2><!--SEC END -->

<!--TOC subsubsection How can I define vectors or lists of size n?-->

<H4><A NAME="htoc154">133</A>&nbsp;&nbsp;How can I define vectors or lists of size n?</H4><!--SEC END -->

<!--TOC subsubsection How to prove that 2 sets are different?-->

<H4><A NAME="htoc155">134</A>&nbsp;&nbsp;How to prove that 2 sets are different?</H4><!--SEC END -->

You need to find a property true on one set and false on the
other one. As an example we show how to prove that <TT>bool</TT> and <TT>nat</TT> are discriminable. As discrimination property we take the
property to have no more than 2 elements.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;nat_bool_discr&nbsp;:&nbsp;bool&nbsp;&lt;&gt;&nbsp;nat.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;pose&nbsp;(discr&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;X:Set&nbsp;=&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~&nbsp;(forall&nbsp;a&nbsp;b:X,&nbsp;~&nbsp;(forall&nbsp;x:X,&nbsp;x&nbsp;&lt;&gt;&nbsp;a&nbsp;-&gt;&nbsp;x&nbsp;&lt;&gt;&nbsp;b&nbsp;-&gt;&nbsp;False))).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;intro&nbsp;Heq;&nbsp;assert&nbsp;(H:&nbsp;discr&nbsp;bool).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;intro&nbsp;H;&nbsp;apply&nbsp;(H&nbsp;true&nbsp;false);&nbsp;destruct&nbsp;x;&nbsp;auto.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;rewrite&nbsp;Heq&nbsp;in&nbsp;H;&nbsp;apply&nbsp;H;&nbsp;clear&nbsp;H.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;destruct&nbsp;a;&nbsp;destruct&nbsp;b&nbsp;as&nbsp;[|n];&nbsp;intro&nbsp;H0;&nbsp;eauto.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;destruct&nbsp;n;&nbsp;[&nbsp;apply&nbsp;(H0&nbsp;2);&nbsp;discriminate&nbsp;|&nbsp;eauto&nbsp;].</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<!--TOC subsubsection Is there an axiom-free proof of Streicher's axiom <I>K</I> for
the equality on <TT>nat</TT>?-->

<H4><A NAME="htoc156">135</A>&nbsp;&nbsp;Is there an axiom-free proof of Streicher's axiom <I>K</I> for
the equality on <TT>nat</TT>?</H4><!--SEC END -->

<A NAME="K-nat"></A>
Yes, because equality is decidable on <TT>nat</TT>. Here is the proof.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Eqdep_dec.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Peano_dec.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;K_nat&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(x:nat)&nbsp;(P:x&nbsp;=&nbsp;x&nbsp;-&gt;&nbsp;Prop),&nbsp;P&nbsp;(refl_equal&nbsp;x)&nbsp;-&gt;&nbsp;forall&nbsp;p:x&nbsp;=&nbsp;x,&nbsp;P&nbsp;p.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros;&nbsp;apply&nbsp;K_dec_set&nbsp;with&nbsp;(p&nbsp;:=&nbsp;p).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;eq_nat_dec.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
Similarly, we have<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;eq_rect_eq_nat&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(p:nat)&nbsp;(Q:nat-&gt;Type)&nbsp;(x:Q&nbsp;p)&nbsp;(h:p=p),&nbsp;x&nbsp;=&nbsp;eq_rect&nbsp;p&nbsp;Q&nbsp;x&nbsp;p&nbsp;h.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros;&nbsp;apply&nbsp;K_nat&nbsp;with&nbsp;(p&nbsp;:=&nbsp;h);&nbsp;reflexivity.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<!--TOC subsubsection How to prove that two proofs of <TT>n&lt;=m</TT> on <TT>nat</TT> are equal?-->

<H4><A NAME="htoc157">136</A>&nbsp;&nbsp;How to prove that two proofs of <TT>n&lt;=m</TT> on <TT>nat</TT> are equal?</H4><!--SEC END -->

<A NAME="le-uniqueness"></A>
This is provable without requiring any axiom because axiom <I>K</I>
directly holds on <TT>nat</TT>. Here is a proof using question <A HREF="#K-nat">135</A>.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Scheme&nbsp;le_ind'&nbsp;:=&nbsp;Induction&nbsp;for&nbsp;le&nbsp;Sort&nbsp;Prop.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;le_uniqueness_proof&nbsp;:&nbsp;forall&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;(p&nbsp;q&nbsp;:&nbsp;n&nbsp;&lt;=&nbsp;m),&nbsp;p&nbsp;=&nbsp;q.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;p&nbsp;using&nbsp;le_ind';&nbsp;intro&nbsp;q.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;replace&nbsp;(le_n&nbsp;n)&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;(eq_rect&nbsp;_&nbsp;(fun&nbsp;n0&nbsp;=&gt;&nbsp;n&nbsp;&lt;=&nbsp;n0)&nbsp;(le_n&nbsp;n)&nbsp;_&nbsp;(refl_equal&nbsp;n)).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;2:reflexivity.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;generalize&nbsp;(refl_equal&nbsp;n).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern&nbsp;n&nbsp;at&nbsp;2&nbsp;4&nbsp;6&nbsp;10,&nbsp;q;&nbsp;case&nbsp;q;&nbsp;[intro&nbsp;|&nbsp;intros&nbsp;m&nbsp;l&nbsp;e].</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;&lt;-&nbsp;eq_rect_eq_nat;&nbsp;trivial.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contradiction&nbsp;(le_Sn_n&nbsp;m);&nbsp;rewrite&nbsp;&lt;-&nbsp;e;&nbsp;assumption.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;replace&nbsp;(le_S&nbsp;n&nbsp;m&nbsp;p)&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;(eq_rect&nbsp;_&nbsp;(fun&nbsp;n0&nbsp;=&gt;&nbsp;n&nbsp;&lt;=&nbsp;n0)&nbsp;(le_S&nbsp;n&nbsp;m&nbsp;p)&nbsp;_&nbsp;(refl_equal&nbsp;(S&nbsp;m))).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;2:reflexivity.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;generalize&nbsp;(refl_equal&nbsp;(S&nbsp;m)).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern&nbsp;(S&nbsp;m)&nbsp;at&nbsp;1&nbsp;3&nbsp;4&nbsp;6,&nbsp;q;&nbsp;case&nbsp;q;&nbsp;[intro&nbsp;Heq&nbsp;|&nbsp;intros&nbsp;m0&nbsp;l&nbsp;HeqS].</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contradiction&nbsp;(le_Sn_n&nbsp;m);&nbsp;rewrite&nbsp;Heq;&nbsp;assumption.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;injection&nbsp;HeqS;&nbsp;intro&nbsp;Heq;&nbsp;generalize&nbsp;l&nbsp;HeqS.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;&lt;-&nbsp;Heq;&nbsp;intros;&nbsp;rewrite&nbsp;&lt;-&nbsp;eq_rect_eq_nat.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;(IHp&nbsp;l0);&nbsp;reflexivity.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<!--TOC subsubsection How to exploit equalities on sets-->

<H4><A NAME="htoc158">137</A>&nbsp;&nbsp;How to exploit equalities on sets</H4><!--SEC END -->

To extract information from an equality on sets, you need to
find a predicate of sets satisfied by the elements of the sets. As an
example, let's consider the following theorem.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;interval_discr&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;m&nbsp;n:nat,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{x&nbsp;:&nbsp;nat&nbsp;|&nbsp;x&nbsp;&lt;=&nbsp;m}&nbsp;=&nbsp;{x&nbsp;:&nbsp;nat&nbsp;|&nbsp;x&nbsp;&lt;=&nbsp;n}&nbsp;-&gt;&nbsp;m&nbsp;=&nbsp;n.</TT><BR>
</DIV>
<BR>
We have a proof requiring the axiom of proof-irrelevance. We
conjecture that proof-irrelevance can be circumvented by introducing a
primitive definition of discrimination of the proofs of
<CODE>{x : nat | x &lt;= m}</CODE>.<BR>
<BR>
<A HREF="./interval_discr.v">Here</A> is the proof.
<BR>
<BR>
<!--TOC subsubsection I have a problem of dependent elimination on
proofs, how to solve it?-->

<H4><A NAME="htoc159">138</A>&nbsp;&nbsp;I have a problem of dependent elimination on
proofs, how to solve it?</H4><!--SEC END -->


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;Def1&nbsp;:&nbsp;Set&nbsp;:=&nbsp;c1&nbsp;:&nbsp;Def1.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;DefProp&nbsp;:&nbsp;Def1&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;c2&nbsp;:&nbsp;forall&nbsp;d:Def1,&nbsp;DefProp&nbsp;d.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;Comb&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;c3&nbsp;:&nbsp;forall&nbsp;d:Def1,&nbsp;DefProp&nbsp;d&nbsp;-&gt;&nbsp;Comb.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;eq_comb&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(d1&nbsp;d1':Def1)&nbsp;(d2:DefProp&nbsp;d1)&nbsp;(d2':DefProp&nbsp;d1'),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d1&nbsp;=&nbsp;d1'&nbsp;-&gt;&nbsp;c3&nbsp;d1&nbsp;d2&nbsp;=&nbsp;c3&nbsp;d1'&nbsp;d2'.</TT><BR>
</DIV>
<BR>
You need to derive the dependent elimination
scheme for DefProp by hand using <TT>S</TT>cheme.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Scheme&nbsp;DefProp_elim&nbsp;:=&nbsp;Induction&nbsp;for&nbsp;DefProp&nbsp;Sort&nbsp;Prop.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;eq_comb&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;d1&nbsp;d1':Def1,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d1&nbsp;=&nbsp;d1'&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(d2:DefProp&nbsp;d1)&nbsp;(d2':DefProp&nbsp;d1'),&nbsp;c3&nbsp;d1&nbsp;d2&nbsp;=&nbsp;c3&nbsp;d1'&nbsp;d2'.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;destruct&nbsp;H.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;destruct&nbsp;d2&nbsp;using&nbsp;DefProp_elim.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;destruct&nbsp;d2'&nbsp;using&nbsp;DefProp_elim.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;reflexivity.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<!--TOC subsubsection And what if I want to prove the following?-->

<H4><A NAME="htoc160">139</A>&nbsp;&nbsp;And what if I want to prove the following?</H4><!--SEC END -->


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;natProp&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;p0&nbsp;:&nbsp;natProp&nbsp;0</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;pS&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;natProp&nbsp;n&nbsp;-&gt;&nbsp;natProp&nbsp;(S&nbsp;n).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;package&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;pack&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;natProp&nbsp;n&nbsp;-&gt;&nbsp;package.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;eq_pack&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;n&nbsp;n':nat,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;n'&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(np:natProp&nbsp;n)&nbsp;(np':natProp&nbsp;n'),&nbsp;pack&nbsp;n&nbsp;np&nbsp;=&nbsp;pack&nbsp;n'&nbsp;np'.</TT><BR>
</DIV>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Scheme&nbsp;natProp_elim&nbsp;:=&nbsp;Induction&nbsp;for&nbsp;natProp&nbsp;Sort&nbsp;Prop.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;pack_S&nbsp;:&nbsp;package&nbsp;-&gt;&nbsp;package.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;destruct&nbsp;1.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;(pack&nbsp;(S&nbsp;n)).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;pS;&nbsp;assumption.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Defined.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;eq_pack&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;n':nat,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;n'&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(np:natProp&nbsp;n)&nbsp;(np':natProp&nbsp;n'),&nbsp;pack&nbsp;n&nbsp;np&nbsp;=&nbsp;pack&nbsp;n'&nbsp;np'.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;n&nbsp;n'&nbsp;Heq&nbsp;np&nbsp;np'.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;generalize&nbsp;dependent&nbsp;n'.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;np&nbsp;using&nbsp;natProp_elim.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;np'&nbsp;using&nbsp;natProp_elim;&nbsp;intros;&nbsp;auto.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;discriminate&nbsp;Heq.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;np'&nbsp;using&nbsp;natProp_elim;&nbsp;intros;&nbsp;auto.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;discriminate&nbsp;Heq.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;change&nbsp;(pack_S&nbsp;(pack&nbsp;n&nbsp;np)&nbsp;=&nbsp;pack_S&nbsp;(pack&nbsp;n0&nbsp;np')).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;(f_equal&nbsp;(A:=package)).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;IHnp.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<!--TOC section Publishing tools-->

<H2><A NAME="htoc161">13</A>&nbsp;&nbsp;Publishing tools</H2><!--SEC END -->

<!--TOC subsubsection How can I generate some latex from my development?-->

<H4><A NAME="htoc162">140</A>&nbsp;&nbsp;How can I generate some latex from my development?</H4><!--SEC END -->

You can use <TT>coqdoc</TT>.<BR>
<BR>
<!--TOC subsubsection How can I generate some HTML from my development?-->

<H4><A NAME="htoc163">141</A>&nbsp;&nbsp;How can I generate some HTML from my development?</H4><!--SEC END -->

You can use <TT>coqdoc</TT>.<BR>
<BR>
<!--TOC subsubsection How can I generate some dependency graph from my development?-->

<H4><A NAME="htoc164">142</A>&nbsp;&nbsp;How can I generate some dependency graph from my development?</H4><!--SEC END -->

<!--TOC subsubsection How can I cite some <FONT COLOR=navy>Coq</FONT> in my latex document?-->

<H4><A NAME="htoc165">143</A>&nbsp;&nbsp;How can I cite some <FONT COLOR=navy>Coq</FONT> in my latex document?</H4><!--SEC END -->

You can use <TT>coq_tex</TT>.<BR>
<BR>
<!--TOC subsubsection How can I cite the <FONT COLOR=navy>Coq</FONT> reference manual?-->

<H4><A NAME="htoc166">144</A>&nbsp;&nbsp;How can I cite the <FONT COLOR=navy>Coq</FONT> reference manual?</H4><!--SEC END -->

You can use this bibtex entry:
<PRE>
@Manual{Coq:manual,
  title =        {The Coq proof assistant reference manual},
  author =       {\mbox{The Coq development team}},
  organization = {LogiCal Project},
  note =         {Version 8.0},
  year =         {2004},
  url =          "http://coq.inria.fr"
}
</PRE>
<!--TOC subsubsection Where can I publish my developments in <FONT COLOR=navy>Coq</FONT>?-->

<H4><A NAME="htoc167">145</A>&nbsp;&nbsp;Where can I publish my developments in <FONT COLOR=navy>Coq</FONT>?</H4><!--SEC END -->

You can submit your developments as a user contribution to the <FONT COLOR=navy>Coq</FONT>
development team. This ensures its liveness along the evolution and
possible changes of <FONT COLOR=navy>Coq</FONT>.<BR>
<BR>
You can also submit your developments to the HELM/MoWGLI repository at
the University of Bologna (see
<A HREF="http://mowgli.cs.unibo.it"><TT>http://mowgli.cs.unibo.it</TT></A>). For
developments submitted in this database, it is possible to visualize
the developments in natural language and execute various retrieving
requests.<BR>
<BR>
<!--TOC subsubsection How can I read my proof in natural language?-->

<H4><A NAME="htoc168">146</A>&nbsp;&nbsp;How can I read my proof in natural language?</H4><!--SEC END -->

You can submit your proof to the HELM/MoWGLI repository and use the
rendering tool provided by the server (see
<A HREF="http://mowgli.cs.unibo.it"><TT>http://mowgli.cs.unibo.it</TT></A>).<BR>
<BR>
<!--TOC section <FONT COLOR=navy>CoqIde</FONT>-->

<H2><A NAME="htoc169">14</A>&nbsp;&nbsp;<FONT COLOR=navy>CoqIde</FONT></H2><!--SEC END -->

<!--TOC subsubsection What is <FONT COLOR=navy>CoqIde</FONT>?-->

<H4><A NAME="htoc170">147</A>&nbsp;&nbsp;What is <FONT COLOR=navy>CoqIde</FONT>?</H4><!--SEC END -->

<FONT COLOR=navy>CoqIde</FONT> is a gtk based GUI for <FONT COLOR=navy>Coq</FONT>.<BR>
<BR>
<!--TOC subsubsection How to enable Emacs keybindings?-->

<H4><A NAME="htoc171">148</A>&nbsp;&nbsp;How to enable Emacs keybindings?</H4><!--SEC END -->

 Insert <TT>gtk-key-theme-name = "Emacs"</TT>
 in your <TT>.coqide-gtk2rc</TT> file. It may be in the current dir
 or in <CODE>$HOME</CODE> dir. This is done by default.<BR>
<BR>
<!--TOC subsubsection How to enable antialiased fonts?-->

<H4><A NAME="htoc172">149</A>&nbsp;&nbsp;How to enable antialiased fonts?</H4><!--SEC END -->

Set the <CODE>GDK_USE_XFT</CODE> variable to <CODE>1</CODE>. This is by default with <CODE>Gtk &gt;= 2.2</CODE>.
 If some of your fonts are not available, set <CODE>GDK_USE_XFT</CODE> to <CODE>0</CODE>.<BR>
<BR>
<!--TOC subsubsection How to use those Forall and Exists pretty symbols?-->

<H4><A NAME="htoc173">150</A>&nbsp;&nbsp;How to use those Forall and Exists pretty symbols?</H4><!--SEC END -->
<A NAME="forallcoqide"></A>
 Thanks to the notation features in <FONT COLOR=navy>Coq</FONT>, you just need to insert these
lines in your <FONT COLOR=navy>Coq</FONT> buffer:<BR>
<TT>N</TT>otation "for all x : t, P" := (forall x:t, P) (at level 200, x ident).
<BR>
<TT>N</TT>otation "there exists x : t, P" := (exists x:t, P) (at level 200, x ident).
<BR>
<BR>
Copy/Paste of these lines from this file will not work outside of <FONT COLOR=navy>CoqIde</FONT>.
You need to load a file containing these lines or to enter the for all
using an input method (see <A HREF="#inputmeth">151</A>). To try it just use <CODE>Require Import utf8</CODE> from inside
<FONT COLOR=navy>CoqIde</FONT>. 
To enable these notations automatically start coqide with
<PRE>
 coqide -l utf8
</PRE>In the ide subdir of <FONT COLOR=navy>Coq</FONT> library, you will find a sample utf8.v with some 
pretty simple notations.<BR>
<BR>
<!--TOC subsubsection How to define an input method for non ASCII symbols?-->

<H4><A NAME="htoc174">151</A>&nbsp;&nbsp;How to define an input method for non ASCII symbols?</H4><!--SEC END -->
<A NAME="inputmeth"></A>
<UL><LI>
First solution: type <CODE>&lt;CONTROL&gt;&lt;SHIFT&gt;2200</CODE> to enter a forall in the script widow. 
	2200 is the hexadecimal code for forall in unicode charts and is encoded as 	
	in UTF-8.
	2203 is for exists. See <A HREF="http://www.unicode.org"><TT>http://www.unicode.org</TT></A> for more codes.
<LI>Second solution: rebind <CODE>&lt;AltGr&gt;a</CODE> to forall and <CODE>&lt;AltGr&gt;e</CODE> to exists. 
	Under X11, you need to use something like
<PRE>
  xmodmap -e "keycode  24 = a A F13 F13" 
  xmodmap -e "keycode  26 = e E F14 F14"
</PRE>	and then to add 
<PRE>
  bind "F13" {"insert-at-cursor" ("")}
  bind "F14" {"insert-at-cursor" ("")}
</PRE>	to your "binding "text"" section in <CODE>.coqiderc-gtk2rc.</CODE>
	The strange ("") argument is the UTF-8 encoding for
	0x2200. 
	You can compute these encodings using the lablgtk2 toplevel with 
<PRE>  
Glib.Utf8.from_unichar 0x2200;;
</PRE>	Further symbols can be bound on higher Fxx keys or on even on other keys you
	do not need .
</UL>
<!--TOC subsubsection How to build a custom <FONT COLOR=navy>CoqIde</FONT> with user ml code?-->

<H4><A NAME="htoc175">152</A>&nbsp;&nbsp;How to build a custom <FONT COLOR=navy>CoqIde</FONT> with user ml code?</H4><!--SEC END -->

 Use 
	coqmktop -ide -byte m1.cmo...mi.cmo
 or 
	coqmktop -ide -opt m1.cmx...mi.cmx<BR>
<BR>
<!--TOC subsubsection How to customize the shortcuts for menus?-->

<H4><A NAME="htoc176">153</A>&nbsp;&nbsp;How to customize the shortcuts for menus?</H4><!--SEC END -->

 Two solutions are offered:
<UL><LI>
Edit $HOME/.coqide.keys by hand or
<LI>Add "gtk-can-change-accels = 1" in your .coqide-gtk2rc file. Then
 from <FONT COLOR=navy>CoqIde</FONT>, you may select a menu entry and press the desired 
 shortcut. 
</UL>
<!--TOC subsubsection What encoding should I use? What is this \x{iiii} in my file?-->

<H4><A NAME="htoc177">154</A>&nbsp;&nbsp;What encoding should I use? What is this \x{iiii} in my file?</H4><!--SEC END -->

 The encoding option is related to the way files are saved. 
 Keep it as UTF-8 until it becomes important for you to exchange files 
 with non UTF-8 aware applications.
 If you choose something else than UTF-8, then missing characters will 
 be encoded by \x{....} or \x{........}
 where each dot is an hex. digit. 
 The number between braces is the hexadecimal UNICODE index for the
 missing character.<BR>
<BR>
<!--TOC section Extraction-->

<H2><A NAME="htoc178">15</A>&nbsp;&nbsp;Extraction</H2><!--SEC END -->

<!--TOC subsubsection What is program extraction?-->

<H4><A NAME="htoc179">155</A>&nbsp;&nbsp;What is program extraction?</H4><!--SEC END -->

Program extraction consist in generating a program from a constructive proof.<BR>
<BR>
<!--TOC subsubsection Which language can I extract to?-->

<H4><A NAME="htoc180">156</A>&nbsp;&nbsp;Which language can I extract to?</H4><!--SEC END -->

You can extract your programs to Objective Caml and Haskell.<BR>
<BR>
<!--TOC subsubsection How can I extract an incomplete proof?-->

<H4><A NAME="htoc181">157</A>&nbsp;&nbsp;How can I extract an incomplete proof?</H4><!--SEC END -->

You can provide programs for your axioms.<BR>
<BR>
<!--TOC section Glossary-->

<H2><A NAME="htoc182">16</A>&nbsp;&nbsp;Glossary</H2><!--SEC END -->

<!--TOC subsubsection Can you explain me what an evaluable constant is?-->

<H4><A NAME="htoc183">158</A>&nbsp;&nbsp;Can you explain me what an evaluable constant is?</H4><!--SEC END -->

An evaluable constant is a constant which is unfoldable.<BR>
<BR>
<!--TOC subsubsection What is a goal?-->

<H4><A NAME="htoc184">159</A>&nbsp;&nbsp;What is a goal?</H4><!--SEC END -->

The goal is the statement to be proved.<BR>
<BR>
<!--TOC subsubsection What is a meta variable?-->

<H4><A NAME="htoc185">160</A>&nbsp;&nbsp;What is a meta variable?</H4><!--SEC END -->

A meta variable in <FONT COLOR=navy>Coq</FONT> represents a ``hole'', i.e. a part of a proof
that is still unknown. <BR>
<BR>
<!--TOC subsubsection What is Gallina?-->

<H4><A NAME="htoc186">161</A>&nbsp;&nbsp;What is Gallina?</H4><!--SEC END -->
 
Gallina is the specification language of <FONT COLOR=navy>Coq</FONT>. Complete documentation
of this language can be found in the Reference Manual.<BR>
<BR>
<!--TOC subsubsection What is The Vernacular?-->

<H4><A NAME="htoc187">162</A>&nbsp;&nbsp;What is The Vernacular?</H4><!--SEC END -->
 
It is the language of commands of Gallina i.e. definitions, lemmas, ... <BR>
<BR>
<!--TOC subsubsection What is a dependent type?-->

<H4><A NAME="htoc188">163</A>&nbsp;&nbsp;What is a dependent type?</H4><!--SEC END -->

A dependant type is a type which depends on some term. For instance
``vector of size n'' is a dependant type representing all the vectors
of size <I>n</I>. Its type depends on <I>n</I><BR>
<BR>
<!--TOC subsubsection What is a proof by reflection?-->

<H4><A NAME="htoc189">164</A>&nbsp;&nbsp;What is a proof by reflection?</H4><!--SEC END -->

This is a proof generated by some computation which is done using the
internal reduction of <FONT COLOR=navy>Coq</FONT> (not using the tactic language of <FONT COLOR=navy>Coq</FONT>
(<FONT COLOR=navy>Ltac</FONT>) nor the implementation language for <FONT COLOR=navy>Coq</FONT>). An example of
tactic using the reflection mechanism is the <TT>ring</TT> tactic. The
reflection method consist in reflecting a subset of <FONT COLOR=navy>Coq</FONT> language (for
example the arithmetical expressions) into an object of the <FONT COLOR=navy>Coq</FONT>language itself (in this case an inductive type denoting arithmetical
expressions). For more information see&nbsp;[<A HREF="#howe"><CITE>13</CITE></A><CITE>, </CITE><A HREF="#harrison"><CITE>11</CITE></A><CITE>, </CITE><A HREF="#boutin"><CITE>2</CITE></A>]
and the last chapter of the Coq'Art.<BR>
<BR>
<!--TOC subsubsection What is intuitionistic logic?-->

<H4><A NAME="htoc190">165</A>&nbsp;&nbsp;What is intuitionistic logic?</H4><!--SEC END -->

This is any logic which does not assume that ``A or not A''.<BR>
<BR>
<!--TOC subsubsection What is proof-irrelevance?-->

<H4><A NAME="htoc191">166</A>&nbsp;&nbsp;What is proof-irrelevance?</H4><!--SEC END -->

See question <A HREF="#proof-irrelevance">34</A><BR>
<BR>
<!--TOC subsubsection What is the difference between opaque and transparent?-->

<H4><A NAME="htoc192">167</A>&nbsp;&nbsp;What is the difference between opaque and transparent?</H4><!--SEC END -->
<A NAME="opaque"></A>	<BR>
<BR>
Opaque definitions can not be unfolded but transparent ones can.<BR>
<BR>
<!--TOC section Troubleshooting-->

<H2><A NAME="htoc193">17</A>&nbsp;&nbsp;Troubleshooting</H2><!--SEC END -->

<!--TOC subsubsection What can I do when <TT>Qed.</TT> is slow?-->

<H4><A NAME="htoc194">168</A>&nbsp;&nbsp;What can I do when <TT>Qed.</TT> is slow?</H4><!--SEC END -->

Sometime you can use the <TT>abstract</TT> tactic, which makes as if you had
stated some local lemma, this speeds up the typing process.<BR>
<BR>
<!--TOC subsubsection Why <TT>Reset Initial.</TT> does not work when using <TT>coqc</TT>?-->

<H4><A NAME="htoc195">169</A>&nbsp;&nbsp;Why <TT>Reset Initial.</TT> does not work when using <TT>coqc</TT>?</H4><!--SEC END -->

The initial state corresponds to the state of coqtop when the interactive
session began. It does not make sense in files to compile.<BR>
<BR>
<!--TOC subsubsection What can I do if I get ``No more subgoals but non-instantiated existential variables''?-->

<H4><A NAME="htoc196">170</A>&nbsp;&nbsp;What can I do if I get ``No more subgoals but non-instantiated existential variables''?</H4><!--SEC END -->

This means that <TT>eauto</TT> or <TT>eapply</TT> didn't instantiate an
existential variable which eventually got erased by some computation.
You have to backtrack to the faulty occurrence of <TT>eauto</TT> or
<TT>eapply</TT> and give the missing argument an explicit value.<BR>
<BR>
<!--TOC subsubsection What can I do if I get ``Cannot solve a second-order unification problem''?-->

<H4><A NAME="htoc197">171</A>&nbsp;&nbsp;What can I do if I get ``Cannot solve a second-order unification problem''?</H4><!--SEC END -->

You can help <FONT COLOR=navy>Coq</FONT> using the <TT>pattern</TT> tactic.<BR>
<BR>
<!--TOC subsubsection Why does <FONT COLOR=navy>Coq</FONT> tell me that <TT>{x:A|(P x)}</TT> is not convertible with <TT>(sig A P)</TT>?-->

<H4><A NAME="htoc198">172</A>&nbsp;&nbsp;Why does <FONT COLOR=navy>Coq</FONT> tell me that <TT>{x:A|(P x)}</TT> is not convertible with <TT>(sig A P)</TT>?</H4><!--SEC END -->

This is because <TT>{x:A|P x}</TT> is a notation for
<TT>sig (fun x:A =&gt; P x)</TT>. Since <FONT COLOR=navy>Coq</FONT> does not reason up to
eta-conversion, this is different from <TT>sig P</TT>.<BR>
<BR>
<!--TOC subsubsection I copy-paste a term and <FONT COLOR=navy>Coq</FONT> says it is not convertible
 to the original term. Sometimes it even says the copied term is not
well-typed.-->

<H4><A NAME="htoc199">173</A>&nbsp;&nbsp;I copy-paste a term and <FONT COLOR=navy>Coq</FONT> says it is not convertible
 to the original term. Sometimes it even says the copied term is not
well-typed.</H4><!--SEC END -->

This is probably due to invisible implicit information (implicit
arguments, coercions and Cases annotations) in the printed term, which
is not re-synthesised from the copied-pasted term in the same way as
it is in the original term.<BR>
<BR>
Consider for instance <TT>(@eq Type True True)</TT>. This term is
printed as <TT>True=True</TT> and re-parsed as <TT>(@eq Prop True
True)</TT>. The two terms are not convertible (hence they fool tactics
like <TT>pattern</TT>).<BR>
<BR>
There is currently no satisfactory answer to the problem. However,
the command <TT>Set Printing All</TT> is useful for diagnosing the
problem.<BR>
<BR>
Due to coercions, one may even face type-checking errors. In some
rare cases, the criterion to hide coercions is a bit too loose, which
may result in a typing error message if the parser is not able to find
again the missing coercion.<BR>
<BR>
<!--TOC section Conclusion and Farewell.-->

<H2><A NAME="htoc200">18</A>&nbsp;&nbsp;Conclusion and Farewell.</H2><!--SEC END -->

<A NAME="ccl"></A>
<!--TOC subsubsection What if my question isn't answered here?-->

<H4><A NAME="htoc201">174</A>&nbsp;&nbsp;What if my question isn't answered here?</H4><!--SEC END -->
 
<A NAME="lastquestion"></A>
Don't panic <CODE>:-)</CODE>. You can try the <FONT COLOR=navy>Coq</FONT> manual&nbsp;[<A HREF="#Coq:manual"><CITE>15</CITE></A>] for a technical
description of the prover. The Coq'Art&nbsp;[<A HREF="#Coq:coqart"><CITE>1</CITE></A>] is the first
book written on <FONT COLOR=navy>Coq</FONT> and provides a comprehensive review of the
theorem prover as well as a number of example and exercises. Finally,
the tutorial&nbsp;[<A HREF="#Coq:Tutorial"><CITE>14</CITE></A>] provides a smooth introduction to
theorem proving in <FONT COLOR=navy>Coq</FONT>.<BR>
<BR>


<!--TOC section References-->

<H2>References</H2><!--SEC END -->
<DL COMPACT=compact><DT><A NAME="Coq:coqart"><FONT COLOR=purple>[1]</FONT></A><DD>
Yves Bertot and Pierre Castéran.
<EM>Interactive Theorem Proving and Program Development, Coq'Art:
 The Calculus of Inductive Constructions</EM>.
Texts in Theoretical Computer Science. An EATCS series. Springer
 Verlag, 2004.<BR>
<BR>
<DT><A NAME="boutin"><FONT COLOR=purple>[2]</FONT></A><DD>
Samuel Boutin.
Using reflection to build efficient and certified decision pro
 cedures.
In M.&nbsp;Abadi and T.&nbsp;Ito, editors, <EM>Proceedings of TACS'97</EM>, volume
 1281 of <EM>LNCS</EM>. Springer-Verlag, 1997.<BR>
<BR>
<DT><A NAME="LaTeX:symb"><FONT COLOR=purple>[3]</FONT></A><DD>
David Carlisle, Scott Pakin, and Alexander Holt.
<EM>The Great, Big List of L<sup>A</sup>T<sub>E</sub>X Symbols</EM>, February 2001.<BR>
<BR>
<DT><A NAME="Coq85"><FONT COLOR=purple>[4]</FONT></A><DD>
Thierry Coquand.
<EM>Une Théorie des Constructions</EM>.
PhD thesis, Université Paris&nbsp;7, January 1985.<BR>
<BR>
<DT><A NAME="CoHu86"><FONT COLOR=purple>[5]</FONT></A><DD>
Thierry Coquand and Gérard Huet.
The Calculus of Constructions.
<EM>Information and Computation</EM>, 76(2/3), 1988.<BR>
<BR>
<DT><A NAME="CoPa89"><FONT COLOR=purple>[6]</FONT></A><DD>
Thierry Coquand and Christine Paulin-Mohring.
Inductively defined types.
In P.&nbsp;Martin-Löf and G.&nbsp;Mints, editors, <EM>Proceedings of
 Colog'88</EM>, volume 417 of <EM>Lecture Notes in Computer Science</EM>.
 Springer-Verlag, 1990.<BR>
<BR>
<DT><A NAME="Types:Dowek"><FONT COLOR=purple>[7]</FONT></A><DD>
Gilles Dowek.
Théorie des types.
Lecture notes, 2002.<BR>
<BR>
<DT><A NAME="EGThese"><FONT COLOR=purple>[8]</FONT></A><DD>
Eduardo Giménez.
<EM>Un Calcul de Constructions Infinies et son application a la
 vérification de systèmes communicants</EM>.
thèse d'université, Ecole Normale Supérieure de Lyon, December 1996.<BR>
<BR>
<DT><A NAME="Gir70"><FONT COLOR=purple>[9]</FONT></A><DD>
Jean-Yves Girard.
Une extension de l'interprétation de Gödel à l'analyse, et
 son application à l'élimination des coupures dans l'analyse et la
 théorie des types.
In <EM>Proceedings of the 2nd Scandinavian Logic Symposium</EM>.
 North-Holland, 1970.<BR>
<BR>
<DT><A NAME="ProofsTypes"><FONT COLOR=purple>[10]</FONT></A><DD>
Jean-Yves Girard, Yves Lafont, and Paul Taylor.
<EM>Proofs and Types</EM>.
Cambrige Tracts in Theoretical Computer Science, Cambridge University
 Press, 1989.<BR>
<BR>
<DT><A NAME="harrison"><FONT COLOR=purple>[11]</FONT></A><DD>
John Harrison.
Meta theory and reflection in theorem proving:a survey and cri tique.
Technical Report CRC-053, SRI International Cambridge Computer
 Science Research Center, 1995.<BR>
<BR>
<DT><A NAME="HofStr98"><FONT COLOR=purple>[12]</FONT></A><DD>
Martin Hofmann and Thomas Streicher.
The groupoid interpretation of type theory.
In <EM>Proceedings of the meeting Twenty-five years of constructive
 type theory</EM>. Oxford University Press, 1998.<BR>
<BR>
<DT><A NAME="howe"><FONT COLOR=purple>[13]</FONT></A><DD>
Doug Howe.
Computation meta theory in nuprl.
In E.&nbsp;Lusk and R.&nbsp;Overbeek, editors, <EM>The Proceedings of the
 Ninth International Conference of Autom ated Deduction</EM>, volume 310, pages
 238--257. Springer-Verlag, 1988.<BR>
<BR>
<DT><A NAME="Coq:Tutorial"><FONT COLOR=purple>[14]</FONT></A><DD>
Gérard Huet, Gilles Kahn, and Christine Paulin-Mohring.
<EM>The Coq Proof Assistant A Tutorial</EM>, 2004.<BR>
<BR>
<DT><A NAME="Coq:manual"><FONT COLOR=purple>[15]</FONT></A><DD>
The Coq development team.
<EM>The Coq proof assistant reference manual</EM>.
LogiCal Project, 2004.
Version 8.0.<BR>
<BR>
<DT><A NAME="LaTeX:intro"><FONT COLOR=purple>[16]</FONT></A><DD>
Tobias Oetiker.
<EM>The Not So Short Introduction to L<sup>A</sup>T<sub>E</sub>X2e</EM>, January 1999.<BR>
<BR>
<DT><A NAME="Pau96b"><FONT COLOR=purple>[17]</FONT></A><DD>
Christine Paulin-Mohring.
<EM>Définitions Inductives en Théorie des Types d'Ordre Supérieur</EM>.
Habilitation à diriger les recherches, Université Claude Bernard Lyon
 I, December 1996.</DL>





<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2>
<BLOCKQUOTE><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</EM></A><EM>.
</EM></BLOCKQUOTE>
</BODY>
</HTML>
