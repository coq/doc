<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
<TITLE>
Extensions of Gallina
</TITLE>
</HEAD>
<BODY >
<A HREF="Reference-Manual003.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual005.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><A NAME="htoc25">Chapter&nbsp;2</A>&nbsp;&nbsp;Extensions of <FONT COLOR=navy>Gallina</FONT></H1>
<A NAME="Gallina-extension"></A><A NAME="@default61"></A>
<FONT COLOR=navy>Gallina</FONT> is the kernel language of <FONT COLOR=navy>Coq</FONT>. We describe here extensions of
the Gallina's syntax.<BR>
<BR>
<A NAME="toc11"></A>
<H2><A NAME="htoc26">2.1</A>&nbsp;&nbsp;Record types
<A NAME="@default62"></A><A NAME="@command25"></A>
<A NAME="Record"></A></H2>
The <CODE>Record</CODE> construction is a macro allowing the definition of
records as is done in many programming languages. Its syntax is
described on figure <A HREF="#record-syntax">2.1</A>. In fact, the <CODE>Record</CODE>
macro is more general than the usual record types, since it allows
also for ``manifest'' expressions. In this sense, the <CODE>Record</CODE>
construction allows to define ``signatures''.
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>sentence</FONT></I></TD>
<TD ALIGN=center NOWRAP>++=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>record</FONT></I></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>record</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><TT>Record</TT> <I><FONT COLOR=maroon>ident</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>binderlet</FONT></I>  ...  <I><FONT COLOR=maroon>binderlet</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>sort</FONT></I> <CODE>:=</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;<I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>ident</FONT></I><I><FONT COLOR=maroon>]</FONT></I>
 <CODE>{</CODE> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>field</FONT></I> <TT>;</TT> ... <TT>;</TT> <I><FONT COLOR=maroon>field</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <CODE>}</CODE> <CODE>.</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>field</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>name</FONT></I> : <I><FONT COLOR=maroon>type</FONT></I></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>name</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>:</TT> <I><FONT COLOR=maroon>term</FONT></I><I><FONT COLOR=maroon>]</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I></TD>
</TR></TABLE>
</DIV>
<BR>
<DIV ALIGN=center>Figure 2.1: Syntax for the definition of <TT>Record</TT></DIV><BR>

<A NAME="record-syntax"></A>
<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
In the expression<BR>
<BR>
<BR>
<TT>Record</TT> <I><FONT COLOR=maroon>ident</FONT></I> <I><FONT COLOR=maroon>params</FONT></I> <TT>:</TT> 
 <I><FONT COLOR=maroon>sort</FONT></I> := <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>0</FONT></SUB> <CODE>{</CODE>
 <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB> <TT>:</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB>; 
 ...<I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> <TT>:</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> <CODE>}</CODE>.
<BR>
the identifier <I><FONT COLOR=maroon>ident</FONT></I> is the name of the defined record
and <I><FONT COLOR=maroon>sort</FONT></I> is its type. The identifier <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>0</FONT></SUB> is the name of
its constructor. If <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>0</FONT></SUB> is omitted, the default name <TT>Build_</TT><I><FONT COLOR=maroon>ident</FONT></I> is used. The identifiers <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB>, ..,
<I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> are the names of fields and <I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB>, .., <I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>
their respective types. Remark that the type of <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> may
depend on the previous <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>j</I></FONT></SUB> (for <I>j</I>&lt;<I>i</I>). Thus the order of the
fields is important. Finally, <I><FONT COLOR=maroon>params</FONT></I> are the parameters of the
record.<BR>
<BR>
More generally, a record may have explicitly defined (a.k.a.
manifest) fields. For instance, <TT>Record</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>[</TT>
<I><FONT COLOR=maroon>params</FONT></I> <TT>]</TT> <TT>:</TT> <I><FONT COLOR=maroon>sort</FONT></I> := <CODE>{</CODE> <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB>
<TT>:</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB> <CODE>;</CODE> <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>2</FONT></SUB> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>2</FONT></SUB>
<CODE>;</CODE> <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>3</FONT></SUB> <TT>:</TT> <I><FONT COLOR=maroon>type</FONT></I><SUB><FONT SIZE=2>3</FONT></SUB> <CODE>}</CODE> in which case
the correctness of <I><FONT COLOR=maroon>type</FONT></I><SUB><FONT SIZE=2>3</FONT></SUB> may rely on the instance <I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>2</FONT></SUB> of
<I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>2</FONT></SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>2</FONT></SUB> in turn may depend on <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB>.<BR>
<BR>
<BR>
<B>Example: </B>The set of rational numbers may be defined as:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Record&nbsp;Rat&nbsp;:&nbsp;Set&nbsp;:=&nbsp;mkRat</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;{sign&nbsp;:&nbsp;bool;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;top&nbsp;:&nbsp;nat;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;bottom&nbsp;:&nbsp;nat;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;Rat_bottom_cond&nbsp;:&nbsp;0&nbsp;&lt;&gt;&nbsp;bottom;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;Rat_irred_cond&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z:nat,&nbsp;(x&nbsp;*&nbsp;y)&nbsp;=&nbsp;top&nbsp;/\&nbsp;(x&nbsp;*&nbsp;z)&nbsp;=&nbsp;bottom&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;1}.</TT><BR>
<TT><I>Rat&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>Rat_rect&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>Rat_ind&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>Rat_rec&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>sign&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>top&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>bottom&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>Rat_bottom_cond&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>Rat_irred_cond&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
Remark here that the field
<CODE>Rat_cond</CODE> depends on the field <CODE>bottom</CODE>. <BR>
<BR>
Let us now see the work done by the <TT>Record</TT> macro. First the
macro generates an inductive definition with just one constructor:
<BLOCKQUOTE>
<TT>Inductive </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>params</FONT></I><TT> :</TT><I><FONT COLOR=maroon>sort</FONT></I><TT> :=</TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<TT></TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>0</FONT></TT></SUB><TT> (</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>:</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>) .. (</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>:</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>).</TT>
</BLOCKQUOTE>
To build an object of type <I><FONT COLOR=maroon>ident</FONT></I>, one should provide the
constructor <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>0</FONT></SUB> with <I>n</I> terms filling the fields of
the record.<BR>
<BR>
As an example, let us define the rational 1/2:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Arith.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;one_two_irred&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z:nat,&nbsp;x&nbsp;*&nbsp;y&nbsp;=&nbsp;1&nbsp;/\&nbsp;x&nbsp;*&nbsp;z&nbsp;=&nbsp;2&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;1.</TT><BR>
</DIV>

...
<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;half&nbsp;:=&nbsp;mkRat&nbsp;true&nbsp;1&nbsp;2&nbsp;(O_S&nbsp;1)&nbsp;one_two_irred.</TT><BR>
<TT><I>half&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;half.</TT><BR>
<TT><I>half</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Rat</I></TT><BR>
</DIV>
<BR>
The macro generates also, when it is possible, the projection
functions for destructuring an object of type <I><FONT COLOR=maroon>ident</FONT></I>. These
projection functions have the same name that the corresponding
fields. If a field is named ``<CODE>_</CODE>'' then no projection is built
for it. In our example:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Eval&nbsp;compute&nbsp;in&nbsp;half.(top).</TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;1</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Eval&nbsp;compute&nbsp;in&nbsp;half.(bottom).</TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;2</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Eval&nbsp;compute&nbsp;in&nbsp;half.(Rat_bottom_cond).</TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;O_S&nbsp;1</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;0&nbsp;&lt;&gt;&nbsp;bottom&nbsp;half</I></TT><BR>
</DIV>
<BR>
<BR>
<B>Warnings: </B><OL type=1><LI>
<TT>Warning: </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>i</I></FONT></TT></SUB><TT> cannot be defined.</TT><BR>
<BR>
It can happen that the definition of a projection is impossible.
 This message is followed by an explanation of this impossibility.
 There may be three reasons:
 <OL type=a><LI>
 The name <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> already exists in the environment (see
 Section&nbsp;<A HREF="Reference-Manual003.html#Axiom">1.3.1</A>).
 <LI>The body of <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> uses an incorrect elimination for
 <I><FONT COLOR=maroon>ident</FONT></I> (see Sections&nbsp;<A HREF="Reference-Manual003.html#Fixpoint">1.3.4</A> and&nbsp;<A HREF="Reference-Manual006.html#Caseexpr">4.5.4</A>).
 <LI>The type of the projections <I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> depends on previous
 projections which themselves couldn't be defined.
 </OL> 
</OL> 
<BR>
<B>Error messages: </B><OL type=1><LI><TT>A record cannot be recursive</TT><A NAME="@error9"></A><BR>
<BR>
The record name <I><FONT COLOR=maroon>ident</FONT></I> appears in the type of its fields.<BR>
<BR>
<LI>During the definition of the one-constructor inductive
 definition, all the errors of inductive definitions, as described in
 Section&nbsp;<A HREF="Reference-Manual003.html#gal_Inductive_Definitions">1.3.3</A>, may also occur.</OL>
<BR>
<B>See also: </B>Coercions and records in Section&nbsp;<A HREF="Reference-Manual019.html#Coercions-and-records">16.9</A>
of the chapter devoted to coercions.<BR>
<BR>
<BR>
<B>Remark: </B><TT>Structure</TT> is a synonym of the keyword <TT>Record</TT>.<BR>
<BR>
<BR>
<B>Remark: </B>An experimental syntax for projections based on a dot notation is
available. The command to activate it is
<BLOCKQUOTE>
<TT>Set Printing Projections.</TT>
</BLOCKQUOTE>
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I></TD>
<TD ALIGN=center NOWRAP>++=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I> <TT>.(</TT> <I><FONT COLOR=maroon>qualid</FONT></I> <TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I> <TT>.(</TT> <I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>arg</FONT></I>  ...  <I><FONT COLOR=maroon>arg</FONT></I> <TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I> <TT>.(</TT> @<I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>term</FONT></I>  ...  <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT></TD>
</TR></TABLE>
</DIV>
<BR>
<DIV ALIGN=center>Figure 2.2: Syntax of <TT>Record</TT> projections</DIV><BR>

<A NAME="fig:projsyntax"></A>
<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
The corresponding grammar rules are given Figure&nbsp;<A HREF="#fig:projsyntax">2.2</A>.
When <I><FONT COLOR=maroon>qualid</FONT></I> denotes a projection, the syntax <TT></TT><I><FONT COLOR=maroon>term</FONT></I><TT>.(</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>)</TT> is equivalent to <I><FONT COLOR=maroon>qualid</FONT></I>&nbsp;<I><FONT COLOR=maroon>term</FONT></I>, the syntax
<TT></TT><I><FONT COLOR=maroon>term</FONT></I><TT>.(</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>&nbsp;</TT><I><FONT COLOR=maroon>arg</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>&nbsp; ...&nbsp; </TT><I><FONT COLOR=maroon>arg</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>)</TT> to
<I><FONT COLOR=maroon>qualid</FONT></I>&nbsp;<I><FONT COLOR=maroon>arg</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB> ...<I><FONT COLOR=maroon>arg</FONT></I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>&nbsp;<I><FONT COLOR=maroon>term</FONT></I>, and the syntax
<TT></TT><I><FONT COLOR=maroon>term</FONT></I><TT>.(@</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>&nbsp;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>&nbsp;...&nbsp;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>)</TT> to
@<I><FONT COLOR=maroon>qualid</FONT></I>&nbsp;<I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB> ...<I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>&nbsp;<I><FONT COLOR=maroon>term</FONT></I>. In each case, <I><FONT COLOR=maroon>term</FONT></I>
is the object projected and the other arguments are the parameters of
the inductive type.<BR>
<BR>
To deactivate the printing of projections, use 
<TT>Unset Printing Projections</TT>.<BR>
<BR>
<A NAME="toc12"></A>
<H2><A NAME="htoc27">2.2</A>&nbsp;&nbsp;Variants and extensions of <TT>match</TT>
<A NAME="Extensions-of-match"></A>
<A NAME="@default63"></A></H2>

<H3><A NAME="htoc28">2.2.1</A>&nbsp;&nbsp;Multiple and nested pattern-matching
<A NAME="@default64"></A>
<A NAME="Mult-match"></A></H3>
The basic version of <CODE>match</CODE> allows pattern-matching on simple
patterns. As an extension, multiple and nested patterns are
allowed, as in ML-like languages.<BR>
<BR>
The extension just acts as a macro that is expanded during parsing
into a sequence of <TT>match</TT> on simple patterns. Especially, a
construction defined using the extended <TT>match</TT> is printed under
its expanded form.<BR>
<BR>
<BR>
<B>See also: </B>chapter <A HREF="Reference-Manual018.html#Mult-match-full">15</A>.<BR>
<BR>

<H3><A NAME="htoc29">2.2.2</A>&nbsp;&nbsp;Pattern-matching on boolean values: the <TT>if</TT> expression
<A NAME="@default65"></A></H3>
For inductive types with exactly two constructors and for
pattern-matchings expressions which do not depend on the arguments of
the constructors, it is possible to use a <TT>if ... then ... else</TT>
notation. For instance, the definition<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;not&nbsp;(b:bool)&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;b&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>not&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
can be alternatively written<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;not&nbsp;(b:bool)&nbsp;:=&nbsp;if&nbsp;b&nbsp;then&nbsp;false&nbsp;else&nbsp;true.</TT><BR>
<TT><I>not&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
More generally, for an inductive type with constructors <TT>C</TT><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB>
and <TT>C</TT><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB>, we have the following equivalence<BR>
<BR>
<BR>
<BR>
<BR>
<TT>if </TT><I><FONT COLOR=maroon>term</FONT></I><TT> <I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>dep_ret_type</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I> then </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT> else </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB> same as
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><TT>match </TT><I><FONT COLOR=maroon>term</FONT></I><TT> <I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>dep_ret_type</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I> with</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE><TT>|</TT></CODE><TT> C</TT><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT> _ ... _ </TT><CODE><TT>=&gt;</TT></CODE><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE><TT>|</TT></CODE><TT> C</TT><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB><TT> _ ... _ </TT><CODE><TT>=&gt;</TT></CODE><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>end</TT></TD>
</TR></TABLE><BR>
Here is an example.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(fun&nbsp;x&nbsp;(H:{x=0}+{x&lt;&gt;0})&nbsp;=&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;H&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;left&nbsp;_&nbsp;=&gt;&nbsp;true</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;right&nbsp;_&nbsp;=&gt;&nbsp;false</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end).</TT><BR>
<TT><I>fun&nbsp;(x&nbsp;:&nbsp;nat)&nbsp;(H&nbsp;:&nbsp;{x&nbsp;=&nbsp;0}&nbsp;+&nbsp;{x&nbsp;&lt;&gt;&nbsp;0})&nbsp;=&gt;&nbsp;if&nbsp;H&nbsp;then&nbsp;true&nbsp;else&nbsp;false</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;x&nbsp;:&nbsp;nat,&nbsp;{x&nbsp;=&nbsp;0}&nbsp;+&nbsp;{x&nbsp;&lt;&gt;&nbsp;0}&nbsp;-&gt;&nbsp;bool</I></TT><BR>
</DIV>
<BR>
Notice that the printing uses the <TT>if</TT> syntax because <TT>sumbool</TT> is
declared as such (see section <A HREF="#printing-options">2.2.4</A>).<BR>
<BR>

<H3><A NAME="htoc30">2.2.3</A>&nbsp;&nbsp;Irrefutable patterns: the destructuring <TT>let</TT>
<A NAME="@default66"></A>
<A NAME="Letin"></A></H3>
Closed terms (that is not relying on any axiom or variable) in an
inductive type having only one constructor, say <TT>foo</TT>, have
necessarily the form <TT>(foo ...)</TT>. In this case, the <TT>match</TT>
construction can be written with a syntax close to the <TT>let ... in
...</TT> construction. Expression <TT>let
(</TT>&nbsp;<I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB>,...,<I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>&nbsp;<TT>) :=</TT>&nbsp;<I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>0</FONT></SUB>&nbsp;<TT>in</TT>&nbsp;<I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB> performs case analysis on <I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>0</FONT></SUB> which must be in
an inductive type with one constructor with <I>n</I> arguments. Variables
<I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB>...<I><FONT COLOR=maroon>ident</FONT></I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> are bound to the <I>n</I> arguments of the
constructor in expression <I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB>. For instance, the definition<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;fst&nbsp;(A&nbsp;B:Set)&nbsp;(H:A&nbsp;*&nbsp;B)&nbsp;:=&nbsp;match&nbsp;H&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;pair&nbsp;x&nbsp;y&nbsp;=&gt;&nbsp;x</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>fst&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
can be alternatively written <BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;fst&nbsp;(A&nbsp;B:Set)&nbsp;(p:A&nbsp;*&nbsp;B)&nbsp;:=&nbsp;let&nbsp;(x,&nbsp;_)&nbsp;:=&nbsp;p&nbsp;in&nbsp;x.</TT><BR>
<TT><I>fst&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>

Note however that reduction is slightly different from regular <TT>let ... in ...</TT> construction since it can occur only if <I><FONT COLOR=maroon>term</FONT></I><SUB><FONT SIZE=2>0</FONT></SUB>
can be put in constructor form. Otherwise, reduction is blocked.<BR>
<BR>
The pretty-printing of a definition by matching on a
irrefutable pattern can either be done using <TT>match</TT> or the <TT>let</TT> construction (see Section&nbsp;<A HREF="#printing-options">2.2.4</A>).<BR>
<BR>
The general equivalence for an inductive type with one constructors <TT>C</TT> is<BR>
<BR>
<BR>
<TT>let (</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>,...,</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>) <I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>dep_ret_type</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I> := </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>term</FONT></I><TT>'</TT> <BR>
same as&nbsp;
<TT>match </TT><I><FONT COLOR=maroon>term</FONT></I><TT> <I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>dep_ret_type</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I> with C </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT> ... </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT> </TT><CODE><TT>=&gt;</TT></CODE><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT>' end</TT><BR>
<BR>

<H3><A NAME="htoc31">2.2.4</A>&nbsp;&nbsp;Options for pretty-printing of <TT>match</TT>
<A NAME="printing-options"></A></H3>
There are three options controlling the pretty-printing of <TT>match</TT>
expressions.<BR>
<BR>

<H4>Printing of wildcard pattern
<A NAME="@default67"></A><A NAME="@command26"></A>
<A NAME="@default68"></A><A NAME="@command27"></A>
<A NAME="@default69"></A><A NAME="@command28"></A></H4>
Some variables in a pattern may not occur in the right-hand side of
the pattern-matching clause. There are options to control the
display of these variables.
<BLOCKQUOTE>
<TT>Set Printing Wildcard.</TT>
</BLOCKQUOTE>
The variables having no occurrences in the right-hand side of the
pattern-matching clause are just printed using the wildcard symbol
``<TT>_</TT>''.
<BLOCKQUOTE>
<TT>Unset Printing Wildcard.</TT>
</BLOCKQUOTE>
The variables, even useless, are printed using their usual name. But some
non dependent variables have no name. These ones are still printed
using a ``<TT>_</TT>''.
<BLOCKQUOTE>
<TT>Test Printing Wildcard.</TT>
</BLOCKQUOTE>
This tells if the wildcard printing mode is on or off. The default is
to print wildcard for useless variables.<BR>
<BR>

<H4>Printing of the elimination predicate
<A NAME="@default70"></A><A NAME="@command29"></A>
<A NAME="@default71"></A><A NAME="@command30"></A>
<A NAME="@default72"></A><A NAME="@command31"></A></H4>
In most of the cases, the type of the result of a matched term is
mechanically synthesisable. Especially, if the result type does not
depend of the matched term.
<BLOCKQUOTE>
<TT>Set Printing Synth.</TT>
</BLOCKQUOTE>
The result type is not printed when <FONT COLOR=navy>Coq</FONT> knows that it can
re-synthesise it.
<BLOCKQUOTE>
<TT>Unset Printing Synth.</TT>
</BLOCKQUOTE>
This forces the result type to be always printed.
<BLOCKQUOTE>
<TT>Test Printing Synth.</TT>
</BLOCKQUOTE>
This tells if the non-printing of synthesisable types is on or off.
The default is to not print synthesisable types.<BR>
<BR>

<H4>Printing matching on irrefutable pattern
<A NAME="@default73"></A><A NAME="@command32"></A>
<A NAME="@default74"></A><A NAME="@command33"></A>
<A NAME="@default75"></A><A NAME="@command34"></A>
<A NAME="@default76"></A><A NAME="@command35"></A></H4>
If an inductive type has just one constructor,
pattern-matching can be written using <TT>let</TT> ... <TT>:=</TT>
... <TT>in</TT>&nbsp;...
<BLOCKQUOTE>
<TT>Add Printing Let </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE>
This adds <I><FONT COLOR=maroon>ident</FONT></I> to the list of inductive types for which
pattern-matching is written using a <TT>let</TT> expression.
<BLOCKQUOTE>
<TT>Remove Printing Let </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE>
This removes <I><FONT COLOR=maroon>ident</FONT></I> from this list.
<BLOCKQUOTE>
<TT>Test Printing Let </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE>
This tells if <I><FONT COLOR=maroon>ident</FONT></I> belongs to the list.
<BLOCKQUOTE>
<TT>Print Table Printing Let.</TT>
</BLOCKQUOTE>
This prints the list of inductive types for which pattern-matching is
written using a <TT>let</TT> expression.<BR>
<BR>
The list of inductive types for which pattern-matching is written
using a <TT>let</TT> expression is managed synchronously. This means that
it is sensible to the command <TT>Reset</TT>.<BR>
<BR>

<H4>Printing matching on booleans
<A NAME="@default77"></A><A NAME="@command36"></A>
<A NAME="@default78"></A><A NAME="@command37"></A>
<A NAME="@default79"></A><A NAME="@command38"></A>
<A NAME="@default80"></A><A NAME="@command39"></A></H4>
If an inductive type is isomorphic to the boolean type,
pattern-matching can be written using <TT>if</TT> ... <TT>then</TT> ... <TT>else</TT> ...
<BLOCKQUOTE>
<TT>Add Printing If </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE>
This adds <I><FONT COLOR=maroon>ident</FONT></I> to the list of inductive types for which
pattern-matching is written using an <TT>if</TT> expression.
<BLOCKQUOTE>
<TT>Remove Printing If </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE>
This removes <I><FONT COLOR=maroon>ident</FONT></I> from this list.
<BLOCKQUOTE>
<TT>Test Printing If </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT>
</BLOCKQUOTE>
This tells if <I><FONT COLOR=maroon>ident</FONT></I> belongs to the list.
<BLOCKQUOTE>
<TT>Print Table Printing If.</TT>
</BLOCKQUOTE>
This prints the list of inductive types for which pattern-matching is
written using an <TT>if</TT> expression.<BR>
<BR>
The list of inductive types for which pattern-matching is written
using an <TT>if</TT> expression is managed synchronously. This means that
it is sensible to the command <TT>Reset</TT>.<BR>
<BR>

<H4>Example</H4>
This example emphasizes what the printing options offer.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Test&nbsp;Printing&nbsp;Let&nbsp;prod.</TT><BR>
<TT><I>Cases&nbsp;on&nbsp;elements&nbsp;of&nbsp;prod&nbsp;are&nbsp;printed&nbsp;using&nbsp;a&nbsp;`let'&nbsp;form</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;fst.</TT><BR>
<TT><I>fst&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fun&nbsp;(A&nbsp;B&nbsp;:&nbsp;Set)&nbsp;(p&nbsp;:&nbsp;A&nbsp;*&nbsp;B)&nbsp;=&gt;&nbsp;let&nbsp;(x,&nbsp;_)&nbsp;:=&nbsp;p&nbsp;in&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Set,&nbsp;A&nbsp;*&nbsp;B&nbsp;-&gt;&nbsp;A</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[type_scope&nbsp;type_scope&nbsp;_]</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Remove&nbsp;Printing&nbsp;Let&nbsp;prod.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Unset&nbsp;Printing&nbsp;Synth.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Unset&nbsp;Printing&nbsp;Wildcard.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;fst.</TT><BR>
<TT><I>fst&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fun&nbsp;(A&nbsp;B&nbsp;:&nbsp;Set)&nbsp;(p&nbsp;:&nbsp;A&nbsp;*&nbsp;B)&nbsp;=&gt;&nbsp;let&nbsp;(x,&nbsp;_)&nbsp;return&nbsp;A&nbsp;:=&nbsp;p&nbsp;in&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Set,&nbsp;A&nbsp;*&nbsp;B&nbsp;-&gt;&nbsp;A</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[type_scope&nbsp;type_scope&nbsp;_]</I></TT><BR>
</DIV>
<BR>
<A NAME="toc13"></A>
<H2><A NAME="htoc32">2.3</A>&nbsp;&nbsp;Section mechanism
<A NAME="@default81"></A>
<A NAME="Section"></A></H2>
The sectioning mechanism allows to organise a proof in structured
sections. Then local declarations become available (see
Section&nbsp;<A HREF="Reference-Manual003.html#Simpl-definitions">1.3.2</A>). <BR>
<BR>

<H3><A NAME="htoc33">2.3.1</A>&nbsp;&nbsp;<TT>Section </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default82"></A><A NAME="@command40"></A></H3>
This command is used to open a section named <I><FONT COLOR=maroon>ident</FONT></I>.<BR>
<BR>

<H3><A NAME="htoc34">2.3.2</A>&nbsp;&nbsp;<TT>End </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default83"></A><A NAME="@command41"></A></H3>
This command closes the section named <I><FONT COLOR=maroon>ident</FONT></I>. When a section is
closed, all local declarations (variables and local definitions) are
<EM>discharged</EM>. This means that all global objects defined in the
section are generalised with respect to all variables and local
definitions it depends on in the section. None of the local
declarations (considered as autonomous declarations) survive the end
of the section.<BR>
<BR>
Here is an example :

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Section&nbsp;s1.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variables&nbsp;x&nbsp;y&nbsp;:&nbsp;nat.</TT><BR>
<TT><I>x&nbsp;is&nbsp;assumed</I></TT><BR>
<TT><I>y&nbsp;is&nbsp;assumed</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Let&nbsp;y'&nbsp;:=&nbsp;y.</TT><BR>
<TT><I>y'&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;x'&nbsp;:=&nbsp;S&nbsp;x.</TT><BR>
<TT><I>x'&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;x''&nbsp;:=&nbsp;x'&nbsp;+&nbsp;y'.</TT><BR>
<TT><I>x''&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;x'.</TT><BR>
<TT><I>x'&nbsp;=&nbsp;S&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;s1.</TT><BR>
<TT><I>x'&nbsp;is&nbsp;discharged.</I></TT><BR>
<TT><I>x''&nbsp;is&nbsp;discharged.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;x'.</TT><BR>
<TT><I>x'&nbsp;=&nbsp;fun&nbsp;x&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;S&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>Argument&nbsp;scope&nbsp;is&nbsp;[nat_scope]</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;x''.</TT><BR>
<TT><I>x''&nbsp;=&nbsp;fun&nbsp;x&nbsp;y&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;let&nbsp;y'&nbsp;:=&nbsp;y&nbsp;in&nbsp;x'&nbsp;x&nbsp;+&nbsp;y'</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[nat_scope&nbsp;nat_scope]</I></TT><BR>
</DIV>

Notice the difference between the value of <TT>x'</TT> and <TT>x''</TT>
inside section <TT>s1</TT> and outside.<BR>
<BR>
<BR>
<B>Error messages: </B><OL type=1><LI>
<TT>This is not the last opened section</TT><A NAME="@error10"></A>
</OL>
<BR>
<B>Remarks: </B><OL type=1><LI>
Most commands, like <TT>Hint</TT>, <TT>Notation</TT>, option management, ...
which appear inside a section are cancelled when the
section is closed.
</OL>
<A NAME="toc14"></A>
<H2><A NAME="htoc35">2.4</A>&nbsp;&nbsp;Module system
<A NAME="@default84"></A>
<A NAME="section:Modules"></A></H2>
The module system provides a way of packaging related elements
together, as well as a mean of massive abstraction.
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=right NOWRAP><I><FONT COLOR=maroon>module_type</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>ident</FONT></I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>module_type</FONT></I> <TT> with Definition </TT><I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>module_type</FONT></I> <TT> with Module </TT><I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>qualid</FONT></I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I><FONT COLOR=maroon>module_binding</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><TT>( </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>  ...  </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>module_type</FONT></I><TT> )</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I><FONT COLOR=maroon>module_bindings</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>module_binding</FONT></I>  ...  <I><FONT COLOR=maroon>module_binding</FONT></I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I><FONT COLOR=maroon>module_expression</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>qualid</FONT></I>  ...  <I><FONT COLOR=maroon>qualid</FONT></I></TD>
</TR></TABLE>
</DIV>
<BR>
<DIV ALIGN=center>Figure 2.3: Syntax of modules</DIV><BR>

<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>

<H3><A NAME="htoc36">2.4.1</A>&nbsp;&nbsp;<TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default85"></A><A NAME="@command42"></A></H3>
This command is used to start an interactive module named <I><FONT COLOR=maroon>ident</FONT></I>.<BR>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><BR>
<BR>
Starts an interactive functor with parameters given by <I><FONT COLOR=maroon>module_bindings</FONT></I>.<BR>
<BR>
<LI><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><CODE><TT>:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><BR>
<BR>
Starts an interactive module specifying its module type. <BR>
<BR>
<LI><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><BR>
<BR>
Starts an interactive functor with parameters given by
 <I><FONT COLOR=maroon>module_bindings</FONT></I>, and output module type <I><FONT COLOR=maroon>module_type</FONT></I>.<BR>
<BR>
<LI><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><BR>
<BR>
Starts an interactive module satisfying <I><FONT COLOR=maroon>module_type</FONT></I>. <BR>
<BR>
<LI><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><BR>
<BR>
Starts an interactive functor with parameters given by
 <I><FONT COLOR=maroon>module_bindings</FONT></I>. The output module type is verified against the
 module type <I><FONT COLOR=maroon>module_type</FONT></I>.</OL>

<H3><A NAME="htoc37">2.4.2</A>&nbsp;&nbsp;<TT>End </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default86"></A><A NAME="@command43"></A></H3>
This command closes the interactive module <I><FONT COLOR=maroon>ident</FONT></I>. If the module type
was given the content of the module is matched against it and an error
is signaled if the matching fails. If the module is basic (is not a
functor) its components (constants, inductive types, submodules etc) are
now available through the dot notation.<BR>
<BR>
<BR>
<B>Error messages: </B><OL type=1><LI>
<TT>No such label </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@error11"></A>
<LI><TT>Signature components for label </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> do not match</TT><A NAME="@error12"></A>
<LI><TT>This is not the last opened module</TT><A NAME="@error13"></A>
</OL>

<H3><A NAME="htoc38">2.4.3</A>&nbsp;&nbsp;<TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> := </TT><I><FONT COLOR=maroon>module_expression</FONT></I><TT>
</TT><A NAME="@default87"></A><A NAME="@command44"></A></H3>
This command defines the module identifier <I><FONT COLOR=maroon>ident</FONT></I> to be equal to
<I><FONT COLOR=maroon>module_expression</FONT></I>. <BR>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI>
<TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> := </TT><I><FONT COLOR=maroon>module_expression</FONT></I><BR>
<BR>
Defines a functor with parameters given by <I><FONT COLOR=maroon>module_bindings</FONT></I> and body <I><FONT COLOR=maroon>module_expression</FONT></I>.<BR>
<BR>
<LI><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><TT> :=
 </TT><I><FONT COLOR=maroon>module_expression</FONT></I><BR>
<BR>
Defines a functor with parameters given by <I><FONT COLOR=maroon>module_bindings</FONT></I> (possibly none),
 and output module type <I><FONT COLOR=maroon>module_type</FONT></I>, with body <I><FONT COLOR=maroon>module_expression</FONT></I>. <BR>
<BR>
<LI><TT>Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><TT> :=
 </TT><I><FONT COLOR=maroon>module_expression</FONT></I><BR>
<BR>
Defines a functor with parameters given by <I><FONT COLOR=maroon>module_bindings</FONT></I> (possibly none) 
 with body <I><FONT COLOR=maroon>module_expression</FONT></I>. The body is checked against <I><FONT COLOR=maroon>module_type</FONT></I>.</OL>

<H3><A NAME="htoc39">2.4.4</A>&nbsp;&nbsp;<TT>Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default88"></A><A NAME="@command45"></A></H3>
This command is used to start an interactive module type <I><FONT COLOR=maroon>ident</FONT></I>.<BR>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI><TT>Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><BR>
<BR>
Starts an interactive functor type with parameters given by <I><FONT COLOR=maroon>module_bindings</FONT></I>.</OL>

<H3><A NAME="htoc40">2.4.5</A>&nbsp;&nbsp;<TT>End </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default89"></A><A NAME="@command46"></A></H3>
This command closes the interactive module type <I><FONT COLOR=maroon>ident</FONT></I>.<BR>
<BR>
<BR>
<B>Error messages: </B><OL type=1><LI>
<TT>This is not the last opened module type</TT><A NAME="@error14"></A>
</OL>

<H3><A NAME="htoc41">2.4.6</A>&nbsp;&nbsp;<TT>Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> := </TT><I><FONT COLOR=maroon>module_type</FONT></I></H3>
Defines a module type <I><FONT COLOR=maroon>ident</FONT></I> equal to <I><FONT COLOR=maroon>module_type</FONT></I>.<BR>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI>
<TT>Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> := </TT><I><FONT COLOR=maroon>module_type</FONT></I><BR>
<BR>
Defines a functor type <I><FONT COLOR=maroon>ident</FONT></I> specifying functors taking arguments
 <I><FONT COLOR=maroon>module_bindings</FONT></I> and returning <I><FONT COLOR=maroon>module_type</FONT></I>.
</OL>

<H3><A NAME="htoc42">2.4.7</A>&nbsp;&nbsp;<TT>Declare Module </TT><I><FONT COLOR=maroon>ident</FONT></I></H3>
Starts an interactive module declaration. This command is available
only in module types. <BR>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI><TT>Declare Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><BR>
<BR>
Starts an interactive declaration of a functor with parameters given
 by <I><FONT COLOR=maroon>module_bindings</FONT></I>.<BR>
<BR>
<LI><TT>Declare Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><BR>
<BR>
Starts an interactive declaration of a functor with parameters given
 by <I><FONT COLOR=maroon>module_bindings</FONT></I> (possibly none). The declared output module type is
 verified against the module type <I><FONT COLOR=maroon>module_type</FONT></I>.</OL>

<H3><A NAME="htoc43">2.4.8</A>&nbsp;&nbsp;<TT>End </TT><I><FONT COLOR=maroon>ident</FONT></I></H3>
This command closes the interactive declaration of module <I><FONT COLOR=maroon>ident</FONT></I>.<BR>
<BR>

<H3><A NAME="htoc44">2.4.9</A>&nbsp;&nbsp;<TT>Declare Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>module_type</FONT></I></H3>
Declares a module of <I><FONT COLOR=maroon>ident</FONT></I> of type <I><FONT COLOR=maroon>module_type</FONT></I>. This command is available
only in module types. <BR>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI><TT>Declare Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>module_bindings</FONT></I><TT> </TT><CODE><TT>:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><BR>
<BR>
Declares a functor with parameters <I><FONT COLOR=maroon>module_bindings</FONT></I> and output module
 type <I><FONT COLOR=maroon>module_type</FONT></I>.<BR>
<BR>
<LI><TT>Declare Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> := </TT><I><FONT COLOR=maroon>qualid</FONT></I><BR>
<BR>
Declares a module equal to the module <I><FONT COLOR=maroon>qualid</FONT></I>.<BR>
<BR>
<LI><TT>Declare Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><CODE><TT>&lt;:</TT></CODE><TT> </TT><I><FONT COLOR=maroon>module_type</FONT></I><TT> := </TT><I><FONT COLOR=maroon>qualid</FONT></I><BR>
<BR>
Declares a module equal to the module <I><FONT COLOR=maroon>qualid</FONT></I>, verifying that the
 module type of the latter is a subtype of <I><FONT COLOR=maroon>module_type</FONT></I>.</OL>

<H4>Example</H4>
Let us define a simple module.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;M.</TT><BR>
<TT><I>Interactive&nbsp;Module&nbsp;M&nbsp;started</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Definition&nbsp;T&nbsp;:=&nbsp;nat.</TT><BR>
<TT><I>T&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Definition&nbsp;x&nbsp;:=&nbsp;0.</TT><BR>
<TT><I>x&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Definition&nbsp;y&nbsp;:&nbsp;bool.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;bool</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exact&nbsp;true.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Defined.</TT><BR>
<TT><I>exact&nbsp;true.</I></TT><BR>
<TT><I>y&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;M.</TT><BR>
<TT><I>Module&nbsp;M&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>

Inside a module one can define constants, prove theorems and do any
other things that can be done in the toplevel. Components of a closed
module can be accessed using the dot notation:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;M.x.</TT><BR>
<TT><I>M.x&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat</I></TT><BR>
</DIV>

A simple module type:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;Type&nbsp;SIG.</TT><BR>
<TT><I>Interactive&nbsp;Module&nbsp;Type&nbsp;SIG&nbsp;started</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Parameter&nbsp;T&nbsp;:&nbsp;Set.</TT><BR>
<TT><I>T&nbsp;is&nbsp;assumed</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Parameter&nbsp;x&nbsp;:&nbsp;T.</TT><BR>
<TT><I>x&nbsp;is&nbsp;assumed</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;SIG.</TT><BR>
<TT><I>Module&nbsp;Type&nbsp;SIG&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>

Inside a module type the proof editing mode is not available.
Consequently commands like <TT>Definition</TT> without body,
<TT>Lemma</TT>, <TT>Theorem</TT> are not allowed. In order to declare
constants, use <TT>Axiom</TT> and <TT>Parameter</TT>.<BR>
<BR>
Now we can create a new module from <TT>M</TT>, giving it a less
precise specification: the <TT>y</TT> component is dropped as well
as the body of <TT>x</TT>.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;N&nbsp;&nbsp;:&nbsp;&nbsp;SIG&nbsp;with&nbsp;Definition&nbsp;T&nbsp;:=&nbsp;nat&nbsp;&nbsp;:=&nbsp;&nbsp;M.</TT><BR>
<TT><I>Coq&nbsp;&lt;&nbsp;Coq&nbsp;&lt;&nbsp;Module&nbsp;N&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;N.T.</TT><BR>
<TT><I>N.T&nbsp;=&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Set</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;N.x.</TT><BR>
<TT><I>***&nbsp;[&nbsp;N.x&nbsp;:&nbsp;N.T&nbsp;]</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;N.y.</TT><BR>
<TT><I>User&nbsp;error:&nbsp;N.y&nbsp;not&nbsp;a&nbsp;defined&nbsp;object</I></TT><BR>
</DIV>
<BR>
The definition of <TT>N</TT> using the module type expression
<TT>SIG with Definition T:=nat</TT> is equivalent to the following
one:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;Type&nbsp;SIG'.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Definition&nbsp;T&nbsp;:&nbsp;Set&nbsp;:=&nbsp;nat.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Parameter&nbsp;x&nbsp;:&nbsp;T.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;SIG'.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;N&nbsp;:&nbsp;SIG'&nbsp;:=&nbsp;M.</TT><BR>
</DIV>

If we just want to be sure that the our implementation satisfies a
given module type without restricting the interface, we can use a
transparent constraint

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;P&nbsp;&lt;:&nbsp;SIG&nbsp;:=&nbsp;M.</TT><BR>
<TT><I>Module&nbsp;P&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;P.y.</TT><BR>
<TT><I>P.y&nbsp;=&nbsp;true</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool</I></TT><BR>
</DIV>

Now let us create a functor, i.e. a parametric module

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;Two&nbsp;(X&nbsp;Y:&nbsp;SIG).</TT><BR>
<TT><I>Interactive&nbsp;Module&nbsp;Two&nbsp;started</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Definition&nbsp;T&nbsp;:=&nbsp;(X.T&nbsp;*&nbsp;Y.T)%type.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Definition&nbsp;x&nbsp;:=&nbsp;(X.x,&nbsp;Y.x).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;Two.</TT><BR>
<TT><I>Module&nbsp;Two&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>

and apply it to our modules and do some computations

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;Q&nbsp;:=&nbsp;Two&nbsp;M&nbsp;N.</TT><BR>
<TT><I>Module&nbsp;Q&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Eval&nbsp;compute&nbsp;in&nbsp;(fst&nbsp;Q.x&nbsp;+&nbsp;snd&nbsp;Q.x).</TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;N.x</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat</I></TT><BR>
</DIV>

In the end, let us define a module type with two sub-modules, sharing
some of the fields and give one of its possible implementations:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;Type&nbsp;SIG2.</TT><BR>
<TT><I>Interactive&nbsp;Module&nbsp;Type&nbsp;SIG2&nbsp;started</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Declare&nbsp;Module&nbsp;M1&nbsp;:&nbsp;SIG.</TT><BR>
<TT><I>Module&nbsp;M1&nbsp;is&nbsp;declared</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Declare&nbsp;Module&nbsp;M2&nbsp;&lt;:&nbsp;SIG.</TT><BR>
<TT><I>Interactive&nbsp;Declaration&nbsp;of&nbsp;Module&nbsp;M2&nbsp;started</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Definition&nbsp;T&nbsp;:=&nbsp;M1.T.</TT><BR>
<TT><I>T&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter&nbsp;x&nbsp;:&nbsp;T.</TT><BR>
<TT><I>x&nbsp;is&nbsp;assumed</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;End&nbsp;M2.</TT><BR>
<TT><I>Module&nbsp;M2&nbsp;is&nbsp;declared</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;SIG2.</TT><BR>
<TT><I>Module&nbsp;Type&nbsp;SIG2&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;Mod&nbsp;&lt;:&nbsp;SIG2.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Module&nbsp;M1.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Definition&nbsp;T&nbsp;:=&nbsp;nat.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Definition&nbsp;x&nbsp;:=&nbsp;1.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;End&nbsp;M1.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Module&nbsp;M2&nbsp;:=&nbsp;M.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;Mod.</TT><BR>
<TT><I>Module&nbsp;Mod&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>

Notice that <TT>M</TT> is a correct body for the component <TT>M2</TT>
since its <TT>T</TT> component is equal <TT>nat</TT> and hence
<TT>M1.T</TT> as specified.<BR>
<BR>
<BR>
<B>Remarks: </B><OL type=1><LI>
Modules and module types can be nested components of each other.
<LI>When a module declaration is started inside a module type,
 the proof editing mode is still unavailable.
<LI>One can have sections inside a module or a module type, but
 not a module or a module type inside a section.
<LI>Commands like <TT>Hint</TT> or <TT>Notation</TT> can
 also appear inside modules and module types. Note that in case of a
 module definition like:<BR>
<BR>
<BR>
<TT>Module N : SIG := M.</TT> 
 <BR>
<BR>
<BR>
 or<BR>
<BR>
<BR>
<TT>Module N : SIG.<BR>
  ...<BR>
End N.</TT>
 <BR>
hints and the like valid for <TT>N</TT> are not those defined in
 <TT>M</TT> (or the module body) but the ones defined in
 <TT>SIG</TT>.</OL>

<H3><A NAME="htoc45">2.4.10</A>&nbsp;&nbsp;Import <I><FONT COLOR=maroon>qualid</FONT></I>
<A NAME="@default90"></A><A NAME="@command47"></A>
<A NAME="Import"></A></H3>
If <I><FONT COLOR=maroon>qualid</FONT></I> denotes a valid basic module (i.e. its module type is a
signature), makes its components available by their short names.<BR>
<BR>
Example:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Module&nbsp;Mod.</TT><BR>
<TT><I>Interactive&nbsp;Module&nbsp;Mod&nbsp;started</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Definition&nbsp;T:=nat.</TT><BR>
<TT><I>T&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Check&nbsp;T.</TT><BR>
<TT><I>T</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Set</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;End&nbsp;Mod.</TT><BR>
<TT><I>Module&nbsp;Mod&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;Mod.T.</TT><BR>
<TT><I>Mod.T</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Set</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;T.&nbsp;(*&nbsp;Incorrect&nbsp;!&nbsp;*)</TT><BR>
<TT><I>Toplevel&nbsp;input,&nbsp;characters&nbsp;1102-1103</I></TT><BR>
<TT><I>&gt;&nbsp;Check&nbsp;T.</I></TT><BR>
<TT><I>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</I></TT><BR>
<TT><I>Error:&nbsp;The&nbsp;reference&nbsp;T&nbsp;was&nbsp;not&nbsp;found&nbsp;in&nbsp;the&nbsp;current&nbsp;environment</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Import&nbsp;Mod.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;T.&nbsp;(*&nbsp;Now&nbsp;correct&nbsp;*)</TT><BR>
<TT><I>T</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Set</I></TT><BR>
</DIV>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI>
<TT>Export </TT><I><FONT COLOR=maroon>qualid</FONT></I><A NAME="@default91"></A><A NAME="@command48"></A><BR>
<BR>
When the module containing the command <TT>Export </TT><I><FONT COLOR=maroon>qualid</FONT></I> is
 imported, <I><FONT COLOR=maroon>qualid</FONT></I> is imported as well.
</OL>
<BR>
<B>Error messages: </B><OL type=1><LI>
 <TT></TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> is not a module</TT><A NAME="@error15"></A>
</OL>
<BR>
<B>Warnings: </B><OL type=1><LI>
 Warning: Trying to mask the absolute name <I><FONT COLOR=maroon>qualid</FONT></I> !
</OL>

<H3><A NAME="htoc46">2.4.11</A>&nbsp;&nbsp;<TT>Print Module </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default92"></A><A NAME="@command49"></A></H3>
Prints the module type and (optionally) the body of the module <I><FONT COLOR=maroon>ident</FONT></I>.<BR>
<BR>

<H3><A NAME="htoc47">2.4.12</A>&nbsp;&nbsp;<TT>Print Module Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default93"></A><A NAME="@command50"></A></H3>
Prints the module type corresponding to <I><FONT COLOR=maroon>ident</FONT></I>.<BR>
<BR>
<A NAME="toc15"></A>
<H2><A NAME="htoc48">2.5</A>&nbsp;&nbsp;Libraries and qualified names</H2>

<H3><A NAME="htoc49">2.5.1</A>&nbsp;&nbsp;Names of libraries and files
<A NAME="Libraries"></A>
<A NAME="@default94"></A>
<A NAME="@default95"></A></H3>

<H5>Libraries</H5>
The theories developed in <FONT COLOR=navy>Coq</FONT> are stored in <EM>libraries</EM>. A
library is characterised by a name called <I>root</I> of the
library. The standard library of <FONT COLOR=navy>Coq</FONT> has root name <TT>Coq</TT> and is
known by default when a <FONT COLOR=navy>Coq</FONT> session starts.<BR>
<BR>
Libraries have a tree structure. E.g., the <TT>Coq</TT> library
contains the sub-libraries <TT>Init</TT>, <TT>Logic</TT>, <TT>Arith</TT>, <TT>Lists</TT>, ... The ``dot notation'' is used to separate the different
component of a library name. For instance, the <TT>Arith</TT> library of
<FONT COLOR=navy>Coq</FONT> standard library is written ``<TT>Coq.Arith</TT>''.<BR>
<BR>
<BR>
<BR>
<B>Remark: </B>no blank is allowed between the dot and the identifier on its
right, otherwise the dot is interpreted as the full stop (period) of
the command!
<BR>
<BR>
<BR>

<H5>Physical paths vs logical paths</H5>
Libraries and sub-libraries are denoted by <EM>logical directory
paths</EM> (written <I><FONT COLOR=maroon>dirpath</FONT></I> and of which the syntax is the same as
<I><FONT COLOR=maroon>qualid</FONT></I>, see <A HREF="Reference-Manual003.html#qualid">1.2.3</A>). Logical directory
paths can be mapped to physical directories of the
operating system using the command (see <A HREF="Reference-Manual008.html#AddLoadPath">6.5.3</A>)
<BLOCKQUOTE>
<TT>Add LoadPath <I>physical_path</I> as </TT><I><FONT COLOR=maroon>dirpath</FONT></I>.
</BLOCKQUOTE>
A library can inherit the tree structure of a physical directory by
using the <TT>-R</TT> option to <TT>coqtop</TT> or the
command (see <A HREF="Reference-Manual008.html#AddRecLoadPath">6.5.4</A>)
<BLOCKQUOTE>
<TT>Add Rec LoadPath <I>physical_path</I> as </TT><I><FONT COLOR=maroon>dirpath</FONT></I>.
</BLOCKQUOTE>
<BR>
<B>Remark: </B>When used interactively with <TT>coqtop</TT> command, <FONT COLOR=navy>Coq</FONT> opens a
library called <TT>Top</TT>.<BR>
<BR>

<H5>The file level</H5>
At some point, (sub-)libraries contain <I>modules</I> which coincide
with files at the physical level. As for sublibraries, the dot
notation is used to denote a specific module of a library. Typically,
<TT>Coq.Init.Logic</TT> is the logical path associated to the file <TT>Logic.v</TT> of <FONT COLOR=navy>Coq</FONT> standard library. Notice that compilation (see
<A HREF="Reference-Manual014.html#Addoc-coqc">12</A>) is done at the level of files.<BR>
<BR>
If the physical directory where a file <TT>File.v</TT> lies is mapped to
the empty logical directory path (which is the default when using the
simple form of <TT>Add LoadPath</TT> or <TT>-I</TT> option to coqtop), then
the name of the module it defines is <TT>File</TT>.<BR>
<BR>

<H3><A NAME="htoc50">2.5.2</A>&nbsp;&nbsp;Qualified names
<A NAME="LongNames"></A>
<A NAME="@default96"></A>
<A NAME="@default97"></A></H3>
Modules contain constructions (sub-modules, axioms, parameters,
definitions, lemmas, theorems, remarks or facts). The (full) name of a
construction starts with the logical name of the module in which it is defined
followed by the (short) name of the construction.
Typically, the full name <TT>Coq.Init.Logic.eq</TT> denotes Leibniz' equality
defined in the module <TT>Logic</TT> in the sublibrary <TT>Init</TT> of the
standard library of <FONT COLOR=navy>Coq</FONT>.<BR>
<BR>

<H5>Absolute, partially qualified and short names</H5>
The full name of a library, module, section, definition, theorem,
... is its <I>absolute name</I>. The last identifier (<TT>eq</TT> in the
previous example) is its <I>short name</I> (or sometimes <I>base
name</I>). Any suffix of the absolute name is a <EM>partially qualified
name</EM> (e.g. <TT>Logic.eq</TT> is a partially qualified name for <TT>Coq.Init.Logic.eq</TT>). Partially qualified names (shortly <EM>qualified name</EM>) are also built from identifiers separated by dots.
They are written <I><FONT COLOR=maroon>qualid</FONT></I> in the documentation.<BR>
<BR>
<FONT COLOR=navy>Coq</FONT> does not accept two constructions (definition, theorem, ...)
with the same absolute name but different constructions can have the
same short name (or even same partially qualified names as soon as the
full names are different).<BR>
<BR>

<H5>Visibility</H5>
<FONT COLOR=navy>Coq</FONT> maintains a <I>name table</I> mapping qualified names to absolute
names. This table is modified by the commands <TT>Require</TT> (see
<A HREF="Reference-Manual008.html#Require">6.4.1</A>), <TT>Import</TT> and <TT>Export</TT> (see <A HREF="#Import">2.4.10</A>) and
also each time a new declaration is added to the context.<BR>
<BR>
An absolute name is called <I>visible</I> from a given short or
partially qualified name when this name suffices to denote it. This
means that the short or partially qualified name is mapped to the absolute
name in <FONT COLOR=navy>Coq</FONT> name table.<BR>
<BR>
It may happen that a visible name is hidden by the short name or a
qualified name of another construction. In this case, the name that
has been hidden must be referred to using one more level of
qualification. Still, to ensure that a construction always remains
accessible, absolute names can never be hidden.<BR>
<BR>
Examples:

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;0.</TT><BR>
<TT><I>0</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;nat&nbsp;:=&nbsp;bool.</TT><BR>
<TT><I>nat&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;0.</TT><BR>
<TT><I>0</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Datatypes.nat</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;Datatypes.nat.</TT><BR>
<TT><I>Datatypes.nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Set</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Locate&nbsp;nat.</TT><BR>
<TT><I>Constant&nbsp;Top.nat</I></TT><BR>
<TT><I>Inductive&nbsp;Coq.Init.Datatypes.nat&nbsp;(visible&nbsp;as&nbsp;Datatypes.nat)</I></TT><BR>
</DIV>
<BR>
<BR>
<B>Remark: </B>There is also a name table for sublibraries, modules and sections.<BR>
<BR>
<BR>
<B>Remark: </B>In versions prior to <FONT COLOR=navy>Coq</FONT> 7.4, lemmas declared with <TT>Remark</TT> and <TT>Fact</TT> kept in their full name the names of the
sections in which they were defined. Since <FONT COLOR=navy>Coq</FONT> 7.4, they strictly
behaves as <TT>Theorem</TT> and <TT>Lemma</TT> do.<BR>
<BR>
<BR>
<B>See also: </B>Command <TT>Locate</TT> in Section&nbsp;<A HREF="Reference-Manual008.html#Locate">6.2.10</A>.<BR>
<BR>

<H5>Requiring a file</H5>
A module compiled in a ``.vo'' file comes with a logical names (e.g. 
physical file <CODE>theories/Init/Datatypes.vo</CODE> in the <FONT COLOR=navy>Coq</FONT> installation directory is bound to the logical module <TT>Coq.Init.Datatypes</TT>). 
When requiring the file, the mapping between physical directories and logical library should be consistent with the mapping used to compile the file (for modules of the standard library, this is automatic -- check it by typing <TT>Print LoadPath</TT>).<BR>
<BR>
The command <TT>Add Rec LoadPath</TT> is also available from <TT>coqtop</TT>
and <TT>coqc</TT> by using option&nbsp;<CODE>-R</CODE>.<BR>
<BR>
<A NAME="toc16"></A>
<H2><A NAME="htoc51">2.6</A>&nbsp;&nbsp;Implicit arguments
<A NAME="@default98"></A>
<A NAME="Implicit Arguments"></A></H2>
An implicit argument of a function is an argument which can be
inferred from the knowledge of the type of other arguments of the
function, or of the type of the surrounding context of the application.
Especially, an implicit argument corresponds to a parameter
dependent in the type of the function. Typical implicit
arguments are the type arguments in polymorphic functions.
More precisely, there are several kinds of implicit arguments.<BR>
<BR>

<H5>Strict Implicit Arguments.</H5> 
An implicit argument can be either strict or non strict. An implicit
argument is said <EM>strict</EM> if, whatever the other arguments of the
function are, it is still inferable from the type of some other
argument. Technically, an implicit argument is strict if it
corresponds to a parameter which is not applied to a variable which
itself is another parameter of the function (since this parameter
may erase its arguments), not in the body of a <TT>match</TT>, and not
itself applied or matched against patterns (since the original
form of the argument can be lost by reduction).<BR>
<BR>
For instance, the first argument of
<BLOCKQUOTE>
<CODE>cons: forall A:Set, A -&gt; list A -&gt; list A</CODE>
</BLOCKQUOTE>
in module <TT>List.v</TT> is strict because <TT>list</TT> is an inductive
type and <TT>A</TT> will always be inferable from the type <TT>list A</TT> of the third argument of <TT>cons</TT>.
On the opposite, the second argument of a term of type 
<BLOCKQUOTE>
<CODE>forall P:nat-&gt;Prop, forall n:nat, P n -&gt; ex nat P</CODE>
</BLOCKQUOTE>
is implicit but not strict, since it can only be inferred from the
type <TT>P n</TT> of the the third argument and if <TT>P</TT> is e.g. <TT>fun _ =&gt; True</TT>, it reduces to an expression where <TT>n</TT> does not
occur any longer. The first argument <TT>P</TT> is implicit but not
strict either because it can only be inferred from <TT>P n</TT> and <TT>P</TT> is not canonically inferable from an arbitrary <TT>n</TT> and the
normal form of <TT>P n</TT> (consider e.g. that <TT>n</TT> is <TT>0</TT> and
the third argument has type <TT>True</TT>, then any <TT>P</TT> of the form
<TT>fun n =&gt; match n with 0 =&gt; True | _ =&gt; <EM>anything</EM> end</TT> would
be a solution of the inference problem.<BR>
<BR>

<H5>Contextual Implicit Arguments.</H5> 
An implicit argument can be <EM>contextual</EM> or non. An implicit
argument is said <EM>contextual</EM> if it can be inferred only from the
knowledge of the type of the context of the current expression. For
instance, the only argument of
<BLOCKQUOTE>
<CODE>nil : forall A:Set, list A</CODE>
</BLOCKQUOTE>
is contextual. Similarly, both arguments of a term of type
<BLOCKQUOTE>
<CODE>forall P:nat-&gt;Prop, forall n:nat, P n \/ n = 0</CODE>
</BLOCKQUOTE>
are contextual (moreover, <TT>n</TT> is strict and <TT>P</TT> is not).<BR>
<BR>

<H3><A NAME="htoc52">2.6.1</A>&nbsp;&nbsp;Casual use of implicit arguments</H3>
In a given expression, if it is clear that some argument of a function
can be inferred from the type of the other arguments, the user can
force the given argument to be guessed by replacing it by ``<TT>_</TT>''. If
possible, the correct argument will be automatically generated.<BR>
<BR>
<BR>
<B>Error messages: </B><OL type=1><LI><TT>Cannot infer a term for this placeholder</TT><A NAME="@error16"></A><BR>
<BR>
<FONT COLOR=navy>Coq</FONT> was not able to deduce an instantiation of a ``<TT>_</TT>''.</OL>

<H3><A NAME="htoc53">2.6.2</A>&nbsp;&nbsp;Declaration of implicit arguments for a constant
<A NAME="@default99"></A><A NAME="@command51"></A></H3>
In case one wants that some arguments of a given object (constant,
inductive types, constructors, assumptions, local or not) are always
inferred by Coq, one may declare once for all which are the expected
implicit arguments of this object. The syntax is
<BLOCKQUOTE>
<TT>Implicit Arguments </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> [ </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>  ...  </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> ]
</TT></BLOCKQUOTE>
where the list of <I><FONT COLOR=maroon>ident</FONT></I> is the list of parameters to be declared
implicit. After this, implicit arguments can just (and have to) be
skipped in any expression involving an application of <I><FONT COLOR=maroon>qualid</FONT></I>.<BR>
<BR>
<BR>
<B>Example: </B>
<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;list&nbsp;(A:Set)&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;|&nbsp;nil&nbsp;:&nbsp;list&nbsp;A&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;|&nbsp;cons&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(cons&nbsp;nat&nbsp;3&nbsp;(nil&nbsp;nat)).</TT><BR>
<TT><I>cons&nbsp;nat&nbsp;3&nbsp;(nil&nbsp;nat)</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;list&nbsp;nat</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Implicit&nbsp;Arguments&nbsp;cons&nbsp;[A].</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Implicit&nbsp;Arguments&nbsp;nil&nbsp;[A].</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(cons&nbsp;3&nbsp;nil).</TT><BR>
<TT><I>cons&nbsp;3&nbsp;nil</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;list&nbsp;nat</I></TT><BR>
</DIV>
<BR>
<BR>
<B>Remark: </B>To know which are the implicit arguments of an object, use command
<TT>Print Implicit</TT> (see <A HREF="#PrintImplicit">2.6.8</A>).<BR>
<BR>
<BR>
<B>Remark: </B>If the list of arguments is empty, the command removes the
implicit arguments of <I><FONT COLOR=maroon>qualid</FONT></I>.<BR>
<BR>

<H3><A NAME="htoc54">2.6.3</A>&nbsp;&nbsp;Automatic declaration of implicit arguments for a constant</H3>
<FONT COLOR=navy>Coq</FONT> can also automatically detect what are the implicit arguments
of a defined object. The command is just
<BLOCKQUOTE>
<TT>Implicit Arguments </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>.
</TT></BLOCKQUOTE>
The auto-detection is governed by options telling if strict and
contextual implicit arguments must be considered or not (see
Sections&nbsp;<A HREF="#SetStrictImplicit">2.6.5</A> and&nbsp;<A HREF="#SetContextualImplicit">2.6.6</A>). <BR>
<BR>
<BR>
<B>Example: </B>
<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;list&nbsp;(A:Set)&nbsp;:&nbsp;Set&nbsp;:=&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;nil&nbsp;:&nbsp;list&nbsp;A&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;cons&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Implicit&nbsp;Arguments&nbsp;cons.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;Implicit&nbsp;cons.</TT><BR>
<TT><I>cons&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Set,&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A</I></TT><BR>
<TT><I>Argument&nbsp;A&nbsp;is&nbsp;implicit</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Implicit&nbsp;Arguments&nbsp;nil.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;Implicit&nbsp;nil.</TT><BR>
<TT><I>nil&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Set,&nbsp;list&nbsp;A</I></TT><BR>
<TT><I>No&nbsp;implicit&nbsp;arguments</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Set&nbsp;Contextual&nbsp;Implicit.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Implicit&nbsp;Arguments&nbsp;nil.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;Implicit&nbsp;nil.</TT><BR>
<TT><I>nil&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Set,&nbsp;list&nbsp;A</I></TT><BR>
<TT><I>Argument&nbsp;A&nbsp;is&nbsp;implicit</I></TT><BR>
</DIV>
<BR>
The computation of implicit arguments takes account of the
unfolding of constants. For instance, the variable <TT>p</TT> below has
type <TT>(Transitivity R)</TT> which is reducible to <TT>forall x,y:U, R x
y -&gt; forall z:U, R y z -&gt; R x z</TT>. As the variables <TT>x</TT>, <TT>y</TT> and
<TT>z</TT> appear strictly in body of the type, they are implicit.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Variable&nbsp;X&nbsp;:&nbsp;Type.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;Relation&nbsp;:=&nbsp;X&nbsp;-&gt;&nbsp;X&nbsp;-&gt;&nbsp;Prop.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;Transitivity&nbsp;(R:Relation)&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y:X,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;forall&nbsp;z:X,&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variables&nbsp;(R&nbsp;:&nbsp;Relation)&nbsp;(p&nbsp;:&nbsp;Transitivity&nbsp;R).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Implicit&nbsp;Arguments&nbsp;p.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;p.</TT><BR>
<TT><I>***&nbsp;[&nbsp;p&nbsp;:&nbsp;Transitivity&nbsp;R&nbsp;]</I></TT><BR>
<TT><I>Expanded&nbsp;type&nbsp;for&nbsp;implicit&nbsp;arguments</I></TT><BR>
<TT><I>p&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;X,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;forall&nbsp;z&nbsp;:&nbsp;X,&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>Arguments&nbsp;x,&nbsp;y,&nbsp;z&nbsp;are&nbsp;implicit</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;Implicit&nbsp;p.</TT><BR>
<TT><I>p&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;X,&nbsp;R&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;forall&nbsp;z&nbsp;:&nbsp;X,&nbsp;R&nbsp;y&nbsp;z&nbsp;-&gt;&nbsp;R&nbsp;x&nbsp;z</I></TT><BR>
<TT><I>Arguments&nbsp;x,&nbsp;y,&nbsp;z&nbsp;are&nbsp;implicit</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Variables&nbsp;(a&nbsp;b&nbsp;c&nbsp;:&nbsp;X)&nbsp;(r1&nbsp;:&nbsp;R&nbsp;a&nbsp;b)&nbsp;(r2&nbsp;:&nbsp;R&nbsp;b&nbsp;c).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(p&nbsp;r1&nbsp;r2).</TT><BR>
<TT><I>p&nbsp;r1&nbsp;r2</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;R&nbsp;a&nbsp;c</I></TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc55">2.6.4</A>&nbsp;&nbsp;Mode for automatic declaration of implicit arguments
<A NAME="Auto-implicit"></A>
<A NAME="@default100"></A><A NAME="@command52"></A>
<A NAME="@default101"></A><A NAME="@command53"></A></H3>
In case one wants to systematically declare implicit the arguments
detectable as such, one may switch to the automatic declaration of
implicit arguments mode by using the command
<BLOCKQUOTE>
<TT>Set Implicit Arguments.
</TT></BLOCKQUOTE>
Conversely, one may unset the mode by using <TT>Unset Implicit
Arguments</TT>. The mode is off by default. Auto-detection of implicit
arguments is governed by options controlling whether strict and
contextual implicit arguments have to be considered or not.<BR>
<BR>

<H3><A NAME="htoc56">2.6.5</A>&nbsp;&nbsp;Controlling strict implicit arguments
<A NAME="@default102"></A><A NAME="@command54"></A>
<A NAME="@default103"></A><A NAME="@command55"></A>
<A NAME="SetStrictImplicit"></A></H3>
By default, <FONT COLOR=navy>Coq</FONT> automatically set implicit only the strict implicit
arguments. To relax this constraint, use command 
<BLOCKQUOTE>
<TT>Unset Strict Implicit.
</TT></BLOCKQUOTE>
Conversely, use command <TT>Set Strict Implicit</TT> to
restore the strict implicit mode.<BR>
<BR>
<BR>
<B>Remark: </B>In versions of <FONT COLOR=navy>Coq</FONT> prior to version 8.0, the default was to
declare the strict implicit arguments as implicit.<BR>
<BR>

<H3><A NAME="htoc57">2.6.6</A>&nbsp;&nbsp;Controlling contextual implicit arguments
<A NAME="@default104"></A><A NAME="@command56"></A>
<A NAME="@default105"></A><A NAME="@command57"></A>
<A NAME="SetContextualImplicit"></A></H3>
By default, <FONT COLOR=navy>Coq</FONT> does not automatically set implicit the contextual
implicit arguments. To tell <FONT COLOR=navy>Coq</FONT> to infer also contextual implicit
argument, use command 
<BLOCKQUOTE>
<TT>Set Contextual Implicit. 
</TT></BLOCKQUOTE>
Conversely, use command <TT>Unset Contextual Implicit</TT> to
unset the contextual implicit mode.<BR>
<BR>

<H3><A NAME="htoc58">2.6.7</A>&nbsp;&nbsp;Explicit Applications
<A NAME="@default106"></A>
<A NAME="Implicits-explicitation"></A>
<A NAME="@default107"></A></H3>
In presence of non strict or contextual argument, or in presence of
partial applications, the synthesis of implicit arguments may fail, so
one may have to give explicitly certain implicit arguments of an
application. The syntax for this is <TT>(</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>:=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>)</TT> where <I><FONT COLOR=maroon>ident</FONT></I>
is the name of the implicit argument and <I><FONT COLOR=maroon>term</FONT></I> is its corresponding
explicit term. Alternatively, one can locally deactivate the hidding of
implicit arguments of a function by using the notation
<TT>@</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>&nbsp;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT>..</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB>. This syntax extension is
given Figure&nbsp;<A HREF="#fig:explicitations">2.4</A>.
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I></TD>
<TD ALIGN=center NOWRAP>++=</TD>
<TD ALIGN=left NOWRAP>@ <I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>term</FONT></I>  ...  <I><FONT COLOR=maroon>term</FONT></I></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP>@ <I><FONT COLOR=maroon>qualid</FONT></I></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>qualid</FONT></I> <I><FONT COLOR=maroon>argument</FONT></I>  ...  <I><FONT COLOR=maroon>argument</FONT></I></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>argument</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>(</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>:=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>)</TT></TD>
</TR></TABLE>
</DIV>
<BR>
<DIV ALIGN=center>Figure 2.4: Syntax for explicitations of implicit arguments</DIV><BR>

<A NAME="fig:explicitations"></A>
<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
<B>Example (continued): </B>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(p&nbsp;r1&nbsp;(z:=c)).</TT><BR>
<TT><I>p&nbsp;r1&nbsp;(z:=c)</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;R&nbsp;b&nbsp;c&nbsp;-&gt;&nbsp;R&nbsp;a&nbsp;c</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(p&nbsp;(x:=a)&nbsp;(y:=b)&nbsp;r1&nbsp;(z:=c)&nbsp;r2).</TT><BR>
<TT><I>p&nbsp;r1&nbsp;r2</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;R&nbsp;a&nbsp;c</I></TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc59">2.6.8</A>&nbsp;&nbsp;Displaying what the implicit arguments are
<A NAME="@default108"></A><A NAME="@command58"></A>
<A NAME="PrintImplicit"></A></H3>
To display the implicit arguments associated to an object use command
<BLOCKQUOTE>
<TT>Print Implicit </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>.
</TT></BLOCKQUOTE>

<H3><A NAME="htoc60">2.6.9</A>&nbsp;&nbsp;Explicitation of implicit arguments for pretty-printing
<A NAME="@default109"></A><A NAME="@command59"></A>
<A NAME="@default110"></A><A NAME="@command60"></A></H3>
By default the basic pretty-printing rules hide the inferable implicit
arguments of an application. To force printing all implicit arguments,
use command
<BLOCKQUOTE>
<TT>Set Printing Implicit.</TT>
</BLOCKQUOTE>
Conversely, to restore the hidding of implicit arguments, use command
<BLOCKQUOTE>
<TT>Unset Printing Implicit.</TT>
</BLOCKQUOTE>
<BR>
<B>See also: </B><TT>Set Printing All</TT> in section <A HREF="#SetPrintingAll">2.8</A>.<BR>
<BR>

<H3><A NAME="htoc61">2.6.10</A>&nbsp;&nbsp;Interaction with subtyping</H3>
When an implicit argument can be inferred from the type of more than
one of the other arguments, then only the type of the first of these
arguments is taken into account, and not an upper type of all of
them. As a consequence, the inference of the implicit argument of
``='' fails in<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;nat&nbsp;=&nbsp;Prop.</TT><BR>
</DIV>
<BR>
but succeeds in <BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;Prop&nbsp;=&nbsp;nat.</TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc62">2.6.11</A>&nbsp;&nbsp;Canonical structures
<A NAME="@default111"></A><A NAME="@command61"></A></H3>
A canonical structure is an instance of a record/structure type that
can be used to solve equations involving implicit arguments. Assume
that <I><FONT COLOR=maroon>qualid</FONT></I> denotes an object (<I>Build</I>_<I>struc</I>&nbsp; <I>c</I><SUB><FONT SIZE=2>1</FONT></SUB>&nbsp; ...&nbsp; <I>c</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) in the
structure <EM>struct</EM> of which the fields are <I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>, ...,
<I>x</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>. Assume that <I><FONT COLOR=maroon>qualid</FONT></I> is declared as a canonical structure
using the command
<BLOCKQUOTE>
<TT>Canonical Structure </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT>.</TT>
</BLOCKQUOTE>
Then, each time an equation of the form (<I>x</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>&nbsp;
_)=<SUB><FONT SIZE=2>betadeltaiotazeta</FONT></SUB><I>c</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> has to be solved during the
type-checking process, <I><FONT COLOR=maroon>qualid</FONT></I> is used as a solution. Otherwise
said, <I><FONT COLOR=maroon>qualid</FONT></I> is canonically used to extend the field <I>c</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> into a
complete structure built on <I>c</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB>.<BR>
<BR>
Canonical structures are particularly useful when mixed with
coercions and strict implicit arguments. Here is an example.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Relations.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;EqNat.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Set&nbsp;Implicit&nbsp;Arguments.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Unset&nbsp;Strict&nbsp;Implicit.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Structure&nbsp;Setoid&nbsp;:&nbsp;Type&nbsp;:=&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;{Carrier&nbsp;:&gt;&nbsp;Set;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;Equal&nbsp;:&nbsp;relation&nbsp;Carrier;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;Prf_equiv&nbsp;:&nbsp;equivalence&nbsp;Carrier&nbsp;Equal}.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;is_law&nbsp;(A&nbsp;B:Setoid)&nbsp;(f:A&nbsp;-&gt;&nbsp;B)&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y:A,&nbsp;Equal&nbsp;x&nbsp;y&nbsp;-&gt;&nbsp;Equal&nbsp;(f&nbsp;x)&nbsp;(f&nbsp;y).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Axiom&nbsp;eq_nat_equiv&nbsp;:&nbsp;equivalence&nbsp;nat&nbsp;eq_nat.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;nat_setoid&nbsp;:&nbsp;Setoid&nbsp;:=&nbsp;Build_Setoid&nbsp;eq_nat_equiv.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Canonical&nbsp;Structure&nbsp;nat_setoid.</TT><BR>
</DIV>
<BR>
Thanks to <TT>nat_setoid</TT> declared as canonical, the implicit
arguments <TT>A</TT> and <TT>B</TT> can be synthesised in the next statement.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;is_law_S&nbsp;:&nbsp;is_law&nbsp;S.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;is_law&nbsp;(A:=nat_setoid)&nbsp;(B:=nat_setoid)&nbsp;S</I></TT><BR>
</DIV>
<BR>
<BR>
<B>Remark: </B>If a same field occurs in several canonical structure, then
only the structure declared first as canonical is considered.<BR>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI>
<TT>Canonical Structure </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><TT>.</TT><BR>
<TT>Canonical Structure </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><TT>.</TT><BR>
<TT>Canonical Structure </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><TT>.</TT><BR>
<BR>
These are equivalent to a regular definition of <I><FONT COLOR=maroon>ident</FONT></I> followed by
the declaration <BR>
<BR>
<TT>Canonical Structure </TT><I><FONT COLOR=maroon>ident</FONT></I>.
</OL>
<BR>
<B>See also: </B>more examples in user contribution <TT>category</TT>
(<TT>Rocq/ALGEBRA</TT>).<BR>
<BR>

<H3><A NAME="htoc63">2.6.12</A>&nbsp;&nbsp;Implicit types of variables</H3>
It is possible to bind variable names to a given type (e.g. in a
development using arithmetic, it may be convenient to bind the names
<TT>n</TT> or <TT>m</TT> to the type <TT>nat</TT> of natural numbers). The
command for that is
<BLOCKQUOTE>
<TT>Implicit Types </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>  ...  </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><TT>
</TT></BLOCKQUOTE>
The effect of the command is to automatically set the type of bound
variables starting with <I><FONT COLOR=maroon>ident</FONT></I> (either <I><FONT COLOR=maroon>ident</FONT></I> itself or
<I><FONT COLOR=maroon>ident</FONT></I> followed by one or more single quotes, underscore or digits)
to be <I><FONT COLOR=maroon>type</FONT></I> (unless the bound variable is already declared with an
explicit type in which case, this latter type is considered).<BR>
<BR>
<BR>
<B>Example: </B>
<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;List.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Implicit&nbsp;Types&nbsp;m&nbsp;n&nbsp;:&nbsp;nat.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;cons_inj_nat&nbsp;:&nbsp;forall&nbsp;m&nbsp;n&nbsp;l,&nbsp;n&nbsp;::&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;m.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;m&nbsp;n&nbsp;(l&nbsp;:&nbsp;list&nbsp;nat),&nbsp;n&nbsp;::&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;m</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;m&nbsp;n.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;m&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;l&nbsp;:&nbsp;list&nbsp;nat,&nbsp;n&nbsp;::&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;m</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;cons_inj_bool&nbsp;:&nbsp;forall&nbsp;(m&nbsp;n:bool)&nbsp;l,&nbsp;n&nbsp;::&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;m.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;(m&nbsp;n&nbsp;:&nbsp;bool)&nbsp;(l&nbsp;:&nbsp;list&nbsp;bool),&nbsp;n&nbsp;::&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;m</I></TT><BR>
</DIV>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI>
<TT>Implicit Type </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><BR>
This is useful for declaring the implicit type of a single variable.
</OL>
<A NAME="toc17"></A>
<H2><A NAME="htoc64">2.7</A>&nbsp;&nbsp;Coercions
<A NAME="Coercions"></A>
<A NAME="@default112"></A></H2>
Coercions can be used to implicitly inject terms from one <EM>class</EM> in
which they reside into another one. A <EM>class</EM> is either a sort
(denoted by the keyword <TT>Sortclass</TT>), a product type (denoted by the
keyword <TT>Funclass</TT>), or a type constructor (denoted by its name),
e.g. an inductive type or any constant with a type of the form
<TT>forall</TT> (<I>x</I><SUB><FONT SIZE=2>1</FONT></SUB>:<I>A</I><SUB><FONT SIZE=2>1</FONT></SUB>) .. (<I>x</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>:<I>A</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>),&nbsp;<I>s</I> where <I>s</I> is a sort.<BR>
<BR>
Then the user is able to apply an
object that is not a function, but can be coerced to a function, and
more generally to consider that a term of type A is of type B provided
that there is a declared coercion between A and B. The main command is
<A NAME="@default113"></A><A NAME="@command62"></A>
<BLOCKQUOTE>
<TT>Coercion </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> : </TT><I><FONT COLOR=maroon>class</FONT></I><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT> &gt;-&gt; </TT><I><FONT COLOR=maroon>class</FONT></I><SUB><TT><FONT SIZE=2>2</FONT></TT></SUB><TT>.
</TT></BLOCKQUOTE>
which declares the construction denoted by <I><FONT COLOR=maroon>qualid</FONT></I> as a
coercion between <I><FONT COLOR=maroon>class</FONT></I><SUB><FONT SIZE=2>1</FONT></SUB> and <I><FONT COLOR=maroon>class</FONT></I><SUB><FONT SIZE=2>2</FONT></SUB>.<BR>
<BR>
More details and examples, and a description of the commands related
to coercions are provided in chapter <A HREF="Reference-Manual019.html#Coercions-full">16</A>.<BR>
<BR>
<A NAME="toc18"></A>
<H2><A NAME="htoc65">2.8</A>&nbsp;&nbsp;Printing constructions in full</H2>
<A NAME="SetPrintingAll"></A>
<A NAME="@default114"></A><A NAME="@command63"></A>
<A NAME="@default115"></A><A NAME="@command64"></A>
Coercions, implicit arguments, the type of pattern-matching, but also
notations (see chapter <A HREF="Reference-Manual013.html#Addoc-syntax">11</A>) can obfuscate the behavior
of some tactics (typically the tactics applying to occurrences of
subterms are sensitive to the implicit arguments). The command
<BLOCKQUOTE>
<TT>Set Printing All.</TT>
</BLOCKQUOTE>
deactivates all high-level printing features such as coercions,
implicit arguments, returned type of pattern-matching, notations and
various syntactic sugar for pattern-matching or record projections.
Otherwise said, <TT>Set Printing All</TT> includes the effects
of the commands <TT>Set Printing Implicit</TT>, <TT>Set Printing
Coercions</TT>, <TT>Set Printing Synth</TT>, <TT>Unset Printing Projections</TT>
and <TT>Unset Printing Notations</TT>. To reactivate the high-level
printing features, use the command
<BLOCKQUOTE>
<TT>Unset Printing All.</TT>
</BLOCKQUOTE>
<HR>
<A HREF="Reference-Manual003.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual005.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
