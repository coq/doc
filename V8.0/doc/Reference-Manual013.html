<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
<TITLE>
Syntax extensions and interpretation scopes
</TITLE>
</HEAD>
<BODY >
<A HREF="Reference-Manual012.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual014.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><A NAME="htoc274">Chapter&nbsp;11</A>&nbsp;&nbsp;Syntax extensions and interpretation scopes</H1>
<A NAME="Addoc-syntax"></A>
In this chapter, we introduce advanced commands to modify the way
<FONT COLOR=navy>Coq</FONT> parses and prints objects, i.e. the translations between the
concrete and internal representations of terms and commands. The main
commands are <TT>Notation</TT> and <TT>Infix</TT> which are described in
section <A HREF="#Notation">11.1</A>. It also happens that the same symbolic
notation is expected in different contexts. To achieve this form of
overloading, <FONT COLOR=navy>Coq</FONT> offers a notion of interpretation scope. This is
described in section <A HREF="#scopes">11.2</A>.<BR>
<BR>
<BR>
<B>Remark: </B>The commands <TT>Grammar</TT>, <TT>Syntax</TT> and <TT>Distfix</TT> which
were present for a while in <FONT COLOR=navy>Coq</FONT> are no longer available from <FONT COLOR=navy>Coq</FONT>
version 8.0. The underlying AST structure is also no longer available.
The functionalities of the command <TT>Syntactic Definition</TT> are
still available, see section <A HREF="#Abbreviations">11.3</A>.<BR>
<BR>
<A NAME="toc68"></A>
<H2><A NAME="htoc275">11.1</A>&nbsp;&nbsp;Notations</H2>
<A NAME="Notation"></A>
<A NAME="@default632"></A><A NAME="@command173"></A>

<H3><A NAME="htoc276">11.1.1</A>&nbsp;&nbsp;Basic notations</H3>
A <EM>notation</EM> is a symbolic abbreviation denoting some term
or term pattern.<BR>
<BR>
A typical notation is the use of the infix symbol <CODE>/\</CODE> to denote
the logical conjunction (<TT>and</TT>). Such a notation is declared
by<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"A&nbsp;/\&nbsp;B"&nbsp;:=&nbsp;(and&nbsp;A&nbsp;B).</TT><BR>
</DIV>
<BR>
The expression <TT>(and A B)</TT> is the abbreviated term and the
string <CODE>"A /\ B"</CODE> (called a <EM>notation</EM>) tells how it is 
symbolically written.<BR>
<BR>
A notation is always surrounded by double quotes (excepted when the
abbreviation is a single ident, see <A HREF="#Abbreviations">11.3</A>). The
notation is composed of <EM>tokens</EM> separated by spaces. Identifiers
in the string (such as <TT>A</TT> and <TT>B</TT>) are the <EM>parameters</EM> of the notation. They must occur at least once each in the
denoted term. The other elements of the string (such as <CODE>/\</CODE>) are
the <EM>symbols</EM>.<BR>
<BR>
An identifier can be used as a symbol but it must be surrounded by
simple quotes to avoid the confusion with a parameter. Similarly,
every symbol of at least 3 characters and starting with a simple quote
must be quoted (then it starts by two single quotes). Here is an example.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"'IF'&nbsp;c1&nbsp;'then'&nbsp;c2&nbsp;'else'&nbsp;c3"&nbsp;:=&nbsp;(IF_then_else&nbsp;c1&nbsp;c2&nbsp;c3).</TT><BR>
</DIV>
<BR>
A notation binds a syntactic expression to a term. Unless the parser
and pretty-printer of <FONT COLOR=navy>Coq</FONT> already know how to deal with the
syntactic expression (see <A HREF="#ReservedNotation">11.1.7</A>), explicit precedences and
associativity rules have to be given.<BR>
<BR>

<H3><A NAME="htoc277">11.1.2</A>&nbsp;&nbsp;Precedences and associativity</H3>
<A NAME="@default633"></A>
<A NAME="@default634"></A>
Mixing different symbolic notations in a same text may cause serious
parsing ambiguity. To deal with the ambiguity of notations, <FONT COLOR=navy>Coq</FONT>
uses precedence levels ranging from 0 to 100 (plus one extra level
numbered 200) and associativity rules.<BR>
<BR>
Consider for example the new notation<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"A&nbsp;\/&nbsp;B"&nbsp;:=&nbsp;(or&nbsp;A&nbsp;B).</TT><BR>
</DIV>
<BR>
Clearly, an expression such as <TT>(A:Prop)True </TT><CODE><TT>/\</TT></CODE><TT> A </TT><CODE><TT>\/</TT></CODE><TT>
A </TT><CODE><TT>\/</TT></CODE><TT> False</TT> is ambiguous. To tell the <FONT COLOR=navy>Coq</FONT> parser how to
interpret the expression, a priority between the symbols <CODE>/\</CODE> and
<CODE>\/</CODE> has to be given. Assume for instance that we want conjunction
to bind more than disjunction. This is expressed by assigning a
precedence level to each notation, knowing that a lower level binds
more than a higher level. Hence the level for disjunction must be
higher than the level for conjunction.<BR>
<BR>
Since connectives are the less tight articulation points of a text, it
is reasonable to choose levels not so far from the higher level which
is 100, for example 85 for disjunction and 80 for
conjunction<SUP><A NAME="text17" HREF="#note17">1</A></SUP>.<BR>
<BR>
Similarly, an associativity is needed to decide whether <TT>True </TT><CODE><TT>/\</TT></CODE><TT>
False </TT><CODE><TT>/\</TT></CODE><TT> False</TT> defaults to <TT>True </TT><CODE><TT>/\</TT></CODE><TT> (False
</TT><CODE><TT>/\</TT></CODE><TT> False)</TT> (right associativity) or to <TT>(True
</TT><CODE><TT>/\</TT></CODE><TT> False) </TT><CODE><TT>/\</TT></CODE><TT> False</TT> (left associativity). We may
even consider that the expression is not well-formed and that
parentheses are mandatory (this is a ``no associativity'')<SUP><A NAME="text18" HREF="#note18">2</A></SUP>.
We don't know of a special convention of the associativity of
disjunction and conjunction, let's apply for instance a right
associativity (which is the choice of <FONT COLOR=navy>Coq</FONT>).<BR>
<BR>
Precedence levels and associativity rules of notations have to be
given between parentheses in a list of modifiers that the
<TT>Notation</TT> command understands. Here is how the previous
examples refine.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"A&nbsp;/\&nbsp;B"&nbsp;:=&nbsp;(and&nbsp;A&nbsp;B)&nbsp;(at&nbsp;level&nbsp;80,&nbsp;right&nbsp;associativity).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"A&nbsp;\/&nbsp;B"&nbsp;:=&nbsp;(or&nbsp;A&nbsp;B)&nbsp;&nbsp;(at&nbsp;level&nbsp;85,&nbsp;right&nbsp;associativity).</TT><BR>
</DIV>
<BR>
By default, a notation is considered non associative, but the
precedence level is mandatory (except for special cases whose level is
canonical). The level is either a number or the mention <TT>next
level</TT> whose meaning is obvious. The list of levels already assigned
is on Figure&nbsp;<A HREF="Reference-Manual005.html#init-notations">3.1</A>.<BR>
<BR>

<H3><A NAME="htoc278">11.1.3</A>&nbsp;&nbsp;Complex notations</H3>
Notations can be made from arbitraly complex symbols. One can for
instance define prefix notations.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"~&nbsp;x"&nbsp;:=&nbsp;(not&nbsp;x)&nbsp;(at&nbsp;level&nbsp;75,&nbsp;right&nbsp;associativity).</TT><BR>
</DIV>
<BR>
One can also define notations for incomplete terms, with the hole
expected to be inferred at typing time.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"x&nbsp;=&nbsp;y"&nbsp;:=&nbsp;(@eq&nbsp;_&nbsp;x&nbsp;y)&nbsp;(at&nbsp;level&nbsp;70,&nbsp;no&nbsp;associativity).</TT><BR>
</DIV>
<BR>
One can define <EM>closed</EM> notations whose both sides are symbols. In
this case, the default precedence level for inner subexpression is 200.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"(&nbsp;x&nbsp;,&nbsp;y&nbsp;)"&nbsp;:=&nbsp;(@pair&nbsp;_&nbsp;_&nbsp;x&nbsp;y)&nbsp;(at&nbsp;level&nbsp;0).</TT><BR>
</DIV>
<BR>
One can also define notations for binders.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"{&nbsp;x&nbsp;:&nbsp;A&nbsp;&nbsp;|&nbsp;&nbsp;P&nbsp;}"&nbsp;:=&nbsp;(sig&nbsp;A&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;P))&nbsp;(at&nbsp;level&nbsp;0).</TT><BR>
</DIV>
<BR>
In the last case though, there is a conflict with the notation for
type casts. This last notation, as shown by the command <TT>Print Grammar
constr</TT> is at level 100. To avoid <CODE>x : A</CODE> being parsed as a type cast,
it is necessary to put <TT>x</TT> at a level below 100, typically 99. Hence, a
correct definition is <BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"{&nbsp;x&nbsp;:&nbsp;A&nbsp;&nbsp;|&nbsp;&nbsp;P&nbsp;}"&nbsp;:=&nbsp;(sig&nbsp;A&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;P))&nbsp;(at&nbsp;level&nbsp;0,&nbsp;x&nbsp;at&nbsp;level&nbsp;99).</TT><BR>
</DIV>
<BR>
See the next section for more about factorization.<BR>
<BR>

<H3><A NAME="htoc279">11.1.4</A>&nbsp;&nbsp;Simple factorization rules</H3>
<FONT COLOR=navy>Coq</FONT> extensible parsing is performed by Camlp4 which is essentially a
LL1 parser. Hence, some care has to be taken not to hide already
existing rules by new rules. Some simple left factorization work has
to be done. Here is an example.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"x&nbsp;&lt;&nbsp;y"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;(lt&nbsp;x&nbsp;y)&nbsp;(at&nbsp;level&nbsp;70).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"x&nbsp;&lt;&nbsp;y&nbsp;&lt;&nbsp;z"&nbsp;:=&nbsp;(x&nbsp;&lt;&nbsp;y&nbsp;/\&nbsp;y&nbsp;&lt;&nbsp;z)&nbsp;(at&nbsp;level&nbsp;70).</TT><BR>
</DIV>
<BR>
In order to factorize the left part of the rules, the subexpression
referred by <TT>y</TT> has to be at the same level in both rules. However
the default behavior puts <TT>y</TT> at the next level below 70
in the first rule (no associativity is the default), and at the level
200 in the second rule (level 200 is the default for inner expressions).
To fix this, we need to force the parsing level of <TT>y</TT>,
as follows.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"x&nbsp;&lt;&nbsp;y"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;(lt&nbsp;x&nbsp;y)&nbsp;(at&nbsp;level&nbsp;70).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"x&nbsp;&lt;&nbsp;y&nbsp;&lt;&nbsp;z"&nbsp;:=&nbsp;(x&nbsp;&lt;&nbsp;y&nbsp;/\&nbsp;y&nbsp;&lt;&nbsp;z)&nbsp;(at&nbsp;level&nbsp;70,&nbsp;y&nbsp;at&nbsp;next&nbsp;level).</TT><BR>
</DIV>
<BR>
For the sake of factorization with <FONT COLOR=navy>Coq</FONT> predefined rules, simple
rules have to be observed for notations starting with a symbol:
e.g. rules starting with ``{'' or ``('' should be put at level 0. The
list of <FONT COLOR=navy>Coq</FONT> predefined notations can be found in chapter <A HREF="Reference-Manual005.html#Theories">3</A>.<BR>
<BR>
The command to display the current state of the <FONT COLOR=navy>Coq</FONT> term parser is
<A NAME="@default635"></A><A NAME="@command174"></A>
<BLOCKQUOTE>
<TT>Print Grammar constr.
</TT></BLOCKQUOTE>

<H3><A NAME="htoc280">11.1.5</A>&nbsp;&nbsp;Displaying symbolic notations</H3>
The command <TT>Notation</TT> has an effect both on the <FONT COLOR=navy>Coq</FONT> parser and
on the <FONT COLOR=navy>Coq</FONT> printer. For example:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(and&nbsp;True&nbsp;True).</TT><BR>
<TT><I>True&nbsp;/\&nbsp;True</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Prop</I></TT><BR>
</DIV>
<BR>
However, printing, especially pretty-printing, requires
more care than parsing. We may want specific indentations,
line breaks, alignment if on several lines, etc. <BR>
<BR>
The default printing of notations is very rudimentary. For printing a
notation, a <EM>formatting box</EM> is opened in such a way that if the
notation and its arguments cannot fit on a single line, a line break
is inserted before the symbols of the notation and the arguments on
the next lines are aligned with the argument on the first line.<BR>
<BR>
A first, simple control that a user can have on the printing of a
notation is the insertion of spaces at some places of the
notation. This is performed by adding extra spaces between the symbols
and parameters: each extra space (other than the single space needed
to separate the components) is interpreted as a space to be inserted
by the printer. Here is an example showing how to add spaces around
the bar of the notation.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"{{&nbsp;x&nbsp;:&nbsp;A&nbsp;&nbsp;|&nbsp;&nbsp;P&nbsp;}}"&nbsp;:=&nbsp;(sig&nbsp;(fun&nbsp;x&nbsp;:&nbsp;A&nbsp;=&gt;&nbsp;P))</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;(at&nbsp;level&nbsp;0,&nbsp;x&nbsp;at&nbsp;level&nbsp;99).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(sig&nbsp;(fun&nbsp;x&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;x=x)).</TT><BR>
<TT><I>{{x&nbsp;:&nbsp;nat&nbsp;|&nbsp;x&nbsp;=&nbsp;x}}</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Set</I></TT><BR>
</DIV>
<BR>
The second, more powerful control on printing is by using the <TT>format</TT> modifier. Here is an example<BR>
<BR>


<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"'If'&nbsp;c1&nbsp;'then'&nbsp;c2&nbsp;'else'&nbsp;c3"&nbsp;:=&nbsp;(IF_then_else&nbsp;c1&nbsp;c2&nbsp;c3)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;(at&nbsp;level&nbsp;200,&nbsp;right&nbsp;associativity,&nbsp;format</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;"'[v&nbsp;&nbsp;&nbsp;'&nbsp;'If'&nbsp;&nbsp;c1&nbsp;'/'&nbsp;'['&nbsp;'then'&nbsp;&nbsp;c2&nbsp;&nbsp;']'&nbsp;'/'&nbsp;'['&nbsp;'else'&nbsp;&nbsp;c3&nbsp;']'&nbsp;']'").</TT><BR>
<TT><I>Defining&nbsp;'If'&nbsp;as&nbsp;keyword</I></TT><BR>
</DIV>

<BR>
A <EM>format</EM> is an extension of the string denoting the notation with
the possible following elements delimited by single quotes:
<UL><LI>
extra spaces are translated into simple spaces
<LI>tokens of the form <CODE>'/  '</CODE> are translated into breaking point,
 in case a line break occurs, an indentation of the number of spaces
 after the ``<CODE>/</CODE>'' is applied (2 spaces in the given example)
<LI>token of the form <CODE>'//'</CODE> force writing on a new line
<LI>well-bracketed pairs of tokens of the form <CODE>'[    '</CODE> and <CODE>']'</CODE>
 are translated into printing boxes; in case a line break occurs,
 an extra indentation of the number of spaces given after the ``<CODE>[</CODE>''
 is applied (4 spaces in the example)
<LI>well-bracketed pairs of tokens of the form <CODE>'[hv   '</CODE> and <CODE>']'</CODE>
 are translated into horizontal-orelse-vertical printing boxes; 
 if the content of the box does not fit on a single line, then every breaking
 point forces a newline and an extra indentation of the number of spaces
 given after the ``<CODE>[</CODE>'' is applied at the beginning of each newline
 (3 spaces in the example)
<LI>well-bracketed pairs of tokens of the form <CODE>'[v '</CODE> and
 <CODE>']'</CODE> are translated into vertical printing boxes; every
 breaking point forces a newline, even if the line is large enough to
 display the whole content of the box, and an extra indentation of the
 number of spaces given after the ``<CODE>[</CODE>'' is applied at the beginning
 of each newline
</UL>
Thus, for the previous example, we get
<BR>
<BR>
Notations do not survive the end of sections. No typing of the denoted
expression is performed at definition time. Type-checking is done only
at the time of use of the notation.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;(IF_then_else&nbsp;(IF_then_else&nbsp;True&nbsp;False&nbsp;True)&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(IF_then_else&nbsp;True&nbsp;False&nbsp;True)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;(IF_then_else&nbsp;True&nbsp;False&nbsp;True)).&nbsp;&nbsp;&nbsp;</TT><BR>
<TT><I>If&nbsp;If&nbsp;True</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;False&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;True</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;then&nbsp;If&nbsp;True</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;False&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;True&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;else&nbsp;If&nbsp;True</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;False&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;True</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Prop</I></TT><BR>
</DIV>
<BR>
<BR>
<B>Remark: </B>Sometimes, a notation is expected only for the parser.
To do so, the option <EM>only parsing</EM> is allowed in the list of modifiers of
<TT>Notation</TT>.<BR>
<BR>

<H3><A NAME="htoc281">11.1.6</A>&nbsp;&nbsp;The <TT>Infix</TT> command
<A NAME="@default636"></A><A NAME="@command175"></A></H3>
The <TT>Infix</TT> command is a shortening for declaring notations of
infix symbols. Its syntax is 
<BLOCKQUOTE>
<TT>Infix "</TT><I><FONT COLOR=maroon>symbol</FONT></I><TT>" :=</TT> <I><FONT COLOR=maroon>qualid</FONT></I> <TT>(</TT> <EM>modifier</EM> <TT>,</TT> ... <TT>,</TT> <EM>modifier</EM> <TT>)</TT>.
</BLOCKQUOTE>
and it is equivalent to
<BLOCKQUOTE>
<TT>Notation "x </TT><I><FONT COLOR=maroon>symbol</FONT></I><TT> y" := (</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> x y) (</TT> <EM>modifier</EM> <TT>,</TT> ... <TT>,</TT> <EM>modifier</EM> <TT>)</TT>.
</BLOCKQUOTE>
where <TT>x</TT> and <TT>y</TT> are fresh names distinct from <I><FONT COLOR=maroon>qualid</FONT></I>. Here is an example.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Infix&nbsp;"/\"&nbsp;:=&nbsp;and&nbsp;(at&nbsp;level&nbsp;80,&nbsp;right&nbsp;associativity).</TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc282">11.1.7</A>&nbsp;&nbsp;Reserving notations
<A NAME="ReservedNotation"></A>
<A NAME="@default637"></A><A NAME="@command176"></A></H3>
A given notation may be used in different contexts. <FONT COLOR=navy>Coq</FONT> expects all
uses of the notation to be defined at the same precedence and with the
same associativity. To avoid giving the precedence and associativity
every time, it is possible to declare a parsing rule in advance
without giving its interpretation. Here is an example from the initial
state of <FONT COLOR=navy>Coq</FONT>.<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Reserved&nbsp;Notation&nbsp;"x&nbsp;=&nbsp;y"&nbsp;(at&nbsp;level&nbsp;70,&nbsp;no&nbsp;associativity).</TT><BR>
</DIV>
<BR>
Reserving a notation is also useful for simultaneously defined an
inductive type or a recursive constant and a notation for it.<BR>
<BR>
<BR>
<B>Remark: </B>The notations mentioned on Figure&nbsp;<A HREF="Reference-Manual005.html#init-notations">3.1</A> are
reserved. Hence their precedence and associativity cannot be changed.<BR>
<BR>

<H3><A NAME="htoc283">11.1.8</A>&nbsp;&nbsp;Simultaneous definition of terms and notations
<A NAME="@default638"></A><A NAME="@command177"></A>
<A NAME="@default639"></A><A NAME="@command178"></A>
<A NAME="@default640"></A><A NAME="@command179"></A></H3>
Thanks to reserved notations, the inductive, coinductive, recursive
and corecursive definitions can benefit of customized notations. To do
this, insert a <TT>where</TT> notation clause after the definition of the
(co)inductive type or (co)recursive term (or after the definition of
each of them in case of mutual definitions). The exact syntax is given
on Figure <A HREF="#notation-syntax">11.1</A>. Here are examples:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;and&nbsp;(A&nbsp;B:Prop)&nbsp;:&nbsp;Prop&nbsp;:=&nbsp;conj&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;where&nbsp;"A&nbsp;/\&nbsp;B"&nbsp;:=&nbsp;(and&nbsp;A&nbsp;B).</TT><BR>
</DIV>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;plus&nbsp;(n&nbsp;m:nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;m</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;S&nbsp;(p+m)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;where&nbsp;"n&nbsp;+&nbsp;m"&nbsp;:=&nbsp;(plus&nbsp;n&nbsp;m).</TT><BR>
</DIV>
<BR>

<H3><A NAME="htoc284">11.1.9</A>&nbsp;&nbsp;Displaying informations about notations
<A NAME="@default641"></A><A NAME="@command180"></A>
<A NAME="@default642"></A><A NAME="@command181"></A></H3>
To deactivate the printing of all notations, use the command
<BLOCKQUOTE>
<TT>Unset Printing Notations.
</TT></BLOCKQUOTE>
To reactivate it, use the command
<BLOCKQUOTE>
<TT>Set Printing Notations.
</TT></BLOCKQUOTE>
The default is to use notations for printing terms wherever possible.<BR>
<BR>
<BR>
<B>See also: </B><TT>Set Printing All</TT> in section <A HREF="Reference-Manual004.html#SetPrintingAll">2.8</A>.<BR>
<BR>

<H3><A NAME="htoc285">11.1.10</A>&nbsp;&nbsp;Locating notations
<A NAME="@default643"></A><A NAME="@command182"></A>
<A NAME="LocateSymbol"></A></H3>
To know to which notations a given symbol belongs to, use the command
<BLOCKQUOTE>
<TT>Locate </TT><I><FONT COLOR=maroon>symbol</FONT></I><TT>
</TT></BLOCKQUOTE>
where symbol is any (composite) symbol surrounded by quotes. To locate
a particular notation, use a string where the variables of the
notation are replaced by ``_''.<BR>
<BR>
<BR>
<B>Example: </B>
<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Locate&nbsp;"exists".</TT><BR>
<TT><I>Notation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scope&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I></TT><BR>
<TT><I>"'exists'&nbsp;x&nbsp;:&nbsp;t&nbsp;,&nbsp;p"&nbsp;:=&nbsp;ex&nbsp;(fun&nbsp;x&nbsp;:&nbsp;t&nbsp;=&gt;&nbsp;p)</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;type_scope</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(default&nbsp;interpretation)</I></TT><BR>
<TT><I>"'exists'&nbsp;x&nbsp;,&nbsp;p"&nbsp;:=&nbsp;ex&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;p)</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;type_scope</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(default&nbsp;interpretation)</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Locate&nbsp;"'exists'&nbsp;_&nbsp;,&nbsp;_".</TT><BR>
<TT><I>Notation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scope&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I></TT><BR>
<TT><I>"'exists'&nbsp;x&nbsp;,&nbsp;p"&nbsp;:=&nbsp;ex&nbsp;(fun&nbsp;x&nbsp;=&gt;&nbsp;p)</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;type_scope</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(default&nbsp;interpretation)</I></TT><BR>
</DIV>
<BR>
<BR>
<B>See also: </B>Section <A HREF="Reference-Manual008.html#Locate">6.2.10</A>.
<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
<DIV ALIGN=center>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>sentence</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><TT>Notation</TT> <I><FONT COLOR=maroon>[</FONT></I><TT>Local<I><FONT COLOR=maroon>]</FONT></I> </TT><I><FONT COLOR=maroon>string</FONT></I><TT> :=</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> 
 <I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>modifiers</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I> <I><FONT COLOR=maroon>[</FONT></I>:</TT><I><FONT COLOR=maroon>scope</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I> .</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>Infix</TT> <I><FONT COLOR=maroon>[</FONT></I><TT>Local<I><FONT COLOR=maroon>]</FONT></I> </TT><I><FONT COLOR=maroon>string</FONT></I><TT> :=</TT><TT> </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> 
 <I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>modifiers</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I> <I><FONT COLOR=maroon>[</FONT></I>:</TT><I><FONT COLOR=maroon>scope</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I> .</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>Reserved Notation</TT> <I><FONT COLOR=maroon>[</FONT></I><TT>Local<I><FONT COLOR=maroon>]</FONT></I> </TT><I><FONT COLOR=maroon>string</FONT></I><TT>
 <I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>modifiers</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I> .</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>Inductive</TT>
 <I><FONT COLOR=maroon>ind_body</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>decl_notation</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>with</TT> ... <TT>with</TT> <I><FONT COLOR=maroon>ind_body</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>decl_notation</FONT></I><I><FONT COLOR=maroon>]</FONT></I><TT>.</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>CoInductive</TT>
 <I><FONT COLOR=maroon>ind_body</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>decl_notation</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>with</TT> ... <TT>with</TT> <I><FONT COLOR=maroon>ind_body</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>decl_notation</FONT></I><I><FONT COLOR=maroon>]</FONT></I><TT>.</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>Fixpoint</TT>
 <I><FONT COLOR=maroon>fix_body</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>decl_notation</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>with</TT> ... <TT>with</TT> <I><FONT COLOR=maroon>fix_body</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>decl_notation</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>.</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>CoFixpoint</TT>
 <I><FONT COLOR=maroon>cofix_body</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>decl_notation</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>with</TT> ... <TT>with</TT> <I><FONT COLOR=maroon>cofix_body</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>decl_notation</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>.</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>decl_notation</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>[</FONT></I><TT>where</TT> <I><FONT COLOR=maroon>string</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <I><FONT COLOR=maroon>[</FONT></I>:<I><FONT COLOR=maroon>scope</FONT></I><I><FONT COLOR=maroon>]</FONT></I><I><FONT COLOR=maroon>]</FONT></I> .</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>modifiers</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>ident</FONT></I> <TT>,</TT> ... <TT>,</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>at level</TT> <I><FONT COLOR=maroon>natural</FONT></I></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>ident</FONT></I> <TT>,</TT> ... <TT>,</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>at next level</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>at level</TT> <I><FONT COLOR=maroon>natural</FONT></I></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>left associativity</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>right associativity</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>no associativity</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>ident</FONT></I> <TT>ident</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>ident</FONT></I> <TT>global</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>ident</FONT></I> <TT>bigint</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>only parsing</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>format</TT> <I><FONT COLOR=maroon>string</FONT></I></TD>
</TR></TABLE>
</DIV>
<BR>
<DIV ALIGN=center>Figure 11.1: Syntax of the variants of <TT>Notation</TT></DIV><BR>

<A NAME="notation-syntax"></A>
<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>

<H3><A NAME="htoc286">11.1.11</A>&nbsp;&nbsp;Notations with recursive patterns</H3>
An experimental mechanism is provided for declaring elementary
notations including recursive patterns. The basic syntax is<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"[&nbsp;x&nbsp;;&nbsp;..&nbsp;;&nbsp;y&nbsp;]"&nbsp;:=&nbsp;(cons&nbsp;x&nbsp;..&nbsp;(cons&nbsp;y&nbsp;nil)&nbsp;..).</TT><BR>
</DIV>
<BR>
On the right-hand-side, an extra construction of the form <TT>..</TT> (<I>f</I>
<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> ... <I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB>) <TT>..</TT> can be used. Notice that <TT>..</TT> is part of
the <FONT COLOR=navy>Coq</FONT> syntax while ... is just a meta-notation of this
manual to denote a sequence of terms of arbitrary size.<BR>
<BR>
This extra construction enclosed within <TT>..</TT>, let's call it <I>t</I>,
must be one of the argument of an applicative term of the form <TT>(<I>f</I> <I>u</I></TT><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT> ... <I>u</I></TT><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>)</TT>. The sequences <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> ... <I>t</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> and
<I>u</I><SUB><FONT SIZE=2>1</FONT></SUB> ... <I>u</I><SUB><FONT SIZE=2><I>n</I></FONT></SUB> must coincide everywhere but in two places. In
one place, say the terms of indice <I>i</I>, we must have <I>u</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> = <I>t</I>. In the
other place, say the terms of indice <I>j</I>, both <I>u</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB> and <I>t</I><SUB><FONT SIZE=2><I>j</I></FONT></SUB> must be
variables, say <I>x</I> and <I>y</I> which are bound by the notation string on
the left-hand-side of the declaration. The variables <I>x</I> and <I>y</I> in
the string must occur in a substring of the form "<I>x</I> <I>s</I> <TT>..</TT> <I>s</I>
<I>y</I>" where <TT>..</TT> is part of the syntax and <I>s</I> is two times the
same sequence of terminal symbols (i.e. symbols which are not
variables).<BR>
<BR>
These invariants must be satisfied in order the notation to be
correct. The term <I>t</I><SUB><FONT SIZE=2><I>i</I></FONT></SUB> is the <EM>terminating</EM> expression of
the notation and the pattern <TT>(<I>f</I> <I>u</I></TT><SUB><TT><FONT SIZE=2>1</FONT></TT></SUB><TT> ... <I>u</I></TT><SUB><TT><FONT SIZE=2><I>i</I>-1</FONT></TT></SUB><TT> </TT>[I]<TT>
<I>u</I></TT><SUB><TT><FONT SIZE=2><I>i</I>+1</FONT></TT></SUB><TT> ... <I>u</I></TT><SUB><TT><FONT SIZE=2><I>j</I>-1</FONT></TT></SUB><TT> </TT>[E]<TT> <I>u</I></TT><SUB><TT><FONT SIZE=2><I>j</I>+1</FONT></TT></SUB><TT> ... <I>u</I></TT><SUB><TT><FONT SIZE=2><I>n</I></FONT></TT></SUB><TT>)</TT> is the
<EM>iterating pattern</EM>. The hole [I] is the <EM>iterative</EM> place
and the hole [E] is the <EM>enumerating</EM> place. Remark that if <I>j</I>&lt;<I>i</I>, the
iterative place comes after the enumerating place accordingly.<BR>
<BR>
The notation parses sequences of tokens such that the subpart "<I>x</I> <I>s</I>
<TT>..</TT> <I>s</I> <I>y</I>" parses any number of time (but at least one time) a
sequence of expressions separated by the sequence of tokens <I>s</I>. The
parsing phase produces a list of expressions which
are used to fill in order the holes [E] of the iterating pattern
which is nested as many time as the length of the list, the hole [I]
being the nesting point. In the innermost occurrence of the nested
iterating pattern, the hole [I] is finally filled with the terminating
expression.<BR>
<BR>
In the example above, <I>f</I> is <TT>cons</TT>, <I>n</I>=3 (because <TT>cons</TT> has
a hidden implicit argument!), <I>i</I>=3 and <I>j</I>=2. The <EM>terminating</EM>
expression is <TT>nil</TT> and the <EM>iterating pattern</EM> is <TT>cons
</TT>[E] [I]. Finally, the sequence <I>s</I> is made of the single token
``<TT>;</TT>''. Here is another example.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"(&nbsp;x&nbsp;,&nbsp;y&nbsp;,&nbsp;..&nbsp;,&nbsp;z&nbsp;)"&nbsp;:=&nbsp;(pair&nbsp;..&nbsp;(pair&nbsp;x&nbsp;y)&nbsp;..&nbsp;z)&nbsp;(at&nbsp;level&nbsp;0).</TT><BR>
</DIV>
<BR>
Notations with recursive patterns can be reserved like standard
notations, they can also be declared within interpretation scopes (see
section <A HREF="#scopes">11.2</A>).<BR>
<BR>

<H3><A NAME="htoc287">11.1.12</A>&nbsp;&nbsp;Notations and binders</H3>
Notations can be defined for binders as in the example:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"{&nbsp;x&nbsp;:&nbsp;A&nbsp;&nbsp;|&nbsp;&nbsp;P&nbsp;&nbsp;}"&nbsp;:=&nbsp;(sig&nbsp;(fun&nbsp;x&nbsp;:&nbsp;A&nbsp;=&gt;&nbsp;P))&nbsp;(at&nbsp;level&nbsp;0).</TT><BR>
</DIV>
<BR>
The binding variables in the left-hand-side that occur as a parameter
of the notation naturally bind all their occurrences appearing in
their respective scope after instantiation of the parameters of the
notation.<BR>
<BR>
Contrastingly, the binding variables that are not a parameter of the
notation do not capture the variables of same name that
could appear in their scope after instantiation of the
notation. E.g., for the notation<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;"'exists_different'&nbsp;n"&nbsp;:=&nbsp;(exists&nbsp;p:nat,&nbsp;p&lt;&gt;n)&nbsp;(at&nbsp;level&nbsp;200).</TT><BR>
</DIV>

the next command fails because <TT>p</TT> does not bind in 
the instance of <TT>n</TT>.

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(exists_different&nbsp;p).</TT><BR>
<TT><I>Coq&nbsp;&lt;&nbsp;Coq&nbsp;&lt;&nbsp;Toplevel&nbsp;input,&nbsp;characters&nbsp;3124-3125</I></TT><BR>
<TT><I>&gt;&nbsp;Check&nbsp;(exists_different&nbsp;p).</I></TT><BR>
<TT><I>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</I></TT><BR>
<TT><I>Error:&nbsp;The&nbsp;reference&nbsp;p&nbsp;was&nbsp;not&nbsp;found&nbsp;in&nbsp;the&nbsp;current&nbsp;environment</I></TT><BR>
</DIV>
<BR>
<BR>
<B>Remark: </B>Binding variables must not necessarily be parsed using the
<TT>ident</TT> entry. For factorization purposes, they can be said to be
parsed at another level (e.g. <TT>x</TT> in <CODE>"{ x : A | P }"</CODE> must be
parsed at level 99 to be factorized with the notation
<CODE>"{ A } + { B }"</CODE> for which <TT>A</TT> can be any term). 
However, even if parsed as a term, this term must at the end be effectively 
a single identifier.<BR>
<BR>

<H3><A NAME="htoc288">11.1.13</A>&nbsp;&nbsp;Summary</H3>

<H5>Syntax of notations</H5>
The different syntactic variants of the command <TT>Notation</TT> are
given on Figure <A HREF="#notation-syntax">11.1</A>. The optional <TT>:</TT><I><FONT COLOR=maroon>scope</FONT></I> is
described in the section <A HREF="#scopes">11.2</A>.<BR>
<BR>
<BR>
<B>Remark: </B>No typing of the denoted expression is performed at definition
time. Type-checking is done only at the time of use of the notation.<BR>
<BR>
<BR>
<B>Remark: </B>Many examples of <TT>Notation</TT> may be found in the files
composing the initial state of <FONT COLOR=navy>Coq</FONT> (see directory <TT>$COQLIB/theories/Init</TT>).<BR>
<BR>
<BR>
<B>Remark: </B>The notation <CODE>"{ x }"</CODE> has a special status in such a way
that complex notations of the form <CODE>"x + { y }"</CODE> or
<CODE>"x * { y }"</CODE> can be nested with correct precedences. Especially,
every notation involving a pattern of the form <CODE>"{ x }"</CODE> is
parsed as a notation where the pattern <CODE>"{ x }"</CODE> has been simply
replaced by <CODE>"x"</CODE> and the curly brackets are parsed separately.
E.g. <CODE>"y + { z }"</CODE> is not parsed as a term of the given form but
as a term of the form <CODE>"y + z"</CODE> where <CODE>z</CODE> has been parsed
using the rule parsing <CODE>"{ x }"</CODE>. Especially, level and
precedences for a rule including patterns of the form <CODE>"{ x }"</CODE>
are relative not to the textual notation but to the notation where the
curly brackets have been removed (e.g. the level and the associativity
given to some notation, say <CODE>"{ y } &amp; { z }"</CODE> in fact applies to
the underlying <CODE>"{ x }"</CODE>-free rule which is <CODE>"y &amp; z"</CODE>).<BR>
<BR>

<H5>Persistence of notations</H5>
Notations do not survive the end of sections. They survive modules
unless the command <TT>Notation Local</TT> is used instead of <TT>Notation</TT>.<BR>
<BR>
<A NAME="toc69"></A>
<H2><A NAME="htoc289">11.2</A>&nbsp;&nbsp;Interpretation scopes</H2>
<A NAME="@default644"></A>
<A NAME="scopes"></A>

An <EM>interpretation scope</EM> is a set of notations for terms with
their interpretation. Interpretation scopes provides with a weak,
purely syntactical form of notations overloading: a same notation, for
instance the infix symbol <CODE>+</CODE> can be used to denote distinct
definitions of an additive operator. Depending on which interpretation
scopes is currently open, the interpretation is different.
Interpretation scopes can include an interpretation for
numerals. However, this is only made possible at the <FONT COLOR=navy>Objective Caml</FONT> level.<BR>
<BR>
See Figure <A HREF="#notation-syntax">11.1</A> for the syntax of notations including
the possibility to declare them in a given scope. Here is a typical
example which declares the notation for conjunction in the scope <TT>type_scope</TT>.
<PRE>
Notation "A /\ B" := (and A B) : type_scope.
</PRE>
<BR>
<B>Remark: </B>A notation not defined in a scope is called a <EM>lonely</EM> notation.<BR>
<BR>

<H3><A NAME="htoc290">11.2.1</A>&nbsp;&nbsp;Global interpretation rules for notations</H3>
At any time, the interpretation of a notation for term is done within
a <EM>stack</EM> of interpretation scopes and lonely notations. In case a
notation has several interpretations, the actual interpretation is the
one defined by (or in) the more recently declared (or open) lonely
notation (or interpretation scope) which defines this notation.
Typically if a given notation is defined in some scope <I><FONT COLOR=maroon>scope</FONT></I> but
has also an interpretation not assigned to a scope, then, if <I><FONT COLOR=maroon>scope</FONT></I>
is open before the lonely interpretation is declared, then the lonely
interpretation is used (and this is the case even if the
interpretation of the notation in <I><FONT COLOR=maroon>scope</FONT></I> is given after the lonely
interpretation: otherwise said, only the order of lonely
interpretations and opening of scopes matters, and not the declaration
of interpretations within a scope).<BR>
<BR>
The initial state of <FONT COLOR=navy>Coq</FONT> declares three interpretation scopes and
no lonely notations. These scopes, in opening order, are <TT>core_scope</TT>, <TT>type_scope</TT> and <TT>nat_scope</TT>.<BR>
<BR>
The command to add a scope to the interpretation scope stack is
<A NAME="@default645"></A><A NAME="@command183"></A>
<A NAME="@default646"></A><A NAME="@command184"></A>
<BLOCKQUOTE>
<TT>Open Scope</TT> <I><FONT COLOR=maroon>scope</FONT></I>.
</BLOCKQUOTE>
It is also possible to remove a scope from the interpretation scope
stack by using the command
<BLOCKQUOTE>
<TT>Close Scope</TT> <I><FONT COLOR=maroon>scope</FONT></I>.
</BLOCKQUOTE>
Notice that this command does not only cancel the last <TT>Open Scope
</TT><I><FONT COLOR=maroon>scope</FONT></I> but all the invocation of it.<BR>
<BR>
<BR>
<B>Remark: </B><TT>Open Scope</TT> and <TT>Close Scope</TT> do not survive the end of
sections where they occur. When defined outside of a section, they are
exported to the modules that import the module where they occur.<BR>
<BR>
<BR>
<B>Variants: </B><OL type=1><LI><TT>Open Local Scope</TT> <I><FONT COLOR=maroon>scope</FONT></I>.<BR>
<BR>
<LI><TT>Close Local Scope</TT> <I><FONT COLOR=maroon>scope</FONT></I>.<BR>
<BR>
These variants are not exported to the modules that import the module
where they occur, even if outside a section.</OL>

<H3><A NAME="htoc291">11.2.2</A>&nbsp;&nbsp;Local interpretation rules for notations</H3>
In addition to the global rules of interpretation of notations, some
ways to change the interpretation of subterms are available.<BR>
<BR>

<H4>Local opening of an interpretation scope 
<A NAME="scopechange"></A>
<A NAME="@default647"></A>
<A NAME="@default648"></A><A NAME="@command185"></A></H4>
It is possible to locally extend the interpretation scope stack using
the syntax (<I><FONT COLOR=maroon>term</FONT></I>)%<I><FONT COLOR=maroon>key</FONT></I> (or simply <I><FONT COLOR=maroon>term</FONT></I>%<I><FONT COLOR=maroon>key</FONT></I>
for atomic terms), where <I><FONT COLOR=maroon>key</FONT></I> is a special identifier called
<EM>delimiting key</EM> and bound to a given scope.<BR>
<BR>
In such a situation, the term <I><FONT COLOR=maroon>term</FONT></I>, and all its subterms, are
interpreted in the scope stack extended with the scope bound to
<I><FONT COLOR=maroon>key</FONT></I>.<BR>
<BR>
To bind a delimiting key to a scope, use the command
<BLOCKQUOTE>
<TT>Delimit Scope</TT> <I><FONT COLOR=maroon>scope</FONT></I> <TT>with</TT> <I><FONT COLOR=maroon>ident</FONT></I> 
</BLOCKQUOTE>

<H4>Binding arguments of a constant to an interpretation scope
<A NAME="@default649"></A><A NAME="@command186"></A></H4>
It is possible to set in advance that some arguments of a given
constant have to be interpreted in a given scope. The command is
<BLOCKQUOTE>
<TT>Arguments Scope</TT> <I><FONT COLOR=maroon>qualid</FONT></I> <TT>[ </TT><I><FONT COLOR=maroon>opt_scope</FONT></I><TT>  ...  </TT><I><FONT COLOR=maroon>opt_scope</FONT></I><TT> ]</TT>
</BLOCKQUOTE>
where the list is a list made either of <TT>_</TT> or of a scope name.
Each scope in the list is bound to the corresponding parameter of
<I><FONT COLOR=maroon>qualid</FONT></I> in order. When interpreting a term, if some of the
arguments of <I><FONT COLOR=maroon>qualid</FONT></I> are built from a notation, then this notation
is interpreted in the scope stack extended by the scopes bound (if any)
to these arguments.<BR>
<BR>
<BR>
<B>See also: </B>The command to show the scopes bound to the arguments of a
function is described in section <A HREF="Reference-Manual008.html#About">2</A>.<BR>
<BR>

<H4>Binding types of arguments to an interpretation scope</H4>
When an interpretation scope is naturally associated to a type
(e.g. the scope of operations on the natural numbers), it may be
convenient to bind it to this type. The effect of this is that any
argument of a function that syntactically expects a parameter of this
type is interpreted using scope. More precisely, it applies only if
this argument is built from a notation, and if so, this notation is
interpreted in the scope stack extended by this particular scope. It
does not apply to the subterms of this notation (unless the
interpretation of the notation itself expects arguments of the same
type that would trigger the same scope).<BR>
<BR>
<A NAME="@default650"></A><A NAME="@command187"></A>
More generally, any <I><FONT COLOR=maroon>class</FONT></I> (see chapter <A HREF="Reference-Manual019.html#Coercions-full">16</A>) can be
bound to an interpretation scope. The command to do it is
<BLOCKQUOTE>
<TT>Bind Scope</TT> <I><FONT COLOR=maroon>scope</FONT></I> <TT>with</TT> <I><FONT COLOR=maroon>class</FONT></I>
</BLOCKQUOTE>
<BR>
<B>Example: </B>
<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Parameter&nbsp;U&nbsp;:&nbsp;Set.</TT><BR>
<TT><I>U&nbsp;is&nbsp;assumed</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Bind&nbsp;Scope&nbsp;U_scope&nbsp;with&nbsp;U.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Parameter&nbsp;Uplus&nbsp;:&nbsp;U&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;U.</TT><BR>
<TT><I>Uplus&nbsp;is&nbsp;assumed</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Parameter&nbsp;P&nbsp;:&nbsp;forall&nbsp;T:Set,&nbsp;T&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;Prop.</TT><BR>
<TT><I>P&nbsp;is&nbsp;assumed</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Parameter&nbsp;f&nbsp;:&nbsp;forall&nbsp;T:Set,&nbsp;T&nbsp;-&gt;&nbsp;U.</TT><BR>
<TT><I>f&nbsp;is&nbsp;assumed</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Infix&nbsp;"+"&nbsp;:=&nbsp;Uplus&nbsp;:&nbsp;U_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Unset&nbsp;Printing&nbsp;Notations.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Scope&nbsp;nat_scope.&nbsp;(*&nbsp;Define&nbsp;+&nbsp;on&nbsp;the&nbsp;nat&nbsp;as&nbsp;the&nbsp;default&nbsp;for&nbsp;+&nbsp;*)</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(fun&nbsp;x&nbsp;y1&nbsp;y2&nbsp;z&nbsp;t&nbsp;=&gt;&nbsp;P&nbsp;_&nbsp;(x&nbsp;+&nbsp;t)&nbsp;((f&nbsp;_&nbsp;(y1&nbsp;+&nbsp;y2)&nbsp;+&nbsp;z))).</TT><BR>
<TT><I>fun&nbsp;(x&nbsp;y1&nbsp;y2&nbsp;:&nbsp;nat)&nbsp;(z&nbsp;:&nbsp;U)&nbsp;(t&nbsp;:&nbsp;nat)&nbsp;=&gt;</I></TT><BR>
<TT><I>P&nbsp;nat&nbsp;(plus&nbsp;x&nbsp;t)&nbsp;(Uplus&nbsp;(f&nbsp;nat&nbsp;(plus&nbsp;y1&nbsp;y2))&nbsp;z)</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;U&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
</DIV>
<BR>
<BR>
<B>Remark: </B>The scope <TT>type_scope</TT> has also a local effect on
interpretation. See the next section.<BR>
<BR>
<BR>
<B>See also: </B>The command to show the scopes bound to the arguments of a
function is described in section <A HREF="Reference-Manual008.html#About">2</A>.<BR>
<BR>

<H3><A NAME="htoc292">11.2.3</A>&nbsp;&nbsp;The <TT>type_scope</TT> interpretation scope</H3>
<A NAME="@default651"></A>
The scope <TT>type_scope</TT> has a special status. It is a primitive
interpretation scope which is temporarily activated each time a
subterm of an expression is expected to be a type. This includes goals
and statements, types of binders, domain and codomain of implication,
codomain of products, and more generally any type argument of a
declared or defined constant.<BR>
<BR>

<H3><A NAME="htoc293">11.2.4</A>&nbsp;&nbsp;Interpretation scopes used in the standard library of <FONT COLOR=navy>Coq</FONT></H3>
We give an overview of the scopes used in the standard library of
<FONT COLOR=navy>Coq</FONT>. For a complete list of notations in each scope, use the
commands <TT>Print Scopes</TT> or <TT>Print Scopes </TT><I><FONT COLOR=maroon>scope</FONT></I>.<BR>
<BR>

<H4><TT>type_scope</TT></H4>
This includes infix <TT>*</TT> for product types and infix <TT>+</TT> for
sum types. It is delimited by key <TT>type</TT>.<BR>
<BR>

<H4><TT>nat_scope</TT></H4>
This includes the standard arithmetical operators and relations on
type <TT>nat</TT>. Positive numerals in this scope are mapped to their
canonical representent built from <TT>O</TT> and <TT>S</TT>. The scope is
delimited by key <TT>nat</TT>.<BR>
<BR>

<H4><TT>N_scope</TT></H4>
This includes the standard arithmetical operators and relations on
type <TT>N</TT> (binary natural numbers). It is delimited by key <TT>N</TT>
and comes with an interpretation for numerals as closed term of type <TT>Z</TT>.<BR>
<BR>

<H4><TT>Z_scope</TT></H4>
This includes the standard arithmetical operators and relations on
type <TT>Z</TT> (binary integer numbers). It is delimited by key <TT>Z</TT> 
and comes with an interpretation for numerals as closed term of type <TT>Z</TT>.<BR>
<BR>

<H4><TT>positive_scope</TT></H4>
This includes the standard arithmetical operators and relations on
type <TT>positive</TT> (binary strictly positive numbers). It is
delimited by key <TT>positive</TT> and comes with an interpretation for
numerals as closed term of type <TT>positive</TT>.<BR>
<BR>

<H4><TT>real_scope</TT></H4>
This includes the standard arithmetical operators and relations on
type <TT>R</TT> (axiomatic real numbers). It is delimited by key <TT>R</TT>
and comes with an interpretation for numerals as term of type <TT>R</TT>. The interpretation is based on the binary decomposition. The
numeral 2 is represented by 1+1. The interpretation phi(<I>n</I>) of an
odd positive numerals greater <I>n</I> than 3 is <TT>1+(1+1)*phi((<I>n</I>-1)/2)</TT>.
The interpretation phi(<I>n</I>) of an even positive numerals greater <I>n</I>
than 4 is <TT>(1+1)*phi(<I>n</I>/2)</TT>. Negative numerals are represented as the
opposite of the interpretation of their absolute value. E.g. the
syntactic object <TT>-11</TT> is interpreted as <TT>-(1+(1+1)*((1+1)*(1+(1+1))))</TT> where the unit 1 and all the operations are
those of <TT>R</TT>.<BR>
<BR>

<H4><TT>bool_scope</TT></H4>
This includes notations for the boolean operators. It is
delimited by key <TT>bool</TT>.<BR>
<BR>

<H4><TT>list_scope</TT></H4>
This includes notations for the list operators. It is
delimited by key <TT>list</TT>.<BR>
<BR>

<H4><TT>core_scope</TT></H4>
This includes the notation for pairs. It is delimited by key <TT>core</TT>.<BR>
<BR>

<H3><A NAME="htoc294">11.2.5</A>&nbsp;&nbsp;Displaying informations about scopes</H3>

<H4><TT>Print Visibility</TT></H4>
This displays the current stack of notations in scopes and lonely
notations that is used to interpret a notation. The top of the stack
is displayed last. Notations in scopes whose interpretation is hidden
by the same notation in a more recently open scope are not
displayed. Hence each notation is displayed only once.<BR>
<BR>
<BR>
<B>Variant: </B><BR>
<BR>
<TT>Print Visibility </TT><I><FONT COLOR=maroon>scope</FONT></I><BR>
This displays the current stack of notations in scopes and lonely
notations assuming that <I><FONT COLOR=maroon>scope</FONT></I> is pushed on top of the stack. This
is useful to know how a subterm locally occurring in the scope of
<I><FONT COLOR=maroon>scope</FONT></I> is interpreted.<BR>
<BR>

<H4><TT>Print Scope </TT><I><FONT COLOR=maroon>scope</FONT></I></H4>
This displays all the notations defined in interpretation scope
<I><FONT COLOR=maroon>scope</FONT></I>. It also displays the delimiting key if any and the class to
which the scope is bound, if any.<BR>
<BR>

<H4><TT>Print Scopes</TT></H4>
This displays all the notations, delimiting keys and corresponding
class of all the existing interpretation scopes.
It also displays the lonely notations.<BR>
<BR>
<A NAME="toc70"></A>
<H2><A NAME="htoc295">11.3</A>&nbsp;&nbsp;Abbreviations</H2>
<A NAME="@default652"></A>
<A NAME="Abbreviations"></A>
<A NAME="@default653"></A><A NAME="@command188"></A>
An <EM>abbreviation</EM> is a name denoting a (presumably) more complex
expression. An abbreviation is a special form of notation with no
parameter and only one symbol which is an identifier. This identifier
is given with no quotes around. Example:<BR>
<BR>

<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;List&nbsp;:=&nbsp;(list&nbsp;nat).</TT><BR>
</DIV>
<BR>
An abbreviation expects no precedence nor associativity, since it can
always be put at the lower level of atomic expressions, and
associativity is irrelevant. Abbreviations are used as much as
possible by the <FONT COLOR=navy>Coq</FONT> printers unless the modifier
<CODE>(only parsing)</CODE> is given.<BR>
<BR>
Abbreviations are bound to an absolute name like for an ordinary
definition, and can be referred by partially qualified names too.<BR>
<BR>
Abbreviations are syntactic in the sense that they are bound to
expressions which are not typed at the time of the definition of the
abbreviation but at the time it is used. Especially, abbreviation can
be bound to terms with holes (i.e. with ``_''). The general syntax
for abbreviations is
<BLOCKQUOTE>
<TT>Notation</TT> <I><FONT COLOR=maroon>[</FONT></I><TT>Local</TT><I><FONT COLOR=maroon>]</FONT></I> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> 
 <I><FONT COLOR=maroon>[</FONT></I><TT>(only parsing)</TT><I><FONT COLOR=maroon>]</FONT></I> <CODE>.</CODE>
</BLOCKQUOTE>
<BR>
<B>Example: </B>
<DIV ALIGN=left>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;explicit_id&nbsp;(A:Set)&nbsp;(a:A)&nbsp;:=&nbsp;a.</TT><BR>
<TT><I>explicit_id&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Notation&nbsp;id&nbsp;:=&nbsp;(explicit_id&nbsp;_).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;(id&nbsp;0).</TT><BR>
<TT><I>id&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat</I></TT><BR>
</DIV>
<BR>
Abbreviations do not survive the end of sections. No typing of the denoted
expression is performed at definition time. Type-checking is done only
at the time of use of the abbreviation.<BR>
<BR>
<BR>
<B>Remark: </B><A NAME="@default654"></A> compatibility Abbreviations are similar to the <EM>syntactic
definitions</EM> available in versions of <FONT COLOR=navy>Coq</FONT> prior to version 8.0,
except that abbreviations are used for printing (unless the modifier
<CODE>(only parsing)</CODE> is given) while syntactic definitions were not.<BR>
<BR>
<A NAME="toc71"></A>
<H2><A NAME="htoc296">11.4</A>&nbsp;&nbsp;Tactic Notations</H2>
Tactic notations allow to customize the syntax of the tactics of the
tactic language<SUP><A NAME="text19" HREF="#note19">3</A></SUP>. Tactic notations obey the following
syntax<BR>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>sentence</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><TT>Tactic Notation</TT> <I><FONT COLOR=maroon>string</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><I><FONT COLOR=maroon>production_item</FONT></I>  ...  <I><FONT COLOR=maroon>production_item</FONT></I><I><FONT COLOR=maroon>]</FONT></I></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><TT>:= </TT><I><FONT COLOR=maroon>tactic</FONT></I><TT> .</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>production_item</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>string</FONT></I> | <I><FONT COLOR=maroon>tactic_argument_type</FONT></I><TT>(</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>tactic_argument_type</FONT></I></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><TT>ident</TT> |
<TT>simple_intropattern</TT> |
<TT>hyp</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>reference</TT> |
<TT>constr</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><TT>int_or_var</TT> |
<TT>tactic</TT> |</TD>
</TR></TABLE><BR>
A tactic notation <TT>Tactic Notation </TT><I><FONT COLOR=maroon>string</FONT></I><TT> <I><FONT COLOR=maroon>[</FONT></I></TT><I><FONT COLOR=maroon>production_item</FONT></I><TT>  ...  </TT><I><FONT COLOR=maroon>production_item</FONT></I><TT><I><FONT COLOR=maroon>]</FONT></I></TT><TT>
:= </TT><I><FONT COLOR=maroon>tactic</FONT></I> extends the parser and pretty-printer of tactics with a
new rule made of the juxtaposition of the head name of the tactic
<I><FONT COLOR=maroon>string</FONT></I> and the list of its production items (in the syntax of
production items, <I><FONT COLOR=maroon>string</FONT></I> stands for a terminal symbol and <TT></TT><I><FONT COLOR=maroon>tactic_argument_type</FONT></I><TT>(</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>) for non terminal entries</TT>. It then evaluates
into the tactic expression <I><FONT COLOR=maroon>tactic</FONT></I>.<BR>
<BR>
Each type of tactic argument has a specific semantic regarding how it
is parsed and how it is interpreted. The semantic is described in the
following table. The last command gives examples of tactics which
use the corresponding kind of argument.<BR>
<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP>Tactic argument type</TD>
<TD ALIGN=left NOWRAP>parsed as</TD>
<TD ALIGN=left NOWRAP>interpreted as</TD>
<TD ALIGN=left NOWRAP>as in tactic</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>ident</TT></TD>
<TD ALIGN=left NOWRAP>identifier</TD>
<TD ALIGN=left NOWRAP>a user-given name</TD>
<TD ALIGN=left NOWRAP><TT>intro</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>simple_intropattern</TT></TD>
<TD ALIGN=left NOWRAP>intro_pattern</TD>
<TD ALIGN=left NOWRAP>an intro_pattern</TD>
<TD ALIGN=left NOWRAP><TT>intros</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>hyp</TT></TD>
<TD ALIGN=left NOWRAP>identifier</TD>
<TD ALIGN=left NOWRAP>an hypothesis defined in context</TD>
<TD ALIGN=left NOWRAP><TT>clear</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>reference</TT></TD>
<TD ALIGN=left NOWRAP>qualified identifier</TD>
<TD ALIGN=left NOWRAP>a global reference of term</TD>
<TD ALIGN=left NOWRAP><TT>unfold</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>constr</TT></TD>
<TD ALIGN=left NOWRAP>term</TD>
<TD ALIGN=left NOWRAP>a term</TD>
<TD ALIGN=left NOWRAP><TT>exact</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>integer</TT></TD>
<TD ALIGN=left NOWRAP>integer</TD>
<TD ALIGN=left NOWRAP>an integer</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>int_or_var</TT></TD>
<TD ALIGN=left NOWRAP>identifier or integer</TD>
<TD ALIGN=left NOWRAP>an integer</TD>
<TD ALIGN=left NOWRAP><TT>do</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>tactic</TT></TD>
<TD ALIGN=left NOWRAP>tactic</TD>
<TD ALIGN=left NOWRAP>a tactic</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE><BR>
<BR>
<B>Remark: </B>In order to be bound in tactic definitions, each syntactic entry
for argument type must include the case of simple <FONT COLOR=red> <I>L</I></FONT><SUB><FONT SIZE=2><I>tac</I></FONT></SUB> identifier
as part of what it parses. This is naturally the case for <TT>ident</TT>,
<TT>simple_intropattern</TT>, <TT>reference</TT>, <TT>constr</TT>, ... but not
for <TT>integer</TT>. This is the reason for introducing a special entry
<TT>int_or_var</TT> which evaluates to integers only but which
syntactically includes identifiers in order to be usable in tactic
definitions.<BR>
<BR>
<HR WIDTH="50%" SIZE=1><DL><DT><A NAME="note17" HREF="#text17"><FONT SIZE=5>1</FONT></A><DD>which are the levels effectively chosen in the
current implementation of <FONT COLOR=navy>Coq</FONT>
<DT><A NAME="note18" HREF="#text18"><FONT SIZE=5>2</FONT></A><DD>
<FONT COLOR=navy>Coq</FONT> accepts notations declared as no associative but the parser on
which <FONT COLOR=navy>Coq</FONT> is built, namely <FONT COLOR=navy>Camlp4</FONT>, currently does not implement the
no-associativity and replace it by a left associativity; hence it is
the same for <FONT COLOR=navy>Coq</FONT>: no-associativity is in fact left associativity
<DT><A NAME="note19" HREF="#text19"><FONT SIZE=5>3</FONT></A><DD>Tactic notations are just a simplification of
the <TT>Grammar tactic simple_tactic</TT> command that existed in
versions prior to version 8.0.
</DL>
<HR>
<A HREF="Reference-Manual012.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual014.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
