<!DOCTYPE html>
<html >
<head>


<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/coq/coqdoc.css" /><title>Chapter 20  Type Classes</title>
</head>
<body >

<div id="container">

<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="/" class="active">Home</a></li>
    <li><a href="/about-coq" title="More about coq">About Coq</a></li>
    <li><a href="/download">Get Coq</a></li>
    <li><a href="/documentation">Documentation</a></li>
    <li><a href="/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">
<div id="logoWrapper">
  <div id="logo"><a href="/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
  </div>
  <div id="siteName"><a href="/" title="Home">The Coq Proof Assistant</a>
  </div>
</div>
</div>

<div id="content">

<h1 id="sec690" class="chapter">Chapter 20  Type Classes</h1>
<ul>
<li><a href="Reference-Manual023.html#sec691">20.1  Class and Instance declarations</a>
</li><li><a href="Reference-Manual023.html#sec692">20.2  Binding classes</a>
</li><li><a href="Reference-Manual023.html#sec693">20.3  Parameterized Instances</a>
</li><li><a href="Reference-Manual023.html#sec694">20.4  Sections and contexts</a>
</li><li><a href="Reference-Manual023.html#sec695">20.5  Building hierarchies</a>
</li><li><a href="Reference-Manual023.html#TypeClassCommands">20.6  Summary of the commands
</a>
</li></ul>
<p>
<span style="font-size:x-large"><span style="font-weight:bold">Matthieu Sozeau</span></span> <br>
<br>

<a id="typeclasses"></a></p><p>This chapter presents a quick reference of the commands related to type
classes. For an actual introduction to type classes, there is a
description of the system [<a href="biblio.html#sozeau08">136</a>] and the literature on type
classes in <span style="font-variant:small-caps">Haskell</span> which also applies.</p>
<h2 id="sec691" class="section">20.1  Class and Instance declarations</h2>
<p>
<a id="ClassesInstances"></a></p><p>The syntax for class and instance declarations is the same as
record syntax of <span style="font-variant:small-caps">Coq</span>:

</p><div class="center">
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Class</span> <span style="font-family:monospace">Id</span> (α<sub>1</sub> : τ<sub>1</sub>) ⋯ (α<sub><span style="font-style:italic">n</span></sub> : τ<sub><span style="font-style:italic">n</span></sub>) 
[: <span style="font-style:oblique">sort</span>] := {</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >&nbsp;</td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-family:sans-serif">f</span><sub>1</sub></td><td style="vertical-align:top;text-align:center;white-space:nowrap" >:</td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub>1</sub> ; </td></tr>
<tr><td style="vertical-align:top;text-align:left;" >&nbsp;</td><td style="vertical-align:top;text-align:left;white-space:nowrap" >⋮</td><td style="vertical-align:top;text-align:center;white-space:nowrap" >&nbsp;</td><td style="vertical-align:top;text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="vertical-align:top;text-align:left;" >&nbsp;</td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-family:sans-serif">f</span><sub><span style="font-style:italic">m</span></sub></td><td style="vertical-align:top;text-align:center;white-space:nowrap" >:</td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">type</span><sub><span style="font-style:italic">m</span></sub> }.
</td></tr>
</table></td></tr>
</table></td></tr>
</table>
</div><div class="center">
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">Instance</span> <span style="font-style:oblique">ident</span> : <span style="font-family:monospace">Id</span> <span style="font-style:oblique">term</span><sub>1</sub> ⋯ <span style="font-style:oblique">term</span><sub><span style="font-style:italic">n</span></sub> := {</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >&nbsp;</td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-family:sans-serif">f</span><sub>1</sub></td><td style="vertical-align:top;text-align:center;white-space:nowrap" >:=</td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span><sub><span style="font-style:italic">f</span><sub>1</sub></sub> ; </td></tr>
<tr><td style="vertical-align:top;text-align:left;" >&nbsp;</td><td style="vertical-align:top;text-align:left;white-space:nowrap" >⋮</td><td style="vertical-align:top;text-align:center;white-space:nowrap" >&nbsp;</td><td style="vertical-align:top;text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="vertical-align:top;text-align:left;" >&nbsp;</td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-family:sans-serif">f</span><sub><span style="font-style:italic">m</span></sub></td><td style="vertical-align:top;text-align:center;white-space:nowrap" >:=</td><td style="vertical-align:top;text-align:left;white-space:nowrap" ><span style="font-style:oblique">term</span><sub><span style="font-style:italic">f</span><sub><span style="font-style:italic">m</span></sub></sub> }.
</td></tr>
</table></td></tr>
</table></td></tr>
</table>
</div><p>The α<sub><span style="font-style:italic">i</span></sub> : τ<sub><span style="font-style:italic">i</span></sub> variables are called the <em>parameters</em>
of the class and the <span style="font-style:italic">f</span><sub><span style="font-style:italic">k</span></sub> : <span style="font-style:oblique">type</span><sub><span style="font-style:italic">k</span></sub> are called the
<em>methods</em>. Each class definition gives rise to a corresponding
record declaration and each instance is a regular definition whose name
is given by <span style="font-style:oblique">ident</span> and type is an instantiation of the record type.</p><p>We’ll use the following example class in the rest of the chapter:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Class EqDec (A : Type) := {</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        eqb : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> bool ;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        eqb</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">leibniz : forall x y, eqb x y = true -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> x = y }.</span></span><span style="font-size:small"><br>
</span></div><p>This class implements a boolean equality test which is compatible with
Leibniz equality on some type. An example implementation is:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Instance unit</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">EqDec : EqDec unit :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      { eqb x y := true ;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        eqb</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">leibniz x y H := </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          match x, y return x = y with tt, tt =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">refl tt end }.</span></span><span style="font-size:small"><br>
</span></div><p>If one does not give all the members in the <span style="font-family:monospace">Instance</span>
declaration, Coq enters the proof-mode and the user is asked to build
inhabitants of the remaining fields, e.g.:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Instance eq</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">bool : EqDec bool :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      { eqb x y := if x then y else negb y }.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Proof. intros x y H.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  forall x y : bool, (if x then y else negb y) = true -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> x = y</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">1 subgoal</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  </span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x, y : bool</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  H : (if x then y else negb y) = true</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  ============================</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">  x = y</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   destruct x ; destruct y ; (discriminate || reflexivity). </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">No more subgoals.</span></span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Defined.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Proof.</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">(intros x y H).</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">(destruct x; destruct y; discriminate || reflexivity).</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Defined.</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">eq</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">bool is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>One has to take care that the transparency of every field is determined
by the transparency of the <span style="font-family:monospace">Instance</span> proof. One can use
alternatively the <span style="font-family:monospace">Program</span> <span style="font-family:monospace">Instance</span> <a id="hevea_default969"></a><a id="hevea_command261"></a> variant which has
richer facilities for dealing with obligations.</p>
<h2 id="sec692" class="section">20.2  Binding classes</h2>
<p>Once a type class is declared, one can use it in class binders:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition neqb {A} {eqa : EqDec A} (x y : A) := negb (eqb x y).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">neqb is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>When one calls a class method, a constraint is generated that is
satisfied only in contexts where the appropriate instances can be
found. In the example above, a constraint <span style="font-family:monospace">EqDec A</span> is generated and
satisfied by <span style="font-family:monospace">eqa : EqDec A</span>. In case no satisfying constraint can be
found, an error is raised:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Fail Definition neqb</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> (A : Type) (x y : A) := negb (eqb x y).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">The command has indeed failed with message:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Unable to satisfy the following constraints:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">In environment:</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">A : Type</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">x, y : A</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">?EqDec : "EqDec A"</span></span></span><span style="font-size:small"><br>
</span></div><p>The algorithm used to solve constraints is a variant of the eauto tactic
that does proof search with a set of lemmas (the instances). It will use
local hypotheses as well as declared lemmas in the
<span style="font-family:monospace">typeclass_instances</span> database. Hence the example can also be
written:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition neqb</span></span><span style="font-size:small"><span style="font-family:monospace">'</span></span><span style="font-size:small"><span style="font-family:monospace"> A (eqa : EqDec A) (x y : A) := negb (eqb x y).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">neqb</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">'</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>However, the generalizing binders should be used instead as they have
particular support for type classes:
</p><ul class="itemize"><li class="li-itemize">
They automatically set the maximally implicit status for type
class arguments, making derived functions as easy to use as class
methods. In the example above, <span style="font-family:monospace">A</span> and <span style="font-family:monospace">eqa</span> should be
set maximally implicit.
</li><li class="li-itemize">They support implicit quantification on partially applied type
classes (§<a href="Reference-Manual004.html#implicit-generalization">2.7.19</a>).
Any argument not given as part of a type class binder will be
automatically generalized.
</li><li class="li-itemize">They also support implicit quantification on superclasses
(§<a href="#classes%3Asuperclasses">20.5.1</a>)
</li></ul><p>Following the previous example, one can write:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition neqb</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">impl `{eqa : EqDec A} (x y : A) := negb (eqb x y).</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">neqb</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">impl is defined</span></span></span><span style="font-size:small"><br>
</span></div><p>Here <span style="font-family:monospace">A</span> is implicitly generalized, and the resulting function
is equivalent to the one above.</p>
<h2 id="sec693" class="section">20.3  Parameterized Instances</h2>
<p>One can declare parameterized instances as in <span style="font-variant:small-caps">Haskell</span> simply by giving
the constraints as a binding context before the instance, e.g.:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Instance prod</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">eqb `(EA : EqDec A, EB : EqDec B) : EqDec (A * B) :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      { eqb x y := match x, y with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        | (la, ra), (lb, rb) =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> andb (eqb la lb) (eqb ra rb)</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        end }.</span></span><span style="font-size:small"><br>
</span></div><p>These instances are used just as well as lemmas in the instance hint database.</p>
<h2 id="sec694" class="section">20.4  Sections and contexts</h2>
<p>
<a id="SectionContext"></a>
To ease the parametrization of developments by type classes, we provide
a new way to introduce variables into section contexts, compatible with 
the implicit argument mechanism. 
The new command works similarly to the <span style="font-family:monospace">Variables</span> vernacular
(see <a href="Reference-Manual003.html#Variable">1.3.1</a>), except it accepts any binding context as argument.
For example:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Section EqDec</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">defs.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Context `{EA : EqDec A}.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">A is declared</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">EA is declared</span></span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace">   Global Instance option</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">eqb : EqDec (option A) :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        { eqb x y := match x, y with</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          | Some x, Some y =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> eqb x y</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          | None, None =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> true</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          | </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">, </span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace"> =</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> false</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">          end }.</span></span><span style="font-size:small"><br>
</span></div><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> End EqDec</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">defs.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> About option</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">eqb.</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">option</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">eqb : forall A : Type, EqDec A -</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">&gt;</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic"> EqDec (option A)</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Arguments A, EA are implicit and maximally inserted</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Argument scopes are [type</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">scope </span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">]</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">option</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">eqb is transparent</span></span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">Expands to: Constant Top.option</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">_</span></span></span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">eqb</span></span></span><span style="font-size:small"><br>
</span></div><p>Here the <span style="font-family:monospace">Global</span> modifier redeclares the instance at the end of 
the section, once it has been generalized by the context variables it uses.</p>
<h2 id="sec695" class="section">20.5  Building hierarchies</h2>
<h3 id="sec696" class="subsection">20.5.1  Superclasses</h3>
<p>
<a id="classes:superclasses"></a>
One can also parameterize classes by other classes, generating a
hierarchy of classes and superclasses. In the same way, we give the
superclasses as a binding context:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Class Ord `(E : EqDec A) :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        { le : A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> A -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> bool }.</span></span><span style="font-size:small"><br>
</span></div><p>Contrary to <span style="font-variant:small-caps">Haskell</span>, we have no special syntax for superclasses, but
this declaration is morally equivalent to:
</p><pre class="verbatim">Class `(E : EqDec A) =&gt; Ord A :=
  { le : A -&gt; A -&gt; bool }.
</pre><p>This declaration means that any instance of the <span style="font-family:monospace">Ord</span> class must
have an instance of <span style="font-family:monospace">EqDec</span>. The parameters of the subclass contain
at least all the parameters of its superclasses in their order of
appearance (here <span style="font-family:monospace">A</span> is the only one).
As we have seen, <span style="font-family:monospace">Ord</span> is encoded as a record type with two parameters:
a type <span style="font-family:monospace">A</span> and an <span style="font-family:monospace">E</span> of type <span style="font-family:monospace">EqDec A</span>. However, one can
still use it as if it had a single parameter inside generalizing binders: the
generalization of superclasses will be done automatically. 
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition le</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">eqb `{Ord A} (x y : A) := andb (le x y) (le y x).</span></span><span style="font-size:small"><br>
</span></div><p>In some cases, to be able to specify sharing of structures, one may want to give
explicitly the superclasses. It is is possible to do it directly in regular
binders, and using the <span style="font-family:monospace">!</span> modifier in class binders. For
example:
<span style="font-size:small">
</span></p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Definition lt `{eqa : EqDec A, ! Ord eqa} (x y : A) := </span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        andb (le x y) (neqb x y).</span></span><span style="font-size:small"><br>
</span></div><p>The <span style="font-family:monospace">!</span> modifier switches the way a binder is parsed back to the
regular interpretation of Coq. In particular, it uses the implicit
arguments mechanism if available, as shown in the example.</p>
<h3 id="sec697" class="subsection">20.5.2  Substructures</h3>
<p>Substructures are components of a class which are instances of a class
themselves. They often arise when using classes for logical properties,
e.g.:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Class Reflexive (A : Type) (R : relation A) :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        reflexivity : forall x, R x x.</span></span><span style="font-size:small"><br>
<br>
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Class Transitive (A : Type) (R : relation A) :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        transitivity : forall x y z, R x y -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> R y z -</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> R x z.</span></span><span style="font-size:small"><br>
</span></div><p>This declares singleton classes for reflexive and transitive relations,
(see <a href="#SingletonClass">1</a> for an explanation).
These may be used as part of other classes:</p><div class="flushleft"><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">Coq </span></span><span style="font-size:small"><span style="font-family:monospace">&lt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Class PreOrder (A : Type) (R : relation A) :=</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">      { PreOrder</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">Reflexive :</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Reflexive A R ;</span></span><span style="font-size:small"><br>
</span><span style="font-size:small"><span style="font-family:monospace">        PreOrder</span></span><span style="font-size:small"><span style="font-family:monospace">_</span></span><span style="font-size:small"><span style="font-family:monospace">Transitive :</span></span><span style="font-size:small"><span style="font-family:monospace">&gt;</span></span><span style="font-size:small"><span style="font-family:monospace"> Transitive A R }.</span></span><span style="font-size:small"><br>
</span></div><p>The syntax <span style="font-family:monospace">:&gt;</span> indicates that each <span style="font-family:monospace">PreOrder</span> can be seen
as a <span style="font-family:monospace">Reflexive</span> relation. So each time a reflexive relation is
needed, a preorder can be used instead. This is very similar to the
coercion mechanism of <span style="font-family:monospace">Structure</span> declarations.
The implementation simply declares each projection as an instance. </p><p>One can also declare existing objects or structure
projections using the <span style="font-family:monospace">Existing Instance</span> command to achieve the 
same effect.</p>
<h2 id="TypeClassCommands" class="section">20.6  Summary of the commands
</h2>
<h3 id="sec699" class="subsection">20.6.1  <span style="font-family:monospace">Class </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace"> … </span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> 
: </span><span style="font-style:oblique">sort</span><span style="font-family:monospace">:= { field</span><sub>1</sub><span style="font-family:monospace"> ; …; field</span><sub><span style="font-style:italic">k</span></sub><span style="font-family:monospace"> }.</span></h3>
<p>
<a id="hevea_default970"></a><a id="hevea_command262"></a>
<a id="Class"></a></p><p>The <span style="font-family:monospace">Class</span> command is used to declare a type class with
parameters <span style="font-style:oblique">binder</span><sub>1</sub> to <span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub> and fields <span style="font-family:monospace">field</span><sub>1</sub> to
<span style="font-family:monospace">field</span><sub><span style="font-style:italic">k</span></sub>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<a id="SingletonClass"></a> <span style="font-family:monospace">Class </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> 
: </span><span style="font-style:oblique">sort</span><span style="font-family:monospace">:= </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> : </span><span style="font-style:oblique">type</span><sub>1</sub><span style="font-family:monospace">.</span>
This variant declares a <em>singleton</em> class whose only method is
<span style="font-style:oblique">ident</span><sub>1</sub>. This singleton class is a so-called definitional
class, represented simply as a definition 
<span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> := </span><span style="font-style:oblique">type</span><sub>1</sub> and whose
instances are themselves objects of this type. Definitional classes
are not wrapped inside records, and the trivial projection of an
instance of such a class is convertible to the instance itself. This can
be useful to make instances of existing objects easily and to reduce 
proof size by not inserting useless projections. The class
constant itself is declared rigid during resolution so that the class 
abstraction is maintained. </li><li class="li-enumerate"><a id="ExistingClass"></a> <span style="font-family:monospace">Existing Class </span><span style="font-style:oblique">ident</span><span style="font-family:monospace">.</span><a id="hevea_default971"></a><a id="hevea_command263"></a>
This variant declares a class a posteriori from a constant or
inductive definition. No methods or instances are defined.
</li></ol>
<h3 id="sec700" class="subsection">20.6.2  <span style="font-family:monospace">Instance </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> :
</span><span style="font-family:monospace">Class</span><span style="font-family:monospace"> </span><span style="font-family:monospace">t</span><sub>1</sub><span style="font-family:monospace"> …t</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> [| </span><span style="font-family:monospace"><span style="font-style:italic">priority</span></span><span style="font-family:monospace">]
:= { field</span><sub>1</sub><span style="font-family:monospace"> := b</span><sub>1</sub><span style="font-family:monospace"> ; …; field</span><sub><span style="font-style:italic">i</span></sub><span style="font-family:monospace"> := b</span><sub><span style="font-style:italic">i</span></sub><span style="font-family:monospace"> }</span></h3>
<p>
<a id="hevea_default972"></a><a id="hevea_command264"></a>
<a id="Instance"></a></p><p>The <span style="font-family:monospace">Instance</span> command is used to declare a type class instance
named <span style="font-style:oblique">ident</span> of the class <em>Class</em> with parameters t<sub>1</sub> to t<sub><span style="font-style:italic">n</span></sub> and
fields <span style="font-family:monospace">b</span><sub>1</sub> to <span style="font-family:monospace">b</span><sub><span style="font-style:italic">i</span></sub>, where each field must be a declared
field of the class. Missing fields must be filled in interactive proof mode.</p><p>An arbitrary context of the form <span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub>
can be put after the name of the instance and before the colon to
declare a parameterized instance.
An optional <span style="font-style:italic">priority</span> can be declared, 0 being the highest
priority as for auto hints. If the priority is not specified, it defaults to
<span style="font-style:italic">n</span>, the number of binders of the instance.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Instance </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> :
forall </span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span>+1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace">,
</span><span style="font-family:monospace">Class</span><span style="font-family:monospace"> </span><span style="font-family:monospace">t</span><sub>1</sub><span style="font-family:monospace"> …t</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace"> [| </span><span style="font-family:monospace"><span style="font-style:italic">priority</span></span><span style="font-family:monospace">] := </span><span style="font-style:oblique">term</span> 
This syntax is used for declaration of singleton class instances or
for directly giving an explicit term of type
<span style="font-family:monospace">forall </span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span>+1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">m</span></sub><span style="font-family:monospace">, </span><span style="font-family:monospace">Class</span><span style="font-family:monospace"> </span><span style="font-family:monospace">t</span><sub>1</sub><span style="font-family:monospace"> …t</span><sub><span style="font-style:italic">n</span></sub>.
One need not even mention the unique field name for singleton classes.</li><li class="li-enumerate"><span style="font-family:monospace">Global Instance</span> One can use the <span style="font-family:monospace">Global</span> modifier on
instances declared in a section so that their generalization is automatically
redeclared after the section is closed.</li><li class="li-enumerate"><span style="font-family:monospace">Program Instance</span> <a id="hevea_default973"></a><a id="hevea_command265"></a>
Switches the type-checking to <span style="font-variant:small-caps">Program</span> (chapter <a href="Reference-Manual027.html#Program">24</a>)
and uses the obligation mechanism to manage missing fields.</li><li class="li-enumerate"><span style="font-family:monospace">Declare Instance</span> <a id="hevea_default974"></a><a id="hevea_command266"></a>
In a <span style="font-family:monospace">Module Type</span>, this command states that a corresponding
concrete instance should exist in any implementation of this
<span style="font-family:monospace">Module Type</span>. This is similar to the distinction between
<span style="font-family:monospace">Parameter</span> vs. <span style="font-family:monospace">Definition</span>, or between <span style="font-family:monospace">Declare Module</span>
and <span style="font-family:monospace">Module</span>.</li></ol><p>Besides the <span style="font-family:monospace">Class</span> and <span style="font-family:monospace">Instance</span> vernacular commands, there
are a few other commands related to type classes.</p>
<h3 id="sec701" class="subsection">20.6.3  <span style="font-family:monospace">Existing Instance </span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> [| </span><span style="font-family:monospace"><span style="font-style:italic">priority</span></span><span style="font-family:monospace">]</span></h3>
<p>
<a id="hevea_default975"></a><a id="hevea_command267"></a>
<a id="ExistingInstance"></a></p><p>This commands adds an arbitrary constant whose type ends with an applied
type class to the instance database with an optional priority. It can be used
for redeclaring instances at the end of sections, or declaring structure
projections as instances. This is almost equivalent to <span style="font-family:monospace">Hint Resolve
</span><span style="font-style:oblique">ident</span><span style="font-family:monospace"> : typeclass_instances</span>.</p><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">Existing Instances </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub><span style="font-family:monospace">
[| </span><span style="font-family:monospace"><span style="font-style:italic">priority</span></span><span style="font-family:monospace">]</span>
<a id="hevea_default976"></a><a id="hevea_command268"></a>
With this command, several existing instances can be declared at once.
</li></ol>
<h3 id="sec702" class="subsection">20.6.4  <span style="font-family:monospace">Context </span><span style="font-style:oblique">binder</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">binder</span><sub><span style="font-style:italic">n</span></sub></h3>
<p>
<a id="hevea_default977"></a><a id="hevea_command269"></a>
<a id="Context"></a></p><p>Declares variables according to the given binding context, which might
use implicit generalization (see <a href="#SectionContext">20.4</a>).</p>
<h3 id="sec703" class="subsection">20.6.5  <span style="font-family:monospace">typeclasses eauto</span></h3>
<p>
<a id="hevea_default978"></a><a id="hevea_tactic224"></a>
<a id="typeclasseseauto"></a></p><p>The <span style="font-family:monospace">typeclasses eauto</span> tactic uses a different resolution engine
than <span style="font-family:monospace">eauto</span> and <span style="font-family:monospace">auto</span>. The main differences are the following:
</p><ul class="itemize"><li class="li-itemize">
Contrary to <span style="font-family:monospace">eauto</span> and <span style="font-family:monospace">auto</span>, the resolution is done
entirely in the new proof engine (as of Coq v8.6), meaning that
backtracking is available among dependent subgoals, and shelving goals
is supported. <span style="font-family:monospace">typeclasses eauto</span> is a multi-goal tactic.
It analyses the dependencies between subgoals to avoid
backtracking on subgoals that are entirely independent.
</li><li class="li-itemize">When called with no arguments, <span style="font-family:monospace">typeclasses eauto</span> uses the
<span style="font-family:monospace">typeclass_instances</span> database by default (instead of <span style="font-family:monospace">core</span>).
Dependent subgoals are automatically shelved, and shelved
goals can remain after resolution ends (following the behavior of
<span style="font-variant:small-caps">Coq</span> 8.5).<p><em>Note: </em> As of Coq 8.6, <span style="font-family:monospace">all:once (typeclasses eauto)</span>
faithfully mimicks what happens during typeclass resolution when it is
called during refinement/type-inference, except that <em>only</em>
declared class subgoals are considered at the start of resolution
during type inference, while “all” can select non-class subgoals as
well. It might move to <span style="font-family:monospace">all:typeclasses eauto</span> in future versions
when the refinement engine will be able to backtrack.
</p></li><li class="li-itemize">When called with specific databases (e.g. <span style="font-family:monospace">with</span>), <span style="font-family:monospace">typeclasses eauto</span> allows shelved goals to remain at any point
during search and treat typeclasses goals like any other.
</li><li class="li-itemize">The transparency information of databases is used consistently for
all hints declared in them. It is always used when calling the unifier.
When considering the local hypotheses, we use the transparent
state of the first hint database given. Using an empty database
(created with <span style="font-family:monospace">Create HintDb</span> for example) with 
unfoldable variables and constants as the first argument of
typeclasses eauto hence makes resolution with the local hypotheses use
full conversion during unification.
</li></ul><p><br>
<span style="font-weight:bold">Variants: </span></p><ol class="enumerate" type=1><li class="li-enumerate">
<a id="depth"></a> <span style="font-family:monospace">typeclasses eauto </span><span style="font-family:monospace"><span style="font-style:oblique">[</span></span><span style="font-style:oblique">num</span><span style="font-family:monospace"><span style="font-style:oblique">]</span></span>
<em>Warning:</em> The semantics for the limit <span style="font-style:oblique">num</span> is different than
for <span style="font-family:monospace">auto</span>. By default, if no limit is given the search is
unbounded. Contrary to <span style="font-family:monospace">auto</span>, introduction steps (<span style="font-family:monospace">intro</span>)
are counted, which might result in larger limits being necessary
when searching with <span style="font-family:monospace">typeclasses eauto</span> than <span style="font-family:monospace">auto</span>.</li><li class="li-enumerate"><a id="with"></a> <span style="font-family:monospace">typeclasses eauto with </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub>.
This variant runs resolution with the given hint databases. It treats
typeclass subgoals the same as other subgoals (no shelving of
non-typeclass goals in particular).
</li></ol>
<h3 id="sec704" class="subsection">20.6.6  <span style="font-family:monospace">autoapply </span><span style="font-style:oblique">term</span><span style="font-family:monospace"> with </span><span style="font-style:oblique">ident</span></h3>
<p>
<a id="hevea_default979"></a><a id="hevea_tactic225"></a></p><p>The tactic <span style="font-family:monospace">autoapply</span> applies a term using the transparency
information of the hint database <span style="font-style:oblique">ident</span>, and does <em>no</em> typeclass
resolution. This can be used in <span style="font-family:monospace">Hint Extern</span>’s for typeclass
instances (in hint db <span style="font-family:monospace">typeclass_instances</span>) to
allow backtracking on the typeclass subgoals created by the lemma
application, rather than doing type class resolution locally at the hint
application time.</p>
<h3 id="sec705" class="subsection">20.6.7  <span style="font-family:monospace">Typeclasses Transparent, Opaque </span><span style="font-style:oblique">ident</span><sub>1</sub><span style="font-family:monospace"> …</span><span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub></h3>
<p>
<a id="hevea_default980"></a><a id="hevea_command270"></a>
<a id="hevea_default981"></a><a id="hevea_command271"></a>
<a id="TypeclassesTransparency"></a></p><p>This commands defines the transparency of <span style="font-style:oblique">ident</span><sub>1</sub> …<span style="font-style:oblique">ident</span><sub><span style="font-style:italic">n</span></sub> 
during type class resolution. It is useful when some constants prevent some
unifications and make resolution fail. It is also useful to declare
constants which should never be unfolded during proof-search, like
fixpoints or anything which does not look like an abbreviation. This can
additionally speed up proof search as the typeclass map can be indexed
by such rigid constants (see <a href="Reference-Manual010.html#HintTransparency">8.9.1</a>).
By default, all constants and local variables are considered transparent.
One should take care not to make opaque any constant that is used to
abbreviate a type, like <span style="font-family:monospace">relation A := A -&gt; A -&gt; Prop</span>.</p><p>This is equivalent to <span style="font-family:monospace">Hint Transparent,Opaque</span> <span style="font-style:oblique">ident</span> <span style="font-family:monospace">: typeclass_instances</span>.</p>
<h3 id="sec706" class="subsection">20.6.8  <span style="font-family:monospace">Set Typeclasses Dependency Order</span></h3>
<p>
<a id="hevea_default982"></a><a id="hevea_option67"></a></p><p>This option (on by default since 8.6) respects the dependency order between
subgoals, meaning that subgoals which are depended on by other subgoals 
come first, while the non-dependent subgoals were put before the
dependent ones previously (Coq v8.5 and below). This can result in quite
different performance behaviors of proof search.</p>
<h3 id="sec707" class="subsection">20.6.9  <span style="font-family:monospace">Set Typeclasses Filtered Unification</span></h3>
<p>
<a id="hevea_default983"></a><a id="hevea_option68"></a></p><p>This option, available since Coq 8.6 and off by default, switches the
hint application procedure to a filter-then-unify strategy. To apply a
hint, we first check that the goal <em>matches</em> syntactically the
inferred or specified pattern of the hint, and only then try to
<em>unify</em> the goal with the conclusion of the hint. This can
drastically improve performance by calling unification less often,
matching syntactic patterns being very quick. This also provides more
control on the triggering of instances. For example, forcing a constant
to explicitely appear in the pattern will make it never apply on a goal
where there is a hole in that place.</p>
<h3 id="sec708" class="subsection">20.6.10  <span style="font-family:monospace">Set Typeclasses Legacy Resolution</span></h3>
<p>
<a id="hevea_default984"></a><a id="hevea_option69"></a></p><p>This option (off by default) uses the 8.5 implementation of resolution.
Use for compatibility purposes only (porting and debugging).</p>
<h3 id="sec709" class="subsection">20.6.11  <span style="font-family:monospace">Set Typeclasses Module Eta</span></h3>
<p>
<a id="hevea_default985"></a><a id="hevea_option70"></a></p><p>This option allows eta-conversion for functions and records during
unification of type-classes. This option is now unsupported in 8.6 with
<span style="font-family:monospace">Typeclasses Filtered Unification</span> set, but still affects the
default unification strategy, and the one used in <span style="font-family:monospace">Legacy
Resolution</span> mode. It is <em>unset</em> by default. If <span style="font-family:monospace">Typeclasses
Filtered Unification</span> is set, this has no effect and unification will
find solutions up-to eta conversion. Note however that syntactic
pattern-matching is not up-to eta.</p>
<h3 id="sec710" class="subsection">20.6.12  <span style="font-family:monospace">Set Typeclasses Limit Intros</span></h3>
<p>
<a id="hevea_default986"></a><a id="hevea_option71"></a></p><p>This option (on by default in Coq 8.6 and below) controls the ability to
apply hints while avoiding (functional) eta-expansions in the generated
proof term. It does so by allowing hints that conclude in a product to
apply to a goal with a matching product directly, avoiding an
introduction. <em>Warning:</em> this can be expensive as it requires
rebuilding hint clauses dynamically, and does not benefit from the
invertibility status of the product introduction rule, resulting in
potentially more expensive proof-search (i.e. more useless
backtracking).</p>
<h3 id="sec711" class="subsection">20.6.13  <span style="font-family:monospace">Set Typeclass Resolution After Apply</span></h3>
<p>
<a id="hevea_default987"></a><a id="hevea_option72"></a>
<em>Deprecated since 8.6</em></p><p>This option (off by default in Coq 8.6 and 8.5) controls the resolution
of typeclass subgoals generated by the <span style="font-family:monospace">apply</span> tactic.</p>
<h3 id="sec712" class="subsection">20.6.14  <span style="font-family:monospace">Set Typeclass Resolution For Conversion</span></h3>
<p>
<a id="hevea_default988"></a><a id="hevea_option73"></a></p><p>This option (on by default) controls the use of typeclass resolution
when a unification problem cannot be solved during
elaboration/type-inference. With this option on, when a unification
fails, typeclass resolution is tried before launching unification once again.</p>
<h3 id="sec713" class="subsection">20.6.15  <span style="font-family:monospace">Set Typeclasses Strict Resolution</span></h3>
<p>
<a id="hevea_default989"></a><a id="hevea_option74"></a></p><p>Typeclass declarations introduced when this option is set have a
stricter resolution behavior (the option is off by default). When
looking for unifications of a goal with an instance of this class, we
“freeze” all the existentials appearing in the goals, meaning that
they are considered rigid during unification and cannot be instantiated.</p>
<h3 id="sec714" class="subsection">20.6.16  <span style="font-family:monospace">Set Typeclasses Unique Solutions</span></h3>
<p>
<a id="hevea_default990"></a><a id="hevea_option75"></a></p><p>When a typeclass resolution is launched we ensure that it has a single
solution or fail. This ensures that the resolution is canonical, but can
make proof search much more expensive.</p>
<h3 id="sec715" class="subsection">20.6.17  <span style="font-family:monospace">Set Typeclasses Unique Instances</span></h3>
<p>
<a id="hevea_default991"></a><a id="hevea_option76"></a></p><p>Typeclass declarations introduced when this option is set have a
more efficient resolution behavior (the option is off by default). When
a solution to the typeclass goal of this class is found, we never
backtrack on it, assuming that it is canonical.</p>
<h3 id="sec716" class="subsection">20.6.18  <span style="font-family:monospace">Typeclasses eauto := [debug] [(dfs) | (bfs)] [</span><span style="font-family:monospace"><em>depth</em></span><span style="font-family:monospace">]</span></h3>
<p>
<a id="hevea_default992"></a><a id="hevea_command272"></a>
<a id="TypeclassesEauto"></a></p><p>This command allows more global customization of the type class
resolution tactic.
The semantics of the options are:
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">debug</span> In debug mode, the trace of successfully applied
tactics is printed.
</li><li class="li-itemize"><span style="font-family:monospace">dfs, bfs</span> This sets the search strategy to depth-first search
(the default) or breadth-first search.
</li><li class="li-itemize"><em>depth</em> This sets the depth limit of the search.
</li></ul>
<h3 id="sec717" class="subsection">20.6.19  <span style="font-family:monospace">Set Typeclasses Debug [Verbosity </span><span style="font-style:oblique">num</span><span style="font-family:monospace">]</span></h3>
<p>
<a id="hevea_default993"></a><a id="hevea_option77"></a>
<a id="hevea_default994"></a><a id="hevea_option78"></a></p><p>These options allow to see the resolution steps of typeclasses that are
performed during search. The <span style="font-family:monospace">Debug</span> option is synonymous to 
<span style="font-family:monospace">Debug Verbosity 1</span>, and <span style="font-family:monospace">Debug Verbosity 2</span> provides more
information (tried tactics, shelving of goals, etc…).</p>
<h3 id="sec718" class="subsection">20.6.20  <span style="font-family:monospace">Set Refine Instance Mode</span></h3>
<p>
<a id="hevea_default995"></a><a id="hevea_option79"></a></p><p>The option <span style="font-family:monospace">Refine Instance Mode</span> allows to switch the behavior of instance
declarations made through the <span style="font-family:monospace">Instance</span> command.
</p><ul class="itemize"><li class="li-itemize">
When it is on (the default), instances that have unsolved holes in their
proof-term silently open the proof mode with the remaining obligations to prove.
</li><li class="li-itemize">When it is off, they fail with an error instead.
</li></ul>

<div id="sidebarWrapper">
  <div id="sidebar">
    <div class="block">
      <h2 class="title">Navigation</h2>
      <div class="content">
        <ul class="menu">
          <li class="leaf"><a href="index.html">Cover</a></li>
          <li class="leaf"><a href="toc.html">Table of contents</a></li>
          <li class="leaf">Index
            <ul class="menu">
              <li><a href="general-index.html">General</a></li>
              <li><a href="command-index.html">Commands</a></li>
              <li><a href="option-index.html">Options</a></li>
              <li><a href="tactic-index.html">Tactics</a></li>
              <li><a href="error-index.html">Errors</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</body>
</html>
