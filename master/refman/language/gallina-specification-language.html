

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Gallina specification language &mdash; Coq 8.12+alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Coq 8.12+alpha documentation" href="../index.html"/>
        <link rel="next" title="Extensions of Gallina" href="gallina-extensions.html"/>
        <link rel="prev" title="Recent changes" href="../changes.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.12+alpha
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Indexes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">Preamble</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#main-novelties">Main novelties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#changes-in-7-3-1">Changes in 7.3.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-11">Version 8.11</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-11-beta1">Changes in 8.11+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-11-0">Changes in 8.11.0</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id147">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id294">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id296">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id297">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id298">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id299">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id300">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id301">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id303">Potential sources of incompatibilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id304">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id305">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id306">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id307">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#id308">Summary of changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The language</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Gallina specification language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#lexical-conventions">Lexical conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#syntax-of-terms">Syntax of terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qualified-identifiers-and-simple-identifiers">Qualified identifiers and simple identifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#numerals-and-strings">Numerals and strings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="#abstractions-fun">Abstractions: fun</a></li>
<li class="toctree-l3"><a class="reference internal" href="#products-forall">Products: forall</a></li>
<li class="toctree-l3"><a class="reference internal" href="#applications">Applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definition-by-cases-match">Definition by cases: match</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recursive-and-co-recursive-functions-fix-and-cofix">Recursive and co-recursive functions: fix and cofix</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-vernacular">The Vernacular</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#assumptions">Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inductive-definitions">Inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variants">Variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#co-inductive-types">Co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#definition-of-recursive-functions">Definition of recursive functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#definition-of-functions-by-recursion-over-inductive-objects">Definition of functions by recursion over inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#definitions-of-recursive-objects-in-co-inductive-types">Definitions of recursive objects in co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assertions-and-proofs">Assertions and proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#attributes">Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a><ul>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#record-types">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#primitive-record-types">Primitive Record Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#compatibility-projections-and-match">Compatibility Projections and <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#variants-and-extensions-of-match">Variants and extensions of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#first-destructuring-let-syntax">First destructuring let syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#second-destructuring-let-syntax">Second destructuring let syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#printing-nested-patterns">Printing nested patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#factorization-of-clauses-with-same-right-hand-side">Factorization of clauses with same right-hand side</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#use-of-a-default-clause">Use of a default clause</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#printing-of-wildcard-patterns">Printing of wildcard patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#printing-of-the-elimination-predicate">Printing of the elimination predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#printing-matching-on-irrefutable-patterns">Printing matching on irrefutable patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#printing-matching-on-booleans">Printing matching on booleans</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#section-mechanism">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#module-system">Module system</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#reserved-commands-inside-an-interactive-module">Reserved commands inside an interactive module</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#reserved-commands-inside-an-interactive-module-type">Reserved commands inside an interactive module type:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#libraries-and-qualified-names">Libraries and qualified names</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#names-of-libraries">Names of libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#libraries-and-filesystem">Libraries and filesystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#implicit-arguments">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#maximal-or-non-maximal-insertion-of-implicit-arguments">Maximal or non maximal insertion of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#trailing-implicit-arguments">Trailing Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#declaring-implicit-arguments">Declaring Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#combining-manual-declaration-and-automatic-declaration">Combining manual declaration and automatic declaration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#displaying-what-the-implicit-arguments-are">Displaying what the implicit arguments are</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#explicit-displaying-of-implicit-arguments-for-pretty-printing">Explicit displaying of implicit arguments for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#canonical-structures">Canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#printing-universes">Printing universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#existential-variables">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#explicit-displaying-of-existential-instances-for-pretty-printing">Explicit displaying of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#primitive-integers">Primitive Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#primitive-floats">Primitive Floats</a></li>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html#bidirectionality-hints">Bidirectionality hints</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="coq-library.html">The <span class="smallcaps">Coq</span> library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="coq-library.html#the-basic-library">The basic library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#logic">Logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#propositional-connectives">Propositional Connectives</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#quantifiers">Quantifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#equality">Equality</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#lemmas">Lemmas</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#datatypes">Datatypes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#programming">Programming</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#specification">Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#basic-arithmetic">Basic Arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#survey">Survey</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#notations-for-integer-arithmetic">Notations for integer arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#real-numbers-library">Real numbers library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#notations-for-real-numbers">Notations for real numbers</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#some-tactics-for-real-numbers">Some tactics for real numbers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#list-library">List library</a></li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#floats-library">Floats library</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cic.html">Calculus of Inductive Constructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="cic.html#the-terms">The terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="cic.html#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#terms">Terms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#typing-rules">Typing rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#conversion-rules">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="cic.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#iota-reduction">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#delta-reduction">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#zeta-reduction">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#inductive-definitions">Inductive Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="cic.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#well-formed-inductive-definitions">Well-formed inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="cic.html#arity-of-a-given-sort">Arity of a given sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#arity">Arity</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#type-of-constructor">Type of constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#positivity-condition">Positivity Condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#strict-positivity">Strict positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#nested-positivity">Nested Positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#correctness-rules">Correctness rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#template-polymorphism">Template polymorphism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#destructors">Destructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="cic.html#the-match-with-end-construction">The match ... with ... end construction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cic.html#fixpoint-definitions">Fixpoint definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="cic.html#id29">Typing rule</a></li>
<li class="toctree-l4"><a class="reference internal" href="cic.html#reduction-rule">Reduction rule</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#co-inductive-types">Co-inductive types</a></li>
<li class="toctree-l2"><a class="reference internal" href="cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="module-system.html">The Module System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="module-system.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l2"><a class="reference internal" href="module-system.html#typing-modules">Typing Modules</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">The proof engine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#flags-options-and-tables">Flags, Options and Tables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#scope-qualifiers-for-set-and-unset">Scope qualifiers for <code class="docutils literal notranslate"><span class="pre">Set</span></code> and <code class="docutils literal notranslate"><span class="pre">Unset</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#loadpath">Loadpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-the-reduction-strategies-and-the-conversion-algorithm">Controlling the reduction strategies and the conversion algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-the-locality-of-commands">Controlling the locality of commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-typing-flags">Controlling Typing Flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#switching-on-off-the-proof-editing-mode">Switching on/off the proof editing mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#proof-modes">Proof modes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#navigation-in-the-proof-tree">Navigation in the proof tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#bullets">Bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#mandatory-bullets">Mandatory Bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#set-bullet-behavior">Set Bullet Behavior</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#requesting-information">Requesting information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#how-diffs-are-calculated">How diffs are calculated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#controlling-the-effect-of-proof-editing-commands">Controlling the effect of proof editing commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#bindings-list">Bindings list</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#occurrence-sets-and-occurrence-clauses">Occurrence sets and occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#case-analysis-and-induction">Case analysis and induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#rewriting-expressions">Rewriting expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#performing-computations">Performing computations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#conversion-tactics-applied-to-hypotheses">Conversion tactics applied to hypotheses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#automation">Automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#controlling-automation">Controlling automation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#the-hints-databases-for-auto-and-eauto">The hints databases for auto and eauto</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#creating-hint-databases">Creating Hint databases</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#hint-locality">Hint locality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#decision-procedures">Decision procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#checking-properties-of-terms">Checking properties of terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#equality">Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#equality-and-inductive-sets">Equality and inductive sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#inversion">Inversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#automating">Automating</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#non-logical-tactics">Non-logical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">Ltac</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#semantics">Semantics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#sequence">Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#local-application-of-tactics">Local application of tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#for-loop">For loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#error-catching">Error catching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#detecting-progress">Detecting progress</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#backtracking-branching">Backtracking branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#first-tactic-to-work">First tactic to work</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#left-biased-branching">Left-biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#generalized-biased-branching">Generalized biased branching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#soft-cut">Soft cut</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-successes">Checking the successes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-failure">Checking the failure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-success">Checking the success</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#solving">Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#identity">Identity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#failing">Failing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#timeout">Timeout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#timing-a-tactic-that-evaluates-to-a-term">Timing a tactic that evaluates to a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#local-definitions">Local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#application">Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#function-construction">Function construction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#pattern-matching-on-terms">Pattern matching on terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#pattern-matching-on-goals">Pattern matching on goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#computing-in-a-constr">Computing in a constr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#recovering-the-type-of-a-term">Recovering the type of a term</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#manipulating-untyped-terms">Manipulating untyped terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#counting-the-goals">Counting the goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#testing-boolean-expressions">Testing boolean expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#proving-a-subgoal-as-a-separate-lemma">Proving a subgoal as a separate lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#defining-ltac-functions">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#info-trace">Info trace</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac2.html">Ltac2</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac2.html#general-design">General design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac2.html#ml-component">ML component</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#type-syntax">Type Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#type-declarations">Type declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#term-syntax">Term Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#ltac-definitions">Ltac Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#reduction">Reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#typing">Typing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#effects">Effects</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#standard-io">Standard IO</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#fatal-errors">Fatal errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#backtracking">Backtracking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#goals">Goals</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac2.html#meta-programming">Meta-programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#id3">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#generic-syntax-for-quotations">Generic Syntax for Quotations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#built-in-quotations">Built-in quotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#strict-vs-non-strict-mode">Strict vs. non-strict mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#term-antiquotations">Term Antiquotations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#syntax">Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#semantics">Semantics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#match-over-terms">Match over terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#match-over-goals">Match over goals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac2.html#notations">Notations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#scopes">Scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#id6">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#abbreviations">Abbreviations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac2.html#evaluation">Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac2.html#debug">Debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac2.html#compatibility-layer-with-ltac1">Compatibility layer with Ltac1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#ltac1-from-ltac2">Ltac1 from Ltac2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#simple-api">Simple API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#low-level-api">Low-level API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#ltac2-from-ltac1">Ltac2 from Ltac1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#switching-between-ltac-languages">Switching between Ltac languages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac2.html#transition-from-ltac1">Transition from Ltac1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#syntax-changes">Syntax changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#tactic-delay">Tactic delay</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#variable-binding">Variable binding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#in-ltac-expressions">In Ltac expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#in-quotations">In quotations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#exception-catching">Exception catching</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#dependent-induction">dependent induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#a-larger-example">A larger example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#autorewrite">autorewrite</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#gallina-extensions"><span class="smallcaps">Gallina</span> extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#abbreviations">Abbreviations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#matching">Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#occurrence-selection">Occurrence selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-move-tactic">The move tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-case-tactic">The case tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-elim-tactic">The elim tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-apply-tactic">The apply tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#discharge">Discharge</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#clear-rules">Clear rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#matching-for-apply-and-exact">Matching for apply and exact</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-abstract-tactic">The abstract tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#simplification-items">Simplification items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#views">Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#clear-switch">Clear switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#branching-and-destructuring">Branching and destructuring</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#block-introduction">Block introduction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#structure">Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-have-tactic">The have tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#generating-let-in-context-entries-with-have">Generating let in context entries with have</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-have-tactic-and-typeclass-resolution">The have tactic and typeclass resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#variants-the-suff-and-wlog-tactics">Variants: the suff and wlog tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewrite-redex-selection">Rewrite redex selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#chained-rewrite-steps">Chained rewrite steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#explicit-redex-switches-are-matched-first">Explicit redex switches are matched first</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#occurrence-switches-and-redex-switches">Occurrence switches and redex switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#occurrence-selection-and-repetition">Occurrence selection and repetition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#multi-rule-rewriting">Multi-rule rewriting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#wildcards-vs-abstractions">Wildcards vs abstractions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">When <span class="smallcaps">SSReflect</span> rewrite fails on standard <span class="smallcaps">Coq</span> licit rewrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#existential-metavariables-and-rewriting">Existential metavariables and rewriting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-under-tactic">The under tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interactive-mode">Interactive mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#one-liner-mode">One-liner mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#contextual-pattern-in-set-and-the-tactical">Contextual pattern in set and the : tactical</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#contextual-patterns-in-rewrite">Contextual patterns in rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#specializing-assumptions">Specializing assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#id13">Specializing assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#id14">Interpreting assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#ssr-searching-tool"><span class="smallcaps">SSReflect</span> searching tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">User extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-symbolic-notations">Displaying symbolic notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-identifiers">Binders bound in the notation and parsed as identifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-patterns">Binders bound in the notation and parsed as patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-bound-in-the-notation-and-parsed-as-terms">Binders bound in the notation and parsed as terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binders-not-bound-in-the-notation">Binders not bound in the notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#summary">Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#syntax-of-notations">Syntax of notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#persistence-of-notations">Persistence of notations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes">Interpretation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-opening-of-an-interpretation-scope">Local opening of an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-arguments-of-a-constant-to-an-interpretation-scope">Binding arguments of a constant to an interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#binding-types-of-arguments-to-an-interpretation-scope">Binding types of arguments to an interpretation scope</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> interpretation scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes-used-in-the-standard-library-of-coq">Interpretation scopes used in the standard library of Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numeral-notations">Numeral notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Practical tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-resource-file">By resource file</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-environment-variables">By environment variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#by-command-line-options">By command line options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-interfaces-produced-using-vos">Compiled interfaces (produced using <code class="docutils literal notranslate"><span class="pre">-vos</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project">Building a <span class="smallcaps">Coq</span> project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile">Building a <span class="smallcaps">Coq</span> project with coq_makefile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coqmakefile-local">CoqMakefile.local</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#timing-targets-and-performance-testing">Timing targets and performance testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#reusing-extending-the-generated-makefile">Reusing/extending the generated Makefile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-subset-of-the-targets-with-j">Building a subset of the targets with <code class="docutils literal notranslate"><span class="pre">-j</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a <span class="smallcaps">Coq</span> project with Dune</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#computing-module-dependencies">Computing Module dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#documenting-coq-files-with-coqdoc">Documenting <span class="smallcaps">Coq</span> files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#coq-material-inside-documentation"><span class="smallcaps">Coq</span> material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#interactive-navigation-into-coq-scripts">Interactive navigation into Coq scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#proof-folding">Proof folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#vernacular-commands-templates">Vernacular commands, templates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Addendum</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns">Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#declaring-coercions">Declaring Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-at-function-application">Coercion at function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-type">Coercion to a type</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-function">Coercion to a function</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#class-and-instance-declarations">Class and Instance declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#binding-classes">Binding classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#parameterized-instances">Parameterized Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html#summary-of-the-commands">Summary of the commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto <code class="docutils literal notranslate"><span class="pre">:=</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#description-of-omega">Description of <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#arithmetical-goals-recognized-by-omega">Arithmetical goals recognized by <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#messages-from-omega">Messages from <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#using-omega">Using <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#options">Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#technical-data">Technical data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-tactic">Overview of the tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#overview-of-the-omega-decision-procedure">Overview of the OMEGA decision procedure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html#bugs">Bugs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html#zify-pre-processing-of-arithmetic-goals"><code class="docutils literal notranslate"><span class="pre">zify</span></code>: pre-processing of arithmetic goals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between <span class="smallcaps">Coq</span> and ML type systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-reflexive-relations">Rewriting and non reflexive relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-symmetric-relations">Rewriting and non symmetric relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#id2">Caveats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/miscellaneous-extensions.html#program-derivation">Program derivation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#an-example-of-a-proof-using-cumulativity">An example of a proof using cumulativity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html#universe-polymorphism-and-sections">Universe polymorphism and sections</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html#issues-with-non-cumulativity">Issues with non-cumulativity</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The Gallina specification language</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/language/gallina-specification-language.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="the-gallina-specification-language">
<span id="gallinaspecificationlanguage"></span><h1>The Gallina specification language<a class="headerlink" href="#the-gallina-specification-language" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes Gallina, the specification language of Coq. It allows
developing mathematical theories and to prove specifications of programs. The
theories are built from axioms, hypotheses, parameters, lemmas, theorems and
definitions of constants, functions, predicates and sets. The syntax of logical
objects involved in theories is described in Section <a class="reference internal" href="#term"><span class="std std-ref">Terms</span></a>. The
language of commands, called <em>The Vernacular</em> is described in Section
<a class="reference internal" href="#vernacular"><span class="std std-ref">The Vernacular</span></a>.</p>
<p>In Coq, logical objects are typed to ensure their logical correctness.  The
rules implemented by the typing algorithm are described in Chapter <a class="reference internal" href="cic.html#calculusofinductiveconstructions"><span class="std std-ref">Calculus of Inductive Constructions</span></a>.</p>
<div class="section" id="lexical-conventions">
<span id="id1"></span><h2>Lexical conventions<a class="headerlink" href="#lexical-conventions" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Blanks</dt>
<dd>Space, newline and horizontal tab are considered blanks.
Blanks are ignored but they separate tokens.</dd>
<dt>Comments</dt>
<dd>Comments are enclosed between <code class="docutils literal notranslate"><span class="pre">(*</span></code> and <code class="docutils literal notranslate"><span class="pre">*)</span></code>.  They can be nested.
They can contain any character. However, embedded <a class="reference internal" href="#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">string</span></code></a> literals must be
correctly closed. Comments are treated as blanks.</dd>
<dt>Identifiers</dt>
<dd><p class="first">Identifiers, written <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>, are sequences of letters, digits, <code class="docutils literal notranslate"><span class="pre">_</span></code> and
<code class="docutils literal notranslate"><span class="pre">'</span></code>, that do not start with a digit or <code class="docutils literal notranslate"><span class="pre">'</span></code>.  That is, they are
recognized by the following grammar (except that the string <code class="docutils literal notranslate"><span class="pre">_</span></code> is reserved;
it is not a valid identifier):</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-ident"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-first_letter"><span class="hole">first_letter</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-subsequent_letter"><span class="hole">subsequent_letter</span></a></span><span class="notation-sup">*</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-first_letter"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-first_letter"><span class="hole">first_letter</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>a</span></span> <span><span>..</span></span> <span><span>z</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>A</span></span> <span><span>..</span></span> <span><span>Z</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>_</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-unicode_letter"><span class="hole">unicode_letter</span></a></span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-subsequent_letter"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-subsequent_letter"><span class="hole">subsequent_letter</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-first_letter"><span class="hole">first_letter</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-digit"><span class="hole">digit</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-unicode_id_part"><span class="hole">unicode_id_part</span></a></span></span></span></span></span></span></span><p class="last">All characters are meaningful. In particular, identifiers are case-sensitive.
<span class="inline-grammar-production"><span class="target" id="grammar-token-unicode_letter"></span><code class="docutils literal notranslate"><span class="pre">unicode_letter</span></code></span> non-exhaustively includes Latin,
Greek, Gothic, Cyrillic, Arabic, Hebrew, Georgian, Hangul, Hiragana
and Katakana characters, CJK ideographs, mathematical letter-like
symbols and non-breaking space. <span class="inline-grammar-production"><span class="target" id="grammar-token-unicode_id_part"></span><code class="docutils literal notranslate"><span class="pre">unicode_id_part</span></code></span>
non-exhaustively includes symbols for prime letters and subscripts.</p>
</dd>
<dt>Numerals</dt>
<dd><p class="first">Numerals are sequences of digits with an optional fractional part
and exponent, optionally preceded by a minus sign. <a class="reference internal" href="#grammar-token-int"><code class="xref std std-token docutils literal notranslate"><span class="pre">int</span></code></a> is an integer;
a numeral without fractional or exponent parts. <a class="reference internal" href="#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a> is a non-negative
integer.  Underscores embedded in the digits are ignored, for example
<code class="docutils literal notranslate"><span class="pre">1_000_000</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">1000000</span></code>.</p>
<span class="prodn-table last"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-numeral"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-numeral"><span class="hole">numeral</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-digit"><span class="hole">digit</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>.</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-digit"><span class="hole">digit</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="alternative"><span class="alternative-block"><span><span>e</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>E</span></span></span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span><span>+</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>-</span></span></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-digit"><span class="hole">digit</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-int"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-int"><span class="hole">int</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>-</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-digit"><span class="hole">digit</span></a></span><span class="notation-sup">+</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-num"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-num"><span class="hole">num</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-digit"><span class="hole">digit</span></a></span><span class="notation-sup">+</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-digit"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-digit"><span class="hole">digit</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>0</span></span> <span><span>..</span></span> <span><span>9</span></span></span></span></span></span></span></dd>
<dt>Strings</dt>
<dd>Strings begin and end with <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> (double quote).  Use <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> to represent
a double quote character within a string.  In the grammar, strings are
identified with <span class="inline-grammar-production"><span class="target" id="grammar-token-string"></span><code class="docutils literal notranslate"><span class="pre">string</span></code></span>.</dd>
<dt>Keywords</dt>
<dd><p class="first">The following character sequences are reserved keywords that cannot be
used as identifiers:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>_ Axiom CoFixpoint Definition Fixpoint Hypothesis IF Parameter Prop
SProp Set Theorem Type Variable as at by cofix discriminated else
end exists exists2 fix for forall fun if in lazymatch let match
multimatch return then using where with
</pre></div>
</div>
<p class="last">Note that plugins may define additional keywords when they are loaded.</p>
</dd>
<dt>Other tokens</dt>
<dd><p class="first">The set of
tokens defined at any given time can vary because the <a class="reference internal" href="../user-extensions/syntax-extensions.html#coq:cmd.notation" title="Notation"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Notation</span></code></a>
command can define new tokens.  A <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.require" title="Require"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Require</span></code></a> command may load more notation definitions,
while the end of a <a class="reference internal" href="gallina-extensions.html#coq:cmd.section" title="Section"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Section</span></code></a> may remove notations.  Some notations
are defined in the basic library (see <a class="reference internal" href="coq-library.html#thecoqlibrary"><span class="std std-ref">The Coq library</span></a>) and are normally
loaded automatically at startup time.</p>
<p>Here are the character sequences that Coq directly defines as tokens
without using <a class="reference internal" href="../user-extensions/syntax-extensions.html#coq:cmd.notation" title="Notation"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Notation</span></code></a> (omitting 25 specialized tokens that begin with
<code class="docutils literal notranslate"><span class="pre">#int63_</span></code>):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>! #[ % &amp; &#39; ( () (bfs) (dfs) ) * ** + , - -&gt;
. .( .. ... / : ::= := :&gt; :&gt;&gt; ; &lt; &lt;+ &lt;- &lt;:
&lt;&lt;: &lt;= = =&gt; &gt; &gt;-&gt; &gt;= ? @ @{ [ [= ] _ _eqn
`( `{ { {| | |- || }
</pre></div>
</div>
<p class="last">When multiple tokens match the beginning of a sequence of characters,
the longest matching token is used.
Occasionally you may need to insert spaces to separate tokens.  For example,
if <code class="docutils literal notranslate"><span class="pre">~</span></code> and <code class="docutils literal notranslate"><span class="pre">~~</span></code> are both defined as tokens, the inputs <code class="docutils literal notranslate"><span class="pre">~</span> <span class="pre">~</span></code> and
<code class="docutils literal notranslate"><span class="pre">~~</span></code> generate different tokens, whereas if <code class="docutils literal notranslate"><span class="pre">~~</span></code> is not defined, then the
two inputs are equivalent.</p>
</dd>
</dl>
</div>
<div class="section" id="terms">
<span id="term"></span><h2>Terms<a class="headerlink" href="#terms" title="Permalink to this headline">¶</a></h2>
<div class="section" id="syntax-of-terms">
<h3>Syntax of terms<a class="headerlink" href="#syntax-of-terms" title="Permalink to this headline">¶</a></h3>
<p>The following grammars describe the basic syntax of the terms of the
<em>Calculus of Inductive Constructions</em> (also called Cic). The formal
presentation of Cic is given in Chapter <a class="reference internal" href="cic.html#calculusofinductiveconstructions"><span class="std std-ref">Calculus of Inductive Constructions</span></a>. Extensions of this syntax
are given in Chapter <a class="reference internal" href="gallina-extensions.html#extensionsofgallina"><span class="std std-ref">Extensions of Gallina</span></a>. How to customize the syntax
is described in Chapter <a class="reference internal" href="../user-extensions/syntax-extensions.html#syntaxextensionsandinterpretationscopes"><span class="std std-ref">Syntax extensions and interpretation scopes</span></a>.</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>forall</span></span> <a class="reference internal" href="#grammar-token-open_binders"><span class="hole">open_binders</span></a> <span><span>,</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>fun</span></span> <a class="reference internal" href="#grammar-token-open_binders"><span class="hole">open_binders</span></a> <span><span>=&gt;</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term_let"><span class="hole">term_let</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>if</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span><span>as</span></span> <a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">?</span></span> <span><span>return</span></span> <a class="reference internal" href="#grammar-token-term100"><span class="hole">term100</span></a></span><span class="notation-sup">?</span></span> <span><span>then</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>else</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term_fix"><span class="hole">term_fix</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term_cofix"><span class="hole">term_cofix</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term100"><span class="hole">term100</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term100"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term100"><span class="hole">term100</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term_cast"><span class="hole">term_cast</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term10"><span class="hole">term10</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term10"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term10"><span class="hole">term10</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term1"><span class="hole">term1</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-arg"><span class="hole">arg</span></a></span><span class="notation-sup">+</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>&#64;</span></span> <a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-univ_annot"><span class="hole">univ_annot</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-term1"><span class="hole">term1</span></a></span><span class="notation-sup">*</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term1"><span class="hole">term1</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-arg"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-arg"><span class="hole">arg</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>)</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term1"><span class="hole">term1</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term1"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term1"><span class="hole">term1</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="gallina-extensions.html#grammar-token-term_projection"><span class="hole">term_projection</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term0"><span class="hole">term0</span></a> <span><span>%</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term0"><span class="hole">term0</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term0"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term0"><span class="hole">term0</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-univ_annot"><span class="hole">univ_annot</span></a></span><span class="notation-sup">?</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-sort"><span class="hole">sort</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-numeral"><span class="hole">numeral</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-string"><span class="hole">string</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>_</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="gallina-extensions.html#grammar-token-term_evar"><span class="hole">term_evar</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term_match"><span class="hole">term_match</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>)</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span><span><span>|</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-field_def"><span class="hole">field_def</span></a></span><span class="notation-sup">*</span></span> <span><span>|</span></span><span><span>}</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>}</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>)</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>ltac</span></span> <span><span>:</span></span> <span><span>(</span></span> <a class="reference internal" href="../proof-engine/ltac2.html#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a> <span><span>)</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-field_def"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-field_def"><span class="hole">field_def</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span></span></span></div>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>Coq terms are typed. Coq types are recognized by the same syntactic
class as <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. We denote by <span class="inline-grammar-production"><span class="target" id="grammar-token-type"></span><code class="docutils literal notranslate"><span class="pre">type</span></code></span> the semantic subclass
of types inside the syntactic class <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
</div>
<div class="section" id="qualified-identifiers-and-simple-identifiers">
<span id="gallina-identifiers"></span><h3>Qualified identifiers and simple identifiers<a class="headerlink" href="#qualified-identifiers-and-simple-identifiers" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-qualid"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-field_ident"><span class="hole">field_ident</span></a></span><span class="notation-sup">*</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-field_ident"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-field_ident"><span class="hole">field_ident</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>.</span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span></span></span></span></span><p><em>Qualified identifiers</em> (<a class="reference internal" href="#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a>) denote <em>global constants</em>
(definitions, lemmas, theorems, remarks or facts), <em>global variables</em>
(parameters or axioms), <em>inductive types</em> or <em>constructors of inductive
types</em>. <em>Simple identifiers</em> (or shortly <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>) are a syntactic subset
of qualified identifiers. Identifiers may also denote <em>local variables</em>,
while qualified identifiers do not.</p>
<p>Field identifiers, written <a class="reference internal" href="#grammar-token-field_ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">field_ident</span></code></a>, are identifiers prefixed by
<code class="docutils literal notranslate"><span class="pre">.</span></code> (dot) with no blank between the dot and the identifier.</p>
</div>
<div class="section" id="numerals-and-strings">
<h3>Numerals and strings<a class="headerlink" href="#numerals-and-strings" title="Permalink to this headline">¶</a></h3>
<p>Numerals and strings have no predefined semantics in the calculus. They are
merely notations that can be bound to objects through the notation mechanism
(see Chapter&nbsp;<a class="reference internal" href="../user-extensions/syntax-extensions.html#syntaxextensionsandinterpretationscopes"><span class="std std-ref">Syntax extensions and interpretation scopes</span></a> for details).
Initially, numerals are bound to Peano’s representation of natural
numbers (see&nbsp;<a class="reference internal" href="coq-library.html#datatypes"><span class="std std-ref">Datatypes</span></a>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Negative integers are not at the same level as <a class="reference internal" href="#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a>, for this
would make precedence unnatural.</p>
</div>
</div>
<div class="section" id="sorts">
<span id="index-0"></span><h3>Sorts<a class="headerlink" href="#sorts" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-sort"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-sort"><span class="hole">sort</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Set</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Prop</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>SProp</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Type</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Type</span></span> <span><span>&#64;{</span></span> <span><span>_</span></span> <span><span>}</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Type</span></span> <span><span>&#64;{</span></span> <a class="reference internal" href="#grammar-token-universe"><span class="hole">universe</span></a> <span><span>}</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-universe"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-universe"><span class="hole">universe</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>max</span></span> <span><span>(</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-universe_expr"><span class="hole">universe_expr</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span><span>)</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-universe_expr"><span class="hole">universe_expr</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-universe_expr"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-universe_expr"><span class="hole">universe_expr</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-universe_name"><span class="hole">universe_name</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>+</span></span> <a class="reference internal" href="#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-universe_name"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-universe_name"><span class="hole">universe_name</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Set</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Prop</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-universe_level"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-universe_level"><span class="hole">universe_level</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Set</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Prop</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Type</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>_</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-univ_annot"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-univ_annot"><span class="hole">univ_annot</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>&#64;{</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-universe_level"><span class="hole">universe_level</span></a></span><span class="notation-sup">*</span></span> <span><span>}</span></span></span></span></span></span></span><p>There are four sorts <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">SProp</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code>  and <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>.</p>
<ul class="simple">
<li><code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">SProp</span></span></code>&nbsp;is the universe of <em>definitionally irrelevant
propositions</em> (also called <em>strict propositions</em>).</li>
<li><code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>&nbsp;is the universe of <em>logical propositions</em>. The logical propositions
themselves are typing the proofs. We denote propositions by <a class="reference internal" href="coq-library.html#grammar-token-form"><code class="xref std std-token docutils literal notranslate"><span class="pre">form</span></code></a>.
This constitutes a semantic subclass of the syntactic class <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</li>
<li><code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code>&nbsp;is the universe of <em>program types</em> or <em>specifications</em>. The
specifications themselves are typing the programs. We denote
specifications by <a class="reference internal" href="coq-library.html#grammar-token-specif"><code class="xref std std-token docutils literal notranslate"><span class="pre">specif</span></code></a>. This constitutes a semantic subclass of
the syntactic class <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</li>
<li><code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code> is the type of sorts.</li>
</ul>
<p>More on sorts can be found in Section&nbsp;<a class="reference internal" href="cic.html#sorts"><span class="std std-ref">Sorts</span></a>.</p>
</div>
<div class="section" id="binders">
<span id="id2"></span><h3>Binders<a class="headerlink" href="#binders" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-open_binders"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-open_binders"><span class="hole">open_binders</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">+</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-name"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>_</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-binder"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-binder"><span class="hole">binder</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>)</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>)</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>}</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>[</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>]</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-typeclass_constraint"><span class="hole">typeclass_constraint</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span><span>)</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-typeclass_constraint"><span class="hole">typeclass_constraint</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span><span>}</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-typeclass_constraint"><span class="hole">typeclass_constraint</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span><span>]</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span></span> <a class="reference internal" href="#grammar-token-pattern0"><span class="hole">pattern0</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>|</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>)</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-typeclass_constraint"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-typeclass_constraint"><span class="hole">typeclass_constraint</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>!</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a> <span><span>}</span></span> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>!</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>!</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span></span></span><p>Various constructions such as <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fix</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">cofix</span></span></code>
<em>bind</em> variables. A binding is represented by an identifier. If the binding
variable is not used in the expression, the identifier can be replaced by the
symbol <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">_</span></span></code>. When the type of a bound variable cannot be synthesized by the
system, it can be specified with the notation <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">&nbsp;:&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span><span class="pre">)</span></span></span></span></code>. There is also
a notation for a sequence of binding variables sharing the same type:
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span><span class="pre">&nbsp;:&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span><span class="pre">)</span></span></span></span></code>. A
binder can also be any pattern prefixed by a quote, e.g. <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">'</span></span><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">,</span></span><span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
<p>Some constructions allow the binding of a variable to value. This is
called a “let-binder”. The entry <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a> of the grammar accepts
either an assumption binder as defined above or a let-binder. The notation in
the latter case is <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">&nbsp;:=&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></code>. In a let-binder, only one
variable can be introduced at the same time. It is also possible to give
the type of the variable as follows:
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">&nbsp;:&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span><span class="pre">&nbsp;:=&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></code>.</p>
<p>Lists of <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a>s are allowed. In the case of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span></code>,
it is intended that at least one binder of the list is an assumption otherwise
fun and forall gets identical. Moreover, parentheses can be omitted in
the case of a single sequence of bindings sharing the same type (e.g.:
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">y</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">z</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">:</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">=&gt;</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">t</span></span></code> can be shortened in <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">x</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">y</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">z</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">:</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">A</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">=&gt;</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">t</span></span></code>).</p>
</div>
<div class="section" id="abstractions-fun">
<span id="index-1"></span><h3>Abstractions: fun<a class="headerlink" href="#abstractions-fun" title="Permalink to this headline">¶</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">fun</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> defines the
<em>abstraction</em> of the variable <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>, of type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, over the term
<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. It denotes a function of the variable <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> that evaluates to
the expression <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> (e.g. <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">x</span></span></code> denotes the identity
function on type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>). The keyword <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span></code> can be followed by several
binders as given in Section&nbsp;<a class="reference internal" href="#binders"><span class="std std-ref">Binders</span></a>. Functions over
several variables are equivalent to an iteration of one-variable
functions. For instance the expression
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">fun</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>
denotes the same function as <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">fun</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">=&gt;</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>. If
a let-binder occurs in
the list of binders, it is expanded to a let-in definition (see
Section&nbsp;<a class="reference internal" href="#let-in"><span class="std std-ref">Let-in definitions</span></a>).</p>
</div>
<div class="section" id="products-forall">
<span id="index-2"></span><h3>Products: forall<a class="headerlink" href="#products-forall" title="Permalink to this headline">¶</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">&nbsp;:&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span><span class="pre">,&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> denotes the
<em>product</em> of the variable <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> of type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, over the term <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.
As for abstractions, <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span></code> is followed by a binder list, and products
over several variables are equivalent to an iteration of one-variable
products. Note that <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is intended to be a type.</p>
<p>If the variable <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> occurs in <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>, the product is called
<em>dependent product</em>. The intention behind a dependent product
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">x</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">:</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">B</span></span></code> is twofold. It denotes either
the universal quantification of the variable <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> of type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>
in the proposition <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> or the functional dependent product from
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> to <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> (a construction usually written
<span class="math notranslate nohighlight">\(\Pi_{x:A}.B\)</span> in set theory).</p>
<p>Non dependent product types have a special notation: <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">B</span></span></code> stands for
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="operator"><span class="pre">_</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">B</span></span></code>. The <em>non dependent product</em> is used both to denote
the propositional implication and function types.</p>
</div>
<div class="section" id="applications">
<h3>Applications<a class="headerlink" href="#applications" title="Permalink to this headline">¶</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">fun</span></sub></span></a> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> denotes the application of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">fun</span></sub></span></a></span></code> (which is expected to have a function type) to
<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<p>The expression <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">fun</span></sub></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">i</span></sub></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> denotes the application
of the term <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">fun</span></sub></span></a></span></code> to the arguments <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">i</span></sub></span></a></span></code>.  It is
equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">fun</span></sub></span></a> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">)</span></span></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">)</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">n</span></sub></span></a></span></code>:
associativity is to the left.</p>
<p>The notation <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">&nbsp;:=&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></code> for arguments is used for making
explicit the value of implicit arguments (see
Section&nbsp;<a class="reference internal" href="gallina-extensions.html#explicit-applications"><span class="std std-ref">Explicit applications</span></a>).</p>
</div>
<div class="section" id="type-cast">
<span id="index-3"></span><h3>Type cast<a class="headerlink" href="#type-cast" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term_cast"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term_cast"><span class="hole">term_cast</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term10"><span class="hole">term10</span></a> <span><span>&lt;:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term10"><span class="hole">term10</span></a> <span><span>&lt;&lt;:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term10"><span class="hole">term10</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term10"><span class="hole">term10</span></a> <span><span>:&gt;</span></span></span></span></span></span></span><p>The expression <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">&nbsp;:&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> is a type cast expression. It enforces
the type of <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to be <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">&nbsp;&lt;:&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> locally sets up the virtual machine for checking that
<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">&nbsp;&lt;&lt;:&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> uses native compilation for checking that <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>
has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</div>
<div class="section" id="inferable-subterms">
<span id="index-4"></span><h3>Inferable subterms<a class="headerlink" href="#inferable-subterms" title="Permalink to this headline">¶</a></h3>
<p>Expressions often contain redundant pieces of information. Subterms that can be
automatically inferred by Coq can be replaced by the symbol <code class="docutils literal notranslate"><span class="pre">_</span></code> and Coq will
guess the missing piece of information.</p>
</div>
<div class="section" id="let-in-definitions">
<span id="let-in"></span><span id="index-5"></span><h3>Let-in definitions<a class="headerlink" href="#let-in-definitions" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term_let"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term_let"><span class="hole">term_let</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>let</span></span> <a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>let</span></span> <a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>let</span></span> <span><span>(</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">*</span><span class="notation-sub">,</span></span> <span><span>)</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span><span>as</span></span> <a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">?</span></span> <span><span>return</span></span> <a class="reference internal" href="#grammar-token-term100"><span class="hole">term100</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>let</span></span> <span></span> <a class="reference internal" href="#grammar-token-pattern"><span class="hole">pattern</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>return</span></span> <a class="reference internal" href="#grammar-token-term100"><span class="hole">term100</span></a></span><span class="notation-sup">?</span></span> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>let</span></span> <span></span> <a class="reference internal" href="#grammar-token-pattern"><span class="hole">pattern</span></a> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-pattern"><span class="hole">pattern</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>return</span></span> <a class="reference internal" href="#grammar-token-term100"><span class="hole">term100</span></a> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span></span></span><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">in</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">’</span></span></span></span></code>
denotes the local binding of <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to the variable
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>’. There is a syntactic sugar for let-in
definition of functions: <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">in</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">’</span></span></span></span></code>
stands for <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <span><span><span class="pre">fun</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">in</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">’</span></span></span></span></code>.</p>
</div>
<div class="section" id="definition-by-cases-match">
<span id="index-6"></span><h3>Definition by cases: match<a class="headerlink" href="#definition-by-cases-match" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term_match"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term_match"><span class="hole">term_match</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>match</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-case_item"><span class="hole">case_item</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>return</span></span> <a class="reference internal" href="#grammar-token-term100"><span class="hole">term100</span></a></span><span class="notation-sup">?</span></span> <span><span>with</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>|</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-eqn"><span class="hole">eqn</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span><span>end</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-case_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-case_item"><span class="hole">case_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term100"><span class="hole">term100</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>as</span></span> <a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>in</span></span> <a class="reference internal" href="#grammar-token-pattern"><span class="hole">pattern</span></a></span><span class="notation-sup">?</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-eqn"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-eqn"><span class="hole">eqn</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-pattern"><span class="hole">pattern</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span><span>=&gt;</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-pattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-pattern"><span class="hole">pattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-pattern10"><span class="hole">pattern10</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-pattern10"><span class="hole">pattern10</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-pattern10"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-pattern10"><span class="hole">pattern10</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-pattern1"><span class="hole">pattern1</span></a> <span><span>as</span></span> <a class="reference internal" href="#grammar-token-name"><span class="hole">name</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-pattern1"><span class="hole">pattern1</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-pattern1"><span class="hole">pattern1</span></a></span><span class="notation-sup">*</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>&#64;</span></span> <a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-pattern1"><span class="hole">pattern1</span></a></span><span class="notation-sup">*</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-pattern1"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-pattern1"><span class="hole">pattern1</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-pattern0"><span class="hole">pattern0</span></a> <span><span>%</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-pattern0"><span class="hole">pattern0</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-pattern0"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-pattern0"><span class="hole">pattern0</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span><span><span>|</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-pattern"><span class="hole">pattern</span></a></span><span class="notation-sup">*</span></span> <span><span>|</span></span><span><span>}</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>_</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-pattern"><span class="hole">pattern</span></a></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span><span>)</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-numeral"><span class="hole">numeral</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-string"><span class="hole">string</span></a></span></span></span></span></span><p>Objects of inductive types can be destructured by a case-analysis
construction called <em>pattern matching</em> expression. A pattern matching
expression is used to analyze the structure of an inductive object and
to apply specific treatments accordingly.</p>
<p>This paragraph describes the basic form of pattern matching. See
Section <a class="reference internal" href="gallina-extensions.html#mult-match"><span class="std std-ref">Multiple and nested pattern matching</span></a> and Chapter <a class="reference internal" href="../addendum/extended-pattern-matching.html#extendedpatternmatching"><span class="std std-ref">Extended pattern matching</span></a> for the description
of the general form. The basic form of pattern matching is characterized
by a single <a class="reference internal" href="#grammar-token-case_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">case_item</span></code></a> expression, an <a class="reference internal" href="#grammar-token-eqn"><code class="xref std std-token docutils literal notranslate"><span class="pre">eqn</span></code></a> restricted to a
single <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> and <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> restricted to the form
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>.</p>
<p>The expression
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">match</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">return</span></span></span> <a class="reference internal" href="#grammar-token-term100"><span class="hole"><span class="pre">term100</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">with</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span><sub><span class="pre">i</span></sub></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">i</span></sub></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">|</span></span></span> <span><span><span class="pre">end</span></span></span></span></code> denotes a
<em>pattern matching</em> over the term <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> (expected to be
of an inductive type <span class="math notranslate nohighlight">\(I\)</span>). The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">i</span></sub></span></a></span></code>
are the <em>branches</em> of the pattern matching
expression. Each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span><sub><span class="pre">i</span></sub></span></a></span></code> has the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> must denote a constructor. There should be
exactly one branch for every constructor of <span class="math notranslate nohighlight">\(I\)</span>.</p>
<p>The <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">return</span></span></span> <a class="reference internal" href="#grammar-token-term100"><span class="hole"><span class="pre">term100</span></span></a></span></code> clause gives the type returned by the whole match
expression. There are several cases. In the <em>non dependent</em> case, all
branches have the same type, and the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">return</span></span></span> <a class="reference internal" href="#grammar-token-term100"><span class="hole"><span class="pre">term100</span></span></a></span></code> specifies that type.
In this case, <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">return</span></span></span> <a class="reference internal" href="#grammar-token-term100"><span class="hole"><span class="pre">term100</span></span></a></span></code> can usually be omitted as it can be
inferred from the type of the branches <a class="footnote-reference" href="#id4" id="id3">[1]</a>.</p>
<p>In the <em>dependent</em> case, there are three subcases. In the first subcase,
the type in each branch may depend on the exact value being matched in
the branch. In this case, the whole pattern matching itself depends on
the term being matched. This dependency of the term being matched in the
return type is expressed with an <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> clause where <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
is dependent in the return type. For instance, in the following example:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">bool</span><span> : </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">true</span><span> : </span><span class="coqdoc-var">bool</span><span> | </span><span class="coqdoc-var">false</span><span> : </span><span class="coqdoc-var">bool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">bool is defined
bool_rect is defined
bool_ind is defined
bool_rec is defined
bool_sind is defined</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">eq</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">eq_refl</span><span> : </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">eq is defined
eq_rect is defined
eq_ind is defined
eq_rec is defined
eq_sind is defined</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">or_introl</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">or_intror</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">or is defined
or_ind is defined
or_sind is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">bool_case</span><span> (</span><span class="coqdoc-var">b</span><span>:</span><span class="coqdoc-var">bool</span><span>) : </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">false</span><span>) :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">false</span><span>) </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">true</span><span> =&gt; </span><span class="coqdoc-var">or_introl</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span>)</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">false</span><span> =&gt; </span><span class="coqdoc-var">or_intror</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span>)</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">bool_case is defined</span></dd>
</dl>
</div>
<p>the branches have respective types &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot;
and &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot; while the whole
pattern matching expression has type &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name"><span class="pre">b</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name"><span class="pre">b</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot;,
the identifier <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">b</span></span></code> being used to represent the dependency.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>When the term being matched is a variable, the <code class="docutils literal notranslate"><span class="pre">as</span></code> clause can be
omitted and the term being matched can serve itself as binding name in
the return type. For instance, the following alternative definition is
accepted and has the same meaning as the previous one.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Reset</span><span> </span><span class="coqdoc-var">bool_case</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">bool_case</span><span> (</span><span class="coqdoc-var">b</span><span>:</span><span class="coqdoc-var">bool</span><span>) : </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">false</span><span>) :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">false</span><span>) </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">true</span><span> =&gt; </span><span class="coqdoc-var">or_introl</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span>)</span><span>
| </span><span class="coqdoc-var">false</span><span> =&gt; </span><span class="coqdoc-var">or_intror</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">bool_case is defined</span></dd>
</dl>
</div>
</div>
<p>The second subcase is only relevant for annotated inductive types such
as the equality predicate (see Section <a class="reference internal" href="coq-library.html#coq-equality"><span class="std std-ref">Equality</span></a>),
the order predicate on natural numbers or the type of lists of a given
length (see Section <a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-dependent"><span class="std std-ref">Matching objects of dependent types</span></a>). In this configuration, the
type of each branch can depend on the type dependencies specific to the
branch and the whole pattern matching expression has a type determined
by the specific dependencies in the type of the term being matched. This
dependency of the return type in the annotations of the inductive type
is expressed with a clause in the form
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">in</span></span></span> <a class="reference internal" href="#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">_</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>, where</p>
<ul class="simple">
<li><a class="reference internal" href="#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> is the inductive type of the term being matched;</li>
<li>the holes <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">_</span></span></span></span></code> match the parameters of the inductive type: the
return type is not dependent on them.</li>
<li>each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a></span></code> matches the annotations of the
inductive type: the return type is dependent on them</li>
<li>in the basic case which we describe below, each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a></span></code>
is a name <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>; see <a class="reference internal" href="../addendum/extended-pattern-matching.html#match-in-patterns"><span class="std std-ref">Patterns in in</span></a> for the
general case</li>
</ul>
<p>For instance, in the following example:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">eq_sym</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">H</span><span>:</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) : </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">x</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">eq_sym is defined</span></dd>
</dl>
</div>
<p>the type of the branch is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">x</span></span></code> because the third argument of
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> in the type of the pattern <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq_refl</span></span></code>. On the contrary, the
type of the whole pattern matching expression has type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">x</span></span></code> because the
third argument of eq is y in the type of H. This dependency of the case analysis
in the third argument of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> is expressed by the identifier <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">z</span></span></code> in the
return type.</p>
<p>Finally, the third subcase is a combination of the first and second
subcase. In particular, it only applies to pattern matching on terms in
a type with annotations. For this third subcase, both the clauses <code class="docutils literal notranslate"><span class="pre">as</span></code> and
<code class="docutils literal notranslate"><span class="pre">in</span></code> are available.</p>
<p>There are specific notations for case analysis on types with one or two
constructors: <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">…</span> <span class="pre">then</span> <span class="pre">…</span> <span class="pre">else</span> <span class="pre">…</span></code> and <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">(…,…)</span> <span class="pre">:=</span> <span class="pre">…</span> <span class="pre">in</span> <span class="pre">…</span></code> (see
Sections <a class="reference internal" href="gallina-extensions.html#if-then-else"><span class="std std-ref">Pattern-matching on boolean values: the if expression</span></a> and <a class="reference internal" href="gallina-extensions.html#irrefutable-patterns"><span class="std std-ref">Irrefutable patterns: the destructuring let variants</span></a>).</p>
</div>
<div class="section" id="recursive-and-co-recursive-functions-fix-and-cofix">
<span id="index-7"></span><h3>Recursive and co-recursive functions: fix and cofix<a class="headerlink" href="#recursive-and-co-recursive-functions-fix-and-cofix" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term_fix"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term_fix"><span class="hole">term_fix</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>let</span></span> <span><span>fix</span></span> <a class="reference internal" href="#grammar-token-fix_body"><span class="hole">fix_body</span></a> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>fix</span></span> <a class="reference internal" href="#grammar-token-fix_body"><span class="hole">fix_body</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-fix_body"><span class="hole">fix_body</span></a></span><span class="notation-sup">+</span></span> <span><span>for</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-fix_body"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-fix_body"><span class="hole">fix_body</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-fixannot"><span class="hole">fixannot</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-fixannot"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-fixannot"><span class="hole">fixannot</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <span><span>struct</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>}</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <span><span>wf</span></span> <a class="reference internal" href="#grammar-token-term1_extended"><span class="hole">term1_extended</span></a> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>}</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <span><span>measure</span></span> <a class="reference internal" href="#grammar-token-term1_extended"><span class="hole">term1_extended</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-term1_extended"><span class="hole">term1_extended</span></a></span><span class="notation-sup">?</span></span> <span><span>}</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term1_extended"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term1_extended"><span class="hole">term1_extended</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-term1"><span class="hole">term1</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>&#64;</span></span> <a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-univ_annot"><span class="hole">univ_annot</span></a></span><span class="notation-sup">?</span></span></span></span></span></span></span><p>The expression “<code class="docutils literal notranslate"><span class="pre">fix</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:</span></code>
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:=</span></code> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">…</span> <span class="pre">with</span></code>
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> : <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_n\)</span>
<code class="docutils literal notranslate"><span class="pre">:=</span></code> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> <code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_i\)</span>” denotes the
<span class="math notranslate nohighlight">\(i\)</span>-th component of a block of functions defined by mutual structural
recursion. It is the local counterpart of the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> command. When
<span class="math notranslate nohighlight">\(n=1\)</span>, the “<code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_i\)</span>” clause is omitted.</p>
<p>The association of a single fixpoint and a local definition have a special
syntax: <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let</span></span></span> <span><span><span class="pre">fix</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">in</span></span></span></span></code> stands for
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <span><span><span class="pre">fix</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">in</span></span></span></span></code>. The same applies for co-fixpoints.</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term_cofix"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term_cofix"><span class="hole">term_cofix</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>let</span></span> <span><span>cofix</span></span> <a class="reference internal" href="#grammar-token-cofix_body"><span class="hole">cofix_body</span></a> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>cofix</span></span> <a class="reference internal" href="#grammar-token-cofix_body"><span class="hole">cofix_body</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-cofix_body"><span class="hole">cofix_body</span></a></span><span class="notation-sup">+</span></span> <span><span>for</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span></span></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-cofix_body"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-cofix_body"><span class="hole">cofix_body</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></span></span></span></span><p>The expression “<code class="docutils literal notranslate"><span class="pre">cofix</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:</span></code>
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">…</span> <span class="pre">with</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate nohighlight">\(_n\)</span>
: <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> <code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_i\)</span>” denotes the
<span class="math notranslate nohighlight">\(i\)</span>-th component of a block of terms defined by a mutual guarded
co-recursion. It is the local counterpart of the <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> command. When
<span class="math notranslate nohighlight">\(n=1\)</span>, the “<code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_i\)</span>” clause is omitted.</p>
</div>
</div>
<div class="section" id="the-vernacular">
<span id="vernacular"></span><h2>The Vernacular<a class="headerlink" href="#the-vernacular" title="Permalink to this headline">¶</a></h2>
<pre>
<strong id="grammar-token-decorated-sentence">decorated-sentence</strong> ::=  [ <a class="reference internal" href="#grammar-token-decoration"><code class="xref docutils literal notranslate"><span class="pre">decoration</span></code></a> … <a class="reference internal" href="#grammar-token-decoration"><code class="xref docutils literal notranslate"><span class="pre">decoration</span></code></a> ] <a class="reference internal" href="#grammar-token-sentence"><code class="xref docutils literal notranslate"><span class="pre">sentence</span></code></a>
<strong id="grammar-token-sentence">sentence          </strong> ::=  <a class="reference internal" href="#grammar-token-assumption"><code class="xref docutils literal notranslate"><span class="pre">assumption</span></code></a>
                        <a class="reference internal" href="#grammar-token-definition"><code class="xref docutils literal notranslate"><span class="pre">definition</span></code></a>
                        <a class="reference internal" href="#grammar-token-inductive"><code class="xref docutils literal notranslate"><span class="pre">inductive</span></code></a>
                        <a class="reference internal" href="#grammar-token-fixpoint"><code class="xref docutils literal notranslate"><span class="pre">fixpoint</span></code></a>
                        <a class="reference internal" href="#grammar-token-assertion"><code class="xref docutils literal notranslate"><span class="pre">assertion</span></code></a> <a class="reference internal" href="#grammar-token-proof"><code class="xref docutils literal notranslate"><span class="pre">proof</span></code></a>
<strong id="grammar-token-assumption">assumption        </strong> ::=  <a class="reference internal" href="#grammar-token-assumption_keyword"><code class="xref docutils literal notranslate"><span class="pre">assumption_keyword</span></code></a> <a class="reference internal" href="#grammar-token-assums"><code class="xref docutils literal notranslate"><span class="pre">assums</span></code></a>.
<strong id="grammar-token-assumption_keyword">assumption_keyword</strong> ::=  Axiom | Conjecture
                        Parameter | Parameters
                        Variable | Variables
                        Hypothesis | Hypotheses
<strong id="grammar-token-assums">assums            </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> … <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                        ( <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> … <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> ) … ( <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> … <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
<strong id="grammar-token-definition">definition        </strong> ::=  [Local] Definition <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> .
                        Let <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> .
<strong id="grammar-token-binders">binders           </strong> ::=  binders binder
                        binder
<strong id="grammar-token-inductive">inductive         </strong> ::=  Inductive <a class="reference internal" href="#grammar-token-ind_body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-ind_body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> .
                        CoInductive <a class="reference internal" href="#grammar-token-ind_body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-ind_body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> .
<strong id="grammar-token-ind_body">ind_body          </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> :=
                        [[|] <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [:<a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] | … | <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [:<a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>]]
<strong id="grammar-token-fixpoint">fixpoint          </strong> ::=  Fixpoint <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> .
                        CoFixpoint <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> .
<strong id="grammar-token-assertion">assertion         </strong> ::=  <a class="reference internal" href="#grammar-token-assertion_keyword"><code class="xref docutils literal notranslate"><span class="pre">assertion_keyword</span></code></a> <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> .
<strong id="grammar-token-assertion_keyword">assertion_keyword </strong> ::=  Theorem | Lemma
                        Remark | Fact
                        Corollary | Property | Proposition
                        Definition | Example
<strong id="grammar-token-proof">proof             </strong> ::=  Proof . … Qed .
                        Proof . … Defined .
                        Proof . … Admitted .
<strong id="grammar-token-decoration">decoration        </strong> ::=  #[ <a class="reference internal" href="#grammar-token-attributes"><code class="xref docutils literal notranslate"><span class="pre">attributes</span></code></a> ]
<strong id="grammar-token-attributes">attributes        </strong> ::=  [<a class="reference internal" href="#grammar-token-attribute"><code class="xref docutils literal notranslate"><span class="pre">attribute</span></code></a>, … , <a class="reference internal" href="#grammar-token-attribute"><code class="xref docutils literal notranslate"><span class="pre">attribute</span></code></a>]
<strong id="grammar-token-attribute">attribute         </strong> ::=   <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
                        <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> = <a class="reference internal" href="#grammar-token-string"><code class="xref docutils literal notranslate"><span class="pre">string</span></code></a>
                        <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> ( <a class="reference internal" href="#grammar-token-attributes"><code class="xref docutils literal notranslate"><span class="pre">attributes</span></code></a> )
</pre>
<p>This grammar describes <em>The Vernacular</em> which is the language of
commands of Gallina. A sentence of the vernacular language, like in
many natural languages, begins with a capital letter and ends with a
dot.</p>
<p>Sentences may be <em>decorated</em> with so-called <em>attributes</em>,
which are described in the corresponding section (<a class="reference internal" href="#gallina-attributes"><span class="std std-ref">Attributes</span></a>).</p>
<p>The different kinds of command are described hereafter. They all suppose
that the terms occurring in the sentences are well-typed.</p>
<div class="section" id="assumptions">
<span id="gallina-assumptions"></span><h3>Assumptions<a class="headerlink" href="#assumptions" title="Permalink to this headline">¶</a></h3>
<p>Assumptions extend the environment with axioms, parameters, hypotheses
or variables. An assumption binds an <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> to a <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>. It is accepted
by Coq if and only if this <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is a correct type in the environment
preexisting the declaration and if <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> was not previously defined in
the same module. This <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is considered to be the type (or
specification, or statement) assumed by <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> and we say that <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<span class="target" id="axiom"></span><dl class="cmd">
<dt id="coq:cmd.parameter">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span><span>Parameter</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>This command links <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> as its specification in
the global context. The fact asserted by <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is thus assumed as a
postulate.</p>
<dl class="exn">
<dt id="coq:exn.ident-already-exists-axiom">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>already</span></span> <span><span>exists.</span></span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-axiom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Parameter</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>Adds several parameters with specification <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Parameter</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds blocks of parameters with different specifications.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.local-parameter">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Local</span></span> <span><span>Parameter</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.local-parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Such parameters are never made accessible through their unqualified name by
<a class="reference internal" href="gallina-extensions.html#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a> and its variants. You have to explicitly give their fully
qualified name to refer to them.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.parameters">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>Local</span></span></span><span class="notation-sup">?</span></span> <span><span>Parameters</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.parameters" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.axiom">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>Local</span></span></span><span class="notation-sup">?</span></span> <span><span>Axiom</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.axiom" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.axioms">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>Local</span></span></span><span class="notation-sup">?</span></span> <span><span>Axioms</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.axioms" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.conjecture">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>Local</span></span></span><span class="notation-sup">?</span></span> <span><span>Conjecture</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.conjecture" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.conjectures">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>Local</span></span></span><span class="notation-sup">?</span></span> <span><span>Conjectures</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.conjectures" title="Permalink to this definition">¶</a></dt>
<dd><p>These variants are synonyms of <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">Local</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">Parameter</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">(</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.variable-outside-a-section">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Variable</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.variable-outside-a-section" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.variables-outside-a-section">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Variables</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.variables-outside-a-section" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.hypothesis-outside-a-section">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Hypothesis</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.hypothesis-outside-a-section" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.hypotheses-outside-a-section">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Hypotheses</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.hypotheses-outside-a-section" title="Permalink to this definition">¶</a></dt>
<dd><p>Outside of any section, these variants are synonyms of
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Local</span></span></span> <span><span><span class="pre">Parameter</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">(</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.
For their meaning inside a section, see <a class="reference internal" href="gallina-extensions.html#coq:cmd.variable" title="Variable"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variable</span></code></a> in
<a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>.</p>
<dl class="warn">
<dt id="coq:warn.ident-is-declared-as-a-local-axiom-local-declaration-scope">
<em class="property"><span class="sigannot">Warning</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>is</span></span> <span><span>declared</span></span> <span><span>as</span></span> <span><span>a</span></span> <span><span>local</span></span> <span><span>axiom</span></span> <span><span>[local-declaration,scope]</span></span></span></code><a class="headerlink" href="#coq:warn.ident-is-declared-as-a-local-axiom-local-declaration-scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Warning generated when using <a class="reference internal" href="gallina-extensions.html#coq:cmd.variable" title="Variable"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variable</span></code></a> instead of
<a class="reference internal" href="#coq:cmdv.local-parameter" title="Local Parameter"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Local</span> <span class="pre">Parameter</span></code></a>.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is advised to use the commands <a class="reference internal" href="#coq:cmdv.axiom" title="Axiom"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Axiom</span></code></a>, <a class="reference internal" href="#coq:cmdv.conjecture" title="Conjecture"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Conjecture</span></code></a> and
<a class="reference internal" href="gallina-extensions.html#coq:cmdv.hypothesis" title="Hypothesis"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hypothesis</span></code></a> (and their plural forms) for logical postulates (i.e. when
the assertion <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is of sort <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>), and to use the commands
<a class="reference internal" href="#coq:cmd.parameter" title="Parameter"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Parameter</span></code></a> and <a class="reference internal" href="gallina-extensions.html#coq:cmd.variable" title="Variable"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variable</span></code></a> (and their plural forms) in other cases
(corresponding to the declaration of an abstract mathematical entity).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Section <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>.</p>
</div>
</div>
<div class="section" id="definitions">
<span id="gallina-definitions"></span><h3>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h3>
<p>Definitions extend the environment with associations of names to terms.
A definition can be seen as a way to give a meaning to a name or as a
way to abbreviate a term. In any case, the name can later be replaced at
any time by its definition.</p>
<p>The operation of unfolding a name into its definition is called
<span class="math notranslate nohighlight">\(\delta\)</span>-conversion (see Section <a class="reference internal" href="cic.html#delta-reduction"><span class="std std-ref">δ-reduction</span></a>). A
definition is accepted by the system if and only if the defined term is
well-typed in the current context of the definition and if the name is
not already used. The name defined by the definition is called a
<em>constant</em> and the term it refers to is its <em>body</em>. A definition has a
type which is the type of its body.</p>
<p>A formal presentation of constants and environments is given in
Section <a class="reference internal" href="cic.html#typing-rules"><span class="std std-ref">Typing rules</span></a>.</p>
<dl class="cmd">
<dt id="coq:cmd.definition">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span><span>Definition</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.definition" title="Permalink to this definition">¶</a></dt>
<dd><p>This command binds <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the environment,
provided that <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is well-typed.</p>
<dl class="exn">
<dt id="coq:exn.ident-already-exists-definition">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>already</span></span> <span><span>exists.</span></span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Definition</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This variant checks that the type of <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is definitionally equal to
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and registers <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> as being of type
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and bound to value <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<dl class="exn">
<dt id="coq:exn.the-term-term-has-type-type-while-it-is-expected-to-have-type-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span><span>The</span></span> <span><span>term</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>has</span></span> <span><span>type</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>while</span></span> <span><span>it</span></span> <span><span>is</span></span> <span><span>expected</span></span> <span><span>to</span></span> <span><span>have</span></span> <span><span>type</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span><span>.</span></span></span></code><a class="headerlink" href="#coq:exn.the-term-term-has-type-type-while-it-is-expected-to-have-type-type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Definition</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Definition</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">&nbsp;:&nbsp;forall</span></span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span><span class="pre">&nbsp;:=&nbsp;fun</span></span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span><span class="pre">&nbsp;=&gt;&nbsp;</span></span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.local-definition">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Local</span></span> <span><span>Definition</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmdv.local-definition" title="Permalink to this definition">¶</a></dt>
<dd><p>Such definitions are never made accessible through their
unqualified name by <a class="reference internal" href="gallina-extensions.html#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a> and its variants.
You have to explicitly give their fully qualified name to refer to them.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.example">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>Local</span></span></span><span class="notation-sup">?</span></span> <span><span>Example</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmdv.example" title="Permalink to this definition">¶</a></dt>
<dd><p>This is equivalent to <a class="reference internal" href="#coq:cmd.definition" title="Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Definition</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.let-outside-a-section">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmdv.let-outside-a-section" title="Permalink to this definition">¶</a></dt>
<dd><p>Outside of any section, this variant is a synonym of
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Local</span></span></span> <span><span><span class="pre">Definition</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.
For its meaning inside a section, see <a class="reference internal" href="gallina-extensions.html#coq:cmd.let" title="Let"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Let</span></code></a> in
<a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>.</p>
<dl class="warn">
<dt id="coq:warn.ident-is-declared-as-a-local-definition-local-declaration-scope">
<em class="property"><span class="sigannot">Warning</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>is</span></span> <span><span>declared</span></span> <span><span>as</span></span> <span><span>a</span></span> <span><span>local</span></span> <span><span>definition</span></span> <span><span>[local-declaration,scope]</span></span></span></code><a class="headerlink" href="#coq:warn.ident-is-declared-as-a-local-definition-local-declaration-scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Warning generated when using <a class="reference internal" href="gallina-extensions.html#coq:cmd.let" title="Let"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Let</span></code></a> instead of
<a class="reference internal" href="#coq:cmdv.local-definition" title="Local Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Local</span> <span class="pre">Definition</span></code></a>.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Section <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>, commands <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.opaque" title="Opaque"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Opaque</span></code></a>,
<a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.transparent" title="Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Transparent</span></code></a>, and tactic <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>.</p>
</div>
</div>
<div class="section" id="inductive-definitions">
<span id="gallina-inductive-definitions"></span><h3>Inductive definitions<a class="headerlink" href="#inductive-definitions" title="Permalink to this headline">¶</a></h3>
<p>We gradually explain simple inductive types, simple annotated inductive
types, simple parametric inductive types, mutually inductive types. We
explain also co-inductive types.</p>
<div class="section" id="simple-inductive-types">
<h4>Simple inductive types<a class="headerlink" href="#simple-inductive-types" title="Permalink to this headline">¶</a></h4>
<dl class="cmd">
<dt id="coq:cmd.inductive">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span><span>Inductive</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-sort"><span class="hole">sort</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat">| <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.inductive" title="Permalink to this definition">¶</a></dt>
<dd><p>This command defines a simple inductive type and its constructors.
The first <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is the name of the inductively defined type
and <a class="reference internal" href="#grammar-token-sort"><code class="xref std std-token docutils literal notranslate"><span class="pre">sort</span></code></a> is the universe where it lives. The next <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>s
are the names of its constructors and <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> their respective types.
Depending on the universe where the inductive type <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> lives
(e.g. its type <a class="reference internal" href="#grammar-token-sort"><code class="xref std std-token docutils literal notranslate"><span class="pre">sort</span></code></a>), Coq provides a number of destructors.
Destructors are named <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_sind</span></code>,:token:<code class="docutils literal notranslate"><span class="pre">ident</span></code><code class="docutils literal notranslate"><span class="pre">_ind</span></code>,
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rec</span></code> or <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rect</span></code> which respectively
correspond to elimination principles on <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">SProp</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>.
The type of the destructors expresses structural induction/recursion
principles over objects of type <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.
The constant <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_ind</span></code> is always provided,
whereas <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rec</span></code> and <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rect</span></code> can be
impossible to derive (for example, when <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is a proposition).</p>
<dl class="exn">
<dt id="coq:exn.non-strictly-positive-occurrence-of-ident-in-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span><span>Non</span></span> <span><span>strictly</span></span> <span><span>positive</span></span> <span><span>occurrence</span></span> <span><span>of</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span><span>.</span></span></span></code><a class="headerlink" href="#coq:exn.non-strictly-positive-occurrence-of-ident-in-type" title="Permalink to this definition">¶</a></dt>
<dd><p>The types of the constructors have to satisfy a <em>positivity condition</em>
(see Section <a class="reference internal" href="cic.html#positivity"><span class="std std-ref">Positivity Condition</span></a>). This condition ensures the soundness of
the inductive definition. The positivity checking can be disabled using
the <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:flag.positivity-checking" title="Positivity Checking"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Positivity</span> <span class="pre">Checking</span></code></a> flag (see <a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-typing-flags"><span class="std std-ref">Controlling Typing Flags</span></a>).</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.the-conclusion-of-type-is-not-valid-it-must-be-built-from-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span><span>The</span></span> <span><span>conclusion</span></span> <span><span>of</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>is</span></span> <span><span>not</span></span> <span><span>valid;</span></span> <span><span>it</span></span> <span><span>must</span></span> <span><span>be</span></span> <span><span>built</span></span> <span><span>from</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a><span><span>.</span></span></span></code><a class="headerlink" href="#coq:exn.the-conclusion-of-type-is-not-valid-it-must-be-built-from-ident" title="Permalink to this definition">¶</a></dt>
<dd><p>The conclusion of the type of the constructors must be the inductive type
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> being defined (or <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> applied to arguments in
the case of annotated inductive types — cf. next section).</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The set of natural numbers is defined as:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nat</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">O</span><span> : </span><span class="coqdoc-var">nat</span><span>
| </span><span class="coqdoc-var">S</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd><span class="first last">nat is defined
nat_rect is defined
nat_ind is defined
nat_rec is defined
nat_sind is defined</span></dd>
</dl>
</div>
<p>The type nat is defined as the least <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code> containing <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> and closed by
the <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span></code> constructor. The names <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span></code> are added to the
environment.</p>
<p>Now let us have a look at the elimination principles. They are three of them:
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_ind</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rec</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rect</span></span></code>. The type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_ind</span></span></code> is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">nat_ind</span><span>.</span></dt>
<dd><span class="first">nat_ind
     : </span><span class="ansi-bold">forall</span><span> P : nat</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>,
       P O</span><span class="ansi-fg-white"> -&gt;</span><span> (</span><span class="ansi-bold">forall</span><span> n : nat, P n</span><span class="ansi-fg-white"> -&gt;</span><span> P (S n))</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span class="last"> n : nat, P n</span></dd>
</dl>
</div>
<p>This is the well known structural induction principle over natural
numbers, i.e. the second-order form of Peano’s induction principle. It
allows proving some universal property of natural numbers (<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span>
<span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">n</span></span></code>) by induction on <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>.</p>
<p class="last">The types of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rec</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rect</span></span></code> are similar, except that they pertain
to <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword namespace"><span class="pre">Set</span></span><span class="operator"><span class="pre">)</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Type</span></span><span class="operator"><span class="pre">)</span></span></code> respectively. They correspond to
primitive induction principles (allowing dependent types) respectively
over sorts <code class="docutils literal notranslate"><span class="pre">Set</span></code> and <code class="docutils literal notranslate"><span class="pre">Type</span></code>.</p>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Inductive</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-sort"><span class="hole">sort</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span></code></dt>
<dd><p>Constructors <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>s can come with <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> in which case,
the actual type of the constructor is <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code>.</p>
<p>In the case where inductive types have no annotations (next section
gives an example of such annotations), a constructor can be defined
by only giving the type of its arguments.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Reset</span><span> </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nat</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">O</span><span> | </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">nat</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first last">nat is defined
nat_rect is defined
nat_ind is defined
nat_rec is defined
nat_sind is defined</span></dd>
</dl>
</div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="simple-annotated-inductive-types">
<h4>Simple annotated inductive types<a class="headerlink" href="#simple-annotated-inductive-types" title="Permalink to this headline">¶</a></h4>
<p>In an annotated inductive types, the universe where the inductive type
is defined is no longer a simple sort, but what is called an arity,
which is a type whose conclusion is a sort.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>As an example of annotated inductive types, let us define the
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code> predicate:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">even</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">even_0</span><span> : </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">even_SS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">even</span><span> (</span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)).</span></dt>
<dd><span class="first last">even is defined
even_ind is defined
even_sind is defined</span></dd>
</dl>
</div>
<p>The type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Prop</span></span></code> means that even is a unary predicate (inductively
defined) over natural numbers. The type of its two constructors are the
defining clauses of the predicate even. The type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_ind</span></span></code> is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">even_ind</span><span>.</span></dt>
<dd><span class="first">even_ind
     : </span><span class="ansi-bold">forall</span><span> P : nat</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>,
       P O</span><span class="ansi-fg-white"> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> n : nat, even n</span><span class="ansi-fg-white"> -&gt;</span><span> P n</span><span class="ansi-fg-white"> -&gt;</span><span> P (S (S n)))</span><span class="ansi-fg-white"> -&gt;</span><span>
       </span><span class="ansi-bold">forall</span><span> n : nat, even n</span><span class="ansi-fg-white"> -&gt;</span><span class="last"> P n</span></dd>
</dl>
</div>
<p class="last">From a mathematical point of view it asserts that the natural numbers satisfying
the predicate even are exactly in the smallest set of naturals satisfying the
clauses <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_0</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_SS</span></span></code>. This is why, when we want to prove any
predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> over elements of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>, it is enough to prove it for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code>
and to prove that if any natural number <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> satisfies <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> its double
successor <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">))</span></span></code> satisfies also <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code>. This is indeed analogous to the
structural induction principle we got for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code>.</p>
</div>
</div>
<div class="section" id="parameterized-inductive-types">
<h4>Parameterized inductive types<a class="headerlink" href="#parameterized-inductive-types" title="Permalink to this headline">¶</a></h4>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Inductive</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat">| <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>In the previous example, each constructor introduces a different
instance of the predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>. In some cases, all the constructors
introduce the same generic instance of the inductive definition, in
which case, instead of an annotation, we use a context of parameters
which are <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> shared by all the constructors of the definition.</p>
<p>Parameters differ from inductive type annotations in the fact that the
conclusion of each type of constructor invoke the inductive type with
the same values of parameters as its specification.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>A typical example is the definition of polymorphic lists:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">list is defined
list_rect is defined
list_ind is defined
list_rec is defined
list_sind is defined</span></dd>
</dl>
</div>
<p>In the type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nil</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code>, we write <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">list</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)</span></span></code> and not
just <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">list</span></span></code>. The constructors <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nil</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code> will have respectively
types:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">nil</span><span>.</span></dt>
<dd><span class="first">nil
     : </span><span class="ansi-bold">forall</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span class="last">, list A</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">cons</span><span>.</span></dt>
<dd><span class="first">cons
     : </span><span class="ansi-bold">forall</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>, A</span><span class="ansi-fg-white"> -&gt;</span><span> list A</span><span class="ansi-fg-white"> -&gt;</span><span class="last"> list A</span></dd>
</dl>
</div>
<p>Types of destructors are also quantified with <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword namespace"><span class="pre">Set</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
<p>Once again, it is possible to specify only the type of the arguments
of the constructors, and to omit the type of the conclusion:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Reset</span><span> </span><span class="coqdoc-var">list</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">nil</span><span> | </span><span class="coqdoc-var">cons</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first last">list is defined
list_rect is defined
list_ind is defined
list_rec is defined
list_sind is defined</span></dd>
</dl>
</div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last">
<li><p class="first">It is possible in the type of a constructor, to
invoke recursively the inductive definition on an argument which is not
the parameter itself.</p>
<p>One can define :</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil2</span><span> : </span><span class="coqdoc-var">list2</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons2</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">list2</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd><span class="first last">list2 is defined
list2_rect is defined
list2_ind is defined
list2_rec is defined
list2_sind is defined</span></dd>
</dl>
</div>
<p>that can also be written by specifying only the type of the arguments:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">nil2</span><span> | </span><span class="coqdoc-var">cons2</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>)).</span></dt>
<dd><span class="first last">list2 is defined
list2_rect is defined
list2_ind is defined
list2_rec is defined
list2_sind is defined</span></dd>
</dl>
</div>
<p>But the following definition will give an error:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nilw</span><span> : </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>)</span><span>
| </span><span class="coqdoc-var">consw</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd><span class="first">The command has indeed failed with message:
Last occurrence of &quot;listw&quot; must have &quot;A&quot; as 1st argument in
 &quot;listw (A</span><span class="ansi-fg-white"> *</span><span class="last"> A)%type&quot;.</span></dd>
</dl>
</div>
<p>because the conclusion of the type of constructors should be <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">listw</span></span> <span class="name"><span class="pre">A</span></span></code>
in both cases.</p>
</li>
<li><p class="first">A parameterized inductive definition can be defined using annotations
instead of parameters but it will sometimes give a different (bigger)
sort for the inductive definition and will produce a less convenient
rule for case elimination.</p>
</li>
</ul>
</div>
<dl class="flag">
<dt id="coq:flag.uniform-inductive-parameters">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span><span>Uniform</span></span> <span><span>Inductive</span></span> <span><span>Parameters</span></span></span></code><a class="headerlink" href="#coq:flag.uniform-inductive-parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>When this flag is set (it is off by default),
inductive definitions are abstracted over their parameters
before type checking constructors, allowing to write:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-var">Uniform</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-keyword">Parameters</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list3</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil3</span><span> : </span><span class="coqdoc-var">list3</span><span>
| </span><span class="coqdoc-var">cons3</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list3</span><span> -&gt; </span><span class="coqdoc-var">list3</span><span>.</span></dt>
<dd><span class="first last">list3 is defined
list3_rect is defined
list3_ind is defined
list3_rec is defined
list3_sind is defined</span></dd>
</dl>
</div>
<p>This behavior is essentially equivalent to starting a new section
and using <a class="reference internal" href="gallina-extensions.html#coq:cmd.context" title="Context"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Context</span></code></a> to give the uniform parameters, like so
(cf. <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>):</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">list3</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Context</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>).</span></dt>
<dd><span class="first last">A is declared</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list3</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil3</span><span> : </span><span class="coqdoc-var">list3</span><span>
| </span><span class="coqdoc-var">cons3</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list3</span><span> -&gt; </span><span class="coqdoc-var">list3</span><span>.</span></dt>
<dd><span class="first last">list3 is defined
list3_rect is defined
list3_ind is defined
list3_rec is defined
list3_sind is defined</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">list3</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Section <a class="reference internal" href="cic.html#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a> and the <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> tactic.</p>
</div>
</div>
<div class="section" id="variants">
<h4>Variants<a class="headerlink" href="#variants" title="Permalink to this headline">¶</a></h4>
<dl class="cmd">
<dt id="coq:cmd.variant">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span><span>Variant</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat">| <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.variant" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:cmd.variant" title="Variant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variant</span></code></a> command is identical to the <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> command, except
that it disallows recursive definition of types (for instance, lists cannot
be defined using <a class="reference internal" href="#coq:cmd.variant" title="Variant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variant</span></code></a>). No induction scheme is generated for
this variant, unless the <a class="reference internal" href="../user-extensions/proof-schemes.html#coq:flag.nonrecursive-elimination-schemes" title="Nonrecursive Elimination Schemes"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Nonrecursive</span> <span class="pre">Elimination</span> <span class="pre">Schemes</span></code></a> flag is on.</p>
<dl class="exn">
<dt id="coq:exn.the-num-th-argument-of-ident-must-be-ident-in-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span><span>The</span></span> <a class="reference internal" href="#grammar-token-num"><span class="hole">num</span></a> <span><span>th</span></span> <span><span>argument</span></span> <span><span>of</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>must</span></span> <span><span>be</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span><span>.</span></span></span></code><a class="headerlink" href="#coq:exn.the-num-th-argument-of-ident-must-be-ident-in-type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="mutually-defined-inductive-types">
<h4>Mutually defined inductive types<a class="headerlink" href="#mutually-defined-inductive-types" title="Permalink to this headline">¶</a></h4>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Inductive</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This variant allows defining a block of mutually inductive types.
It has the same semantics as the above <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> definition for each
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>. All <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> are simultaneously added to the environment.
Then well-typing of constructors can be checked. Each one of the <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
can be used on its own.</p>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Inductive</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>In this variant, the inductive definitions are parameterized
with <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a>. However, parameters correspond to a local context
in which the whole set of inductive declarations is done. For this
reason, the parameters must be strictly the same for each inductive types.</p>
</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The typical example of a mutual inductive data type is the one for trees and
forests. We assume given two types <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> as variables. It can
be declared the following way.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Parameters</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">A is declared
B is declared</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span>
</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">tree</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">tree, forest are defined
tree_rect is defined
tree_ind is defined
tree_rec is defined
tree_sind is defined
forest_rect is defined
forest_ind is defined
forest_rec is defined
forest_sind is defined</span></dd>
</dl>
</div>
<p>This declaration generates automatically six induction principles. They are
respectively called <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_rec</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_ind</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_rect</span></span></code>,
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_rec</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_ind</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_rect</span></span></code>. These ones are not the most
general ones but are just the induction principles corresponding to each
inductive part seen as a single inductive definition.</p>
<p>To illustrate this point on our example, we give the types of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_rec</span></span></code>
and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_rec</span></span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">tree_rec</span><span>.</span></dt>
<dd><span class="first">tree_rec
     : </span><span class="ansi-bold">forall</span><span> P : tree</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>,
       (</span><span class="ansi-bold">forall</span><span> (a : A) (f : forest), P (node a f))</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span class="last"> t : tree, P t</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">forest_rec</span><span>.</span></dt>
<dd><span class="first">forest_rec
     : </span><span class="ansi-bold">forall</span><span> P : forest</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>,
       (</span><span class="ansi-bold">forall</span><span> b : B, P (leaf b))</span><span class="ansi-fg-white"> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> (t : tree) (f0 : forest), P f0</span><span class="ansi-fg-white"> -&gt;</span><span> P (cons t f0))</span><span class="ansi-fg-white"> -&gt;</span><span>
       </span><span class="ansi-bold">forall</span><span class="last"> f1 : forest, P f1</span></dd>
</dl>
</div>
<p>Assume we want to parameterize our mutual inductive definitions with the
two type variables <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>, the declaration should be
done the following way:</p>
<div class="coqdoc literal-block docutils container">
<span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></span></div>
<p class="last">Assume we define an inductive definition inside a section
(cf. <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>). When the section is closed, the variables
declared in the section and occurring free in the declaration are added as
parameters to the inductive definition.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">A generic command <a class="reference internal" href="../user-extensions/proof-schemes.html#coq:cmd.scheme" title="Scheme"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span></code></a> is useful to build automatically various
mutual induction principles.</p>
</div>
</div>
<div class="section" id="co-inductive-types">
<span id="coinductive-types"></span><h4>Co-inductive types<a class="headerlink" href="#co-inductive-types" title="Permalink to this headline">¶</a></h4>
<p>The objects of an inductive type are well-founded with respect to the
constructors of the type. In other words, such objects contain only a
<em>finite</em> number of constructors. Co-inductive types arise from relaxing
this condition, and admitting types whose objects contain an infinity of
constructors. Infinite objects are introduced by a non-ending (but
effective) process of construction, defined in terms of the constructors
of the type.</p>
<dl class="cmd">
<dt id="coq:cmd.coinductive">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span><span>CoInductive</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <span class="repeat-wrapper"><span class="repeat">|</span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat">| <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.coinductive" title="Permalink to this definition">¶</a></dt>
<dd><p>This command introduces a co-inductive type.
The syntax of the command is the same as the command <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a>.
No principle of induction is derived from the definition of a co-inductive
type, since such principles only make sense for inductive types.
For co-inductive types, the only elimination principle is case analysis.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>An example of a co-inductive type is the type of infinite sequences of
natural numbers, usually called streams.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">CoInductive</span><span> </span><span class="coqdoc-var">Stream</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">Seq</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">Stream</span><span> -&gt; </span><span class="coqdoc-var">Stream</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">Stream is defined</span></dd>
</dl>
</div>
<p>The usual destructors on streams <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">hd</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">Stream</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">nat</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tl</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">Str</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">Str</span></span></code>
can be defined as follows:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">hd</span><span> (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">Stream</span><span>) := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">a</span><span>,</span><span class="coqdoc-var">s</span><span>) := </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">hd is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">tl</span><span> (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">Stream</span><span>) := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">a</span><span>,</span><span class="coqdoc-var">s</span><span>) := </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">s</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">tl is defined</span></dd>
</dl>
</div>
</div>
<p>Definition of co-inductive predicates and blocks of mutually
co-inductive definitions are also allowed.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>An example of a co-inductive predicate is the extensional equality on
streams:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">CoInductive</span><span> </span><span class="coqdoc-var">EqSt</span><span> : </span><span class="coqdoc-var">Stream</span><span> -&gt; </span><span class="coqdoc-var">Stream</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">eqst</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">s1</span><span> </span><span class="coqdoc-var">s2</span><span>:</span><span class="coqdoc-var">Stream</span><span>,</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s1</span><span> = </span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s2</span><span> -&gt; </span><span class="coqdoc-var">EqSt</span><span> (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s1</span><span>) (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s2</span><span>) -&gt; </span><span class="coqdoc-var">EqSt</span><span> </span><span class="coqdoc-var">s1</span><span> </span><span class="coqdoc-var">s2</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">EqSt is defined</span></dd>
</dl>
</div>
<p class="last">In order to prove the extensional equality of two streams <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">s1</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">s2</span></span></code>
we have to construct an infinite proof of equality, that is, an infinite
object of type <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">EqSt</span></span> <span class="name"><span class="pre">s1</span></span> <span class="name"><span class="pre">s2</span></span><span class="operator"><span class="pre">)</span></span></code>. We will see how to introduce infinite
objects in Section <a class="reference internal" href="#cofixpoint"><span class="std std-ref">Definitions of recursive objects in co-inductive types</span></a>.</p>
</div>
<div class="section" id="caveat">
<h5>Caveat<a class="headerlink" href="#caveat" title="Permalink to this headline">¶</a></h5>
<p>The ability to define co-inductive types by constructors, hereafter called
<em>positive co-inductive types</em>, is known to break subject reduction. The story is
a bit long: this is due to dependent pattern-matching which implies
propositional η-equality, which itself would require full η-conversion for
subject reduction to hold, but full η-conversion is not acceptable as it would
make type-checking undecidable.</p>
<p>Since the introduction of primitive records in Coq 8.5, an alternative
presentation is available, called <em>negative co-inductive types</em>. This consists
in defining a co-inductive type as a primitive record type through its
projections. Such a technique is akin to the <em>co-pattern</em> style that can be
found in e.g. Agda, and preserves subject reduction.</p>
<p>The above example can be rewritten in the following way.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Reset</span><span> </span><span class="coqdoc-var">Stream</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-var">Primitive</span><span> </span><span class="coqdoc-var">Projections</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">CoInductive</span><span> </span><span class="coqdoc-var">Stream</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">Seq</span><span> { </span><span class="coqdoc-var">hd</span><span> : </span><span class="coqdoc-var">nat</span><span>; </span><span class="coqdoc-var">tl</span><span> : </span><span class="coqdoc-var">Stream</span><span> }.</span></dt>
<dd><span class="first last">Stream is defined
hd is defined
tl is defined</span></dd>
<dt><span class="coqdoc-keyword">CoInductive</span><span> </span><span class="coqdoc-var">EqSt</span><span> (</span><span class="coqdoc-var">s1</span><span> </span><span class="coqdoc-var">s2</span><span>: </span><span class="coqdoc-var">Stream</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">eqst</span><span> {</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">eqst_hd</span><span> : </span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s1</span><span> = </span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s2</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">eqst_tl</span><span> : </span><span class="coqdoc-var">EqSt</span><span> (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s1</span><span>) (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s2</span><span>);</span><span>
}.</span></dt>
<dd><span class="first last">EqSt is defined
eqst_hd is defined
eqst_tl is defined</span></dd>
</dl>
</div>
<p>Some properties that hold over positive streams are lost when going to the
negative presentation, typically when they imply equality over streams.
For instance, propositional η-equality is lost when going to the negative
presentation. It is nonetheless logically consistent to recover it through an
axiom.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">Stream_eta</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">s</span><span>: </span><span class="coqdoc-var">Stream</span><span>, </span><span class="coqdoc-var">s</span><span> = </span><span class="coqdoc-var">Seq</span><span> (</span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s</span><span>) (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s</span><span>).</span></dt>
<dd><span class="first last">Stream_eta is declared</span></dd>
</dl>
</div>
<p>More generally, as in the case of positive coinductive types, it is consistent
to further identify extensional equality of coinductive types with propositional
equality:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">Stream_ext</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">s1</span><span> </span><span class="coqdoc-var">s2</span><span>: </span><span class="coqdoc-var">Stream</span><span>), </span><span class="coqdoc-var">EqSt</span><span> </span><span class="coqdoc-var">s1</span><span> </span><span class="coqdoc-var">s2</span><span> -&gt; </span><span class="coqdoc-var">s1</span><span> = </span><span class="coqdoc-var">s2</span><span>.</span></dt>
<dd><span class="first last">Stream_ext is declared</span></dd>
</dl>
</div>
<p>As of Coq 8.9, it is now advised to use negative co-inductive types rather than
their positive counterparts.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="gallina-extensions.html#primitive-projections"><span class="std std-ref">Primitive Projections</span></a> for more information about negative
records and primitive projections.</p>
</div>
</div>
</div>
</div>
<div class="section" id="definition-of-recursive-functions">
<h3>Definition of recursive functions<a class="headerlink" href="#definition-of-recursive-functions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="definition-of-functions-by-recursion-over-inductive-objects">
<h4>Definition of functions by recursion over inductive objects<a class="headerlink" href="#definition-of-functions-by-recursion-over-inductive-objects" title="Permalink to this headline">¶</a></h4>
<p>This section describes the primitive form of definition by recursion over
inductive objects. See the <a class="reference internal" href="gallina-extensions.html#coq:cmd.function" title="Function"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Function</span></code></a> command for more advanced
constructions.</p>
<span class="target" id="fixpoint"></span><dl class="cmd">
<dt id="coq:cmd.fixpoint">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span><span>Fixpoint</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="curlies">{<span><span>struct</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a>}</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.fixpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This command allows defining functions by pattern matching over inductive
objects using a fixed point construction. The meaning of this declaration is
to define <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> a recursive function with arguments specified by
the <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> such that <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> applied to arguments
corresponding to these <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and is
equivalent to the expression <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. The type of <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is
consequently <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> and its value is equivalent
to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">fun</span></span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
<p>To be accepted, a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> definition has to satisfy some syntactical
constraints on a special argument called the decreasing argument. They
are needed to ensure that the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> definition always terminates.
The point of the <code class="docutils literal notranslate"><span class="notation"><span class="curlies"><span class="pre">{</span><span><span><span class="pre">struct</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span class="pre">}</span></span></span></code> annotation is to let the user tell the
system which argument decreases along the recursive calls.</p>
<p>The <code class="docutils literal notranslate"><span class="notation"><span class="curlies"><span class="pre">{</span><span><span><span class="pre">struct</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span class="pre">}</span></span></span></code> annotation may be left implicit, in this case the
system tries successively arguments from left to right until it finds one
that satisfies the decreasing condition.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Some fixpoints may have several arguments that fit as decreasing
arguments, and this choice influences the reduction of the fixpoint.
Hence an explicit annotation must be used if the leftmost decreasing
argument is not the desired one. Writing explicit annotations can also
speed up type checking of large mutual fixpoints.</li>
<li>In order to keep the strong normalization property, the fixed point
reduction will only be performed when the argument in position of the
decreasing argument (which type should be in an inductive definition)
starts with a constructor.</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>One can define the addition function as :</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">add</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">add</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">m</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">add is defined
add is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
<p>The match operator matches a value (here <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>) with the various
constructors of its (inductive) type. The remaining arguments give the
respective values to be returned, as functions of the parameters of the
corresponding constructor. Thus here when <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> equals <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> we return
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code>, and when <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> equals <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span><span class="operator"><span class="pre">)</span></span></code> we return <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">add</span></span> <span class="name"><span class="pre">p</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">))</span></span></code>.</p>
<p class="last">The match operator is formally described in
Section <a class="reference internal" href="cic.html#match-construction"><span class="std std-ref">The match ... with ... end construction</span></a>.
The system recognizes that in the inductive call <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">add</span></span> <span class="name"><span class="pre">p</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">)</span></span></code> the first
argument actually decreases because it is a <em>pattern variable</em> coming
from <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span> <span class="name"><span class="pre">n</span></span> <span class="keyword"><span class="pre">with</span></span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The following definition is not correct and generates an error message:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">wrongplus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">wrongplus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first">The command has indeed failed with message:
Recursive definition of wrongplus is ill-formed.
In environment
wrongplus : nat</span><span class="ansi-fg-white"> -&gt;</span><span> nat</span><span class="ansi-fg-white"> -&gt;</span><span> nat
n : nat
m : nat
p : nat
Recursive call to wrongplus has principal argument equal to 
&quot;n&quot; instead of a subterm of &quot;n&quot;.
Recursive definition is:
&quot;</span><span class="ansi-bold">fun</span><span> n m : nat =&gt; </span><span class="ansi-bold">match</span><span> m </span><span class="ansi-bold">with</span><span>
                  | 0 =&gt; n
                  | S p =&gt; S (wrongplus n p)
                  </span><span class="ansi-bold">end</span><span class="last">&quot;.</span></dd>
</dl>
</div>
<p>because the declared decreasing argument <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> does not actually
decrease in the recursive call. The function computing the addition over
the second argument should rather be written:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">m</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">plus is defined
plus is recursively defined (decreasing on 2nd argument)</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The recursive call may not only be on direct subterms of the recursive
variable <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> but also on a deeper subterm and we can directly write
the function <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">mod2</span></span></code> which gives the remainder modulo 2 of a natural
number.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">mod2</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">O</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">q</span><span> =&gt; </span><span class="coqdoc-var">mod2</span><span> </span><span class="coqdoc-var">q</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">mod2 is defined
mod2 is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Fixpoint</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="curlies">{<span><span>struct</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a>}</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This variant allows defining simultaneously several mutual fixpoints.
It is especially useful when defining functions over mutually defined
inductive types.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The size of trees and forests can be defined the following way:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">tree_size</span><span> (</span><span class="coqdoc-var">t</span><span>:</span><span class="coqdoc-var">tree</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">node</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">f</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">forest_size</span><span> </span><span class="coqdoc-var">f</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest_size</span><span> (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">forest</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">leaf</span><span> </span><span class="coqdoc-var">b</span><span> =&gt; 1</span><span>
| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">f'</span><span> =&gt; (</span><span class="coqdoc-var">tree_size</span><span> </span><span class="coqdoc-var">t</span><span> + </span><span class="coqdoc-var">forest_size</span><span> </span><span class="coqdoc-var">f'</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">tree_size is defined
forest_size is defined
tree_size, forest_size are recursively defined
(decreasing respectively on 1st, 1st arguments)</span></dd>
</dl>
</div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="definitions-of-recursive-objects-in-co-inductive-types">
<span id="cofixpoint"></span><h4>Definitions of recursive objects in co-inductive types<a class="headerlink" href="#definitions-of-recursive-objects-in-co-inductive-types" title="Permalink to this headline">¶</a></h4>
<dl class="cmd">
<dt id="coq:cmd.cofixpoint">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span><span>CoFixpoint</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.cofixpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This command introduces a method for constructing an infinite object of a
coinductive type. For example, the stream containing all natural numbers can
be introduced applying the following method to the number <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> (see
Section <a class="reference internal" href="#coinductive-types"><span class="std std-ref">Co-inductive types</span></a> for the definition of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Stream</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">hd</span></span></code>
and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tl</span></span></code>):</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">CoFixpoint</span><span> </span><span class="coqdoc-var">from</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">Stream</span><span> := </span><span class="coqdoc-var">Seq</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">from</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)).</span></dt>
<dd><span class="first last">from is defined
from is corecursively defined</span></dd>
</dl>
</div>
<p>Oppositely to recursive ones, there is no decreasing argument in a
co-recursive definition. To be admissible, a method of construction must
provide at least one extra constructor of the infinite object for each
iteration. A syntactical guard condition is imposed on co-recursive
definitions in order to ensure this: each recursive call in the
definition must be protected by at least one constructor, and only by
constructors. That is the case in the former definition, where the single
recursive call of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">from</span></span></code> is guarded by an application of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Seq</span></span></code>.
On the contrary, the following recursive function does not satisfy the
guard condition:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">CoFixpoint</span><span> </span><span class="coqdoc-var">filter</span><span> (</span><span class="coqdoc-var">p</span><span>:</span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">s</span><span>:</span><span class="coqdoc-var">Stream</span><span>) : </span><span class="coqdoc-var">Stream</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s</span><span>) </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">Seq</span><span> (</span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s</span><span>) (</span><span class="coqdoc-var">filter</span><span> </span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s</span><span>)) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">filter</span><span> </span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s</span><span>).</span></dt>
<dd><span class="first">The command has indeed failed with message:
Recursive definition of filter is ill-formed.
In environment
filter : (nat</span><span class="ansi-fg-white"> -&gt;</span><span> bool)</span><span class="ansi-fg-white"> -&gt;</span><span> Stream</span><span class="ansi-fg-white"> -&gt;</span><span> Stream
p : nat</span><span class="ansi-fg-white"> -&gt;</span><span> bool
s : Stream
Unguarded recursive call in &quot;filter p (tl s)&quot;.
Recursive definition is:
&quot;</span><span class="ansi-bold">fun</span><span> (p : nat</span><span class="ansi-fg-white"> -&gt;</span><span> bool) (s : Stream) =&gt;
 </span><span class="ansi-bold">if</span><span> p (hd s)
 </span><span class="ansi-bold">then</span><span> {| hd := hd s; tl := filter p (tl s) |}
 </span><span class="ansi-bold">else</span><span class="last"> filter p (tl s)&quot;.</span></dd>
</dl>
</div>
<p>The elimination of co-recursive definition is done lazily, i.e. the
definition is expanded only when it occurs at the head of an application
which is the argument of a case analysis expression. In any other
context, it is considered as a canonical expression which is completely
evaluated. We can test this using the command <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.eval" title="Eval"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Eval</span></code></a>, which computes
the normal forms of a term:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">from</span><span> 0).</span></dt>
<dd><span class="first last">     = (cofix from (n : nat) : Stream := {| hd := n; tl := from (S n) |}) 0
     : Stream</span></dd>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">hd</span><span> (</span><span class="coqdoc-var">from</span><span> 0)).</span></dt>
<dd><span class="first last">     = 0
     : nat</span></dd>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">tl</span><span> (</span><span class="coqdoc-var">from</span><span> 0)).</span></dt>
<dd><span class="first last">     = (cofix from (n : nat) : Stream := {| hd := n; tl := from (S n) |}) 1
     : Stream</span></dd>
</dl>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>CoFixpoint</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>As in the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> command, it is possible to introduce a block of
mutually dependent methods.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="assertions-and-proofs">
<span id="assertions"></span><h3>Assertions and proofs<a class="headerlink" href="#assertions-and-proofs" title="Permalink to this headline">¶</a></h3>
<p>An assertion states a proposition (or a type) of which the proof (or an
inhabitant of the type) is interactively built using tactics. The interactive
proof mode is described in Chapter <a class="reference internal" href="../proof-engine/proof-handling.html#proofhandling"><span class="std std-ref">Proof handling</span></a> and the tactics in
Chapter <a class="reference internal" href="../proof-engine/tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. The basic assertion command is:</p>
<dl class="cmd">
<dt id="coq:cmd.theorem">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span><span>Theorem</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.theorem" title="Permalink to this definition">¶</a></dt>
<dd><p>After the statement is asserted, Coq needs a proof. Once a proof of
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> under the assumptions represented by <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> is given and
validated, the proof is generalized into a proof of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> and
the theorem is bound to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the environment.</p>
<dl class="exn">
<dt id="coq:exn.the-term-term-has-type-type-which-should-be-set-prop-or-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span><span>The</span></span> <span><span>term</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span><span>has</span></span> <span><span>type</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span><span>which</span></span> <span><span>should</span></span> <span><span>be</span></span> <span><span>Set,</span></span> <span><span>Prop</span></span> <span><span>or</span></span> <span><span>Type.</span></span></span></code><a class="headerlink" href="#coq:exn.the-term-term-has-type-type-which-should-be-set-prop-or-type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.ident-already-exists-theorem">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span><span>already</span></span> <span><span>exists.</span></span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-theorem" title="Permalink to this definition">¶</a></dt>
<dd><p>The name you provided is already defined. You have then to choose
another name.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.nested-proofs-are-not-allowed-unless-you-turn-the-nested-proofs-allowed-flag-on">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span><span>Nested</span></span> <span><span>proofs</span></span> <span><span>are</span></span> <span><span>not</span></span> <span><span>allowed</span></span> <span><span>unless</span></span> <span><span>you</span></span> <span><span>turn</span></span> <span><span>the</span></span> <span><span>Nested</span></span> <span><span>Proofs</span></span> <span><span>Allowed</span></span> <span><span>flag</span></span> <span><span>on.</span></span></span></code><a class="headerlink" href="#coq:exn.nested-proofs-are-not-allowed-unless-you-turn-the-nested-proofs-allowed-flag-on" title="Permalink to this definition">¶</a></dt>
<dd><p>You are asserting a new statement while already being in proof editing mode.
This feature, called nested proofs, is disabled by default.
To activate it, turn the <a class="reference internal" href="../proof-engine/proof-handling.html#coq:flag.nested-proofs-allowed" title="Nested Proofs Allowed"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Nested</span> <span class="pre">Proofs</span> <span class="pre">Allowed</span></code></a> flag on.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.lemma">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Lemma</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.lemma" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.remark">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Remark</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.remark" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.fact">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Fact</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.fact" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.corollary">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Corollary</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.corollary" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmdv.proposition">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Proposition</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.proposition" title="Permalink to this definition">¶</a></dt>
<dd><p>These commands are all synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Theorem</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">:</span></span></span> <span><span><span class="pre">type</span></span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Theorem</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This command is useful for theorems that are proved by simultaneous induction
over a mutually inductive assumption, or that assert mutually dependent
statements in some mutual co-inductive type. It is equivalent to
<a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> or <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> but using tactics to build the proof of
the statements (or the body of the specification, depending on the point of
view). The inductive or co-inductive types on which the induction or
coinduction has to be done is assumed to be non ambiguous and is guessed by
the system.</p>
<p>Like in a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> or <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> definition, the induction hypotheses
have to be used on <em>structurally smaller</em> arguments (for a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a>) or
be <em>guarded by a constructor</em> (for a <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a>). The verification that
recursive proof arguments are correct is done only at the time of registering
the lemma in the environment. To know if the use of induction hypotheses is
correct at some time of the interactive development of a proof, use the
command <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.guarded" title="Guarded"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Guarded</span></code></a>.</p>
<p>The command can be used also with <a class="reference internal" href="#coq:cmdv.lemma" title="Lemma"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Lemma</span></code></a>, <a class="reference internal" href="#coq:cmdv.remark" title="Remark"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remark</span></code></a>, etc. instead of
<a class="reference internal" href="#coq:cmd.theorem" title="Theorem"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Theorem</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Definition</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>This allows defining a term of type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> using the proof editing
mode. It behaves as <a class="reference internal" href="#coq:cmd.theorem" title="Theorem"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Theorem</span></code></a> but is intended to be used in conjunction with
<a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a> in order to define a constant of which the computational
behavior is relevant.</p>
<p>The command can be used also with <a class="reference internal" href="#coq:cmdv.example" title="Example"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Example</span></code></a> instead of <a class="reference internal" href="#coq:cmd.definition" title="Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Definition</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.opaque" title="Opaque"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Opaque</span></code></a>, <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.transparent" title="Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Transparent</span></code></a>, <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>.</p>
</div>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Definition</span></span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> except that the definition is
turned into a let-in definition generalized over the declarations depending
on it after closing the current section.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>Fixpoint</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This generalizes the syntax of <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> so that one or more bodies
can be defined interactively using the proof editing mode (when a
body is omitted, its type is mandatory in the syntax). When the block
of proofs is completed, it is intended to be ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span><span>CoFixpoint</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This generalizes the syntax of <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> so that one or more bodies
can be defined interactively using the proof editing mode.</p>
</dd></dl>

<p>A proof starts by the keyword <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.proof" title="Proof"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Proof</span></code></a>. Then Coq enters the proof editing mode
until the proof is completed. The proof editing mode essentially contains
tactics that are described in chapter <a class="reference internal" href="../proof-engine/tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. Besides tactics, there
are commands to manage the proof editing mode. They are described in Chapter
<a class="reference internal" href="../proof-engine/proof-handling.html#proofhandling"><span class="std std-ref">Proof handling</span></a>.</p>
<p>When the proof is completed it should be validated and put in the environment
using the keyword <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>Several statements can be simultaneously asserted provided the
<a class="reference internal" href="../proof-engine/proof-handling.html#coq:flag.nested-proofs-allowed" title="Nested Proofs Allowed"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Nested</span> <span class="pre">Proofs</span> <span class="pre">Allowed</span></code></a> flag was turned on.</li>
<li>Not only other assertions but any vernacular command can be given
while in the process of proving a given assertion. In this case, the
command is understood as if it would have been given before the
statements still to be proved. Nonetheless, this practice is discouraged
and may stop working in future versions.</li>
<li>Proofs ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> are declared opaque. Their content cannot be
unfolded (see <a class="reference internal" href="../proof-engine/tactics.html#performingcomputations"><span class="std std-ref">Performing computations</span></a>), thus
realizing some form of <em>proof-irrelevance</em>. To be able to unfold a
proof, the proof should be ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>.</li>
<li><a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.proof" title="Proof"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Proof</span></code></a> is recommended but can currently be omitted. On the opposite
side, <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> (or <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>) is mandatory to validate a proof.</li>
<li>One can also use <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.admitted" title="Admitted"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Admitted</span></code></a> in place of <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> to turn the
current asserted statement into an axiom and exit the proof editing mode.</li>
</ol>
</div>
</div>
<div class="section" id="attributes">
<span id="gallina-attributes"></span><h3>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h3>
<p>Any vernacular command can be decorated with a list of attributes, enclosed
between <code class="docutils literal notranslate"><span class="pre">#[</span></code> (hash and opening square bracket) and <code class="docutils literal notranslate"><span class="pre">]</span></code> (closing square bracket)
and separated by commas <code class="docutils literal notranslate"><span class="pre">,</span></code>. Multiple space-separated blocks may be provided.</p>
<p>Each attribute has a name (an identifier) and may have a value.
A value is either a <a class="reference internal" href="#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">string</span></code></a> (in which case it is specified with an equal <code class="docutils literal notranslate"><span class="pre">=</span></code> sign),
or a list of attributes, enclosed within brackets.</p>
<p>Some attributes are specific to a command, and so are described with
that command. Currently, the following attributes are recognized by a
variety of commands:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">universes(monomorphic)</span></code>, <code class="docutils literal notranslate"><span class="pre">universes(polymorphic)</span></code></dt>
<dd>Equivalent to the <code class="docutils literal notranslate"><span class="pre">Monomorphic</span></code> and
<code class="docutils literal notranslate"><span class="pre">Polymorphic</span></code> flags (see <a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">program</span></code></dt>
<dd>Takes no value, equivalent to the <code class="docutils literal notranslate"><span class="pre">Program</span></code> flag
(see <a class="reference internal" href="../addendum/program.html#programs"><span class="std std-ref">Program</span></a>).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">global</span></code>, <code class="docutils literal notranslate"><span class="pre">local</span></code></dt>
<dd>Take no value, equivalent to the <code class="docutils literal notranslate"><span class="pre">Global</span></code> and <code class="docutils literal notranslate"><span class="pre">Local</span></code> flags
(see <a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-locality-of-commands"><span class="std std-ref">Controlling the locality of commands</span></a>).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deprecated</span></code></dt>
<dd><p class="first">Takes as value the optional attributes <code class="docutils literal notranslate"><span class="pre">since</span></code> and <code class="docutils literal notranslate"><span class="pre">note</span></code>;
both have a string value.</p>
<p>This attribute is supported by the following commands: <a class="reference internal" href="../proof-engine/ltac.html#coq:cmd.ltac" title="Ltac"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Ltac</span></code></a>,
<a class="reference internal" href="../user-extensions/syntax-extensions.html#coq:cmd.tactic-notation" title="Tactic Notation"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Tactic</span> <span class="pre">Notation</span></code></a>, <a class="reference internal" href="../user-extensions/syntax-extensions.html#coq:cmd.notation" title="Notation"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Notation</span></code></a>, <a class="reference internal" href="../user-extensions/syntax-extensions.html#coq:cmd.infix" title="Infix"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Infix</span></code></a>.</p>
<p>It can trigger the following warnings:</p>
<dl class="warn">
<dt id="coq:warn.tactic-qualid-is-deprecated-since-string-string">
<em class="property"><span class="sigannot">Warning</span></em> <code class="descname"><span class="notation"><span><span>Tactic</span></span> <a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a> <span><span>is</span></span> <span><span>deprecated</span></span> <span><span>since</span></span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string</span></a><span><span>.</span></span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string</span></a><span><span>.</span></span></span></code><a class="headerlink" href="#coq:warn.tactic-qualid-is-deprecated-since-string-string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="warn">
<dt id="coq:warn.tactic-notation-qualid-is-deprecated-since-string-string">
<em class="property"><span class="sigannot">Warning</span></em> <code class="descname"><span class="notation"><span><span>Tactic</span></span> <span><span>Notation</span></span> <a class="reference internal" href="#grammar-token-qualid"><span class="hole">qualid</span></a> <span><span>is</span></span> <span><span>deprecated</span></span> <span><span>since</span></span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string</span></a><span><span>.</span></span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string</span></a><span><span>.</span></span></span></code><a class="headerlink" href="#coq:warn.tactic-notation-qualid-is-deprecated-since-string-string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="last warn">
<dt id="coq:warn.notation-string-is-deprecated-since-string-string">
<em class="property"><span class="sigannot">Warning</span></em> <code class="descname"><span class="notation"><span><span>Notation</span></span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string<sub>1</sub></span></a> <span><span>is</span></span> <span><span>deprecated</span></span> <span><span>since</span></span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string<sub>2</sub></span></a><span><span>.</span></span> <a class="reference internal" href="#grammar-token-string"><span class="hole">string<sub>3</sub></span></a><span><span>.</span></span></span></code><a class="headerlink" href="#coq:warn.notation-string-is-deprecated-since-string-string" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-string"><span class="hole"><span class="pre">string</span><sub><span class="pre">1</span></sub></span></a></span></code> is the actual notation, <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-string"><span class="hole"><span class="pre">string</span><sub><span class="pre">2</span></sub></span></a></span></code> is the version number,
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-string"><span class="hole"><span class="pre">string</span><sub><span class="pre">3</span></sub></span></a></span></code> is the note.</p>
</dd></dl>

</dd>
<dt><code class="docutils literal notranslate"><span class="pre">canonical</span></code></dt>
<dd><p class="first">This attribute can decorate a <a class="reference internal" href="#coq:cmd.definition" title="Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Definition</span></code></a> or <a class="reference internal" href="gallina-extensions.html#coq:cmd.let" title="Let"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Let</span></code></a> command.
It is equivalent to having a <a class="reference internal" href="gallina-extensions.html#coq:cmd.canonical-structure" title="Canonical Structure"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Canonical</span> <span class="pre">Structure</span></code></a> declaration just
after the command.</p>
<p>This attirbute can take the value <code class="docutils literal notranslate"><span class="pre">false</span></code> when decorating a record field
declaration with the effect of preventing the field from being involved in
the inference of canonical instances.</p>
<p class="last">See also <a class="reference internal" href="gallina-extensions.html#canonical-structure-declaration"><span class="std std-ref">Canonical structures</span></a>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-var">Program</span><span>.</span></dt>
<dd><span class="first last">[Loading ML file extraction_plugin.cmxs ... done]</span></dd>
<dt><span>
#[</span><span class="coqdoc-var">program</span><span>] </span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">one</span><span> : </span><span class="coqdoc-var">nat</span><span> := </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd><span class="first last">one has type-checked, generating 1 obligation
Solving obligations automatically...
1 obligation remaining
Obligation 1 of one: nat.
                      </span></dd>
<dt><span class="coqdoc-keyword">Next</span><span> </span><span class="coqdoc-keyword">Obligation</span><span>.</span></dt>
<dd><span class="first last">1 subgoal
  
  ============================
  nat</span></dd>
<dt><span class="coqdoc-tactic">exact</span><span> </span><span class="coqdoc-var">O</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Defined</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span>
#[</span><span class="coqdoc-var">deprecated</span><span>(</span><span class="coqdoc-var">since</span><span>=&quot;8.9.0&quot;, </span><span class="coqdoc-var">note</span><span>=&quot;Use idtac instead.&quot;)]</span><span>
</span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">foo</span><span> := </span><span class="coqdoc-tactic">idtac</span><span>.</span></dt>
<dd><span class="first last">foo is defined</span></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first last">1 subgoal
  
  ============================
  True</span></dd>
<dt><span class="coqdoc-keyword">Proof</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-var">now</span><span> </span><span class="coqdoc-var">foo</span><span>.</span></dt>
<dd><span class="first">Toplevel input, characters 4-7:
&gt; now foo.
&gt;     ^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold">Warning:</span><span class="last"> Tactic foo is deprecated since 8.9.0. Use idtac instead.
[deprecated-tactic,deprecated]
No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
<dl class="warn">
<dt id="coq:warn.unsupported-attribute">
<em class="property"><span class="sigannot">Warning</span></em> <code class="descname"><span class="notation"><span><span>Unsupported</span></span> <span><span>attribute</span></span></span></code><a class="headerlink" href="#coq:warn.unsupported-attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>This warning is an error by default. It is caused by using a
command with some attribute it does not understand.</p>
</dd></dl>

<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>Except if the inductive type is empty in which case there is no
equation that can be used to infer the return type.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gallina-extensions.html" class="btn btn-neutral float-right" title="Extensions of Gallina" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../changes.html" class="btn btn-neutral" title="Recent changes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2019, Inria, CNRS and contributors.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'8.12+alpha',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/notations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>