

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Calculus of Inductive Constructions &mdash; Coq 8.12+alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Coq 8.12+alpha documentation" href="../index.html"/>
        <link rel="up" title="Core language" href="core/index.html"/>
        <link rel="next" title="Record types" href="core/records.html"/>
        <link rel="prev" title="The Gallina specification language" href="gallina-specification-language.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.12+alpha
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
</ul>
<p class="caption"><span class="caption-text">Specification language</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="core/index.html">Core language</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="gallina-specification-language.html">The Gallina specification language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-specification-language.html#lexical-conventions">Lexical conventions</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-specification-language.html#terms">Terms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#syntax-of-terms">Syntax of terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#types">Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#qualified-identifiers-and-simple-identifiers">Qualified identifiers and simple identifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#numerals-and-strings">Numerals and strings</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#sorts">Sorts</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#binders">Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#abstractions-fun">Abstractions: fun</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#products-forall">Products: forall</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#applications">Applications</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#type-cast">Type cast</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#definition-by-cases-match">Definition by cases: match</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#recursive-and-co-recursive-functions-fix-and-cofix">Recursive and co-recursive functions: fix and cofix</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-specification-language.html#the-vernacular">The Vernacular</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#assumptions">Assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#definitions">Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#inductive-types">Inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#co-inductive-types">Co-inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#definition-of-recursive-functions">Definition of recursive functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#computations">Computations</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#assertions-and-proofs">Assertions and proofs</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-specification-language.html#attributes">Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Calculus of Inductive Constructions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-terms">The terms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sorts">Sorts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#terms">Terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#typing-rules">Typing rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conversion-rules">Conversion rules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#reduction">β-reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iota-reduction">ι-reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#delta-reduction">δ-reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zeta-reduction">ζ-reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expansion">η-expansion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inductive-definitions">Inductive Definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#well-formed-inductive-definitions">Well-formed inductive definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#destructors">Destructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fixpoint-definitions">Fixpoint definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#co-inductive-types">Co-inductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core/records.html">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="core/records.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="core/records.html#primitive-record-types">Primitive Record Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="core/records.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="core/records.html#compatibility-projections-and-match">Compatibility Projections and <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#an-example-of-a-proof-using-cumulativity">An example of a proof using cumulativity</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#universe-polymorphism-and-sections">Universe polymorphism and sections</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#issues-with-non-cumulativity">Issues with non-cumulativity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core/sections.html">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="module-system.html">The Module System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="module-system.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l3"><a class="reference internal" href="module-system.html#typing-modules">Typing Modules</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extensions/index.html">Language extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a><ul>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#variants-and-extensions-of-match">Variants and extensions of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#module-system">Module system</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#libraries-and-qualified-names">Libraries and qualified names</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#names-of-libraries">Names of libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#qualified-names">Qualified names</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#libraries-and-filesystem">Libraries and filesystem</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#coercions">Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#printing-universes">Printing universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#existential-variables">Existential variables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#explicit-displaying-of-existential-instances-for-pretty-printing">Explicit displaying of existential instances for pretty-printing</a></li>
<li class="toctree-l4"><a class="reference internal" href="gallina-extensions.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#primitive-integers">Primitive Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#primitive-floats">Primitive Floats</a></li>
<li class="toctree-l3"><a class="reference internal" href="gallina-extensions.html#bidirectionality-hints">Bidirectionality hints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="extensions/implicit-arguments.html">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#maximal-or-non-maximal-insertion-of-implicit-arguments">Maximal or non maximal insertion of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#trailing-implicit-arguments">Trailing Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#declaring-implicit-arguments">Declaring Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="extensions/implicit-arguments.html#combining-manual-declaration-and-automatic-declaration">Combining manual declaration and automatic declaration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#displaying-implicit-arguments">Displaying implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#displaying-implicit-arguments-when-pretty-printing">Displaying implicit arguments when pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#canonical-structures">Canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/implicit-arguments.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns">Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extended-pattern-matching.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extended-pattern-matching.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extended-pattern-matching.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extended-pattern-matching.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extended-pattern-matching.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-symbolic-notations">Displaying symbolic notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#inheritance-of-the-properties-of-arguments-of-constants-bound-to-a-notation">Inheritance of the properties of arguments of constants bound to a notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes">Interpretation scopes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-interpretation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> interpretation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#interpretation-scopes-used-in-the-standard-library-of-coq">Interpretation scopes used in the standard library of Coq</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numeral-notations">Numeral notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#classes">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions">Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#declaring-coercions">Declaring Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-at-function-application">Coercion at function application</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-type">Coercion to a type</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-to-a-function">Coercion to a function</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#class-and-instance-declarations">Class and Instance declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#binding-classes">Binding classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#parameterized-instances">Parameterized Instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#summary-of-the-commands">Summary of the commands</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto <code class="docutils literal notranslate"><span class="pre">:=</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/canonical-structures.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/canonical-structures.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/canonical-structures.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html">Program</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#flags-options-and-tables">Flags, Options and Tables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/vernacular-commands.html#locality-attributes-supported-by-set-and-unset">Locality attributes supported by <code class="docutils literal notranslate"><span class="pre">Set</span></code> and <code class="docutils literal notranslate"><span class="pre">Unset</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#query-commands">Query commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#loadpath">Loadpath</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-the-reduction-strategies-and-the-conversion-algorithm">Controlling the reduction strategies and the conversion algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-the-locality-of-commands">Controlling the locality of commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#controlling-typing-flags">Controlling Typing Flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Proofs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proofs/writing-proofs/index.html">Writing proofs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#entering-and-leaving-proof-editing-mode">Entering and leaving proof editing mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/proof-handling.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/proof-handling.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/proof-handling.html#proof-modes">Proof modes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#navigation-in-the-proof-tree">Navigation in the proof tree</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/proof-handling.html#bullets">Bullets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/proof-handling.html#mandatory-bullets">Mandatory Bullets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/proof-handling.html#set-bullet-behavior">Set Bullet Behavior</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#requesting-information">Requesting information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/proof-handling.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/proof-handling.html#how-diffs-are-calculated">How diffs are calculated</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#controlling-the-effect-of-proof-editing-commands">Controlling the effect of proof editing commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/proof-handling.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#bindings-list">Bindings list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#occurrence-sets-and-occurrence-clauses">Occurrence sets and occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#case-analysis-and-induction">Case analysis and induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#rewriting-expressions">Rewriting expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#performing-computations">Performing computations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#conversion-tactics-applied-to-hypotheses">Conversion tactics applied to hypotheses</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#automation">Automation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#controlling-automation">Controlling automation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#the-hints-databases-for-auto-and-eauto">The hints databases for auto and eauto</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#hint-locality">Hint locality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/tactics.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#decision-procedures">Decision procedures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#checking-properties-of-terms">Checking properties of terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#equality">Equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#equality-and-inductive-sets">Equality and inductive sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#automating">Automating</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#non-logical-tactics">Non-logical tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#gallina-extensions"><span class="smallcaps">Gallina</span> extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#discharge">Discharge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#structure">Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#examples">Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#ssr-searching-tool"><span class="smallcaps">SSReflect</span> searching tool</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#dependent-induction">dependent induction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#a-larger-example">A larger example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html#autorewrite">autorewrite</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/proof-schemes.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/proof-schemes.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/proof-schemes.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proofs/automatic-tactics/index.html">Built-in decision procedures and programmable tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#description-of-omega">Description of <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#arithmetical-goals-recognized-by-omega">Arithmetical goals recognized by <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#messages-from-omega">Messages from <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#using-omega">Using <code class="docutils literal notranslate"><span class="pre">omega</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#options">Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#technical-data">Technical data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/omega.html#overview-of-the-tactic">Overview of the tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/omega.html#overview-of-the-omega-decision-procedure">Overview of the OMEGA decision procedure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/omega.html#bugs">Bugs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#zify-pre-processing-of-arithmetic-goals"><code class="docutils literal notranslate"><span class="pre">zify</span></code>: pre-processing of arithmetic goals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-reflexive-relations">Rewriting and non reflexive relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-non-symmetric-relations">Rewriting and non symmetric relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proofs/creating-tactics/index.html">Creating new tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac.html">Ltac</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#semantics">Semantics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#sequence">Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#local-application-of-tactics">Local application of tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#for-loop">For loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#error-catching">Error catching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#detecting-progress">Detecting progress</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#backtracking-branching">Backtracking branching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#first-tactic-to-work">First tactic to work</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#left-biased-branching">Left-biased branching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#generalized-biased-branching">Generalized biased branching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#soft-cut">Soft cut</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-successes">Checking the successes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-failure">Checking the failure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#checking-the-success">Checking the success</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#solving">Solving</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#identity">Identity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#failing">Failing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#timeout">Timeout</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#timing-a-tactic-that-evaluates-to-a-term">Timing a tactic that evaluates to a term</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#local-definitions">Local definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#application">Application</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#function-construction">Function construction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#pattern-matching-on-terms">Pattern matching on terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#pattern-matching-on-goals">Pattern matching on goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#computing-in-a-constr">Computing in a constr</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#recovering-the-type-of-a-term">Recovering the type of a term</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#manipulating-untyped-terms">Manipulating untyped terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#counting-the-goals">Counting the goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#testing-boolean-expressions">Testing boolean expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#proving-a-subgoal-as-a-separate-lemma">Proving a subgoal as a separate lemma</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#defining-ltac-functions">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#info-trace">Info trace</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proof-engine/ltac2.html">Ltac2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#general-design">General design</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#ml-component">ML component</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#type-syntax">Type Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#type-declarations">Type declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#term-syntax">Term Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#ltac-definitions">Ltac Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#typing">Typing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#effects">Effects</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#meta-programming">Meta-programming</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#id3">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#generic-syntax-for-quotations">Generic Syntax for Quotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#term-antiquotations">Term Antiquotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#match-over-terms">Match over terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#match-over-goals">Match over goals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#scopes">Scopes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#id6">Notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#abbreviations">Abbreviations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#evaluation">Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#debug">Debug</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#compatibility-layer-with-ltac1">Compatibility layer with Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#ltac1-from-ltac2">Ltac1 from Ltac2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#ltac2-from-ltac1">Ltac2 from Ltac1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#switching-between-ltac-languages">Switching between Ltac languages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proof-engine/ltac2.html#transition-from-ltac1">Transition from Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#syntax-changes">Syntax changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#tactic-delay">Tactic delay</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#variable-binding">Variable binding</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proof-engine/ltac2.html#exception-catching">Exception catching</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Using Coq</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../using/libraries/index.html">Libraries and plugins</a><ul>
<li class="toctree-l2"><a class="reference internal" href="coq-library.html">The <span class="smallcaps">Coq</span> library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#the-basic-library">The basic library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#notations">Notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#logic">Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#datatypes">Datatypes</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#specification">Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#basic-arithmetic">Basic Arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#survey">Survey</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#notations-for-integer-arithmetic">Notations for integer arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#real-numbers-library">Real numbers library</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#list-library">List library</a></li>
<li class="toctree-l4"><a class="reference internal" href="coq-library.html#floats-library">Floats library</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html">Program extraction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between <span class="smallcaps">Coq</span> and ML type systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Program derivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../using/libraries/funind.html">Functional induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../using/tools/index.html">Command-line and graphical tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#by-resource-file">By resource file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#by-environment-variables">By environment variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#by-command-line-options">By command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-interfaces-produced-using-vos">Compiled interfaces (produced using <code class="docutils literal notranslate"><span class="pre">-vos</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project">Building a <span class="smallcaps">Coq</span> project</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile">Building a <span class="smallcaps">Coq</span> project with coq_makefile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a <span class="smallcaps">Coq</span> project with Dune</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#computing-module-dependencies">Computing Module dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../using/tools/coqdoc.html">Documenting <span class="smallcaps">Coq</span> files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#coq-material-inside-documentation"><span class="smallcaps">Coq</span> material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source.</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#interactive-navigation-into-coq-scripts">Interactive navigation into Coq scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#vernacular-commands-templates">Vernacular commands, templates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#id2">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/history-and-changes/index.html">History and recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-11">Version 8.11</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-beta1">Changes in 8.11+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-0">Changes in 8.11.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-1">Changes in 8.11.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id260">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id407">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id409">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id410">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id411">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id412">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id413">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id414">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id416">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id417">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id418">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id419">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id420">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id421">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/indexes/index.html">Indexes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../genindex.html">General index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-attrindex.html">Attribute index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="core/index.html">Core language</a> &raquo;</li>
        
      <li>Calculus of Inductive Constructions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/language/cic.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\case}{\kw{case}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\end{split}\]</div>
<div class="section" id="calculus-of-inductive-constructions">
<span id="calculusofinductiveconstructions"></span><h1>Calculus of Inductive Constructions<a class="headerlink" href="#calculus-of-inductive-constructions" title="Permalink to this headline">¶</a></h1>
<p>The underlying formal language of <span class="smallcaps">Coq</span> is a <em>Calculus of Inductive
Constructions</em> (CIC) whose inference rules are presented in this
chapter. The history of this formalism as well as pointers to related
work are provided in a separate chapter; see <em>Credits</em>.</p>
<div class="section" id="the-terms">
<span id="id1"></span><h2>The terms<a class="headerlink" href="#the-terms" title="Permalink to this headline">¶</a></h2>
<p>The expressions of the CIC are <em>terms</em> and all terms have a <em>type</em>.
There are types for functions (or programs), there are atomic types
(especially datatypes)... but also types for proofs and types for the
types themselves. Especially, any object handled in the formalism must
belong to a type. For instance, universal quantification is relative
to a type and takes the form “<em>for all x of type</em> <span class="math notranslate nohighlight">\(T\)</span>, <span class="math notranslate nohighlight">\(P\)</span>”. The expression
“<span class="math notranslate nohighlight">\(x\)</span> <em>of type</em> <span class="math notranslate nohighlight">\(T\)</span>” is written “<span class="math notranslate nohighlight">\(x:T\)</span>”. Informally, “<span class="math notranslate nohighlight">\(x:T\)</span>” can be thought as
“<span class="math notranslate nohighlight">\(x\)</span> <em>belongs to</em> <span class="math notranslate nohighlight">\(T\)</span>”.</p>
<p>The types of types are <em>sorts</em>. Types and sorts are themselves terms
so that terms, types and sorts are all components of a common
syntactic language of terms which is described in Section <a class="reference internal" href="#terms"><span class="std std-ref">Terms</span></a> but,
first, we describe sorts.</p>
<div class="section" id="sorts">
<span id="id2"></span><h3>Sorts<a class="headerlink" href="#sorts" title="Permalink to this headline">¶</a></h3>
<p>All sorts have a type and there is an infinite well-founded typing
hierarchy of sorts whose base sorts are <span class="math notranslate nohighlight">\(\SProp\)</span>, <span class="math notranslate nohighlight">\(\Prop\)</span>
and <span class="math notranslate nohighlight">\(\Set\)</span>.</p>
<p>The sort <span class="math notranslate nohighlight">\(\Prop\)</span> intends to be the type of logical propositions. If <span class="math notranslate nohighlight">\(M\)</span> is a
logical proposition then it denotes the class of terms representing
proofs of <span class="math notranslate nohighlight">\(M\)</span>. An object <span class="math notranslate nohighlight">\(m\)</span> belonging to <span class="math notranslate nohighlight">\(M\)</span> witnesses the fact that <span class="math notranslate nohighlight">\(M\)</span> is
provable. An object of type <span class="math notranslate nohighlight">\(\Prop\)</span> is called a proposition.</p>
<p>The sort <span class="math notranslate nohighlight">\(\SProp\)</span> is like <span class="math notranslate nohighlight">\(\Prop\)</span> but the propositions in
<span class="math notranslate nohighlight">\(\SProp\)</span> are known to have irrelevant proofs (all proofs are
equal). Objects of type <span class="math notranslate nohighlight">\(\SProp\)</span> are called strict propositions.
See <a class="reference internal" href="../addendum/sprop.html#sprop"><span class="std std-ref">SProp (proof irrelevant propositions)</span></a> for information about using
<span class="math notranslate nohighlight">\(\SProp\)</span>, and <a class="reference internal" href="../zebibliography.html#gilbert-popl2019" id="id3">[GCST19]</a> for meta theoretical
considerations.</p>
<p>The sort <span class="math notranslate nohighlight">\(\Set\)</span> intends to be the type of small sets. This includes data
types such as booleans and naturals, but also products, subsets, and
function types over these data types.</p>
<p><span class="math notranslate nohighlight">\(\SProp\)</span>, <span class="math notranslate nohighlight">\(\Prop\)</span> and <span class="math notranslate nohighlight">\(\Set\)</span> themselves can be manipulated as ordinary terms.
Consequently they also have a type. Because assuming simply that <span class="math notranslate nohighlight">\(\Set\)</span>
has type <span class="math notranslate nohighlight">\(\Set\)</span> leads to an inconsistent theory <a class="reference internal" href="../zebibliography.html#coq86" id="id4">[Coq86]</a>, the language of
CIC has infinitely many sorts. There are, in addition to the base sorts,
a hierarchy of universes <span class="math notranslate nohighlight">\(\Type(i)\)</span> for any integer <span class="math notranslate nohighlight">\(i ≥ 1\)</span>.</p>
<p>Like <span class="math notranslate nohighlight">\(\Set\)</span>, all of the sorts <span class="math notranslate nohighlight">\(\Type(i)\)</span> contain small sets such as
booleans, natural numbers, as well as products, subsets and function
types over small sets. But, unlike <span class="math notranslate nohighlight">\(\Set\)</span>, they also contain large sets,
namely the sorts <span class="math notranslate nohighlight">\(\Set\)</span> and <span class="math notranslate nohighlight">\(\Type(j)\)</span> for <span class="math notranslate nohighlight">\(j&lt;i\)</span>, and all products, subsets
and function types over these sorts.</p>
<p>Formally, we call <span class="math notranslate nohighlight">\(\Sort\)</span> the set of sorts which is defined by:</p>
<div class="math notranslate nohighlight">
\[\Sort \equiv \{\SProp,\Prop,\Set,\Type(i)\;|\; i~∈ ℕ\}\]</div>
<p>Their properties, such as: <span class="math notranslate nohighlight">\(\Prop:\Type(1)\)</span>, <span class="math notranslate nohighlight">\(\Set:\Type(1)\)</span>, and
<span class="math notranslate nohighlight">\(\Type(i):\Type(i+1)\)</span>, are defined in Section <a class="reference internal" href="#subtyping-rules"><span class="std std-ref">Subtyping rules</span></a>.</p>
<p>The user does not have to mention explicitly the index <span class="math notranslate nohighlight">\(i\)</span> when
referring to the universe <span class="math notranslate nohighlight">\(\Type(i)\)</span>. One only writes <span class="math notranslate nohighlight">\(\Type\)</span>. The system
itself generates for each instance of <span class="math notranslate nohighlight">\(\Type\)</span> a new index for the
universe and checks that the constraints between these indexes can be
solved. From the user point of view we consequently have <span class="math notranslate nohighlight">\(\Type:\Type\)</span>. We
shall make precise in the typing rules the constraints between the
indices.</p>
<p id="implementation-issues"><strong>Implementation issues</strong> In practice, the Type hierarchy is
implemented using <em>algebraic
universes</em>. An algebraic universe <span class="math notranslate nohighlight">\(u\)</span> is either a variable (a qualified
identifier with a number) or a successor of an algebraic universe (an
expression <span class="math notranslate nohighlight">\(u+1\)</span>), or an upper bound of algebraic universes (an
expression <span class="math notranslate nohighlight">\(\max(u_1 ,...,u_n )\)</span>), or the base universe (the expression
<span class="math notranslate nohighlight">\(0\)</span>) which corresponds, in the arity of template polymorphic inductive
types (see Section
<a class="reference internal" href="#well-formed-inductive-definitions"><span class="std std-ref">Well-formed inductive definitions</span></a>),
to the predicative sort <span class="math notranslate nohighlight">\(\Set\)</span>. A graph of
constraints between the universe variables is maintained globally. To
ensure the existence of a mapping of the universes to the positive
integers, the graph of constraints must remain acyclic. Typing
expressions that violate the acyclicity of the graph of constraints
results in a Universe inconsistency error.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Section <a class="reference internal" href="gallina-extensions.html#printing-universes"><span class="std std-ref">Printing universes</span></a>.</p>
</div>
</div>
<div class="section" id="terms">
<span id="id5"></span><h3>Terms<a class="headerlink" href="#terms" title="Permalink to this headline">¶</a></h3>
<p>Terms are built from sorts, variables, constants, abstractions,
applications, local definitions, and products. From a syntactic point
of view, types cannot be distinguished from terms, except that they
cannot start by an abstraction or a constructor. More precisely the
language of the <em>Calculus of Inductive Constructions</em> is built from
the following rules.</p>
<ol class="arabic simple">
<li>the sorts <span class="math notranslate nohighlight">\(\SProp\)</span>, <span class="math notranslate nohighlight">\(\Prop\)</span>, <span class="math notranslate nohighlight">\(\Set\)</span>, <span class="math notranslate nohighlight">\(\Type(i)\)</span> are terms.</li>
<li>variables, hereafter ranged over by letters <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, etc., are terms</li>
<li>constants, hereafter ranged over by letters <span class="math notranslate nohighlight">\(c\)</span>, <span class="math notranslate nohighlight">\(d\)</span>, etc., are terms.</li>
<li>if <span class="math notranslate nohighlight">\(x\)</span> is a variable and <span class="math notranslate nohighlight">\(T\)</span>, <span class="math notranslate nohighlight">\(U\)</span> are terms then
<span class="math notranslate nohighlight">\(∀ x:T,~U\)</span> (<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">U</span></span></code>   in <span class="smallcaps">Coq</span> concrete syntax) is a term.
If <span class="math notranslate nohighlight">\(x\)</span> occurs in <span class="math notranslate nohighlight">\(U\)</span>, <span class="math notranslate nohighlight">\(∀ x:T,~U\)</span> reads as
“for all <span class="math notranslate nohighlight">\(x\)</span> of type <span class="math notranslate nohighlight">\(T\)</span>, <span class="math notranslate nohighlight">\(U\)</span>”.
As <span class="math notranslate nohighlight">\(U\)</span> depends on <span class="math notranslate nohighlight">\(x\)</span>, one says that <span class="math notranslate nohighlight">\(∀ x:T,~U\)</span> is
a <em>dependent product</em>. If <span class="math notranslate nohighlight">\(x\)</span> does not occur in <span class="math notranslate nohighlight">\(U\)</span> then
<span class="math notranslate nohighlight">\(∀ x:T,~U\)</span> reads as
“if <span class="math notranslate nohighlight">\(T\)</span> then <span class="math notranslate nohighlight">\(U\)</span>”. A <em>non dependent product</em> can be
written: <span class="math notranslate nohighlight">\(T \rightarrow U\)</span>.</li>
<li>if <span class="math notranslate nohighlight">\(x\)</span> is a variable and <span class="math notranslate nohighlight">\(T\)</span>, <span class="math notranslate nohighlight">\(u\)</span> are terms then
<span class="math notranslate nohighlight">\(λ x:T .~u\)</span> (<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">u</span></span></code>
in <span class="smallcaps">Coq</span> concrete syntax) is a term. This is a notation for the
λ-abstraction of λ-calculus <a class="reference internal" href="../zebibliography.html#bar81" id="id6">[Bar81]</a>. The term <span class="math notranslate nohighlight">\(λ x:T .~u\)</span> is a function
which maps elements of <span class="math notranslate nohighlight">\(T\)</span> to the expression <span class="math notranslate nohighlight">\(u\)</span>.</li>
<li>if <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(u\)</span> are terms then <span class="math notranslate nohighlight">\((t~u)\)</span> is a term
(<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span> <span class="name"><span class="pre">u</span></span></code> in <span class="smallcaps">Coq</span> concrete
syntax). The term <span class="math notranslate nohighlight">\((t~u)\)</span> reads as “<span class="math notranslate nohighlight">\(t\)</span> applied to <span class="math notranslate nohighlight">\(u\)</span>”.</li>
<li>if <span class="math notranslate nohighlight">\(x\)</span> is a variable, and <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(u\)</span> are
terms then <span class="math notranslate nohighlight">\(\letin{x}{t:T}{u}\)</span> is
a term which denotes the term <span class="math notranslate nohighlight">\(u\)</span> where the variable <span class="math notranslate nohighlight">\(x\)</span> is locally bound
to <span class="math notranslate nohighlight">\(t\)</span> of type <span class="math notranslate nohighlight">\(T\)</span>. This stands for the common “let-in” construction of
functional programs such as ML or Scheme.</li>
</ol>
<p id="free-variables"><strong>Free variables.</strong>
The notion of free variables is defined as usual. In the expressions
<span class="math notranslate nohighlight">\(λx:T.~U\)</span> and <span class="math notranslate nohighlight">\(∀ x:T,~U\)</span> the occurrences of <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(U\)</span> are bound.</p>
<p id="substitution"><strong>Substitution.</strong>
The notion of substituting a term <span class="math notranslate nohighlight">\(t\)</span> to free occurrences of a variable
<span class="math notranslate nohighlight">\(x\)</span> in a term <span class="math notranslate nohighlight">\(u\)</span> is defined as usual. The resulting term is written
<span class="math notranslate nohighlight">\(\subst{u}{x}{t}\)</span>.</p>
<p id="the-logical-vs-programming-readings"><strong>The logical vs programming readings.</strong>
The constructions of the CIC can be used to express both logical and
programming notions, accordingly to the Curry-Howard correspondence
between proofs and programs, and between propositions and types
<a class="reference internal" href="../zebibliography.html#cur58" id="id7">[CFC58]</a><a class="reference internal" href="../zebibliography.html#how80" id="id8">[How80]</a><a class="reference internal" href="../zebibliography.html#bru72" id="id9">[dB72]</a>.</p>
<p>For instance, let us assume that <span class="math notranslate nohighlight">\(\nat\)</span> is the type of natural numbers
with zero element written <span class="math notranslate nohighlight">\(0\)</span> and that <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">True</span></span></code> is the always true
proposition. Then <span class="math notranslate nohighlight">\(→\)</span> is used both to denote <span class="math notranslate nohighlight">\(\nat→\nat\)</span> which is the type
of functions from <span class="math notranslate nohighlight">\(\nat\)</span> to <span class="math notranslate nohighlight">\(\nat\)</span>, to denote True→True which is an
implicative proposition, to denote <span class="math notranslate nohighlight">\(\nat →\Prop\)</span> which is the type of
unary predicates over the natural numbers, etc.</p>
<p>Let us assume that <code class="docutils literal notranslate"><span class="pre">mult</span></code> is a function of type <span class="math notranslate nohighlight">\(\nat→\nat→\nat\)</span> and <code class="docutils literal notranslate"><span class="pre">eqnat</span></code> a
predicate of type <span class="math notranslate nohighlight">\(\nat→\nat→ \Prop\)</span>. The λ-abstraction can serve to build
“ordinary” functions as in <span class="math notranslate nohighlight">\(λ x:\nat.~(\kw{mult}~x~x)\)</span> (i.e.
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">mult</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">x</span></span></code>
in <span class="smallcaps">Coq</span> notation) but may build also predicates over the natural
numbers. For instance <span class="math notranslate nohighlight">\(λ x:\nat.~(\kw{eqnat}~x~0)\)</span>
(i.e. <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">eqnat</span></span> <span class="name"><span class="pre">x</span></span> <span class="literal number integer"><span class="pre">0</span></span></code>
in <span class="smallcaps">Coq</span> notation) will represent the predicate of one variable <span class="math notranslate nohighlight">\(x\)</span> which
asserts the equality of <span class="math notranslate nohighlight">\(x\)</span> with <span class="math notranslate nohighlight">\(0\)</span>. This predicate has type
<span class="math notranslate nohighlight">\(\nat → \Prop\)</span>
and it can be applied to any expression of type <span class="math notranslate nohighlight">\(\nat\)</span>, say <span class="math notranslate nohighlight">\(t\)</span>, to give an
object <span class="math notranslate nohighlight">\(P~t\)</span> of type <span class="math notranslate nohighlight">\(\Prop\)</span>, namely a proposition.</p>
<p>Furthermore <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span></code> will represent the type of functions
which associate to each natural number <span class="math notranslate nohighlight">\(n\)</span> an object of type <span class="math notranslate nohighlight">\((P~n)\)</span> and
consequently represent the type of proofs of the formula “<span class="math notranslate nohighlight">\(∀ x.~P(x)\)</span>”.</p>
</div>
</div>
<div class="section" id="typing-rules">
<span id="id10"></span><h2>Typing rules<a class="headerlink" href="#typing-rules" title="Permalink to this headline">¶</a></h2>
<p>As objects of type theory, terms are subjected to <em>type discipline</em>.
The well typing of a term depends on a global environment and a local
context.</p>
<p id="local-context"><strong>Local context.</strong>
A <em>local context</em> is an ordered list of <em>local declarations</em> of names
which we call <em>variables</em>. The declaration of some variable <span class="math notranslate nohighlight">\(x\)</span> is
either a <em>local assumption</em>, written <span class="math notranslate nohighlight">\(x:T\)</span> (<span class="math notranslate nohighlight">\(T\)</span> is a type) or a <em>local
definition</em>, written <span class="math notranslate nohighlight">\(x:=t:T\)</span>. We use brackets to write local contexts.
A typical example is <span class="math notranslate nohighlight">\([x:T;~y:=u:U;~z:V]\)</span>. Notice that the variables
declared in a local context must be distinct. If <span class="math notranslate nohighlight">\(Γ\)</span> is a local context
that declares some <span class="math notranslate nohighlight">\(x\)</span>, we
write <span class="math notranslate nohighlight">\(x ∈ Γ\)</span>. By writing <span class="math notranslate nohighlight">\((x:T) ∈ Γ\)</span> we mean that either <span class="math notranslate nohighlight">\(x:T\)</span> is an
assumption in <span class="math notranslate nohighlight">\(Γ\)</span> or that there exists some <span class="math notranslate nohighlight">\(t\)</span> such that <span class="math notranslate nohighlight">\(x:=t:T\)</span> is a
definition in <span class="math notranslate nohighlight">\(Γ\)</span>. If <span class="math notranslate nohighlight">\(Γ\)</span> defines some <span class="math notranslate nohighlight">\(x:=t:T\)</span>, we also write <span class="math notranslate nohighlight">\((x:=t:T) ∈ Γ\)</span>.
For the rest of the chapter, <span class="math notranslate nohighlight">\(Γ::(y:T)\)</span> denotes the local context <span class="math notranslate nohighlight">\(Γ\)</span>
enriched with the local assumption <span class="math notranslate nohighlight">\(y:T\)</span>. Similarly, <span class="math notranslate nohighlight">\(Γ::(y:=t:T)\)</span> denotes
the local context <span class="math notranslate nohighlight">\(Γ\)</span> enriched with the local definition <span class="math notranslate nohighlight">\((y:=t:T)\)</span>. The
notation <span class="math notranslate nohighlight">\([]\)</span> denotes the empty local context. By <span class="math notranslate nohighlight">\(Γ_1 ; Γ_2\)</span> we mean
concatenation of the local context <span class="math notranslate nohighlight">\(Γ_1\)</span> and the local context <span class="math notranslate nohighlight">\(Γ_2\)</span>.</p>
<p id="global-environment"><strong>Global environment.</strong>
A <em>global environment</em> is an ordered list of <em>global declarations</em>.
Global declarations are either <em>global assumptions</em> or <em>global
definitions</em>, but also declarations of inductive objects. Inductive
objects themselves declare both inductive or coinductive types and
constructors (see Section <a class="reference internal" href="#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a>).</p>
<p>A <em>global assumption</em> will be represented in the global environment as
<span class="math notranslate nohighlight">\((c:T)\)</span> which assumes the name <span class="math notranslate nohighlight">\(c\)</span> to be of some type <span class="math notranslate nohighlight">\(T\)</span>. A <em>global
definition</em> will be represented in the global environment as <span class="math notranslate nohighlight">\(c:=t:T\)</span>
which defines the name <span class="math notranslate nohighlight">\(c\)</span> to have value <span class="math notranslate nohighlight">\(t\)</span> and type <span class="math notranslate nohighlight">\(T\)</span>. We shall call
such names <em>constants</em>. For the rest of the chapter, the <span class="math notranslate nohighlight">\(E;~c:T\)</span> denotes
the global environment <span class="math notranslate nohighlight">\(E\)</span> enriched with the global assumption <span class="math notranslate nohighlight">\(c:T\)</span>.
Similarly, <span class="math notranslate nohighlight">\(E;~c:=t:T\)</span> denotes the global environment <span class="math notranslate nohighlight">\(E\)</span> enriched with the
global definition <span class="math notranslate nohighlight">\((c:=t:T)\)</span>.</p>
<p>The rules for inductive definitions (see Section
<a class="reference internal" href="#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a>) have to be considered as assumption
rules to which the following definitions apply: if the name <span class="math notranslate nohighlight">\(c\)</span>
is declared in <span class="math notranslate nohighlight">\(E\)</span>, we write <span class="math notranslate nohighlight">\(c ∈ E\)</span> and if <span class="math notranslate nohighlight">\(c:T\)</span> or
<span class="math notranslate nohighlight">\(c:=t:T\)</span> is declared in <span class="math notranslate nohighlight">\(E\)</span>, we write <span class="math notranslate nohighlight">\((c : T) ∈ E\)</span>.</p>
<p id="typing-rules2"><strong>Typing rules.</strong>
In the following, we define simultaneously two judgments. The first
one <span class="math notranslate nohighlight">\(\WTEG{t}{T}\)</span> means the term <span class="math notranslate nohighlight">\(t\)</span> is well-typed and has type <span class="math notranslate nohighlight">\(T\)</span> in the
global environment <span class="math notranslate nohighlight">\(E\)</span> and local context <span class="math notranslate nohighlight">\(Γ\)</span>. The second judgment <span class="math notranslate nohighlight">\(\WFE{Γ}\)</span>
means that the global environment <span class="math notranslate nohighlight">\(E\)</span> is well-formed and the local
context <span class="math notranslate nohighlight">\(Γ\)</span> is a valid local context in this global environment.</p>
<p>A term <span class="math notranslate nohighlight">\(t\)</span> is well typed in a global environment <span class="math notranslate nohighlight">\(E\)</span> iff
there exists a local context <span class="math notranslate nohighlight">\(\Gamma\)</span> and a term <span class="math notranslate nohighlight">\(T\)</span> such
that the judgment <span class="math notranslate nohighlight">\(\WTEG{t}{T}\)</span> can be derived from the
following rules.</p>
<dl class="docutils">
<dt id="inference-w-empty">W-Empty<td><div class="first last math notranslate nohighlight">
\[\frac{%
%
}{%
\WF{[]}{}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-w-local-assum">W-Local-Assum<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTEG{T}{s}%
\hspace{3em}%
s \in \Sort%
\hspace{3em}%
x \not\in \Gamma % \cup E%
}{%
\WFE{\Gamma::(x:T)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-w-local-def">W-Local-Def<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTEG{t}{T}%
\hspace{3em}%
x \not\in \Gamma % \cup E%
}{%
\WFE{\Gamma::(x:=t:T)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-w-global-assum">W-Global-Assum<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTE{}{T}{s}%
\hspace{3em}%
s \in \Sort%
\hspace{3em}%
c \notin E%
}{%
\WF{E;~c:T}{}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-w-global-def">W-Global-Def<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTE{}{t}{T}%
\hspace{3em}%
c \notin E%
}{%
\WF{E;~c:=t:T}{}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-ax-sprop">Ax-SProp<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{\Gamma}%
}{%
\WTEG{\SProp}{\Type(1)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-ax-prop">Ax-Prop<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{\Gamma}%
}{%
\WTEG{\Prop}{\Type(1)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-ax-set">Ax-Set<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{\Gamma}%
}{%
\WTEG{\Set}{\Type(1)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-ax-type">Ax-Type<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{\Gamma}%
}{%
\WTEG{\Type(i)}{\Type(i+1)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-var">Var<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{\Gamma}%
\hspace{3em}%
(x:T) \in \Gamma~~\mbox{or}~~(x:=t:T) \in \Gamma~\mbox{for some $t$}%
}{%
\WTEG{x}{T}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-const">Const<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{\Gamma}%
\hspace{3em}%
(c:T) \in E~~\mbox{or}~~(c:=t:T) \in E~\mbox{for some $t$}%
}{%
\WTEG{c}{T}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-prod-sprop">Prod-SProp<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTEG{T}{s}%
\hspace{3em}%
s \in {\Sort}%
\hspace{3em}%
\WTE{\Gamma::(x:T)}{U}{\SProp}%
}{%
\WTEG{\forall~x:T,U}{\SProp}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-prod-prop">Prod-Prop<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTEG{T}{s}%
\hspace{3em}%
s \in \Sort%
\hspace{3em}%
\WTE{\Gamma::(x:T)}{U}{\Prop}%
}{%
\WTEG{∀ x:T,~U}{\Prop}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-prod-set">Prod-Set<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTEG{T}{s}%
\hspace{3em}%
s \in \{\SProp, \Prop, \Set\}%
\hspace{3em}%
\WTE{\Gamma::(x:T)}{U}{\Set}%
}{%
\WTEG{∀ x:T,~U}{\Set}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-prod-type">Prod-Type<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTEG{T}{s}%
\hspace{3em}%
s \in \{\SProp, \Type{i}\}%
\hspace{3em}%
\WTE{\Gamma::(x:T)}{U}{\Type(i)}%
}{%
\WTEG{∀ x:T,~U}{\Type(i)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-lam">Lam<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTEG{∀ x:T,~U}{s}%
\hspace{3em}%
\WTE{\Gamma::(x:T)}{t}{U}%
}{%
\WTEG{λ x:T\mto t}{∀ x:T,~U}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-app">App<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTEG{t}{∀ x:U,~T}%
\hspace{3em}%
\WTEG{u}{U}%
}{%
\WTEG{(t\ u)}{\subst{T}{x}{u}}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-let">Let<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WTEG{t}{T}%
\hspace{3em}%
\WTE{\Gamma::(x:=t:T)}{u}{U}%
}{%
\WTEG{\letin{x}{t:T}{u}}{\subst{U}{x}{t}}%
}\]</div>
</td></dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>Prod-Prop</strong> and <strong>Prod-Set</strong> typing-rules make sense if we consider the
semantic difference between <span class="math notranslate nohighlight">\(\Prop\)</span> and <span class="math notranslate nohighlight">\(\Set\)</span>:</p>
<ul class="last simple">
<li>All values of a type that has a sort <span class="math notranslate nohighlight">\(\Set\)</span> are extractable.</li>
<li>No values of a type that has a sort <span class="math notranslate nohighlight">\(\Prop\)</span> are extractable.</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We may have <span class="math notranslate nohighlight">\(\letin{x}{t:T}{u}\)</span> well-typed without having
<span class="math notranslate nohighlight">\(((λ x:T.~u)~t)\)</span> well-typed (where <span class="math notranslate nohighlight">\(T\)</span> is a type of
<span class="math notranslate nohighlight">\(t\)</span>). This is because the value <span class="math notranslate nohighlight">\(t\)</span> associated to
<span class="math notranslate nohighlight">\(x\)</span> may be used in a conversion rule
(see Section <a class="reference internal" href="#conversion-rules"><span class="std std-ref">Conversion rules</span></a>).</p>
</div>
</div>
<div class="section" id="conversion-rules">
<span id="id11"></span><h2>Conversion rules<a class="headerlink" href="#conversion-rules" title="Permalink to this headline">¶</a></h2>
<p>In CIC, there is an internal reduction mechanism. In particular, it
can decide if two programs are <em>intentionally</em> equal (one says
<em>convertible</em>). Convertibility is described in this section.</p>
<div class="section" id="reduction">
<span id="beta-reduction"></span><h3>β-reduction<a class="headerlink" href="#reduction" title="Permalink to this headline">¶</a></h3>
<p>We want to be able to identify some terms as we can identify the
application of a function to a given argument with its result. For
instance the identity function over a given type <span class="math notranslate nohighlight">\(T\)</span> can be written
<span class="math notranslate nohighlight">\(λx:T.~x\)</span>. In any global environment <span class="math notranslate nohighlight">\(E\)</span> and local context
<span class="math notranslate nohighlight">\(Γ\)</span>, we want to identify any object <span class="math notranslate nohighlight">\(a\)</span> (of type
<span class="math notranslate nohighlight">\(T\)</span>) with the application <span class="math notranslate nohighlight">\(((λ x:T.~x)~a)\)</span>.  We define for
this a <em>reduction</em> (or a <em>conversion</em>) rule we call <span class="math notranslate nohighlight">\(β\)</span>:</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ ((λx:T.~t)~u)~\triangleright_β~\subst{t}{x}{u}\]</div>
<p>We say that <span class="math notranslate nohighlight">\(\subst{t}{x}{u}\)</span> is the <em>β-contraction</em> of
<span class="math notranslate nohighlight">\(((λx:T.~t)~u)\)</span> and, conversely, that <span class="math notranslate nohighlight">\(((λ x:T.~t)~u)\)</span> is the
<em>β-expansion</em> of <span class="math notranslate nohighlight">\(\subst{t}{x}{u}\)</span>.</p>
<p>According to β-reduction, terms of the <em>Calculus of Inductive
Constructions</em> enjoy some fundamental properties such as confluence,
strong normalization, subject reduction. These results are
theoretically of great importance but we will not detail them here and
refer the interested reader to <a class="reference internal" href="../zebibliography.html#coq85" id="id12">[Coq85]</a>.</p>
</div>
<div class="section" id="iota-reduction">
<span id="id13"></span><h3>ι-reduction<a class="headerlink" href="#iota-reduction" title="Permalink to this headline">¶</a></h3>
<p>A specific conversion rule is associated to the inductive objects in
the global environment. We shall give later on (see Section
<a class="reference internal" href="#well-formed-inductive-definitions"><span class="std std-ref">Well-formed inductive definitions</span></a>) the precise rules but it
just says that a destructor applied to an object built from a
constructor behaves as expected. This reduction is called ι-reduction
and is more precisely studied in <a class="reference internal" href="../zebibliography.html#moh93" id="id14">[PM93a]</a><a class="reference internal" href="../zebibliography.html#wer94" id="id15">[Wer94]</a>.</p>
</div>
<div class="section" id="delta-reduction">
<span id="id16"></span><h3>δ-reduction<a class="headerlink" href="#delta-reduction" title="Permalink to this headline">¶</a></h3>
<p>We may have variables defined in local contexts or constants defined
in the global environment. It is legal to identify such a reference
with its value, that is to expand (or unfold) it into its value. This
reduction is called δ-reduction and shows as follows.</p>
<dl class="docutils">
<dt id="inference-delta-local">Delta-Local<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{\Gamma}%
\hspace{3em}%
(x:=t:T) ∈ Γ%
}{%
E[Γ] ⊢ x~\triangleright_Δ~t%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-delta-global">Delta-Global<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{\Gamma}%
\hspace{3em}%
(c:=t:T) ∈ E%
}{%
E[Γ] ⊢ c~\triangleright_δ~t%
}\]</div>
</td></dl>
</div>
<div class="section" id="zeta-reduction">
<span id="id17"></span><h3>ζ-reduction<a class="headerlink" href="#zeta-reduction" title="Permalink to this headline">¶</a></h3>
<p><span class="smallcaps">Coq</span> allows also to remove local definitions occurring in terms by
replacing the defined variable by its value. The declaration being
destroyed, this reduction differs from δ-reduction. It is called
ζ-reduction and shows as follows.</p>
<dl class="docutils">
<dt id="inference-zeta">Zeta<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{\Gamma}%
\hspace{3em}%
\WTEG{u}{U}%
\hspace{3em}%
\WTE{\Gamma::(x:=u:U)}{t}{T}%
}{%
E[Γ] ⊢ \letin{x}{u:U}{t}~\triangleright_ζ~\subst{t}{x}{u}%
}\]</div>
</td></dl>
</div>
<div class="section" id="expansion">
<span id="eta-expansion"></span><h3>η-expansion<a class="headerlink" href="#expansion" title="Permalink to this headline">¶</a></h3>
<p>Another important concept is η-expansion. It is legal to identify any
term <span class="math notranslate nohighlight">\(t\)</span> of functional type <span class="math notranslate nohighlight">\(∀ x:T,~U\)</span> with its so-called η-expansion</p>
<div class="math notranslate nohighlight">
\[λx:T.~(t~x)\]</div>
<p>for <span class="math notranslate nohighlight">\(x\)</span> an arbitrary variable name fresh in <span class="math notranslate nohighlight">\(t\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>We deliberately do not define η-reduction:</p>
<div class="math notranslate nohighlight">
\[λ x:T.~(t~x)~\not\triangleright_η~t\]</div>
<p>This is because, in general, the type of <span class="math notranslate nohighlight">\(t\)</span> need not to be convertible
to the type of <span class="math notranslate nohighlight">\(λ x:T.~(t~x)\)</span>. E.g., if we take <span class="math notranslate nohighlight">\(f\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[f ~:~ ∀ x:\Type(2),~\Type(1)\]</div>
<p>then</p>
<div class="math notranslate nohighlight">
\[λ x:\Type(1).~(f~x) ~:~ ∀ x:\Type(1),~\Type(1)\]</div>
<p>We could not allow</p>
<div class="math notranslate nohighlight">
\[λ x:\Type(1).~(f~x) ~\triangleright_η~ f\]</div>
<p class="last">because the type of the reduced term <span class="math notranslate nohighlight">\(∀ x:\Type(2),~\Type(1)\)</span> would not be
convertible to the type of the original term <span class="math notranslate nohighlight">\(∀ x:\Type(1),~\Type(1)\)</span>.</p>
</div>
</div>
<div class="section" id="proof-irrelevance">
<span id="id18"></span><h3>Proof Irrelevance<a class="headerlink" href="#proof-irrelevance" title="Permalink to this headline">¶</a></h3>
<p>It is legal to identify any two terms whose common type is a strict
proposition <span class="math notranslate nohighlight">\(A : \SProp\)</span>. Terms in a strict propositions are
therefore called <em>irrelevant</em>.</p>
</div>
<div class="section" id="convertibility">
<span id="id19"></span><h3>Convertibility<a class="headerlink" href="#convertibility" title="Permalink to this headline">¶</a></h3>
<p>Let us write <span class="math notranslate nohighlight">\(E[Γ] ⊢ t \triangleright u\)</span> for the contextual closure of the
relation <span class="math notranslate nohighlight">\(t\)</span> reduces to <span class="math notranslate nohighlight">\(u\)</span> in the global environment
<span class="math notranslate nohighlight">\(E\)</span> and local context <span class="math notranslate nohighlight">\(Γ\)</span> with one of the previous
reductions β, δ, ι or ζ.</p>
<p>We say that two terms <span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span> are
<em>βδιζη-convertible</em>, or simply <em>convertible</em>, or <em>equivalent</em>, in the
global environment <span class="math notranslate nohighlight">\(E\)</span> and local context <span class="math notranslate nohighlight">\(Γ\)</span> iff there
exist terms <span class="math notranslate nohighlight">\(u_1\)</span> and <span class="math notranslate nohighlight">\(u_2\)</span> such that <span class="math notranslate nohighlight">\(E[Γ] ⊢ t_1 \triangleright
… \triangleright u_1\)</span> and <span class="math notranslate nohighlight">\(E[Γ] ⊢ t_2 \triangleright … \triangleright u_2\)</span> and either <span class="math notranslate nohighlight">\(u_1\)</span> and
<span class="math notranslate nohighlight">\(u_2\)</span> are identical up to irrelevant subterms, or they are convertible up to η-expansion,
i.e. <span class="math notranslate nohighlight">\(u_1\)</span> is <span class="math notranslate nohighlight">\(λ x:T.~u_1'\)</span> and <span class="math notranslate nohighlight">\(u_2 x\)</span> is
recursively convertible to <span class="math notranslate nohighlight">\(u_1'\)</span>, or, symmetrically,
<span class="math notranslate nohighlight">\(u_2\)</span> is <span class="math notranslate nohighlight">\(λx:T.~u_2'\)</span>
and <span class="math notranslate nohighlight">\(u_1 x\)</span> is recursively convertible to <span class="math notranslate nohighlight">\(u_2'\)</span>. We then write
<span class="math notranslate nohighlight">\(E[Γ] ⊢ t_1 =_{βδιζη} t_2\)</span>.</p>
<p>Apart from this we consider two instances of polymorphic and
cumulative (see Chapter <a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>) inductive types
(see below) convertible</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ t~w_1 … w_m =_{βδιζη} t~w_1' … w_m'\]</div>
<p>if we have subtypings (see below) in both directions, i.e.,</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ t~w_1 … w_m ≤_{βδιζη} t~w_1' … w_m'\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ t~w_1' … w_m' ≤_{βδιζη} t~w_1 … w_m.\]</div>
<p>Furthermore, we consider</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ c~v_1 … v_m =_{βδιζη} c'~v_1' … v_m'\]</div>
<p>convertible if</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ v_i =_{βδιζη} v_i'\]</div>
<p>and we have that <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(c'\)</span>
are the same constructors of different instances of the same inductive
types (differing only in universe levels) such that</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ c~v_1 … v_m : t~w_1 … w_m\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ c'~v_1' … v_m' : t'~ w_1' … w_m '\]</div>
<p>and we have</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ t~w_1 … w_m =_{βδιζη} t~w_1' … w_m'.\]</div>
<p>The convertibility relation allows introducing a new typing rule which
says that two convertible well-formed types have the same inhabitants.</p>
</div>
</div>
<div class="section" id="subtyping-rules">
<span id="id20"></span><h2>Subtyping rules<a class="headerlink" href="#subtyping-rules" title="Permalink to this headline">¶</a></h2>
<p>At the moment, we did not take into account one rule between universes
which says that any term in a universe of index <span class="math notranslate nohighlight">\(i\)</span> is also a term in
the universe of index <span class="math notranslate nohighlight">\(i+1\)</span> (this is the <em>cumulativity</em> rule of CIC).
This property extends the equivalence relation of convertibility into
a <em>subtyping</em> relation inductively defined by:</p>
<ol class="arabic">
<li><p class="first">if <span class="math notranslate nohighlight">\(E[Γ] ⊢ t =_{βδιζη} u\)</span> then <span class="math notranslate nohighlight">\(E[Γ] ⊢ t ≤_{βδιζη} u\)</span>,</p>
</li>
<li><p class="first">if <span class="math notranslate nohighlight">\(i ≤ j\)</span> then <span class="math notranslate nohighlight">\(E[Γ] ⊢ \Type(i) ≤_{βδιζη} \Type(j)\)</span>,</p>
</li>
<li><p class="first">for any <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(E[Γ] ⊢ \Set ≤_{βδιζη} \Type(i)\)</span>,</p>
</li>
<li><p class="first"><span class="math notranslate nohighlight">\(E[Γ] ⊢ \Prop ≤_{βδιζη} \Set\)</span>, hence, by transitivity,
<span class="math notranslate nohighlight">\(E[Γ] ⊢ \Prop ≤_{βδιζη} \Type(i)\)</span>, for any <span class="math notranslate nohighlight">\(i\)</span>
(note: <span class="math notranslate nohighlight">\(\SProp\)</span> is not related by cumulativity to any other term)</p>
</li>
<li><p class="first">if <span class="math notranslate nohighlight">\(E[Γ] ⊢ T =_{βδιζη} U\)</span> and
<span class="math notranslate nohighlight">\(E[Γ::(x:T)] ⊢ T' ≤_{βδιζη} U'\)</span> then
<span class="math notranslate nohighlight">\(E[Γ] ⊢ ∀x:T,~T′ ≤_{βδιζη} ∀ x:U,~U′\)</span>.</p>
</li>
<li><p class="first">if <span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span> is a universe polymorphic and cumulative
(see Chapter <a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>) inductive type (see below)
and
<span class="math notranslate nohighlight">\((t : ∀Γ_P ,∀Γ_{\mathit{Arr}(t)}, S)∈Γ_I\)</span>
and
<span class="math notranslate nohighlight">\((t' : ∀Γ_P' ,∀Γ_{\mathit{Arr}(t)}', S')∈Γ_I\)</span>
are two different instances of <em>the same</em> inductive type (differing only in
universe levels) with constructors</p>
<div class="math notranslate nohighlight">
\[[c_1 : ∀Γ_P ,∀ T_{1,1} … T_{1,n_1} ,~t~v_{1,1} … v_{1,m} ;~…;~
 c_k : ∀Γ_P ,∀ T_{k,1} … T_{k,n_k} ,~t~v_{k,1} … v_{k,m} ]\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[[c_1 : ∀Γ_P' ,∀ T_{1,1}' … T_{1,n_1}' ,~t'~v_{1,1}' … v_{1,m}' ;~…;~
 c_k : ∀Γ_P' ,∀ T_{k,1}' … T_{k,n_k}' ,~t'~v_{k,1}' … v_{k,m}' ]\]</div>
<p>respectively then</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ t~w_1 … w_m ≤_{βδιζη} t'~w_1' … w_m'\]</div>
<p>(notice that <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(t'\)</span> are both
fully applied, i.e., they have a sort as a type) if</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ w_i =_{βδιζη} w_i'\]</div>
<p>for <span class="math notranslate nohighlight">\(1 ≤ i ≤ m\)</span> and we have</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ T_{i,j} ≤_{βδιζη} T_{i,j}'\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[E[Γ] ⊢ A_i ≤_{βδιζη} A_i'\]</div>
<p>where <span class="math notranslate nohighlight">\(Γ_{\mathit{Arr}(t)} = [a_1 : A_1 ;~ … ;~a_l : A_l ]\)</span> and
<span class="math notranslate nohighlight">\(Γ_{\mathit{Arr}(t)}' = [a_1 : A_1';~ … ;~a_l : A_l']\)</span>.</p>
</li>
</ol>
<p>The conversion rule up to subtyping is now exactly:</p>
<dl class="docutils">
<dt id="inference-conv">Conv<td><div class="first last math notranslate nohighlight">
\[\frac{%
E[Γ] ⊢ U : s%
\hspace{3em}%
E[Γ] ⊢ t : T%
\hspace{3em}%
E[Γ] ⊢ T ≤_{βδιζη} U%
}{%
E[Γ] ⊢ t : U%
}\]</div>
</td></dl>
<p id="normal-form"><strong>Normal form</strong>. A term which cannot be any more reduced is said to be in <em>normal
form</em>. There are several ways (or strategies) to apply the reduction
rules. Among them, we have to mention the <em>head reduction</em> which will
play an important role (see Chapter <a class="reference internal" href="../proof-engine/tactics.html#tactics"><span class="std std-ref">Tactics</span></a>). Any term <span class="math notranslate nohighlight">\(t\)</span> can be written as
<span class="math notranslate nohighlight">\(λ x_1 :T_1 .~… λ x_k :T_k .~(t_0~t_1 … t_n )\)</span> where <span class="math notranslate nohighlight">\(t_0\)</span> is not an
application. We say then that <span class="math notranslate nohighlight">\(t_0\)</span> is the <em>head of</em> <span class="math notranslate nohighlight">\(t\)</span>. If we assume
that <span class="math notranslate nohighlight">\(t_0\)</span> is <span class="math notranslate nohighlight">\(λ x:T.~u_0\)</span> then one step of β-head reduction of <span class="math notranslate nohighlight">\(t\)</span> is:</p>
<div class="math notranslate nohighlight">
\[λ x_1 :T_1 .~… λ x_k :T_k .~(λ x:T.~u_0~t_1 … t_n ) ~\triangleright~
λ (x_1 :T_1 )…(x_k :T_k ).~(\subst{u_0}{x}{t_1}~t_2 … t_n )\]</div>
<p>Iterating the process of head reduction until the head of the reduced
term is no more an abstraction leads to the <em>β-head normal form</em> of <span class="math notranslate nohighlight">\(t\)</span>:</p>
<div class="math notranslate nohighlight">
\[t \triangleright … \triangleright λ x_1 :T_1 .~…λ x_k :T_k .~(v~u_1 … u_m )\]</div>
<p>where <span class="math notranslate nohighlight">\(v\)</span> is not an abstraction (nor an application). Note that the head
normal form must not be confused with the normal form since some <span class="math notranslate nohighlight">\(u_i\)</span>
can be reducible. Similar notions of head-normal forms involving δ, ι
and ζ reductions or any combination of those can also be defined.</p>
</div>
<div class="section" id="inductive-definitions">
<span id="id21"></span><h2>Inductive Definitions<a class="headerlink" href="#inductive-definitions" title="Permalink to this headline">¶</a></h2>
<p>Formally, we can represent any <em>inductive definition</em> as
<span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span> where:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(Γ_I\)</span> determines the names and types of inductive types;</li>
<li><span class="math notranslate nohighlight">\(Γ_C\)</span> determines the names and types of constructors of these
inductive types;</li>
<li><span class="math notranslate nohighlight">\(p\)</span> determines the number of parameters of these inductive types.</li>
</ul>
<p>These inductive definitions, together with global assumptions and
global definitions, then form the global environment. Additionally,
for any <span class="math notranslate nohighlight">\(p\)</span> there always exists <span class="math notranslate nohighlight">\(Γ_P =[a_1 :A_1 ;~…;~a_p :A_p ]\)</span> such that
each <span class="math notranslate nohighlight">\(T\)</span> in <span class="math notranslate nohighlight">\((t:T)∈Γ_I \cup Γ_C\)</span> can be written as: <span class="math notranslate nohighlight">\(∀Γ_P , T'\)</span> where <span class="math notranslate nohighlight">\(Γ_P\)</span> is
called the <em>context of parameters</em>. Furthermore, we must have that
each <span class="math notranslate nohighlight">\(T\)</span> in <span class="math notranslate nohighlight">\((t:T)∈Γ_I\)</span> can be written as: <span class="math notranslate nohighlight">\(∀Γ_P,∀Γ_{\mathit{Arr}(t)}, S\)</span> where
<span class="math notranslate nohighlight">\(Γ_{\mathit{Arr}(t)}\)</span> is called the <em>Arity</em> of the inductive type <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(S\)</span> is called
the sort of the inductive type <span class="math notranslate nohighlight">\(t\)</span> (not to be confused with <span class="math notranslate nohighlight">\(\Sort\)</span> which is the set of sorts).</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The declaration for parameterized lists is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\ind{1}{[\List:\Set→\Set]}{\left[\begin{array}{rcl}
\Nil &amp; : &amp; ∀ A:\Set,~\List~A \\
\cons &amp; : &amp; ∀ A:\Set,~A→ \List~A→ \List~A
\end{array}
\right]}\end{split}\]</div>
<p>which corresponds to the result of the <span class="smallcaps">Coq</span> declaration:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">list is defined
list_rect is defined
list_ind is defined
list_rec is defined
list_sind is defined</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The declaration for a mutual inductive definition of tree and forest
is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\ind{0}{\left[\begin{array}{rcl}\tree&amp;:&amp;\Set\\\forest&amp;:&amp;\Set\end{array}\right]}
 {\left[\begin{array}{rcl}
          \node &amp;:&amp; \forest → \tree\\
          \emptyf &amp;:&amp; \forest\\
          \consf &amp;:&amp; \tree → \forest → \forest\\
                    \end{array}\right]}\end{split}\]</div>
<p>which corresponds to the result of the <span class="smallcaps">Coq</span> declaration:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">emptyf</span><span> : </span><span class="coqdoc-var">forest</span><span>
| </span><span class="coqdoc-var">consf</span><span> : </span><span class="coqdoc-var">tree</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">tree, forest are defined
tree_rect is defined
tree_ind is defined
tree_rec is defined
tree_sind is defined
forest_rect is defined
forest_ind is defined
forest_rec is defined
forest_sind is defined</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The declaration for a mutual inductive definition of even and odd is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\ind{0}{\left[\begin{array}{rcl}\even&amp;:&amp;\nat → \Prop \\
                                \odd&amp;:&amp;\nat → \Prop \end{array}\right]}
 {\left[\begin{array}{rcl}
          \evenO &amp;:&amp; \even~0\\
          \evenS &amp;:&amp; ∀ n,~\odd~n → \even~(\nS~n)\\
          \oddS &amp;:&amp; ∀ n,~\even~n → \odd~(\nS~n)
                    \end{array}\right]}\end{split}\]</div>
<p>which corresponds to the result of the <span class="smallcaps">Coq</span> declaration:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">even</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">even_O</span><span> : </span><span class="coqdoc-var">even</span><span> 0</span><span>
| </span><span class="coqdoc-var">even_S</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">odd</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">even</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">odd</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">odd_S</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">odd</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first last">even, odd are defined
even_ind is defined
even_sind is defined
odd_ind is defined
odd_sind is defined</span></dd>
</dl>
</div>
</div>
<div class="section" id="types-of-inductive-objects">
<span id="id22"></span><h3>Types of inductive objects<a class="headerlink" href="#types-of-inductive-objects" title="Permalink to this headline">¶</a></h3>
<p>We have to give the type of constants in a global environment <span class="math notranslate nohighlight">\(E\)</span> which
contains an inductive definition.</p>
<dl class="docutils">
<dt id="inference-ind">Ind<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{Γ}%
\hspace{3em}%
\ind{p}{Γ_I}{Γ_C} ∈ E%
\hspace{3em}%
(a:A)∈Γ_I%
}{%
E[Γ] ⊢ a : A%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-constr">Constr<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{Γ}%
\hspace{3em}%
\ind{p}{Γ_I}{Γ_C} ∈ E%
\hspace{3em}%
(c:C)∈Γ_C%
}{%
E[Γ] ⊢ c : C%
}\]</div>
</td></dl>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>Provided that our environment <span class="math notranslate nohighlight">\(E\)</span> contains inductive definitions we showed before,
these two inference rules above enable us to conclude that:</p>
<div class="last math notranslate nohighlight">
\[\begin{split}\begin{array}{l}
E[Γ] ⊢ \even : \nat→\Prop\\
E[Γ] ⊢ \odd : \nat→\Prop\\
E[Γ] ⊢ \evenO : \even~\nO\\
E[Γ] ⊢ \evenS : ∀ n:\nat,~\odd~n → \even~(\nS~n)\\
E[Γ] ⊢ \oddS : ∀ n:\nat,~\even~n → \odd~(\nS~n)
\end{array}\end{split}\]</div>
</div>
</div>
<div class="section" id="well-formed-inductive-definitions">
<span id="id23"></span><h3>Well-formed inductive definitions<a class="headerlink" href="#well-formed-inductive-definitions" title="Permalink to this headline">¶</a></h3>
<p>We cannot accept any inductive definition because some of them lead
to inconsistent systems. We restrict ourselves to definitions which
satisfy a syntactic criterion of positivity. Before giving the formal
rules, we need a few definitions:</p>
<div class="section" id="arity-of-a-given-sort">
<h4>Arity of a given sort<a class="headerlink" href="#arity-of-a-given-sort" title="Permalink to this headline">¶</a></h4>
<p>A type <span class="math notranslate nohighlight">\(T\)</span> is an <em>arity of sort</em> <span class="math notranslate nohighlight">\(s\)</span> if it converts to the sort <span class="math notranslate nohighlight">\(s\)</span> or to a
product <span class="math notranslate nohighlight">\(∀ x:T,~U\)</span> with <span class="math notranslate nohighlight">\(U\)</span> an arity of sort <span class="math notranslate nohighlight">\(s\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p class="last"><span class="math notranslate nohighlight">\(A→\Set\)</span> is an arity of sort <span class="math notranslate nohighlight">\(\Set\)</span>. <span class="math notranslate nohighlight">\(∀ A:\Prop,~A→ \Prop\)</span> is an arity of sort
<span class="math notranslate nohighlight">\(\Prop\)</span>.</p>
</div>
</div>
<div class="section" id="arity">
<h4>Arity<a class="headerlink" href="#arity" title="Permalink to this headline">¶</a></h4>
<p>A type <span class="math notranslate nohighlight">\(T\)</span> is an <em>arity</em> if there is a <span class="math notranslate nohighlight">\(s∈ \Sort\)</span> such that <span class="math notranslate nohighlight">\(T\)</span> is an arity of
sort <span class="math notranslate nohighlight">\(s\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p class="last"><span class="math notranslate nohighlight">\(A→ \Set\)</span> and <span class="math notranslate nohighlight">\(∀ A:\Prop,~A→ \Prop\)</span> are arities.</p>
</div>
</div>
<div class="section" id="type-of-constructor">
<h4>Type of constructor<a class="headerlink" href="#type-of-constructor" title="Permalink to this headline">¶</a></h4>
<p>We say that <span class="math notranslate nohighlight">\(T\)</span> is a <em>type of constructor of</em> <span class="math notranslate nohighlight">\(I\)</span> in one of the following
two cases:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(T\)</span> is <span class="math notranslate nohighlight">\((I~t_1 … t_n )\)</span></li>
<li><span class="math notranslate nohighlight">\(T\)</span> is <span class="math notranslate nohighlight">\(∀ x:U,~T'\)</span> where <span class="math notranslate nohighlight">\(T'\)</span> is also a type of constructor of <span class="math notranslate nohighlight">\(I\)</span></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p class="last"><span class="math notranslate nohighlight">\(\nat\)</span> and <span class="math notranslate nohighlight">\(\nat→\nat\)</span> are types of constructor of <span class="math notranslate nohighlight">\(\nat\)</span>.
<span class="math notranslate nohighlight">\(∀ A:\Type,~\List~A\)</span> and <span class="math notranslate nohighlight">\(∀ A:\Type,~A→\List~A→\List~A\)</span> are types of constructor of <span class="math notranslate nohighlight">\(\List\)</span>.</p>
</div>
</div>
<div class="section" id="positivity-condition">
<span id="positivity"></span><h4>Positivity Condition<a class="headerlink" href="#positivity-condition" title="Permalink to this headline">¶</a></h4>
<p>The type of constructor <span class="math notranslate nohighlight">\(T\)</span> will be said to <em>satisfy the positivity
condition</em> for a constant <span class="math notranslate nohighlight">\(X\)</span> in the following cases:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(T=(X~t_1 … t_n )\)</span> and <span class="math notranslate nohighlight">\(X\)</span> does not occur free in any <span class="math notranslate nohighlight">\(t_i\)</span></li>
<li><span class="math notranslate nohighlight">\(T=∀ x:U,~V\)</span> and <span class="math notranslate nohighlight">\(X\)</span> occurs only strictly positively in <span class="math notranslate nohighlight">\(U\)</span> and the type <span class="math notranslate nohighlight">\(V\)</span>
satisfies the positivity condition for <span class="math notranslate nohighlight">\(X\)</span>.</li>
</ul>
</div>
<div class="section" id="strict-positivity">
<h4>Strict positivity<a class="headerlink" href="#strict-positivity" title="Permalink to this headline">¶</a></h4>
<p>The constant <span class="math notranslate nohighlight">\(X\)</span> <em>occurs strictly positively</em> in <span class="math notranslate nohighlight">\(T\)</span> in the following
cases:</p>
<ul>
<li><p class="first"><span class="math notranslate nohighlight">\(X\)</span> does not occur in <span class="math notranslate nohighlight">\(T\)</span></p>
</li>
<li><p class="first"><span class="math notranslate nohighlight">\(T\)</span> converts to <span class="math notranslate nohighlight">\((X~t_1 … t_n )\)</span> and <span class="math notranslate nohighlight">\(X\)</span> does not occur in any of <span class="math notranslate nohighlight">\(t_i\)</span></p>
</li>
<li><p class="first"><span class="math notranslate nohighlight">\(T\)</span> converts to <span class="math notranslate nohighlight">\(∀ x:U,~V\)</span> and <span class="math notranslate nohighlight">\(X\)</span> does not occur in type <span class="math notranslate nohighlight">\(U\)</span> but occurs
strictly positively in type <span class="math notranslate nohighlight">\(V\)</span></p>
</li>
<li><p class="first"><span class="math notranslate nohighlight">\(T\)</span> converts to <span class="math notranslate nohighlight">\((I~a_1 … a_m~t_1 … t_p )\)</span> where <span class="math notranslate nohighlight">\(I\)</span> is the name of an
inductive definition of the form</p>
<div class="math notranslate nohighlight">
\[\ind{m}{I:A}{c_1 :∀ p_1 :P_1 ,… ∀p_m :P_m ,~C_1 ;~…;~c_n :∀ p_1 :P_1 ,… ∀p_m :P_m ,~C_n}\]</div>
<p>(in particular, it is
not mutually defined and it has <span class="math notranslate nohighlight">\(m\)</span> parameters) and <span class="math notranslate nohighlight">\(X\)</span> does not occur in
any of the <span class="math notranslate nohighlight">\(t_i\)</span>, and the (instantiated) types of constructor
<span class="math notranslate nohighlight">\(\subst{C_i}{p_j}{a_j}_{j=1… m}\)</span> of <span class="math notranslate nohighlight">\(I\)</span> satisfy the nested positivity condition for <span class="math notranslate nohighlight">\(X\)</span></p>
</li>
</ul>
</div>
<div class="section" id="nested-positivity">
<h4>Nested Positivity<a class="headerlink" href="#nested-positivity" title="Permalink to this headline">¶</a></h4>
<p>The type of constructor <span class="math notranslate nohighlight">\(T\)</span> of <span class="math notranslate nohighlight">\(I\)</span> <em>satisfies the nested positivity
condition</em> for a constant <span class="math notranslate nohighlight">\(X\)</span> in the following cases:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(T=(I~b_1 … b_m~u_1 … u_p)\)</span>, <span class="math notranslate nohighlight">\(I\)</span> is an inductive type with <span class="math notranslate nohighlight">\(m\)</span>
parameters and <span class="math notranslate nohighlight">\(X\)</span> does not occur in any <span class="math notranslate nohighlight">\(u_i\)</span></li>
<li><span class="math notranslate nohighlight">\(T=∀ x:U,~V\)</span> and <span class="math notranslate nohighlight">\(X\)</span> occurs only strictly positively in <span class="math notranslate nohighlight">\(U\)</span> and the type <span class="math notranslate nohighlight">\(V\)</span>
satisfies the nested positivity condition for <span class="math notranslate nohighlight">\(X\)</span></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>For instance, if one considers the following variant of a tree type
branching over the natural numbers:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nattree</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">nattree</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">natnode</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; (</span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nattree</span><span> </span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">nattree</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">nattree is defined
nattree_rect is defined
nattree_ind is defined
nattree_rec is defined
nattree_sind is defined</span></dd>
</dl>
</div>
<p>Then every instantiated constructor of <code class="docutils literal notranslate"><span class="pre">nattree</span> <span class="pre">A</span></code> satisfies the nested positivity
condition for <code class="docutils literal notranslate"><span class="pre">nattree</span></code>:</p>
<ul class="last simple">
<li>Type <code class="docutils literal notranslate"><span class="pre">nattree</span> <span class="pre">A</span></code> of constructor <code class="docutils literal notranslate"><span class="pre">leaf</span></code> satisfies the positivity condition for
<code class="docutils literal notranslate"><span class="pre">nattree</span></code> because <code class="docutils literal notranslate"><span class="pre">nattree</span></code> does not appear in any (real) arguments of the
type of that constructor (primarily because <code class="docutils literal notranslate"><span class="pre">nattree</span></code> does not have any (real)
arguments) ... (bullet 1)</li>
<li>Type <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">→</span> <span class="pre">(nat</span> <span class="pre">→</span> <span class="pre">nattree</span> <span class="pre">A)</span> <span class="pre">→</span> <span class="pre">nattree</span> <span class="pre">A</span></code> of constructor <code class="docutils literal notranslate"><span class="pre">natnode</span></code> satisfies the
positivity condition for <code class="docutils literal notranslate"><span class="pre">nattree</span></code> because:<ul>
<li><code class="docutils literal notranslate"><span class="pre">nattree</span></code> occurs only strictly positively in <code class="docutils literal notranslate"><span class="pre">A</span></code> ... (bullet 1)</li>
<li><code class="docutils literal notranslate"><span class="pre">nattree</span></code> occurs only strictly positively in <code class="docutils literal notranslate"><span class="pre">nat</span> <span class="pre">→</span> <span class="pre">nattree</span> <span class="pre">A</span></code> ... (bullet 3 + 2)</li>
<li><code class="docutils literal notranslate"><span class="pre">nattree</span></code> satisfies the positivity condition for <code class="docutils literal notranslate"><span class="pre">nattree</span> <span class="pre">A</span></code> ... (bullet 1)</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="correctness-rules">
<span id="id24"></span><h4>Correctness rules<a class="headerlink" href="#correctness-rules" title="Permalink to this headline">¶</a></h4>
<p>We shall now describe the rules allowing the introduction of a new
inductive definition.</p>
<p>Let <span class="math notranslate nohighlight">\(E\)</span> be a global environment and <span class="math notranslate nohighlight">\(Γ_P\)</span>, <span class="math notranslate nohighlight">\(Γ_I\)</span>, <span class="math notranslate nohighlight">\(Γ_C\)</span> be contexts
such that <span class="math notranslate nohighlight">\(Γ_I\)</span> is <span class="math notranslate nohighlight">\([I_1 :∀ Γ_P ,A_1 ;~…;~I_k :∀ Γ_P ,A_k]\)</span>, and
<span class="math notranslate nohighlight">\(Γ_C\)</span> is <span class="math notranslate nohighlight">\([c_1:∀ Γ_P ,C_1 ;~…;~c_n :∀ Γ_P ,C_n ]\)</span>. Then</p>
<dl class="docutils">
<dt id="inference-w-ind">W-Ind<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WFE{Γ_P}%
\hspace{3em}%
(E[Γ_I ;Γ_P ] ⊢ C_i : s_{q_i} )_{i=1… n}%
}{%
\WF{E;~\ind{p}{Γ_I}{Γ_C}}{}%
}\]</div>
</td></dl>
<p>provided that the following side conditions hold:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math notranslate nohighlight">\(k&gt;0\)</span> and all of <span class="math notranslate nohighlight">\(I_j\)</span> and <span class="math notranslate nohighlight">\(c_i\)</span> are distinct names for <span class="math notranslate nohighlight">\(j=1… k\)</span> and <span class="math notranslate nohighlight">\(i=1… n\)</span>,</li>
<li><span class="math notranslate nohighlight">\(p\)</span> is the number of parameters of <span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span> and <span class="math notranslate nohighlight">\(Γ_P\)</span> is the
context of parameters,</li>
<li>for <span class="math notranslate nohighlight">\(j=1… k\)</span> we have that <span class="math notranslate nohighlight">\(A_j\)</span> is an arity of sort <span class="math notranslate nohighlight">\(s_j\)</span> and <span class="math notranslate nohighlight">\(I_j ∉ E\)</span>,</li>
<li>for <span class="math notranslate nohighlight">\(i=1… n\)</span> we have that <span class="math notranslate nohighlight">\(C_i\)</span> is a type of constructor of <span class="math notranslate nohighlight">\(I_{q_i}\)</span> which
satisfies the positivity condition for <span class="math notranslate nohighlight">\(I_1 … I_k\)</span> and <span class="math notranslate nohighlight">\(c_i ∉  E\)</span>.</li>
</ul>
</div></blockquote>
<p>One can remark that there is a constraint between the sort of the
arity of the inductive type and the sort of the type of its
constructors which will always be satisfied for the impredicative
sorts <span class="math notranslate nohighlight">\(\SProp\)</span> and <span class="math notranslate nohighlight">\(\Prop\)</span> but may fail to define
inductive type on sort <span class="math notranslate nohighlight">\(\Set\)</span> and generate constraints
between universes for inductive types in the Type hierarchy.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>It is well known that the existential quantifier can be encoded as an
inductive definition. The following declaration introduces the
second-order existential quantifier <span class="math notranslate nohighlight">\(∃ X.P(X)\)</span>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">exProp</span><span> (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">exP_intro</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">exProp</span><span> </span><span class="coqdoc-var">P</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">exProp is defined
exProp_ind is defined
exProp_sind is defined</span></dd>
</dl>
</div>
<p>The same definition on <span class="math notranslate nohighlight">\(\Set\)</span> is not allowed and fails:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">exSet</span><span> (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-keyword">Set</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
</span><span class="coqdoc-var">exS_intro</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Set</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">exSet</span><span> </span><span class="coqdoc-var">P</span><span>.</span></dt>
<dd><span class="first last">The command has indeed failed with message:
Large non-propositional inductive types must be in Type.</span></dd>
</dl>
</div>
<p>It is possible to declare the same inductive definition in the
universe <span class="math notranslate nohighlight">\(\Type\)</span>. The <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">exType</span></span></code> inductive definition has type
<span class="math notranslate nohighlight">\((\Type(i)→\Prop)→\Type(j)\)</span> with the constraint that the parameter <span class="math notranslate nohighlight">\(X\)</span> of <span class="math notranslate nohighlight">\(\kw{exT}_{\kw{intro}}\)</span>
has type <span class="math notranslate nohighlight">\(\Type(k)\)</span> with <span class="math notranslate nohighlight">\(k&lt;j\)</span> and <span class="math notranslate nohighlight">\(k≤ i\)</span>.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">exType</span><span> (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-keyword">Type</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
</span><span class="coqdoc-var">exT_intro</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Type</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">exType</span><span> </span><span class="coqdoc-var">P</span><span>.</span></dt>
<dd><span class="first last">exType is defined
exType_rect is defined
exType_ind is defined
exType_rec is defined
exType_sind is defined</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Example: Negative occurrence (first example)</p>
<p>The following inductive definition is rejected because it does not
satisfy the positivity condition:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">not_I_I</span><span> (</span><span class="coqdoc-var">not_I</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">False</span><span>) : </span><span class="coqdoc-var">I</span><span>.</span></dt>
<dd><span class="first">The command has indeed failed with message:
Non strictly positive occurrence of &quot;I&quot; in &quot;(I</span><span class="ansi-fg-white"> -&gt;</span><span> False)</span><span class="ansi-fg-white"> -&gt;</span><span class="last"> I&quot;.</span></dd>
</dl>
</div>
<p>If we were to accept such definition, we could derive a
contradiction from it (we can test this by disabling the
<a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:flag.positivity-checking" title="Positivity Checking"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Positivity</span> <span class="pre">Checking</span></code></a> flag):</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-var">Positivity</span><span> </span><span class="coqdoc-var">Checking</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">not_I_I</span><span> (</span><span class="coqdoc-var">not_I</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">False</span><span>) : </span><span class="coqdoc-var">I</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">I is defined</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-var">Positivity</span><span> </span><span class="coqdoc-var">Checking</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">I_not_I</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; ~ </span><span class="coqdoc-var">I</span><span> := </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">i</span><span> =&gt;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">not_I_I</span><span> </span><span class="coqdoc-var">not_I</span><span> =&gt; </span><span class="coqdoc-var">not_I</span><span> </span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">I_not_I is defined</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">contradiction</span><span> : </span><span class="coqdoc-var">False</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">1 subgoal
  
  ============================
  False</span></dd>
<dt><span class="coqdoc-keyword">Proof</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-var">enough</span><span> (</span><span class="coqdoc-var">I</span><span> /\ ~ </span><span class="coqdoc-var">I</span><span>) </span><span class="coqdoc-keyword">as</span><span> [] </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-var">contradiction</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  I</span><span class="ansi-fg-white"> /\</span><span> </span><span class="ansi-fg-white">~</span><span class="last"> I</span></dd>
<dt><span class="coqdoc-tactic">split</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">2 subgoals
  
  ============================
  I

subgoal 2 is:
 </span><span class="ansi-fg-white">~</span><span class="last"> I</span></dd>
<dt><span>
- </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">not_I_I</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  I

1 subgoal
  
  ============================
  I</span><span class="ansi-fg-white"> -&gt;</span><span class="last"> False</span></dd>
<dt><span class="coqdoc-tactic">intro</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">1 subgoal
  
  H : I
  ============================
  False</span></dd>
<dt><span class="coqdoc-var">now</span><span> </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">I_not_I</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">This subproof is complete, but there are some unfocused goals.
Focus next goal with bullet -.

1 subgoal

subgoal 1 is:
 </span><span class="ansi-fg-white">~</span><span class="last"> I</span></dd>
<dt><span>
- </span><span class="coqdoc-tactic">intro</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-white">~</span><span class="last"> I

1 subgoal
  
  H : I
  ============================
  False</span></dd>
<dt><span class="coqdoc-var">now</span><span> </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">I_not_I</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Qed</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Example: Negative occurrence (second example)</p>
<p>Here is another example of an inductive definition which is
rejected because it does not satify the positivity condition:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Lam</span><span> := </span><span class="coqdoc-var">lam</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">Lam</span><span> -&gt; </span><span class="coqdoc-var">Lam</span><span>).</span></dt>
<dd><span class="first">The command has indeed failed with message:
Non strictly positive occurrence of &quot;Lam&quot; in &quot;(Lam</span><span class="ansi-fg-white"> -&gt;</span><span> Lam)</span><span class="ansi-fg-white"> -&gt;</span><span class="last"> Lam&quot;.</span></dd>
</dl>
</div>
<p>Again, if we were to accept it, we could derive a contradiction
(this time through a non-terminating recursive function):</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-var">Positivity</span><span> </span><span class="coqdoc-var">Checking</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Lam</span><span> := </span><span class="coqdoc-var">lam</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">Lam</span><span> -&gt; </span><span class="coqdoc-var">Lam</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first last">Lam is defined</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-var">Positivity</span><span> </span><span class="coqdoc-var">Checking</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">infinite_loop</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">False</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">lam</span><span> </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">infinite_loop</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">l</span><span>) </span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">infinite_loop is defined
infinite_loop is recursively defined (decreasing on 1st argument)</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">infinite_loop</span><span> (</span><span class="coqdoc-var">lam</span><span> (&#64;</span><span class="coqdoc-var">id</span><span> </span><span class="coqdoc-var">Lam</span><span>)) : </span><span class="coqdoc-var">False</span><span>.</span></dt>
<dd><span class="first last">infinite_loop (lam (id (A:=Lam))) : False
     : False</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="template-polymorphism">
<span id="id25"></span><h4>Template polymorphism<a class="headerlink" href="#template-polymorphism" title="Permalink to this headline">¶</a></h4>
<p>Inductive types can be made polymorphic over the universes introduced by
their parameters in <span class="math notranslate nohighlight">\(\Type\)</span>, if the minimal inferred sort of the
inductive declarations either mention some of those parameter universes
or is computed to be <span class="math notranslate nohighlight">\(\Prop\)</span> or <span class="math notranslate nohighlight">\(\Set\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(A\)</span> is an arity of some sort and <span class="math notranslate nohighlight">\(s\)</span> is a sort, we write <span class="math notranslate nohighlight">\(A_{/s}\)</span>
for the arity obtained from <span class="math notranslate nohighlight">\(A\)</span> by replacing its sort with <span class="math notranslate nohighlight">\(s\)</span>.
Especially, if <span class="math notranslate nohighlight">\(A\)</span> is well-typed in some global environment and local
context, then <span class="math notranslate nohighlight">\(A_{/s}\)</span> is typable by typability of all products in the
Calculus of Inductive Constructions. The following typing rule is
added to the theory.</p>
<p>Let <span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span> be an inductive definition. Let
<span class="math notranslate nohighlight">\(Γ_P = [p_1 :P_1 ;~…;~p_p :P_p ]\)</span> be its context of parameters,
<span class="math notranslate nohighlight">\(Γ_I = [I_1:∀ Γ_P ,A_1 ;~…;~I_k :∀ Γ_P ,A_k ]\)</span> its context of definitions and
<span class="math notranslate nohighlight">\(Γ_C = [c_1 :∀ Γ_P ,C_1 ;~…;~c_n :∀ Γ_P ,C_n]\)</span> its context of constructors,
with <span class="math notranslate nohighlight">\(c_i\)</span> a constructor of <span class="math notranslate nohighlight">\(I_{q_i}\)</span>. Let <span class="math notranslate nohighlight">\(m ≤ p\)</span> be the length of the
longest prefix of parameters such that the <span class="math notranslate nohighlight">\(m\)</span> first arguments of all
occurrences of all <span class="math notranslate nohighlight">\(I_j\)</span> in all <span class="math notranslate nohighlight">\(C_k\)</span> (even the occurrences in the
hypotheses of <span class="math notranslate nohighlight">\(C_k\)</span>) are exactly applied to <span class="math notranslate nohighlight">\(p_1 … p_m\)</span> (<span class="math notranslate nohighlight">\(m\)</span> is the number
of <em>recursively uniform parameters</em> and the <span class="math notranslate nohighlight">\(p−m\)</span> remaining parameters
are the <em>recursively non-uniform parameters</em>). Let <span class="math notranslate nohighlight">\(q_1 , …, q_r\)</span>, with
<span class="math notranslate nohighlight">\(0≤ r≤ m\)</span>, be a (possibly) partial instantiation of the recursively
uniform parameters of <span class="math notranslate nohighlight">\(Γ_P\)</span>. We have:</p>
<dl class="docutils">
<dt id="inference-ind-family">Ind-Family<td><div class="first last math notranslate nohighlight">
\[\begin{split}\frac{%
\left\{\begin{array}{l}%
\hspace{3em}%
\ind{p}{Γ_I}{Γ_C} \in E\\%
\hspace{3em}%
(E[]  ⊢ q_l : P'_l)_{l=1\ldots r}\\%
\hspace{3em}%
(E[]  ⊢ P'_l ≤_{βδιζη} \subst{P_l}{p_u}{q_u}_{u=1\ldots l-1})_{l=1\ldots r}\\%
\hspace{3em}%
1 \leq j \leq k%
\hspace{3em}%
\end{array}%
\hspace{3em}%
\right.%
}{%
E[] ⊢ I_j~q_1 … q_r :∀ [p_{r+1} :P_{r+1} ;~…;~p_p :P_p], (A_j)_{/s_j}%
}\end{split}\]</div>
</td></dl>
<p>provided that the following side conditions hold:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math notranslate nohighlight">\(Γ_{P′}\)</span> is the context obtained from <span class="math notranslate nohighlight">\(Γ_P\)</span> by replacing each <span class="math notranslate nohighlight">\(P_l\)</span> that is
an arity with <span class="math notranslate nohighlight">\(P_l'\)</span> for <span class="math notranslate nohighlight">\(1≤ l ≤ r\)</span> (notice that <span class="math notranslate nohighlight">\(P_l\)</span> arity implies <span class="math notranslate nohighlight">\(P_l'\)</span>
arity since <span class="math notranslate nohighlight">\(E[] ⊢ P_l' ≤_{βδιζη} \subst{P_l}{p_u}{q_u}_{u=1\ldots l-1}\)</span>);</li>
<li>there are sorts <span class="math notranslate nohighlight">\(s_i\)</span>, for <span class="math notranslate nohighlight">\(1 ≤ i ≤ k\)</span> such that, for
<span class="math notranslate nohighlight">\(Γ_{I'} = [I_1 :∀ Γ_{P'} ,(A_1)_{/s_1} ;~…;~I_k :∀ Γ_{P'} ,(A_k)_{/s_k}]\)</span>
we have <span class="math notranslate nohighlight">\((E[Γ_{I′} ;Γ_{P′}] ⊢ C_i : s_{q_i})_{i=1… n}\)</span> ;</li>
<li>the sorts <span class="math notranslate nohighlight">\(s_i\)</span> are all introduced by the inductive
declaration and have no universe constraints beside being greater
than or equal to <span class="math notranslate nohighlight">\(\Prop\)</span>, and such that all
eliminations, to <span class="math notranslate nohighlight">\(\Prop\)</span>, <span class="math notranslate nohighlight">\(\Set\)</span> and <span class="math notranslate nohighlight">\(\Type(j)\)</span>,
are allowed (see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>).</li>
</ul>
</div></blockquote>
<p>Notice that if <span class="math notranslate nohighlight">\(I_j~q_1 … q_r\)</span> is typable using the rules <strong>Ind-Const</strong> and
<strong>App</strong>, then it is typable using the rule <strong>Ind-Family</strong>. Conversely, the
extended theory is not stronger than the theory without <strong>Ind-Family</strong>. We
get an equiconsistency result by mapping each <span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span>
occurring into a given derivation into as many different inductive
types and constructors as the number of different (partial)
replacements of sorts, needed for this derivation, in the parameters
that are arities (this is possible because <span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span> well-formed
implies that <span class="math notranslate nohighlight">\(\ind{p}{Γ_{I'}}{Γ_{C'}}\)</span> is well-formed and has the
same allowed eliminations, where <span class="math notranslate nohighlight">\(Γ_{I′}\)</span> is defined as above and
<span class="math notranslate nohighlight">\(Γ_{C′} = [c_1 :∀ Γ_{P′} ,C_1 ;~…;~c_n :∀ Γ_{P′} ,C_n ]\)</span>). That is, the changes in the
types of each partial instance <span class="math notranslate nohighlight">\(q_1 … q_r\)</span> can be characterized by the
ordered sets of arity sorts among the types of parameters, and to each
signature is associated a new inductive definition with fresh names.
Conversion is preserved as any (partial) instance <span class="math notranslate nohighlight">\(I_j~q_1 … q_r\)</span> or
<span class="math notranslate nohighlight">\(C_i~q_1 … q_r\)</span> is mapped to the names chosen in the specific instance of
<span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The restriction that sorts are introduced by the inductive
declaration prevents inductive types declared in sections to be
template-polymorphic on universes introduced previously in the
section: they cannot parameterize over the universes introduced with
section variables that become parameters at section closing time, as
these may be shared with other definitions from the same section
which can impose constraints on them.</p>
</div>
<dl class="flag">
<dt id="coq:flag.auto-template-polymorphism">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span><span>Auto</span></span> <span><span>Template</span></span> <span><span>Polymorphism</span></span></span></code><a class="headerlink" href="#coq:flag.auto-template-polymorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>This flag, enabled by default, makes every inductive type declared
at level <span class="math notranslate nohighlight">\(\Type\)</span> (without annotations or hiding it behind a
definition) template polymorphic if possible.</p>
<p>This can be prevented using the <a class="reference internal" href="#coq:attr.universes-notemplate" title="universes(notemplate)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(notemplate)</span></code></a>
attribute.</p>
<p>Template polymorphism and full universe polymorphism (see Chapter
<a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>) are incompatible, so if the latter is
enabled (through the <a class="reference internal" href="../addendum/universe-polymorphism.html#coq:flag.universe-polymorphism" title="Universe Polymorphism"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Universe</span> <span class="pre">Polymorphism</span></code></a> flag or the
<a class="reference internal" href="../addendum/universe-polymorphism.html#coq:attr.universes-polymorphic" title="universes(polymorphic)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(polymorphic)</span></code></a> attribute) it will prevail over
automatic template polymorphism.</p>
</dd></dl>

<dl class="warn">
<dt id="coq:warn.automatically-declaring-ident-as-template-polymorphic">
<em class="property"><span class="sigannot">Warning</span></em> <code class="descname"><span class="notation"><span><span>Automatically</span></span> <span><span>declaring</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>as</span></span> <span><span>template</span></span> <span><span>polymorphic.</span></span></span></code><a class="headerlink" href="#coq:warn.automatically-declaring-ident-as-template-polymorphic" title="Permalink to this definition">¶</a></dt>
<dd><p>Warning <code class="docutils literal notranslate"><span class="pre">auto-template</span></code> can be used (it is off by default) to
find which types are implicitly declared template polymorphic by
<a class="reference internal" href="#coq:flag.auto-template-polymorphism" title="Auto Template Polymorphism"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Auto</span> <span class="pre">Template</span> <span class="pre">Polymorphism</span></code></a>.</p>
<p>An inductive type can be forced to be template polymorphic using
the <a class="reference internal" href="#coq:attr.universes-template" title="universes(template)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(template)</span></code></a> attribute: in this case, the
warning is not emitted.</p>
</dd></dl>

<dl class="attr">
<dt id="coq:attr.universes-template">
<em class="property"><span class="sigannot">Attribute</span></em> <code class="descname"><span class="notation"><span><span>universes(template)</span></span></span></code><a class="headerlink" href="#coq:attr.universes-template" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute can be used to explicitly declare an inductive type
as template polymorphic, whether the <a class="reference internal" href="#coq:flag.auto-template-polymorphism" title="Auto Template Polymorphism"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Auto</span> <span class="pre">Template</span>
<span class="pre">Polymorphism</span></code></a> flag is on or off.</p>
<dl class="exn">
<dt id="coq:exn.template-and-polymorphism-not-compatible">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span><span>template</span></span> <span><span>and</span></span> <span><span>polymorphism</span></span> <span><span>not</span></span> <span><span>compatible</span></span></span></code><a class="headerlink" href="#coq:exn.template-and-polymorphism-not-compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute cannot be used in a full universe polymorphic
context, i.e. if the <a class="reference internal" href="../addendum/universe-polymorphism.html#coq:flag.universe-polymorphism" title="Universe Polymorphism"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Universe</span> <span class="pre">Polymorphism</span></code></a> flag is on or
if the <a class="reference internal" href="../addendum/universe-polymorphism.html#coq:attr.universes-polymorphic" title="universes(polymorphic)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(polymorphic)</span></code></a> attribute is used.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.ill-formed-template-inductive-declaration-not-polymorphic-on-any-universe">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span><span>Ill-formed</span></span> <span><span>template</span></span> <span><span>inductive</span></span> <span><span>declaration:</span></span> <span><span>not</span></span> <span><span>polymorphic</span></span> <span><span>on</span></span> <span><span>any</span></span> <span><span>universe.</span></span></span></code><a class="headerlink" href="#coq:exn.ill-formed-template-inductive-declaration-not-polymorphic-on-any-universe" title="Permalink to this definition">¶</a></dt>
<dd><p>The attribute was used but the inductive definition does not
satisfy the criterion to be template polymorphic.</p>
</dd></dl>

</dd></dl>

<dl class="attr">
<dt id="coq:attr.universes-notemplate">
<em class="property"><span class="sigannot">Attribute</span></em> <code class="descname"><span class="notation"><span><span>universes(notemplate)</span></span></span></code><a class="headerlink" href="#coq:attr.universes-notemplate" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute can be used to prevent an inductive type to be
template polymorphic, even if the <a class="reference internal" href="#coq:flag.auto-template-polymorphism" title="Auto Template Polymorphism"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Auto</span> <span class="pre">Template</span>
<span class="pre">Polymorphism</span></code></a> flag is on.</p>
</dd></dl>

<p>In practice, the rule <strong>Ind-Family</strong> is used by <span class="smallcaps">Coq</span> only when all the
inductive types of the inductive definition are declared with an arity
whose sort is in the Type hierarchy. Then, the polymorphism is over
the parameters whose type is an arity of sort in the Type hierarchy.
The sorts <span class="math notranslate nohighlight">\(s_j\)</span> are chosen canonically so that each <span class="math notranslate nohighlight">\(s_j\)</span> is minimal with
respect to the hierarchy <span class="math notranslate nohighlight">\(\Prop ⊂ \Set_p ⊂ \Type\)</span> where <span class="math notranslate nohighlight">\(\Set_p\)</span> is predicative
<span class="math notranslate nohighlight">\(\Set\)</span>. More precisely, an empty or small singleton inductive definition
(i.e. an inductive definition of which all inductive types are
singleton – see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>) is set in <span class="math notranslate nohighlight">\(\Prop\)</span>, a small non-singleton
inductive type is set in <span class="math notranslate nohighlight">\(\Set\)</span> (even in case <span class="math notranslate nohighlight">\(\Set\)</span> is impredicative – see
Section <a class="reference internal" href="#the-calculus-of-inductive-construction-with-impredicative-set">The-Calculus-of-Inductive-Construction-with-impredicative-Set</a>),
and otherwise in the Type hierarchy.</p>
<p>Note that the side-condition about allowed elimination sorts in the rule
<strong>Ind-Family</strong> avoids to recompute the allowed elimination sorts at each
instance of a pattern matching (see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>). As an
example, let us consider the following definition:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">option</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">None</span><span> : </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">Some</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">option is defined
option_rect is defined
option_ind is defined
option_rec is defined
option_sind is defined</span></dd>
</dl>
</div>
</div>
<p>As the definition is set in the Type hierarchy, it is used
polymorphically over its parameters whose types are arities of a sort
in the Type hierarchy. Here, the parameter <span class="math notranslate nohighlight">\(A\)</span> has this property, hence,
if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">option</span></span></code> is applied to a type in <span class="math notranslate nohighlight">\(\Set\)</span>, the result is in <span class="math notranslate nohighlight">\(\Set\)</span>. Note that
if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">option</span></span></code> is applied to a type in <span class="math notranslate nohighlight">\(\Prop\)</span>, then, the result is not set in
<span class="math notranslate nohighlight">\(\Prop\)</span> but in <span class="math notranslate nohighlight">\(\Set\)</span> still. This is because <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">option</span></span></code> is not a singleton type
(see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>) and it would lose the elimination to <span class="math notranslate nohighlight">\(\Set\)</span> and <span class="math notranslate nohighlight">\(\Type\)</span>
if set in <span class="math notranslate nohighlight">\(\Prop\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span> =&gt; </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd><span class="ansi-bold first">fun</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span> =&gt; option A
     : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold last">Set</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span> =&gt; </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd><span class="ansi-bold first">fun</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; option A
     : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold last">Set</span></dd>
</dl>
</div>
</div>
<p>Here is another example.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">prod</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">pair</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">prod is defined
prod_rect is defined
prod_ind is defined
prod_rec is defined
prod_sind is defined</span></dd>
</dl>
</div>
</div>
<p>As <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">prod</span></span></code> is a singleton type, it will be in <span class="math notranslate nohighlight">\(\Prop\)</span> if applied twice to
propositions, in <span class="math notranslate nohighlight">\(\Set\)</span> if applied twice to at least one type in <span class="math notranslate nohighlight">\(\Set\)</span> and
none in <span class="math notranslate nohighlight">\(\Type\)</span>, and in <span class="math notranslate nohighlight">\(\Type\)</span> otherwise. In all cases, the three kind of
eliminations schemes are allowed.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span> =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd><span class="ansi-bold first">fun</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span> =&gt; prod A
     : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Type</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold last">Type</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span> =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd><span class="ansi-bold first">fun</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; prod A A
     : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold last">Prop</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>).</span></dt>
<dd><span class="ansi-bold first">fun</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>) (B : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>) =&gt; prod A B
     : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold last">Set</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>).</span></dt>
<dd><span class="ansi-bold first">fun</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>) =&gt; prod A B
     : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold last">Type</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Template polymorphism used to be called “sort-polymorphism of
inductive types” before universe polymorphism
(see Chapter <a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>) was introduced.</p>
</div>
</div>
</div>
<div class="section" id="destructors">
<span id="id26"></span><h3>Destructors<a class="headerlink" href="#destructors" title="Permalink to this headline">¶</a></h3>
<p>The specification of inductive definitions with arities and
constructors is quite natural. But we still have to say how to use an
object in an inductive type.</p>
<p>This problem is rather delicate. There are actually several different
ways to do that. Some of them are logically equivalent but not always
equivalent from the computational point of view or from the user point
of view.</p>
<p>From the computational point of view, we want to be able to define a
function whose domain is an inductively defined type by using a
combination of case analysis over the possible constructors of the
object and recursion.</p>
<p>Because we need to keep a consistent theory and also we prefer to keep
a strongly normalizing reduction, we cannot accept any sort of
recursion (even terminating). So the basic idea is to restrict
ourselves to primitive recursive functions and functionals.</p>
<p>For instance, assuming a parameter <span class="math notranslate nohighlight">\(A:\Set\)</span> exists in the local context,
we want to build a function <span class="math notranslate nohighlight">\(\length\)</span> of type <span class="math notranslate nohighlight">\(\List~A → \nat\)</span> which computes
the length of the list, such that <span class="math notranslate nohighlight">\((\length~(\Nil~A)) = \nO\)</span> and
<span class="math notranslate nohighlight">\((\length~(\cons~A~a~l)) = (\nS~(\length~l))\)</span>.
We want these equalities to be
recognized implicitly and taken into account in the conversion rule.</p>
<p>From the logical point of view, we have built a type family by giving
a set of constructors. We want to capture the fact that we do not have
any other way to build an object in this type. So when trying to prove
a property about an object <span class="math notranslate nohighlight">\(m\)</span> in an inductive type it is enough
to enumerate all the cases where <span class="math notranslate nohighlight">\(m\)</span> starts with a different
constructor.</p>
<p>In case the inductive definition is effectively a recursive one, we
want to capture the extra property that we have built the smallest
fixed point of this recursive equation. This says that we are only
manipulating finite objects. This analysis provides induction
principles. For instance, in order to prove
<span class="math notranslate nohighlight">\(∀ l:\List~A,~(\kw{has}\_\kw{length}~A~l~(\length~l))\)</span> it is enough to prove:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\((\kw{has}\_\kw{length}~A~(\Nil~A)~(\length~(\Nil~A)))\)</span></li>
<li><span class="math notranslate nohighlight">\(∀ a:A,~∀ l:\List~A,~(\kw{has}\_\kw{length}~A~l~(\length~l)) →\)</span>
<span class="math notranslate nohighlight">\((\kw{has}\_\kw{length}~A~(\cons~A~a~l)~(\length~(\cons~A~a~l)))\)</span></li>
</ul>
<p>which given the conversion equalities satisfied by <span class="math notranslate nohighlight">\(\length\)</span> is the same
as proving:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\((\kw{has}\_\kw{length}~A~(\Nil~A)~\nO)\)</span></li>
<li><span class="math notranslate nohighlight">\(∀ a:A,~∀ l:\List~A,~(\kw{has}\_\kw{length}~A~l~(\length~l)) →\)</span>
<span class="math notranslate nohighlight">\((\kw{has}\_\kw{length}~A~(\cons~A~a~l)~(\nS~(\length~l)))\)</span></li>
</ul>
<p>One conceptually simple way to do that, following the basic scheme
proposed by Martin-Löf in his Intuitionistic Type Theory, is to
introduce for each inductive definition an elimination operator. At
the logical level it is a proof of the usual induction principle and
at the computational level it implements a generic operator for doing
primitive recursion over the structure.</p>
<p>But this operator is rather tedious to implement and use. We choose in
this version of <span class="smallcaps">Coq</span> to factorize the operator for primitive recursion
into two more primitive operations as was first suggested by Th.
Coquand in <a class="reference internal" href="../zebibliography.html#coq92" id="id27">[Coq92]</a>. One is the definition by pattern matching. The
second one is a definition by guarded fixpoints.</p>
<div class="section" id="the-match-with-end-construction">
<span id="match-construction"></span><h4>The match ... with ... end construction<a class="headerlink" href="#the-match-with-end-construction" title="Permalink to this headline">¶</a></h4>
<p>The basic idea of this operator is that we have an object <span class="math notranslate nohighlight">\(m\)</span> in an
inductive type <span class="math notranslate nohighlight">\(I\)</span> and we want to prove a property which possibly
depends on <span class="math notranslate nohighlight">\(m\)</span>. For this, it is enough to prove the property for
<span class="math notranslate nohighlight">\(m = (c_i~u_1 … u_{p_i} )\)</span> for each constructor of <span class="math notranslate nohighlight">\(I\)</span>.
The <span class="smallcaps">Coq</span> term for this proof
will be written:</p>
<div class="math notranslate nohighlight">
\[\Match~m~\with~(c_1~x_{11} ... x_{1p_1} ) ⇒ f_1 | … | (c_n~x_{n1} ... x_{np_n} ) ⇒ f_n~\kwend\]</div>
<p>In this expression, if <span class="math notranslate nohighlight">\(m\)</span> eventually happens to evaluate to
<span class="math notranslate nohighlight">\((c_i~u_1 … u_{p_i})\)</span> then the expression will behave as specified in its <span class="math notranslate nohighlight">\(i\)</span>-th branch
and it will reduce to <span class="math notranslate nohighlight">\(f_i\)</span> where the <span class="math notranslate nohighlight">\(x_{i1} …x_{ip_i}\)</span> are replaced by the
<span class="math notranslate nohighlight">\(u_1 … u_{p_i}\)</span> according to the ι-reduction.</p>
<p>Actually, for type checking a <span class="math notranslate nohighlight">\(\Match…\with…\kwend\)</span> expression we also need
to know the predicate <span class="math notranslate nohighlight">\(P\)</span> to be proved by case analysis. In the general
case where <span class="math notranslate nohighlight">\(I\)</span> is an inductively defined <span class="math notranslate nohighlight">\(n\)</span>-ary relation, <span class="math notranslate nohighlight">\(P\)</span> is a predicate
over <span class="math notranslate nohighlight">\(n+1\)</span> arguments: the <span class="math notranslate nohighlight">\(n\)</span> first ones correspond to the arguments of <span class="math notranslate nohighlight">\(I\)</span>
(parameters excluded), and the last one corresponds to object <span class="math notranslate nohighlight">\(m\)</span>. <span class="smallcaps">Coq</span>
can sometimes infer this predicate but sometimes not. The concrete
syntax for describing this predicate uses the <span class="math notranslate nohighlight">\(\as…\In…\return\)</span>
construction. For instance, let us assume that <span class="math notranslate nohighlight">\(I\)</span> is an unary predicate
with one parameter and one argument. The predicate is made explicit
using the syntax:</p>
<div class="math notranslate nohighlight">
\[\Match~m~\as~x~\In~I~\_~a~\return~P~\with~
(c_1~x_{11} ... x_{1p_1} ) ⇒ f_1 | …
| (c_n~x_{n1} ... x_{np_n} ) ⇒ f_n~\kwend\]</div>
<p>The <span class="math notranslate nohighlight">\(\as\)</span> part can be omitted if either the result type does not depend
on <span class="math notranslate nohighlight">\(m\)</span> (non-dependent elimination) or <span class="math notranslate nohighlight">\(m\)</span> is a variable (in this case, <span class="math notranslate nohighlight">\(m\)</span>
can occur in <span class="math notranslate nohighlight">\(P\)</span> where it is considered a bound variable). The <span class="math notranslate nohighlight">\(\In\)</span> part
can be omitted if the result type does not depend on the arguments
of <span class="math notranslate nohighlight">\(I\)</span>. Note that the arguments of <span class="math notranslate nohighlight">\(I\)</span> corresponding to parameters <em>must</em>
be <span class="math notranslate nohighlight">\(\_\)</span>, because the result type is not generalized to all possible
values of the parameters. The other arguments of <span class="math notranslate nohighlight">\(I\)</span> (sometimes called
indices in the literature) have to be variables (<span class="math notranslate nohighlight">\(a\)</span> above) and these
variables can occur in <span class="math notranslate nohighlight">\(P\)</span>. The expression after <span class="math notranslate nohighlight">\(\In\)</span> must be seen as an
<em>inductive type pattern</em>. Notice that expansion of implicit arguments
and notations apply to this pattern. For the purpose of presenting the
inference rules, we use a more compact notation:</p>
<div class="math notranslate nohighlight">
\[\case(m,(λ a x . P), λ x_{11} ... x_{1p_1} . f_1~| … |~λ x_{n1} ...x_{np_n} . f_n )\]</div>
<p id="allowed-elimination-sorts"><strong>Allowed elimination sorts.</strong> An important question for building the typing rule for <span class="math notranslate nohighlight">\(\Match\)</span> is what
can be the type of <span class="math notranslate nohighlight">\(λ a x . P\)</span> with respect to the type of <span class="math notranslate nohighlight">\(m\)</span>. If <span class="math notranslate nohighlight">\(m:I\)</span>
and <span class="math notranslate nohighlight">\(I:A\)</span> and <span class="math notranslate nohighlight">\(λ a x . P : B\)</span> then by <span class="math notranslate nohighlight">\([I:A|B]\)</span> we mean that one can use
<span class="math notranslate nohighlight">\(λ a x . P\)</span> with <span class="math notranslate nohighlight">\(m\)</span> in the above match-construct.</p>
<p id="cic-notations"><strong>Notations.</strong> The <span class="math notranslate nohighlight">\([I:A|B]\)</span> is defined as the smallest relation satisfying the
following rules: We write <span class="math notranslate nohighlight">\([I|B]\)</span> for <span class="math notranslate nohighlight">\([I:A|B]\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is the type of <span class="math notranslate nohighlight">\(I\)</span>.</p>
<p>The case of inductive types in sorts <span class="math notranslate nohighlight">\(\Set\)</span> or <span class="math notranslate nohighlight">\(\Type\)</span> is simple.
There is no restriction on the sort of the predicate to be eliminated.</p>
<dl class="docutils">
<dt id="inference-prod">Prod<td><div class="first last math notranslate nohighlight">
\[\frac{%
[(I~x):A′|B′]%
}{%
[I:∀ x:A,~A′|∀ x:A,~B′]%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-set-type">Set &amp; Type<td><div class="first last math notranslate nohighlight">
\[\frac{%
s_1 ∈ \{\Set,\Type(j)\}%
\hspace{3em}%
s_2 ∈ \Sort%
}{%
[I:s_1 |I→ s_2 ]%
}\]</div>
</td></dl>
<p>The case of Inductive definitions of sort <span class="math notranslate nohighlight">\(\Prop\)</span> is a bit more
complicated, because of our interpretation of this sort. The only
harmless allowed eliminations, are the ones when predicate <span class="math notranslate nohighlight">\(P\)</span>
is also of sort <span class="math notranslate nohighlight">\(\Prop\)</span> or is of the morally smaller sort
<span class="math notranslate nohighlight">\(\SProp\)</span>.</p>
<dl class="docutils">
<dt id="inference-prop">Prop<td><div class="first last math notranslate nohighlight">
\[\frac{%
s ∈ \{\SProp,\Prop\}%
}{%
[I:\Prop|I→s]%
}\]</div>
</td></dl>
<p><span class="math notranslate nohighlight">\(\Prop\)</span> is the type of logical propositions, the proofs of properties <span class="math notranslate nohighlight">\(P\)</span> in
<span class="math notranslate nohighlight">\(\Prop\)</span> could not be used for computation and are consequently ignored by
the extraction mechanism. Assume <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are two propositions, and the
logical disjunction <span class="math notranslate nohighlight">\(A ∨ B\)</span> is defined inductively by:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
</span><span class="coqdoc-var">or_introl</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> | </span><span class="coqdoc-var">or_intror</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">or is defined
or_ind is defined
or_sind is defined</span></dd>
</dl>
</div>
</div>
<p>The following definition which computes a boolean value by case over
the proof of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">B</span></span></code> is not accepted:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">choice</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>) :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">or_introl</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">a</span><span> =&gt; </span><span class="coqdoc-var">true</span><span> | </span><span class="coqdoc-var">or_intror</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">b</span><span> =&gt; </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first">The command has indeed failed with message:
Incorrect elimination of &quot;x&quot; in the inductive type &quot;or&quot;:
the return type has sort &quot;</span><span class="ansi-fg-yellow ansi-bold">Set</span><span class="last">&quot; while it should be &quot;SProp&quot; or &quot;Prop&quot;.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort Set
because proofs can be eliminated only to build proofs.</span></dd>
</dl>
</div>
</div>
<p>From the computational point of view, the structure of the proof of
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">or</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">B</span></span><span class="operator"><span class="pre">)</span></span></code> in this term is needed for computing the boolean value.</p>
<p>In general, if <span class="math notranslate nohighlight">\(I\)</span> has type <span class="math notranslate nohighlight">\(\Prop\)</span> then <span class="math notranslate nohighlight">\(P\)</span> cannot have type <span class="math notranslate nohighlight">\(I→\Set\)</span>, because
it will mean to build an informative proof of type <span class="math notranslate nohighlight">\((P~m)\)</span> doing a case
analysis over a non-computational object that will disappear in the
extracted program. But the other way is safe with respect to our
interpretation we can have <span class="math notranslate nohighlight">\(I\)</span> a computational object and <span class="math notranslate nohighlight">\(P\)</span> a
non-computational one, it just corresponds to proving a logical property
of a computational object.</p>
<p>In the same spirit, elimination on <span class="math notranslate nohighlight">\(P\)</span> of type <span class="math notranslate nohighlight">\(I→\Type\)</span> cannot be allowed
because it trivially implies the elimination on <span class="math notranslate nohighlight">\(P\)</span> of type <span class="math notranslate nohighlight">\(I→ \Set\)</span> by
cumulativity. It also implies that there are two proofs of the same
property which are provably different, contradicting the
proof-irrelevance property which is sometimes a useful axiom:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">proof_irrelevance</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">P</span><span>), </span><span class="coqdoc-var">x</span><span>=</span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first last">proof_irrelevance is declared</span></dd>
</dl>
</div>
</div>
<p>The elimination of an inductive type of sort <span class="math notranslate nohighlight">\(\Prop\)</span> on a predicate
<span class="math notranslate nohighlight">\(P\)</span> of type <span class="math notranslate nohighlight">\(I→ \Type\)</span> leads to a paradox when applied to impredicative
inductive definition like the second-order existential quantifier
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">exProp</span></span></code> defined above, because it gives access to the two projections on
this type.</p>
<p id="empty-and-singleton-elimination"><strong>Empty and singleton elimination.</strong> There are special inductive definitions in
<span class="math notranslate nohighlight">\(\Prop\)</span> for which more eliminations are allowed.</p>
<dl class="docutils">
<dt id="inference-prop-extended">Prop-extended<td><div class="first last math notranslate nohighlight">
\[\frac{%
I~\kw{is an empty or singleton definition}%
\hspace{3em}%
s ∈ \Sort%
}{%
[I:\Prop|I→ s]%
}\]</div>
</td></dl>
<p>A <em>singleton definition</em> has only one constructor and all the
arguments of this constructor have type <span class="math notranslate nohighlight">\(\Prop\)</span>. In that case, there is a
canonical way to interpret the informative extraction on an object in
that type, such that the elimination on any sort <span class="math notranslate nohighlight">\(s\)</span> is legal. Typical
examples are the conjunction of non-informative propositions and the
equality. If there is a hypothesis <span class="math notranslate nohighlight">\(h:a=b\)</span> in the local context, it can
be used for rewriting not only in logical propositions but also in any
type.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">eq_rec</span><span>.</span></dt>
<dd><span class="first">eq_rec = 
</span><span class="ansi-bold">fun</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (x : A) (P : A</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>) =&gt; eq_rect x P
     : </span><span class="ansi-bold">forall</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (x : A) (P : A</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>),
       P x</span><span class="ansi-fg-white"> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> y : A, x</span><span class="ansi-fg-white"> =</span><span> y</span><span class="ansi-fg-white"> -&gt;</span><span> P y

Arguments </span><span class="ansi-fg-light-green">eq_rec</span><span class="last"> [A]%type_scope _ _%function_scope</span></dd>
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Extraction</span><span>.</span></dt>
<dd><span class="first last">[Loading ML file extraction_plugin.cmxs ... done]</span></dd>
<dt><span class="coqdoc-keyword">Extraction</span><span> </span><span class="coqdoc-var">eq_rec</span><span>.</span></dt>
<dd><span class="first last">(** val eq_rec : 'a1 -&gt; 'a2 -&gt; 'a1 -&gt; 'a2 **)

let eq_rec _ f _ =
  f</span></dd>
</dl>
</div>
</div>
<p>An empty definition has no constructors, in that case also,
elimination on any sort is allowed.</p>
<p id="eliminaton-for-sprop">Inductive types in <span class="math notranslate nohighlight">\(\SProp\)</span> must have no constructors (i.e. be
empty) to be eliminated to produce relevant values.</p>
<p>Note that thanks to proof irrelevance elimination functions can be
produced for other types, for instance the elimination for a unit type
is the identity.</p>
<p id="type-of-branches"><strong>Type of branches.</strong>
Let <span class="math notranslate nohighlight">\(c\)</span> be a term of type <span class="math notranslate nohighlight">\(C\)</span>, we assume <span class="math notranslate nohighlight">\(C\)</span> is a type of constructor for an
inductive type <span class="math notranslate nohighlight">\(I\)</span>. Let <span class="math notranslate nohighlight">\(P\)</span> be a term that represents the property to be
proved. We assume <span class="math notranslate nohighlight">\(r\)</span> is the number of parameters and <span class="math notranslate nohighlight">\(s\)</span> is the number of
arguments.</p>
<p>We define a new type <span class="math notranslate nohighlight">\(\{c:C\}^P\)</span> which represents the type of the branch
corresponding to the <span class="math notranslate nohighlight">\(c:C\)</span> constructor.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ll}
\{c:(I~q_1\ldots q_r\ t_1 \ldots t_s)\}^P &amp;\equiv (P~t_1\ldots ~t_s~c) \\
\{c:∀ x:T,~C\}^P &amp;\equiv ∀ x:T,~\{(c~x):C\}^P
\end{array}\end{split}\]</div>
<p>We write <span class="math notranslate nohighlight">\(\{c\}^P\)</span> for <span class="math notranslate nohighlight">\(\{c:C\}^P\)</span> with <span class="math notranslate nohighlight">\(C\)</span> the type of <span class="math notranslate nohighlight">\(c\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The following term in concrete syntax:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>match t as l return P&#39; with
| nil _ =&gt; t1
| cons _ hd tl =&gt; t2
end
</pre></div>
</div>
<p>can be represented in abstract syntax as</p>
<div class="math notranslate nohighlight">
\[\case(t,P,f_1 | f_2 )\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
  P &amp; = &amp; λ l.~P^\prime\\
  f_1 &amp; = &amp; t_1\\
  f_2 &amp; = &amp; λ (hd:\nat).~λ (tl:\List~\nat).~t_2
\end{eqnarray*}</div><p>According to the definition:</p>
<div class="math notranslate nohighlight">
\[\{(\Nil~\nat)\}^P ≡ \{(\Nil~\nat) : (\List~\nat)\}^P ≡ (P~(\Nil~\nat))\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rl}
\{(\cons~\nat)\}^P &amp; ≡\{(\cons~\nat) : (\nat→\List~\nat→\List~\nat)\}^P \\
&amp; ≡∀ n:\nat,~\{(\cons~\nat~n) : (\List~\nat→\List~\nat)\}^P \\
&amp; ≡∀ n:\nat,~∀ l:\List~\nat,~\{(\cons~\nat~n~l) : (\List~\nat)\}^P \\
&amp; ≡∀ n:\nat,~∀ l:\List~\nat,~(P~(\cons~\nat~n~l)).
\end{array}\end{split}\]</div>
<p class="last">Given some <span class="math notranslate nohighlight">\(P\)</span> then <span class="math notranslate nohighlight">\(\{(\Nil~\nat)\}^P\)</span> represents the expected type of <span class="math notranslate nohighlight">\(f_1\)</span>,
and <span class="math notranslate nohighlight">\(\{(\cons~\nat)\}^P\)</span> represents the expected type of <span class="math notranslate nohighlight">\(f_2\)</span>.</p>
</div>
<p id="typing-rule"><strong>Typing rule.</strong>
Our very general destructor for inductive definition enjoys the
following typing rule</p>
<dl class="docutils">
<dt id="inference-match">match<td><div class="first last math notranslate nohighlight">
\[\begin{split}\frac{%
\begin{array}{l}%
\hspace{3em}%
E[Γ] ⊢ c : (I~q_1 … q_r~t_1 … t_s ) \\%
\hspace{3em}%
E[Γ] ⊢ P : B \\%
\hspace{3em}%
[(I~q_1 … q_r)|B] \\%
\hspace{3em}%
(E[Γ] ⊢ f_i : \{(c_{p_i}~q_1 … q_r)\}^P)_{i=1… l}%
\hspace{3em}%
\end{array}%
}{%
E[Γ] ⊢ \case(c,P,f_1  |… |f_l ) : (P~t_1 … t_s~c)%
}\end{split}\]</div>
</td></dl>
<p>provided <span class="math notranslate nohighlight">\(I\)</span> is an inductive type in a
definition <span class="math notranslate nohighlight">\(\ind{r}{Γ_I}{Γ_C}\)</span> with <span class="math notranslate nohighlight">\(Γ_C = [c_1 :C_1 ;~…;~c_n :C_n ]\)</span> and
<span class="math notranslate nohighlight">\(c_{p_1} … c_{p_l}\)</span> are the only constructors of <span class="math notranslate nohighlight">\(I\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>Below is a typing rule for the term shown in the previous example:</p>
<dl class="last docutils">
<dt id="inference-list-example">list example<td><div class="first last math notranslate nohighlight">
\[\begin{split}\frac{%
\begin{array}{l}%
\hspace{3em}%
  E[Γ] ⊢ t : (\List ~\nat) \\%
\hspace{3em}%
  E[Γ] ⊢ P : B \\%
\hspace{3em}%
  [(\List ~\nat)|B] \\%
\hspace{3em}%
  E[Γ] ⊢ f_1 : \{(\Nil ~\nat)\}^P \\%
\hspace{3em}%
  E[Γ] ⊢ f_2 : \{(\cons ~\nat)\}^P%
\hspace{3em}%
\end{array}%
}{%
E[Γ] ⊢ \case(t,P,f_1 |f_2 ) : (P~t)%
}\end{split}\]</div>
</td></dl>
</div>
<p id="definition-of-reduction"><strong>Definition of ι-reduction.</strong>
We still have to define the ι-reduction in the general case.</p>
<p>An ι-redex is a term of the following form:</p>
<div class="math notranslate nohighlight">
\[\case((c_{p_i}~q_1 … q_r~a_1 … a_m ),P,f_1 |… |f_l )\]</div>
<p>with <span class="math notranslate nohighlight">\(c_{p_i}\)</span> the <span class="math notranslate nohighlight">\(i\)</span>-th constructor of the inductive type <span class="math notranslate nohighlight">\(I\)</span> with <span class="math notranslate nohighlight">\(r\)</span>
parameters.</p>
<p>The ι-contraction of this term is <span class="math notranslate nohighlight">\((f_i~a_1 … a_m )\)</span> leading to the
general reduction rule:</p>
<div class="math notranslate nohighlight">
\[\case((c_{p_i}~q_1 … q_r~a_1 … a_m ),P,f_1 |… |f_l ) \triangleright_ι (f_i~a_1 … a_m )\]</div>
</div>
</div>
<div class="section" id="fixpoint-definitions">
<span id="id28"></span><h3>Fixpoint definitions<a class="headerlink" href="#fixpoint-definitions" title="Permalink to this headline">¶</a></h3>
<p>The second operator for elimination is fixpoint definition. This
fixpoint may involve several mutually recursive definitions. The basic
concrete syntax for a recursive set of mutually recursive declarations
is (with <span class="math notranslate nohighlight">\(Γ_i\)</span> contexts):</p>
<div class="math notranslate nohighlight">
\[\fix~f_1 (Γ_1 ) :A_1 :=t_1~\with … \with~f_n (Γ_n ) :A_n :=t_n\]</div>
<p>The terms are obtained by projections from this set of declarations
and are written</p>
<div class="math notranslate nohighlight">
\[\fix~f_1 (Γ_1 ) :A_1 :=t_1~\with … \with~f_n (Γ_n ) :A_n :=t_n~\for~f_i\]</div>
<p>In the inference rules, we represent such a term by</p>
<div class="math notranslate nohighlight">
\[\Fix~f_i\{f_1 :A_1':=t_1' … f_n :A_n':=t_n'\}\]</div>
<p>with <span class="math notranslate nohighlight">\(t_i'\)</span> (resp. <span class="math notranslate nohighlight">\(A_i'\)</span>) representing the term <span class="math notranslate nohighlight">\(t_i\)</span> abstracted (resp.
generalized) with respect to the bindings in the context <span class="math notranslate nohighlight">\(Γ_i\)</span>, namely
<span class="math notranslate nohighlight">\(t_i'=λ Γ_i . t_i\)</span> and <span class="math notranslate nohighlight">\(A_i'=∀ Γ_i , A_i\)</span>.</p>
<div class="section" id="id29">
<h4>Typing rule<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<p>The typing rule is the expected one for a fixpoint.</p>
<dl class="docutils">
<dt id="inference-fix">Fix<td><div class="first last math notranslate nohighlight">
\[\frac{%
(E[Γ] ⊢ A_i : s_i )_{i=1… n}%
\hspace{3em}%
(E[Γ;~f_1 :A_1 ;~…;~f_n :A_n ] ⊢ t_i : A_i )_{i=1… n}%
}{%
E[Γ] ⊢ \Fix~f_i\{f_1 :A_1 :=t_1 … f_n :A_n :=t_n \} : A_i%
}\]</div>
</td></dl>
<p>Any fixpoint definition cannot be accepted because non-normalizing
terms allow proofs of absurdity. The basic scheme of recursion that
should be allowed is the one needed for defining primitive recursive
functionals. In that case the fixpoint enjoys a special syntactic
restriction, namely one of the arguments belongs to an inductive type,
the function starts with a case analysis and recursive calls are done
on variables coming from patterns and representing subterms. For
instance in the case of natural numbers, a proof of the induction
principle of type</p>
<div class="math notranslate nohighlight">
\[∀ P:\nat→\Prop,~(P~\nO)→(∀ n:\nat,~(P~n)→(P~(\nS~n)))→ ∀ n:\nat,~(P~n)\]</div>
<p>can be represented by the term:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{l}
λ P:\nat→\Prop.~λ f:(P~\nO).~λ g:(∀ n:\nat,~(P~n)→(P~(\nS~n))).\\
\Fix~h\{h:∀ n:\nat,~(P~n):=λ n:\nat.~\case(n,P,f | λp:\nat.~(g~p~(h~p)))\}
\end{array}\end{split}\]</div>
<p>Before accepting a fixpoint definition as being correctly typed, we
check that the definition is “guarded”. A precise analysis of this
notion can be found in <a class="reference internal" href="../zebibliography.html#gim94" id="id30">[Gimenez94]</a>. The first stage is to precise on which
argument the fixpoint will be decreasing. The type of this argument
should be an inductive type. For doing this, the syntax of
fixpoints is extended and becomes</p>
<div class="math notranslate nohighlight">
\[\Fix~f_i\{f_1/k_1 :A_1:=t_1 … f_n/k_n :A_n:=t_n\}\]</div>
<p>where <span class="math notranslate nohighlight">\(k_i\)</span> are positive integers. Each <span class="math notranslate nohighlight">\(k_i\)</span> represents the index of
parameter of <span class="math notranslate nohighlight">\(f_i\)</span>, on which <span class="math notranslate nohighlight">\(f_i\)</span> is decreasing. Each <span class="math notranslate nohighlight">\(A_i\)</span> should be a
type (reducible to a term) starting with at least <span class="math notranslate nohighlight">\(k_i\)</span> products
<span class="math notranslate nohighlight">\(∀ y_1 :B_1 ,~… ∀ y_{k_i} :B_{k_i} ,~A_i'\)</span> and <span class="math notranslate nohighlight">\(B_{k_i}\)</span> an inductive type.</p>
<p>Now in the definition <span class="math notranslate nohighlight">\(t_i\)</span>, if <span class="math notranslate nohighlight">\(f_j\)</span> occurs then it should be applied to
at least <span class="math notranslate nohighlight">\(k_j\)</span> arguments and the <span class="math notranslate nohighlight">\(k_j\)</span>-th argument should be
syntactically recognized as structurally smaller than <span class="math notranslate nohighlight">\(y_{k_i}\)</span>.</p>
<p>The definition of being structurally smaller is a bit technical. One
needs first to define the notion of <em>recursive arguments of a
constructor</em>. For an inductive definition <span class="math notranslate nohighlight">\(\ind{r}{Γ_I}{Γ_C}\)</span>, if the
type of a constructor <span class="math notranslate nohighlight">\(c\)</span> has the form
<span class="math notranslate nohighlight">\(∀ p_1 :P_1 ,~… ∀ p_r :P_r,~∀ x_1:T_1,~… ∀ x_m :T_m,~(I_j~p_1 … p_r~t_1 … t_s )\)</span>,
then the recursive
arguments will correspond to <span class="math notranslate nohighlight">\(T_i\)</span> in which one of the <span class="math notranslate nohighlight">\(I_l\)</span> occurs.</p>
<p>The main rules for being structurally smaller are the following.
Given a variable <span class="math notranslate nohighlight">\(y\)</span> of an inductively defined type in a declaration
<span class="math notranslate nohighlight">\(\ind{r}{Γ_I}{Γ_C}\)</span> where <span class="math notranslate nohighlight">\(Γ_I\)</span> is <span class="math notranslate nohighlight">\([I_1 :A_1 ;~…;~I_k :A_k]\)</span>, and <span class="math notranslate nohighlight">\(Γ_C\)</span> is
<span class="math notranslate nohighlight">\([c_1 :C_1 ;~…;~c_n :C_n ]\)</span>, the terms structurally smaller than <span class="math notranslate nohighlight">\(y\)</span> are:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\((t~u)\)</span> and <span class="math notranslate nohighlight">\(λ x:U .~t\)</span> when <span class="math notranslate nohighlight">\(t\)</span> is structurally smaller than <span class="math notranslate nohighlight">\(y\)</span>.</li>
<li><span class="math notranslate nohighlight">\(\case(c,P,f_1 … f_n)\)</span> when each <span class="math notranslate nohighlight">\(f_i\)</span> is structurally smaller than <span class="math notranslate nohighlight">\(y\)</span>.
If <span class="math notranslate nohighlight">\(c\)</span> is <span class="math notranslate nohighlight">\(y\)</span> or is structurally smaller than <span class="math notranslate nohighlight">\(y\)</span>, its type is an inductive
type <span class="math notranslate nohighlight">\(I_p\)</span> part of the inductive definition corresponding to <span class="math notranslate nohighlight">\(y\)</span>.
Each <span class="math notranslate nohighlight">\(f_i\)</span> corresponds to a type of constructor
<span class="math notranslate nohighlight">\(C_q ≡ ∀ p_1 :P_1 ,~…,∀ p_r :P_r ,~∀ y_1 :B_1 ,~… ∀ y_m :B_m ,~(I_p~p_1 … p_r~t_1 … t_s )\)</span>
and can consequently be written <span class="math notranslate nohighlight">\(λ y_1 :B_1' .~… λ y_m :B_m'.~g_i\)</span>. (<span class="math notranslate nohighlight">\(B_i'\)</span> is
obtained from <span class="math notranslate nohighlight">\(B_i\)</span> by substituting parameters for variables) the variables
<span class="math notranslate nohighlight">\(y_j\)</span> occurring in <span class="math notranslate nohighlight">\(g_i\)</span> corresponding to recursive arguments <span class="math notranslate nohighlight">\(B_i\)</span> (the
ones in which one of the <span class="math notranslate nohighlight">\(I_l\)</span> occurs) are structurally smaller than <span class="math notranslate nohighlight">\(y\)</span>.</li>
</ul>
<p>The following definitions are correct, we enter them using the <a class="reference internal" href="gallina-specification-language.html#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a>
command and show the internal representation.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">m</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">plus is defined
plus is recursively defined (decreasing on 1st argument)</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">plus</span><span>.</span></dt>
<dd><span class="first">plus = 
fix plus (n m : nat) {</span><span class="ansi-bold">struct</span><span> n} : nat :=
  </span><span class="ansi-bold">match</span><span> n </span><span class="ansi-bold">with</span><span>
  | 0 =&gt; m
  | S p =&gt; S (plus p m)
  </span><span class="ansi-bold">end</span><span>
     : nat</span><span class="ansi-fg-white"> -&gt;</span><span> nat</span><span class="ansi-fg-white"> -&gt;</span><span> nat

Arguments </span><span class="ansi-fg-light-green">plus</span><span class="last"> (_ _)%nat_scope</span></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">lgth</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">l</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">l'</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">lgth</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">l'</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">lgth is defined
lgth is recursively defined (decreasing on 2nd argument)</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">lgth</span><span>.</span></dt>
<dd><span class="first">lgth = 
fix lgth (A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>) (l : list A) {</span><span class="ansi-bold">struct</span><span> l} : nat :=
  </span><span class="ansi-bold">match</span><span> l </span><span class="ansi-bold">with</span><span>
  | nil _ =&gt; 0
  | cons _ _ l' =&gt; S (lgth A l')
  </span><span class="ansi-bold">end</span><span>
     : </span><span class="ansi-bold">forall</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>, list A</span><span class="ansi-fg-white"> -&gt;</span><span> nat

Arguments </span><span class="ansi-fg-light-green">lgth</span><span class="last"> _%type_scope</span></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">sizet</span><span> (</span><span class="coqdoc-var">t</span><span>:</span><span class="coqdoc-var">tree</span><span>) : </span><span class="coqdoc-var">nat</span><span> := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">f</span><span>) := </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">sizef</span><span> </span><span class="coqdoc-var">f</span><span>)</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">sizef</span><span> (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">forest</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">emptyf</span><span> =&gt; </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">consf</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">f</span><span> =&gt; </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">sizet</span><span> </span><span class="coqdoc-var">t</span><span>) (</span><span class="coqdoc-var">sizef</span><span> </span><span class="coqdoc-var">f</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">sizet is defined
sizef is defined
sizet, sizef are recursively defined (decreasing respectively on 1st,
1st arguments)</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">sizet</span><span>.</span></dt>
<dd><span class="first">sizet = 
with sizet (t : tree) : nat :=
  </span><span class="ansi-bold">let</span><span> (f) := t</span><span class="ansi-bold"> in</span><span> S (sizef f)
with sizef (f : forest) : nat :=
  </span><span class="ansi-bold">match</span><span> f </span><span class="ansi-bold">with</span><span>
  | emptyf =&gt; 0
  | consf t f0 =&gt; plus (sizet t) (sizef f0)
  </span><span class="ansi-bold">end</span><span>
</span><span class="ansi-bold">for</span><span>
sizet
     : tree</span><span class="ansi-fg-white"> -&gt;</span><span class="last"> nat</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="reduction-rule">
<span id="id31"></span><h4>Reduction rule<a class="headerlink" href="#reduction-rule" title="Permalink to this headline">¶</a></h4>
<p>Let <span class="math notranslate nohighlight">\(F\)</span> be the set of declarations:
<span class="math notranslate nohighlight">\(f_1 /k_1 :A_1 :=t_1 …f_n /k_n :A_n:=t_n\)</span>.
The reduction for fixpoints is:</p>
<div class="math notranslate nohighlight">
\[(\Fix~f_i \{F\}~a_1 …a_{k_i}) ~\triangleright_ι~ \subst{t_i}{f_k}{\Fix~f_k \{F\}}_{k=1… n} ~a_1 … a_{k_i}\]</div>
<p>when <span class="math notranslate nohighlight">\(a_{k_i}\)</span> starts with a constructor. This last restriction is needed
in order to keep strong normalization and corresponds to the reduction
for primitive recursive operators. The following reductions are now
possible:</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
\plus~(\nS~(\nS~\nO))~(\nS~\nO)~&amp; \trii &amp; \nS~(\plus~(\nS~\nO)~(\nS~\nO))\\
                                &amp; \trii &amp; \nS~(\nS~(\plus~\nO~(\nS~\nO)))\\
                                &amp; \trii &amp; \nS~(\nS~(\nS~\nO))\\
\end{eqnarray*}</div><p id="mutual-induction"><strong>Mutual induction</strong></p>
<p>The principles of mutual induction can be automatically generated
using the Scheme command described in Section <a class="reference internal" href="../user-extensions/proof-schemes.html#proofschemes-induction-principles"><span class="std std-ref">Generation of induction principles with Scheme</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="admissible-rules-for-global-environments">
<span id="id32"></span><h2>Admissible rules for global environments<a class="headerlink" href="#admissible-rules-for-global-environments" title="Permalink to this headline">¶</a></h2>
<p>From the original rules of the type system, one can show the
admissibility of rules which change the local context of definition of
objects in the global environment. We show here the admissible rules
that are used in the discharge mechanism at the end of a section.</p>
<p id="abstraction"><strong>Abstraction.</strong>
One can modify a global declaration by generalizing it over a
previously assumed constant <span class="math notranslate nohighlight">\(c\)</span>. For doing that, we need to modify the
reference to the global declaration in the subsequent global
environment and local context by explicitly applying this constant to
the constant <span class="math notranslate nohighlight">\(c\)</span>.</p>
<p>Below, if <span class="math notranslate nohighlight">\(Γ\)</span> is a context of the form <span class="math notranslate nohighlight">\([y_1 :A_1 ;~…;~y_n :A_n]\)</span>, we write
<span class="math notranslate nohighlight">\(∀x:U,~\subst{Γ}{c}{x}\)</span> to mean
<span class="math notranslate nohighlight">\([y_1 :∀ x:U,~\subst{A_1}{c}{x};~…;~y_n :∀ x:U,~\subst{A_n}{c}{x}]\)</span>
and <span class="math notranslate nohighlight">\(\subst{E}{|Γ|}{|Γ|c}\)</span> to mean the parallel substitution
<span class="math notranslate nohighlight">\(E\{y_1 /(y_1~c)\}…\{y_n/(y_n~c)\}\)</span>.</p>
<p id="first-abstracting-property"><strong>First abstracting property:</strong></p>
<div class="math notranslate nohighlight">
\[\frac{\WF{E;~c:U;~E′;~c′:=t:T;~E″}{Γ}}
     {\WF{E;~c:U;~E′;~c′:=λ x:U.~\subst{t}{c}{x}:∀x:U,~\subst{T}{c}{x};~\subst{E″}{c′}{(c′~c)}}
     {\subst{Γ}{c′}{(c′~c)}}}\]</div>
<div class="math notranslate nohighlight">
\[\frac{\WF{E;~c:U;~E′;~c′:T;~E″}{Γ}}
     {\WF{E;~c:U;~E′;~c′:∀ x:U,~\subst{T}{c}{x};~\subst{E″}{c′}{(c′~c)}}{\subst{Γ}{c′}{(c′~c)}}}\]</div>
<div class="math notranslate nohighlight">
\[\frac{\WF{E;~c:U;~E′;~\ind{p}{Γ_I}{Γ_C};~E″}{Γ}}
     {\WFTWOLINES{E;~c:U;~E′;~\ind{p+1}{∀ x:U,~\subst{Γ_I}{c}{x}}{∀ x:U,~\subst{Γ_C}{c}{x}};~
       \subst{E″}{|Γ_I ;Γ_C |}{|Γ_I ;Γ_C | c}}
      {\subst{Γ}{|Γ_I ;Γ_C|}{|Γ_I ;Γ_C | c}}}\]</div>
<p>One can similarly modify a global declaration by generalizing it over
a previously defined constant <span class="math notranslate nohighlight">\(c\)</span>. Below, if <span class="math notranslate nohighlight">\(Γ\)</span> is a context of the form
<span class="math notranslate nohighlight">\([y_1 :A_1 ;~…;~y_n :A_n]\)</span>, we write <span class="math notranslate nohighlight">\(\subst{Γ}{c}{u}\)</span> to mean
<span class="math notranslate nohighlight">\([y_1 :\subst{A_1} {c}{u};~…;~y_n:\subst{A_n} {c}{u}]\)</span>.</p>
<p id="second-abstracting-property"><strong>Second abstracting property:</strong></p>
<div class="math notranslate nohighlight">
\[\frac{\WF{E;~c:=u:U;~E′;~c′:=t:T;~E″}{Γ}}
     {\WF{E;~c:=u:U;~E′;~c′:=(\letin{x}{u:U}{\subst{t}{c}{x}}):\subst{T}{c}{u};~E″}{Γ}}\]</div>
<div class="math notranslate nohighlight">
\[\frac{\WF{E;~c:=u:U;~E′;~c′:T;~E″}{Γ}}
     {\WF{E;~c:=u:U;~E′;~c′:\subst{T}{c}{u};~E″}{Γ}}\]</div>
<div class="math notranslate nohighlight">
\[\frac{\WF{E;~c:=u:U;~E′;~\ind{p}{Γ_I}{Γ_C};~E″}{Γ}}
     {\WF{E;~c:=u:U;~E′;~\ind{p}{\subst{Γ_I}{c}{u}}{\subst{Γ_C}{c}{u}};~E″}{Γ}}\]</div>
<p id="pruning-the-local-context"><strong>Pruning the local context.</strong>
If one abstracts or substitutes constants with the above rules then it
may happen that some declared or defined constant does not occur any
more in the subsequent global environment and in the local context.
One can consequently derive the following property.</p>
<dl class="docutils" id="first-pruning-property">
<dt id="inference-first-pruning-property">First pruning property:<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WF{E;~c:U;~E′}{Γ}%
\hspace{3em}%
c~\kw{does not occur in}~E′~\kw{and}~Γ%
}{%
\WF{E;E′}{Γ}%
}\]</div>
</td></dl>
<dl class="docutils" id="second-pruning-property">
<dt id="inference-second-pruning-property">Second pruning property:<td><div class="first last math notranslate nohighlight">
\[\frac{%
\WF{E;~c:=u:U;~E′}{Γ}%
\hspace{3em}%
c~\kw{does not occur in}~E′~\kw{and}~Γ%
}{%
\WF{E;E′}{Γ}%
}\]</div>
</td></dl>
</div>
<div class="section" id="co-inductive-types">
<span id="id33"></span><h2>Co-inductive types<a class="headerlink" href="#co-inductive-types" title="Permalink to this headline">¶</a></h2>
<p>The implementation contains also co-inductive definitions, which are
types inhabited by infinite objects. More information on co-inductive
definitions can be found in <a class="reference internal" href="../zebibliography.html#gimenez95b" id="id34">[Gimenez95]</a><a class="reference internal" href="../zebibliography.html#gim98" id="id35">[Gimenez98]</a><a class="reference internal" href="../zebibliography.html#gimcas05" id="id36">[GimenezCasteran05]</a>.</p>
</div>
<div class="section" id="the-calculus-of-inductive-constructions-with-impredicative-set">
<span id="the-calculus-of-inductive-construction-with-impredicative-set"></span><h2>The Calculus of Inductive Constructions with impredicative Set<a class="headerlink" href="#the-calculus-of-inductive-constructions-with-impredicative-set" title="Permalink to this headline">¶</a></h2>
<p><span class="smallcaps">Coq</span> can be used as a type checker for the Calculus of Inductive
Constructions with an impredicative sort <span class="math notranslate nohighlight">\(\Set\)</span> by using the compiler
option <code class="docutils literal notranslate"><span class="pre">-impredicative-set</span></code>. For example, using the ordinary <code class="docutils literal notranslate"><span class="pre">coqtop</span></code>
command, the following is rejected,</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">id</span><span>: </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Set</span><span>,</span><span class="coqdoc-var">X</span><span>-&gt;</span><span class="coqdoc-var">X</span><span>.</span></dt>
<dd><span class="first">The command has indeed failed with message:
The term &quot;</span><span class="ansi-bold">forall</span><span> X : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>, X</span><span class="ansi-fg-white"> -&gt;</span><span> X&quot; has type &quot;</span><span class="ansi-fg-yellow ansi-bold">Type</span><span>&quot;
while it is expected to have type &quot;</span><span class="ansi-fg-yellow ansi-bold">Set</span><span class="last">&quot;
(universe inconsistency: Cannot enforce Set+1 &lt;= Set).</span></dd>
</dl>
</div>
</div>
<p>while it will type check, if one uses instead the <code class="docutils literal notranslate"><span class="pre">coqtop</span></code>
<code class="docutils literal notranslate"><span class="pre">-impredicative-set</span></code> option..</p>
<p>The major change in the theory concerns the rule for product formation
in the sort <span class="math notranslate nohighlight">\(\Set\)</span>, which is extended to a domain in any sort:</p>
<dl class="docutils">
<dt id="inference-prodimp">ProdImp<td><div class="first last math notranslate nohighlight">
\[\frac{%
E[Γ] ⊢ T : s%
\hspace{3em}%
s ∈ \Sort%
\hspace{3em}%
E[Γ::(x:T)] ⊢ U : \Set%
}{%
E[Γ] ⊢ ∀ x:T,~U : \Set%
}\]</div>
</td></dl>
<p>This extension has consequences on the inductive definitions which are
allowed. In the impredicative system, one can build so-called <em>large
inductive definitions</em> like the example of second-order existential
quantifier (<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">exSet</span></span></code>).</p>
<p>There should be restrictions on the eliminations which can be
performed on such definitions. The elimination rules in the
impredicative system for sort <span class="math notranslate nohighlight">\(\Set\)</span> become:</p>
<dl class="docutils">
<dt id="inference-set1">Set1<td><div class="first last math notranslate nohighlight">
\[\frac{%
s ∈ \{\Prop, \Set\}%
}{%
[I:\Set|I→ s]%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-set2">Set2<td><div class="first last math notranslate nohighlight">
\[\frac{%
I~\kw{is a small inductive definition}%
\hspace{3em}%
s ∈ \{\Type(i)\}%
}{%
[I:\Set|I→ s]%
}\]</div>
</td></dl>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="core/records.html" class="btn btn-neutral float-right" title="Record types" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="gallina-specification-language.html" class="btn btn-neutral" title="The Gallina specification language" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2020, Inria, CNRS and contributors.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'8.12+alpha',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/notations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>