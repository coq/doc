<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Refine (coq.Refine)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Refine</nav><h1>Module <code>Refine</code></h1><p>The primitive refine tactic used to fill the holes in partial proofs. This is the recommended way to write tactics when the proof term is easy to write down. Note that this is not the user-level refine tactic defined in Ltac which is actually based on the one below.</p><nav class="toc"><ul><li><a href="#the-refine-tactic">The refine tactic</a></li><li><a href="#refinement-primitives">Refinement primitives</a></li><li><a href="#unification-constraint-handling">Unification constraint handling</a></li></ul></nav></header><section><header><h6 id="the-refine-tactic"><a href="#the-refine-tactic" class="anchor"></a>The refine tactic</h6></header></section><section><header><h6 id="refinement-primitives"><a href="#refinement-primitives" class="anchor"></a>Refinement primitives</h6></header><dl><dt class="spec value" id="val-refine"><a href="#val-refine" class="anchor"></a><code><span class="keyword">val</span> refine : typecheck:bool <span>&#45;&gt;</span> (<a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../EConstr/index.html#type-t">EConstr.t</a>) <span>&#45;&gt;</span> unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></code></dt><dd><p>In <code>refine ~typecheck t</code>, <code>t</code> is a term with holes under some <code>evar_map</code> context. The term <code>t</code> is used as a partial solution for the current goal (refine is a goal-dependent tactic), the new holes created by <code>t</code> become the new subgoals. Exceptions raised during the interpretation of <code>t</code> are caught and result in tactic failures. If <code>typecheck</code> is <code>true</code> <code>t</code> is type-checked beforehand.</p></dd></dl><dl><dt class="spec value" id="val-generic_refine"><a href="#val-generic_refine" class="anchor"></a><code><span class="keyword">val</span> generic_refine : typecheck:bool <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <a href="../EConstr/index.html#type-t">EConstr.t</a>) <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a> <span>&#45;&gt;</span> <a href="../Proofview/Goal/index.html#type-t">Proofview.Goal.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></code></dt><dd><p>The general version of refine.</p></dd></dl></section><section><header><h6 id="unification-constraint-handling"><a href="#unification-constraint-handling" class="anchor"></a>Unification constraint handling</h6></header><dl><dt class="spec value" id="val-solve_constraints"><a href="#val-solve_constraints" class="anchor"></a><code><span class="keyword">val</span> solve_constraints : unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></code></dt><dd><p>Solve any remaining unification problems, applying heuristics.</p></dd></dl></section></div></body></html>