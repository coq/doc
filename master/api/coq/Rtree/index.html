<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rtree (coq.Rtree)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Rtree</nav><h1>Module <code>Rtree</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt><dd><p>Type of regular tree with nodes labelled by values of type 'a The implementation uses de Bruijn indices, so binding capture is avoided by the lift operator (see example below)</p></dd></dl><aside><p>Building trees</p></aside><dl><dt class="spec value" id="val-mk_node"><a href="#val-mk_node" class="anchor"></a><code><span class="keyword">val</span> mk_node : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>build a node given a label and the vector of sons</p></dd></dl><dl><dt class="spec value" id="val-mk_rec_calls"><a href="#val-mk_rec_calls" class="anchor"></a><code><span class="keyword">val</span> mk_rec_calls : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> array</code></dt><dd><p>Build mutually recursive trees: X_1 = f_1(X_1,..,X_n) ... X_n = f_n(X_1,..,X_n) is obtained by the following pseudo-code let vx = mk_rec_calls n in let <code>|x_1;..;x_n|</code> = mk_rec<code>|f_1(vx.(0),..,vx.(n-1);..;f_n(vx.(0),..,vx.(n-1))|</code></p><p>First example: build rec X = a(X,Y) and Y = b(X,Y,Y) let <code>|vx;vy|</code> = mk_rec_calls 2 in let <code>|x;y|</code> = mk_rec <code>|mk_node a [|vx;vy|]; mk_node b [|vx;vy;vy|]|</code></p><p>Another example: nested recursive trees rec Y = b(rec X = a(X,Y),Y,Y) let <code>|vy|</code> = mk_rec_calls 1 in let <code>|vx|</code> = mk_rec_calls 1 in let <code>|x|</code> = mk_rec<code>|mk_node a vx;lift 1 vy|</code> let <code>|y|</code> = mk_rec<code>|mk_node b x;vy;vy|</code> (note the lift to avoid</p></dd></dl><dl><dt class="spec value" id="val-mk_rec"><a href="#val-mk_rec" class="anchor"></a><code><span class="keyword">val</span> mk_rec : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> array</code></dt><dt class="spec value" id="val-lift"><a href="#val-lift" class="anchor"></a><code><span class="keyword">val</span> lift : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lift k t</code> increases of <code>k</code> the free parameters of <code>t</code>. Needed to avoid captures when a tree appears under <code>mk_rec</code></p></dd></dl><dl><dt class="spec value" id="val-is_node"><a href="#val-is_node" class="anchor"></a><code><span class="keyword">val</span> is_node : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-dest_node"><a href="#val-dest_node" class="anchor"></a><code><span class="keyword">val</span> dest_node : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a> array</code></dt><dd><p>Destructors (recursive calls are expanded)</p></dd></dl><dl><dt class="spec value" id="val-dest_param"><a href="#val-dest_param" class="anchor"></a><code><span class="keyword">val</span> dest_param : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int * int</code></dt><dd><p>dest_param is not needed for closed trees (i.e. with no free variable)</p></dd></dl><dl><dt class="spec value" id="val-is_infinite"><a href="#val-is_infinite" class="anchor"></a><code><span class="keyword">val</span> is_infinite : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Tells if a tree has an infinite branch. The first arg is a comparison used to detect already seen elements, hence loops</p></dd></dl><dl><dt class="spec value" id="val-equiv"><a href="#val-equiv" class="anchor"></a><code><span class="keyword">val</span> equiv : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>Rtree.equiv eq eqlab t1 t2</code> compares t1 t2 (top-down). If t1 and t2 are both nodes, <code>eqlab</code> is called on their labels, in case of success deeper nodes are examined. In case of loop (detected via structural equality parametrized by <code>eq</code>), then the comparison is successful.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>Rtree.equal eq t1 t2</code> compares t1 and t2, first via physical equality, then by structural equality (using <code>eq</code> on elements), then by logical equivalence <code>Rtree.equiv eq eq</code></p></dd></dl><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val</span> inter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-incl"><a href="#val-incl" class="anchor"></a><code><span class="keyword">val</span> incl : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl><aside><p>Iterators</p></aside><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>See also <code>Smart.map</code></p></dd></dl><dl><dt class="spec value" id="val-pp_tree"><a href="#val-pp_tree" class="anchor"></a><code><span class="keyword">val</span> pp_tree : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Pp/index.html#type-t">Pp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Pp/index.html#type-t">Pp.t</a></code></dt><dd><p>A rather simple minded pretty-printer</p></dd></dl><div class="spec module" id="module-Smart"><a href="#module-Smart" class="anchor"></a><code><span class="keyword">module</span> <a href="Smart/index.html">Smart</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>