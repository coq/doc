<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Proofview (coq.Proofview)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Proofview</nav><h1>Module <code>Proofview</code></h1><p>This files defines the basic mechanism of proofs: the <code>proofview</code> type is the state which tactics manipulate (a global state for existential variables, together with the list of goals), and the type <code>'a tactic</code> is the (abstract) type of tactics modifying the proof state and returning a value of type <code>'a</code>.</p><nav class="toc"><ul><li><a href="#starting-and-querying-a-proof-view">Starting and querying a proof view</a></li><li><a href="#focusing-commands">Focusing commands</a></li><li><a href="#the-tactic-monad">The tactic monad</a></li><li><a href="#monadic-primitives">Monadic primitives</a></li><li><a href="#failure-and-backtracking">Failure and backtracking</a></li><li><a href="#focusing-tactics">Focusing tactics</a></li><li><a href="#dispatching-on-goals">Dispatching on goals</a></li><li><a href="#goal-manipulation">Goal manipulation</a></li><li><a href="#access-primitives">Access primitives</a></li><li><a href="#put-like-primitives">Put-like primitives</a></li><li><a href="#control-primitives">Control primitives</a></li><li><a href="#unsafe-primitives">Unsafe primitives</a></li><li><a href="#goal-dependent-tactics">Goal-dependent tactics</a></li><li><a href="#trace">Trace</a></li><li><a href="#non-logical-state">Non-logical state</a></li></ul></nav></header><dl><dt class="spec type" id="type-proofview"><a href="#type-proofview" class="anchor"></a><code><span class="keyword">type</span> proofview</code></dt><dd><p>Main state of tactics</p></dd></dl><dl><dt class="spec value" id="val-proofview"><a href="#val-proofview" class="anchor"></a><code><span class="keyword">val</span> proofview : <a href="index.html#type-proofview">proofview</a> <span>&#45;&gt;</span> <a href="../Evar/index.html#type-t">Evar.t</a> list * <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></code></dt><dd><p>Returns a stylised view of a proofview for use by, for instance, ide-s.</p></dd></dl><section><header><h6 id="starting-and-querying-a-proof-view"><a href="#starting-and-querying-a-proof-view" class="anchor"></a>Starting and querying a proof view</h6></header><dl><dt class="spec type" id="type-entry"><a href="#type-entry" class="anchor"></a><code><span class="keyword">type</span> entry</code></dt><dd><p>Abstract representation of the initial goals of a proof.</p></dd></dl><dl><dt class="spec value" id="val-compact"><a href="#val-compact" class="anchor"></a><code><span class="keyword">val</span> compact : <a href="index.html#type-entry">entry</a> <span>&#45;&gt;</span> <a href="index.html#type-proofview">proofview</a> <span>&#45;&gt;</span> <a href="index.html#type-entry">entry</a> * <a href="index.html#type-proofview">proofview</a></code></dt><dd><p>Optimize memory consumption</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> (<a href="../Environ/index.html#type-env">Environ.env</a> * <a href="../EConstr/index.html#type-types">EConstr.types</a>) list <span>&#45;&gt;</span> <a href="index.html#type-entry">entry</a> * <a href="index.html#type-proofview">proofview</a></code></dt><dd><p>Initialises a proofview, the main argument is a list of environments (including a <code>named_context</code> which are used as hypotheses) pair with conclusion types, creating accordingly many initial goals. Because a proof does not necessarily starts in an empty <code>evar_map</code> (indeed a proof can be triggered by an incomplete pretyping), <code>init</code> takes an additional argument to represent the initial <code>evar_map</code>.</p></dd></dl><dl><dt class="spec type" id="type-telescope"><a href="#type-telescope" class="anchor"></a><code><span class="keyword">type</span> telescope</code><code> = </code><table class="variant"><tr id="type-telescope.TNil" class="anchored"><td class="def constructor"><a href="#type-telescope.TNil" class="anchor"></a><code>| </code><code><span class="constructor">TNil</span> <span class="keyword">of</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></code></td></tr><tr id="type-telescope.TCons" class="anchored"><td class="def constructor"><a href="#type-telescope.TCons" class="anchor"></a><code>| </code><code><span class="constructor">TCons</span> <span class="keyword">of</span> <a href="../Environ/index.html#type-env">Environ.env</a> * <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../EConstr/index.html#type-types">EConstr.types</a> * <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span>&#45;&gt;</span> <a href="index.html#type-telescope">telescope</a></code></td></tr></table></dt><dd><p>A <code>telescope</code> is a list of environment and conclusion like in <a href="index.html#val-init"><code>init</code></a>, except that each element may depend on the previous goals. The telescope passes the goals in the form of a <code>Term.constr</code> which represents the goal as an <code>evar</code>. The <code>evar_map</code> is threaded in state passing style.</p></dd></dl><dl><dt class="spec value" id="val-dependent_init"><a href="#val-dependent_init" class="anchor"></a><code><span class="keyword">val</span> dependent_init : <a href="index.html#type-telescope">telescope</a> <span>&#45;&gt;</span> <a href="index.html#type-entry">entry</a> * <a href="index.html#type-proofview">proofview</a></code></dt><dd><p>Like <a href="index.html#val-init"><code>init</code></a>, but goals are allowed to be dependent on one another. Dependencies between goals is represented with the type <code>telescope</code> instead of <code>list</code>. Note that the first <code>evar_map</code> of the telescope plays the role of the <code>evar_map</code> argument in <code>init</code>.</p></dd></dl><dl><dt class="spec value" id="val-finished"><a href="#val-finished" class="anchor"></a><code><span class="keyword">val</span> finished : <a href="index.html#type-proofview">proofview</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>finished pv</code> is <code>true</code> if and only if <code>pv</code> is complete. That is, if it has an empty list of focused goals. There could still be unsolved subgoals, but they would then be out of focus.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <a href="index.html#type-proofview">proofview</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></code></dt><dd><p>Returns the current <code>evar</code> state.</p></dd></dl><dl><dt class="spec value" id="val-partial_proof"><a href="#val-partial_proof" class="anchor"></a><code><span class="keyword">val</span> partial_proof : <a href="index.html#type-entry">entry</a> <span>&#45;&gt;</span> <a href="index.html#type-proofview">proofview</a> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-constr">EConstr.constr</a> list</code></dt><dt class="spec value" id="val-initial_goals"><a href="#val-initial_goals" class="anchor"></a><code><span class="keyword">val</span> initial_goals : <a href="index.html#type-entry">entry</a> <span>&#45;&gt;</span> (<a href="../EConstr/index.html#type-constr">EConstr.constr</a> * <a href="../EConstr/index.html#type-types">EConstr.types</a>) list</code></dt></dl><aside><p>goal &lt;-&gt; goal_with_state</p></aside><dl><dt class="spec value" id="val-with_empty_state"><a href="#val-with_empty_state" class="anchor"></a><code><span class="keyword">val</span> with_empty_state : <a href="../Proofview_monad/index.html#type-goal">Proofview_monad.goal</a> <span>&#45;&gt;</span> <a href="../Proofview_monad/index.html#type-goal_with_state">Proofview_monad.goal_with_state</a></code></dt><dt class="spec value" id="val-drop_state"><a href="#val-drop_state" class="anchor"></a><code><span class="keyword">val</span> drop_state : <a href="../Proofview_monad/index.html#type-goal_with_state">Proofview_monad.goal_with_state</a> <span>&#45;&gt;</span> <a href="../Proofview_monad/index.html#type-goal">Proofview_monad.goal</a></code></dt><dt class="spec value" id="val-goal_with_state"><a href="#val-goal_with_state" class="anchor"></a><code><span class="keyword">val</span> goal_with_state : <a href="../Proofview_monad/index.html#type-goal">Proofview_monad.goal</a> <span>&#45;&gt;</span> <a href="../Proofview_monad/StateStore/index.html#type-t">Proofview_monad.StateStore.t</a> <span>&#45;&gt;</span> <a href="../Proofview_monad/index.html#type-goal_with_state">Proofview_monad.goal_with_state</a></code></dt></dl></section><section><header><h6 id="focusing-commands"><a href="#focusing-commands" class="anchor"></a>Focusing commands</h6></header><dl><dt class="spec type" id="type-focus_context"><a href="#type-focus_context" class="anchor"></a><code><span class="keyword">type</span> focus_context</code></dt><dd><p>A <code>focus_context</code> represents the part of the proof view which has been removed by a focusing action, it can be used to unfocus later on.</p></dd></dl><dl><dt class="spec value" id="val-focus_context"><a href="#val-focus_context" class="anchor"></a><code><span class="keyword">val</span> focus_context : <a href="index.html#type-focus_context">focus_context</a> <span>&#45;&gt;</span> <a href="../Evar/index.html#type-t">Evar.t</a> list * <a href="../Evar/index.html#type-t">Evar.t</a> list</code></dt><dd><p>Returns a stylised view of a focus_context for use by, for instance, ide-s.</p></dd></dl><dl><dt class="spec value" id="val-focus"><a href="#val-focus" class="anchor"></a><code><span class="keyword">val</span> focus : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-proofview">proofview</a> <span>&#45;&gt;</span> <a href="index.html#type-proofview">proofview</a> * <a href="index.html#type-focus_context">focus_context</a></code></dt><dd><p><code>focus i j</code> focuses a proofview on the goals from index <code>i</code> to index <code>j</code> (inclusive, goals are indexed from <code>1</code>). I.e. goals number <code>i</code> to <code>j</code> become the only focused goals of the returned proofview. It returns the focused proofview, and a context for the focus stack.</p></dd></dl><dl><dt class="spec value" id="val-unfocus"><a href="#val-unfocus" class="anchor"></a><code><span class="keyword">val</span> unfocus : <a href="index.html#type-focus_context">focus_context</a> <span>&#45;&gt;</span> <a href="index.html#type-proofview">proofview</a> <span>&#45;&gt;</span> <a href="index.html#type-proofview">proofview</a></code></dt><dd><p>Unfocuses a proofview with respect to a context.</p></dd></dl></section><section><header><h6 id="the-tactic-monad"><a href="#the-tactic-monad" class="anchor"></a>The tactic monad</h6></header><aside><ul><li>Tactics are objects which apply a transformation to all the subgoals of the current view at the same time. By opposition to the old vision of applying it to a single goal. It allows tactics such as <code>shelve_unifiable</code>, tactics to reorder the focused goals, or global automation tactic for dependent subgoals (instantiating an evar has influences on the other goals of the proof in progress, not being able to take that into account causes the current eauto tactic to fail on some instances where it could succeed). Another benefit is that it is possible to write tactics that can be executed even if there are no focused goals.</li><li>Tactics form a monad <code>'a tactic</code>, in a sense a tactic can be seen as a function (without argument) which returns a value of type 'a and modifies the environment (in our case: the view). Tactics of course have arguments, but these are given at the meta-level as OCaml functions. Most tactics in the sense we are used to return <code>()</code>, that is no really interesting values. But some might pass information around. The tactics seen in Coq's Ltac are (for now at least) only <code>unit tactic</code>, the return values are kept for the OCaml toolkit. The operation or the monad are <code>Proofview.tclUNIT</code> (which is the &quot;return&quot; of the tactic monad) <code>Proofview.tclBIND</code> (which is the &quot;bind&quot;) and <code>Proofview.tclTHEN</code> (which is a specialized bind on unit-returning tactics).</li><li>Tactics have support for full-backtracking. Tactics can be seen having multiple success: if after returning the first success a failure is encountered, the tactic can backtrack and use a second success if available. The state is backtracked to its previous value, except the non-logical state defined in the <a href="NonLogical/index.html"><code>NonLogical</code></a> module below.</li></ul></aside><dl><dt class="spec type" id="type-tactic"><a href="#type-tactic" class="anchor"></a><code><span class="keyword">type</span> +'a tactic</code></dt><dd><p>The abstract type of tactics</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : name:<a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> poly:bool <span>&#45;&gt;</span> <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <a href="index.html#type-proofview">proofview</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <a href="index.html#type-proofview">proofview</a> * (bool * <a href="../Evar/index.html#type-t">Evar.t</a> list * <a href="../Evar/index.html#type-t">Evar.t</a> list) * <a href="../Proofview_monad/Info/index.html#type-tree">Proofview_monad.Info.tree</a></code></dt><dd><p>Applies a tactic to the current proofview. Returns a tuple <code>a,pv,(b,sh,gu)</code> where <code>a</code> is the return value of the tactic, <code>pv</code> is the updated proofview, <code>b</code> a boolean which is <code>true</code> if the tactic has not done any action considered unsafe (such as admitting a lemma), <code>sh</code> is the list of goals which have been shelved by the tactic, and <code>gu</code> the list of goals on which the tactic has given up. In case of multiple success the first one is selected. If there is no success, fails with <a href="../Logic_monad/index.html#exception-TacticFailure"><code>Logic_monad.TacticFailure</code></a></p></dd></dl></section><section><header><h6 id="monadic-primitives"><a href="#monadic-primitives" class="anchor"></a>Monadic primitives</h6></header><dl><dt class="spec value" id="val-tclUNIT"><a href="#val-tclUNIT" class="anchor"></a><code><span class="keyword">val</span> tclUNIT : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Unit of the tactic monad.</p></dd></dl><dl><dt class="spec value" id="val-tclBIND"><a href="#val-tclBIND" class="anchor"></a><code><span class="keyword">val</span> tclBIND : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-tactic">tactic</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Bind operation of the tactic monad.</p></dd></dl><dl><dt class="spec value" id="val-tclTHEN"><a href="#val-tclTHEN" class="anchor"></a><code><span class="keyword">val</span> tclTHEN : unit <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Interprets the &quot;;&quot; (semicolon) of Ltac. As a monadic operation, it's a specialized &quot;bind&quot;.</p></dd></dl><dl><dt class="spec value" id="val-tclIGNORE"><a href="#val-tclIGNORE" class="anchor"></a><code><span class="keyword">val</span> tclIGNORE : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclIGNORE t</code> has the same operational content as <code>t</code>, but drops the returned value.</p></dd></dl><dl><dt class="spec module" id="module-Monad"><a href="#module-Monad" class="anchor"></a><code><span class="keyword">module</span> <a href="Monad/index.html">Monad</a> : <a href="../Monad/index.html#module-type-S">Monad.S</a> <span class="keyword">with</span> <span class="keyword">type</span> +'a <a href="../Monad/module-type-S/index.html#type-t">t</a> = <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Generic monadic combinators for tactics.</p></dd></dl></section><section><header><h6 id="failure-and-backtracking"><a href="#failure-and-backtracking" class="anchor"></a>Failure and backtracking</h6></header><dl><dt class="spec value" id="val-tclZERO"><a href="#val-tclZERO" class="anchor"></a><code><span class="keyword">val</span> tclZERO : ?&#8288;info:<a href="../Exninfo/index.html#type-info">Exninfo.info</a> <span>&#45;&gt;</span> exn <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclZERO e</code> fails with exception <code>e</code>. It has no success.</p></dd></dl><dl><dt class="spec value" id="val-tclOR"><a href="#val-tclOR" class="anchor"></a><code><span class="keyword">val</span> tclOR : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> (<a href="../Util/index.html#type-iexn">Util.iexn</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclOR t1 t2</code> behaves like <code>t1</code> as long as <code>t1</code> succeeds. Whenever the successes of <code>t1</code> have been depleted and it failed with <code>e</code>, then it behaves as <code>t2 e</code>. In other words, <code>tclOR</code> inserts a backtracking point.</p></dd></dl><dl><dt class="spec value" id="val-tclORELSE"><a href="#val-tclORELSE" class="anchor"></a><code><span class="keyword">val</span> tclORELSE : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> (<a href="../Util/index.html#type-iexn">Util.iexn</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclORELSE t1 t2</code> is equal to <code>t1</code> if <code>t1</code> has at least one success or <code>t2 e</code> if <code>t1</code> fails with <code>e</code>. It is analogous to <code>try/with</code> handler of exception in that it is not a backtracking point.</p></dd></dl><dl><dt class="spec value" id="val-tclIFCATCH"><a href="#val-tclIFCATCH" class="anchor"></a><code><span class="keyword">val</span> tclIFCATCH : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-tactic">tactic</a>) <span>&#45;&gt;</span> (<a href="../Util/index.html#type-iexn">Util.iexn</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-tactic">tactic</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclIFCATCH a s f</code> is a generalisation of <a href="index.html#val-tclORELSE"><code>tclORELSE</code></a>: if <code>a</code> succeeds at least once then it behaves as <code>tclBIND a s</code> otherwise, if <code>a</code> fails with <code>e</code>, then it behaves as <code>f e</code>.</p></dd></dl><dl><dt class="spec value" id="val-tclONCE"><a href="#val-tclONCE" class="anchor"></a><code><span class="keyword">val</span> tclONCE : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclONCE t</code> behave like <code>t</code> except it has at most one success: <code>tclONCE t</code> stops after the first success of <code>t</code>. If <code>t</code> fails with <code>e</code>, <code>tclONCE t</code> also fails with <code>e</code>.</p></dd></dl><dl><dt class="spec exception" id="exception-MoreThanOneSuccess"><a href="#exception-MoreThanOneSuccess" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">MoreThanOneSuccess</span></code></dt><dd><p><code>tclEXACTLY_ONCE e t</code> succeeds as <code>t</code> if <code>t</code> has exactly one success. Otherwise it fails. The tactic <code>t</code> is run until its first success, then a failure with exception <code>e</code> is simulated. It <code>t</code> yields another success, then <code>tclEXACTLY_ONCE e t</code> fails with <code>MoreThanOneSuccess</code> (it is a user error). Otherwise, <code>tclEXACTLY_ONCE e t</code> succeeds with the first success of <code>t</code>. Notice that the choice of <code>e</code> is relevant, as the presence of further successes may depend on <code>e</code> (see <a href="index.html#val-tclOR"><code>tclOR</code></a>).</p></dd></dl><dl><dt class="spec value" id="val-tclEXACTLY_ONCE"><a href="#val-tclEXACTLY_ONCE" class="anchor"></a><code><span class="keyword">val</span> tclEXACTLY_ONCE : exn <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt></dl><dl><dt class="spec type" id="type-case"><a href="#type-case" class="anchor"></a><code><span class="keyword">type</span> 'a case</code><code> = </code><table class="variant"><tr id="type-case.Fail" class="anchored"><td class="def constructor"><a href="#type-case.Fail" class="anchor"></a><code>| </code><code><span class="constructor">Fail</span> <span class="keyword">of</span> <a href="../Util/index.html#type-iexn">Util.iexn</a></code></td></tr><tr id="type-case.Next" class="anchored"><td class="def constructor"><a href="#type-case.Next" class="anchor"></a><code>| </code><code><span class="constructor">Next</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <a href="../Util/index.html#type-iexn">Util.iexn</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></td></tr></table></dt><dd><p><code>tclCASE t</code> splits <code>t</code> into its first success and a continuation. It is the most general primitive to control backtracking.</p></dd></dl><dl><dt class="spec value" id="val-tclCASE"><a href="#val-tclCASE" class="anchor"></a><code><span class="keyword">val</span> tclCASE : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-case">case</a> <a href="index.html#type-tactic">tactic</a></code></dt><dt class="spec value" id="val-tclBREAK"><a href="#val-tclBREAK" class="anchor"></a><code><span class="keyword">val</span> tclBREAK : (<a href="../Util/index.html#type-iexn">Util.iexn</a> <span>&#45;&gt;</span> <a href="../Util/index.html#type-iexn">Util.iexn</a> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclBREAK p t</code> is a generalization of <code>tclONCE t</code>. Instead of stopping after the first success, it succeeds like <code>t</code> until a failure with an exception <code>e</code> such that <code>p e = Some e'</code> is raised. At which point it drops the remaining successes, failing with <code>e'</code>. <code>tclONCE t</code> is equivalent to <code>tclBREAK (fun e -&gt; Some e) t</code>.</p></dd></dl></section><section><header><h6 id="focusing-tactics"><a href="#focusing-tactics" class="anchor"></a>Focusing tactics</h6></header><dl><dt class="spec exception" id="exception-NoSuchGoals"><a href="#exception-NoSuchGoals" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">NoSuchGoals</span> <span class="keyword">of</span> int</code></dt><dd><p><code>tclFOCUS i j t</code> applies <code>t</code> after focusing on the goals number <code>i</code> to <code>j</code> (see <a href="index.html#val-focus"><code>focus</code></a>). The rest of the goals is restored after the tactic action. If the specified range doesn't correspond to existing goals, fails with the <code>nosuchgoal</code> argument, by default raising <code>NoSuchGoals</code> (a user error). This exception is caught at toplevel with a default message.</p></dd></dl><dl><dt class="spec value" id="val-tclFOCUS"><a href="#val-tclFOCUS" class="anchor"></a><code><span class="keyword">val</span> tclFOCUS : ?&#8288;nosuchgoal:<span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dt class="spec value" id="val-tclFOCUSLIST"><a href="#val-tclFOCUSLIST" class="anchor"></a><code><span class="keyword">val</span> tclFOCUSLIST : ?&#8288;nosuchgoal:<span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> (int * int) list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclFOCUSLIST li t</code> applies <code>t</code> on the list of focused goals described by <code>li</code>. Each element of <code>li</code> is a pair <code>(i, j)</code> denoting the goals numbered from <code>i</code> to <code>j</code> (inclusive, starting from 1). It will try to apply <code>t</code> to all the valid goals in any of these intervals. If the set of such goals is not a single range, then it will move goals such that it is a single range. (So, for instance, <code>[1, 3-5]; idtac.</code> is not the identity.) If the set of such goals is empty, it will fail with <code>nosuchgoal</code>, by default raising <code>NoSuchGoals 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-tclFOCUSID"><a href="#val-tclFOCUSID" class="anchor"></a><code><span class="keyword">val</span> tclFOCUSID : ?&#8288;nosuchgoal:<span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclFOCUSID x t</code> applies <code>t</code> on a (single) focused goal like <a href="index.html#val-tclFOCUS"><code>tclFOCUS</code></a>. The goal is found by its name rather than its number. Fails with <code>nosuchgoal</code>, by default raising <code>NoSuchGoals 1</code>.</p></dd></dl><dl><dt class="spec value" id="val-tclTRYFOCUS"><a href="#val-tclTRYFOCUS" class="anchor"></a><code><span class="keyword">val</span> tclTRYFOCUS : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclTRYFOCUS i j t</code> behaves like <a href="index.html#val-tclFOCUS"><code>tclFOCUS</code></a>, except that if the specified range doesn't correspond to existing goals, behaves like <code>tclUNIT ()</code> instead of failing.</p></dd></dl></section><section><header><h6 id="dispatching-on-goals"><a href="#dispatching-on-goals" class="anchor"></a>Dispatching on goals</h6></header><dl><dt class="spec exception" id="exception-SizeMismatch"><a href="#exception-SizeMismatch" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">SizeMismatch</span> <span class="keyword">of</span> int * int</code></dt><dd><p>Dispatch tacticals are used to apply a different tactic to each goal under focus. They come in two flavours: <code>tclDISPATCH</code> takes a list of <code>unit tactic</code>-s and build a <code>unit tactic</code>. <code>tclDISPATCHL</code> takes a list of <code>'a tactic</code> and returns an <code>'a list tactic</code>.</p><p>They both work by applying each of the tactic in a focus restricted to the corresponding goal (starting with the first goal). In the case of <code>tclDISPATCHL</code>, the tactic returns a list of the same size as the argument list (of tactics), each element being the result of the tactic executed in the corresponding goal.</p><p>When the length of the tactic list is not the number of goal, raises <code>SizeMismatch (g,t)</code> where <code>g</code> is the number of available goals, and <code>t</code> the number of tactics passed.</p></dd></dl><dl><dt class="spec value" id="val-tclDISPATCH"><a href="#val-tclDISPATCH" class="anchor"></a><code><span class="keyword">val</span> tclDISPATCH : unit <a href="index.html#type-tactic">tactic</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a></code></dt><dt class="spec value" id="val-tclDISPATCHL"><a href="#val-tclDISPATCHL" class="anchor"></a><code><span class="keyword">val</span> tclDISPATCHL : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-tactic">tactic</a></code></dt><dt class="spec value" id="val-tclEXTEND"><a href="#val-tclEXTEND" class="anchor"></a><code><span class="keyword">val</span> tclEXTEND : unit <a href="index.html#type-tactic">tactic</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclEXTEND b r e</code> is a variant of <a href="index.html#val-tclDISPATCH"><code>tclDISPATCH</code></a>, where the <code>r</code> tactic is &quot;repeated&quot; enough time such that every goal has a tactic assigned to it (<code>b</code> is the list of tactics applied to the first goals, <code>e</code> to the last goals, and <code>r</code> is applied to every goal in between).</p></dd></dl><dl><dt class="spec value" id="val-tclINDEPENDENT"><a href="#val-tclINDEPENDENT" class="anchor"></a><code><span class="keyword">val</span> tclINDEPENDENT : unit <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclINDEPENDENT tac</code> runs <code>tac</code> on each goal successively, from the first one to the last one. Backtracking in one goal is independent of backtracking in another. It is equivalent to <code>tclEXTEND [] tac []</code>.</p></dd></dl><dl><dt class="spec value" id="val-tclINDEPENDENTL"><a href="#val-tclINDEPENDENTL" class="anchor"></a><code><span class="keyword">val</span> tclINDEPENDENTL : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-tactic">tactic</a></code></dt></dl></section><section><header><h6 id="goal-manipulation"><a href="#goal-manipulation" class="anchor"></a>Goal manipulation</h6></header><dl><dt class="spec value" id="val-shelve"><a href="#val-shelve" class="anchor"></a><code><span class="keyword">val</span> shelve : unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Shelves all the goals under focus. The goals are placed on the shelf for later use (or being solved by side-effects).</p></dd></dl><dl><dt class="spec value" id="val-shelve_goals"><a href="#val-shelve_goals" class="anchor"></a><code><span class="keyword">val</span> shelve_goals : <a href="../Evar/index.html#type-t">Evar.t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Shelves the given list of goals, which might include some that are under focus and some that aren't. All the goals are placed on the shelf for later use (or being solved by side-effects).</p></dd></dl><dl><dt class="spec value" id="val-unifiable"><a href="#val-unifiable" class="anchor"></a><code><span class="keyword">val</span> unifiable : <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../Evar/index.html#type-t">Evar.t</a> <span>&#45;&gt;</span> <a href="../Evar/index.html#type-t">Evar.t</a> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>unifiable sigma g l</code> checks whether <code>g</code> appears in another subgoal of <code>l</code>. The list <code>l</code> may contain <code>g</code>, but it does not affect the result. Used by <code>shelve_unifiable</code>.</p></dd></dl><dl><dt class="spec value" id="val-shelve_unifiable"><a href="#val-shelve_unifiable" class="anchor"></a><code><span class="keyword">val</span> shelve_unifiable : unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Shelves the unifiable goals under focus, i.e. the goals which appear in other goals under focus (the unfocused goals are not considered).</p></dd></dl><dl><dt class="spec value" id="val-shelve_unifiable_informative"><a href="#val-shelve_unifiable_informative" class="anchor"></a><code><span class="keyword">val</span> shelve_unifiable_informative : <a href="../Evar/index.html#type-t">Evar.t</a> list <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Idem but also returns the list of shelved variables</p></dd></dl><dl><dt class="spec value" id="val-guard_no_unifiable"><a href="#val-guard_no_unifiable" class="anchor"></a><code><span class="keyword">val</span> guard_no_unifiable : <a href="../Names/Name/index.html#type-t">Names.Name.t</a> list option <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>guard_no_unifiable</code> returns the list of unifiable goals if some goals are unifiable (see <a href="index.html#val-shelve_unifiable"><code>shelve_unifiable</code></a>) in the current focus.</p></dd></dl><dl><dt class="spec value" id="val-unshelve"><a href="#val-unshelve" class="anchor"></a><code><span class="keyword">val</span> unshelve : <a href="../Evar/index.html#type-t">Evar.t</a> list <span>&#45;&gt;</span> <a href="index.html#type-proofview">proofview</a> <span>&#45;&gt;</span> <a href="index.html#type-proofview">proofview</a></code></dt><dd><p><code>unshelve l p</code> adds all the goals in <code>l</code> at the end of the focused goals of p</p></dd></dl><dl><dt class="spec value" id="val-depends_on"><a href="#val-depends_on" class="anchor"></a><code><span class="keyword">val</span> depends_on : <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../Evar/index.html#type-t">Evar.t</a> <span>&#45;&gt;</span> <a href="../Evar/index.html#type-t">Evar.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>depends_on g1 g2 sigma</code> checks if g1 occurs in the type/ctx of g2</p></dd></dl><dl><dt class="spec value" id="val-with_shelf"><a href="#val-with_shelf" class="anchor"></a><code><span class="keyword">val</span> with_shelf : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> (<a href="../Evar/index.html#type-t">Evar.t</a> list * <span class="type-var">'a</span>) <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>with_shelf tac</code> executes <code>tac</code> and returns its result together with the set of goals shelved by <code>tac</code>. The current shelf is unchanged and the returned list contains only unsolved goals.</p></dd></dl><dl><dt class="spec value" id="val-cycle"><a href="#val-cycle" class="anchor"></a><code><span class="keyword">val</span> cycle : int <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>If <code>n</code> is positive, <code>cycle n</code> puts the <code>n</code> first goal last. If <code>n</code> is negative, then it puts the <code>n</code> last goals first.</p></dd></dl><dl><dt class="spec value" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span class="keyword">val</span> swap : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>swap i j</code> swaps the position of goals number <code>i</code> and <code>j</code> (negative numbers can be used to address goals from the end. Goals are indexed from <code>1</code>. For simplicity index <code>0</code> corresponds to goal <code>1</code> as well, rather than raising an error.</p></dd></dl><dl><dt class="spec value" id="val-revgoals"><a href="#val-revgoals" class="anchor"></a><code><span class="keyword">val</span> revgoals : unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>revgoals</code> reverses the list of focused goals.</p></dd></dl><dl><dt class="spec value" id="val-numgoals"><a href="#val-numgoals" class="anchor"></a><code><span class="keyword">val</span> numgoals : int <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>numgoals</code> returns the number of goals under focus.</p></dd></dl></section><section><header><h6 id="access-primitives"><a href="#access-primitives" class="anchor"></a>Access primitives</h6></header><dl><dt class="spec value" id="val-tclEVARMAP"><a href="#val-tclEVARMAP" class="anchor"></a><code><span class="keyword">val</span> tclEVARMAP : <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclEVARMAP</code> doesn't affect the proof, it returns the current <code>evar_map</code>.</p></dd></dl><dl><dt class="spec value" id="val-tclENV"><a href="#val-tclENV" class="anchor"></a><code><span class="keyword">val</span> tclENV : <a href="../Environ/index.html#type-env">Environ.env</a> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclENV</code> doesn't affect the proof, it returns the current environment. It is not the environment of a particular goal, rather the &quot;global&quot; environment of the proof. The goal-wise environment is obtained via <a href="Goal/index.html#val-env"><code>Proofview.Goal.env</code></a>.</p></dd></dl></section><section><header><h6 id="put-like-primitives"><a href="#put-like-primitives" class="anchor"></a>Put-like primitives</h6></header><dl><dt class="spec value" id="val-tclEFFECTS"><a href="#val-tclEFFECTS" class="anchor"></a><code><span class="keyword">val</span> tclEFFECTS : <a href="../Evd/index.html#type-side_effects">Evd.side_effects</a> <span>&#45;&gt;</span> unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclEFFECTS eff</code> add the effects <code>eff</code> to the current state.</p></dd></dl><dl><dt class="spec value" id="val-mark_as_unsafe"><a href="#val-mark_as_unsafe" class="anchor"></a><code><span class="keyword">val</span> mark_as_unsafe : unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>mark_as_unsafe</code> declares the current tactic is unsafe.</p></dd></dl><dl><dt class="spec value" id="val-give_up"><a href="#val-give_up" class="anchor"></a><code><span class="keyword">val</span> give_up : unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Gives up on the goal under focus. Reports an unsafe status. Proofs with given up goals cannot be closed.</p></dd></dl></section><section><header><h6 id="control-primitives"><a href="#control-primitives" class="anchor"></a>Control primitives</h6></header><dl><dt class="spec value" id="val-tclPROGRESS"><a href="#val-tclPROGRESS" class="anchor"></a><code><span class="keyword">val</span> tclPROGRESS : <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclPROGRESS t</code> checks the state of the proof after <code>t</code>. It it is identical to the state before, then <code>tclPROGRESS t</code> fails, otherwise it succeeds like <code>t</code>.</p></dd></dl><div class="spec module" id="module-Progress"><a href="#module-Progress" class="anchor"></a><code><span class="keyword">module</span> <a href="Progress/index.html">Progress</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-tclCHECKINTERRUPT"><a href="#val-tclCHECKINTERRUPT" class="anchor"></a><code><span class="keyword">val</span> tclCHECKINTERRUPT : unit <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Checks for interrupts</p></dd></dl><dl><dt class="spec value" id="val-tclTIMEOUT"><a href="#val-tclTIMEOUT" class="anchor"></a><code><span class="keyword">val</span> tclTIMEOUT : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclTIMEOUT n t</code> can have only one success. In case of timeout if fails with <code>tclZERO Timeout</code>.</p></dd></dl><dl><dt class="spec value" id="val-tclTIME"><a href="#val-tclTIME" class="anchor"></a><code><span class="keyword">val</span> tclTIME : string option <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclTIME s t</code> displays time for each atomic call to t, using s as an identifying annotation if present</p></dd></dl><dl><dt class="spec value" id="val-tclProofInfo"><a href="#val-tclProofInfo" class="anchor"></a><code><span class="keyword">val</span> tclProofInfo : (<a href="../Names/Id/index.html#type-t">Names.Id.t</a> * bool) <a href="index.html#type-tactic">tactic</a></code></dt><dd><p>Internal, don't use.</p></dd></dl></section><section><header><h6 id="unsafe-primitives"><a href="#unsafe-primitives" class="anchor"></a>Unsafe primitives</h6></header><dl><dt class="spec module" id="module-Unsafe"><a href="#module-Unsafe" class="anchor"></a><code><span class="keyword">module</span> <a href="Unsafe/index.html">Unsafe</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The primitives in the <code>Unsafe</code> module should be avoided as much as possible, since they can make the proof state inconsistent. They are nevertheless helpful, in particular when interfacing the pretyping and the proof engine.</p></dd></dl><dl><dt class="spec module" id="module-UnsafeRepr"><a href="#module-UnsafeRepr" class="anchor"></a><code><span class="keyword">module</span> <a href="UnsafeRepr/index.html">UnsafeRepr</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module gives access to the innards of the monad. Its use is restricted to very specific cases.</p></dd></dl></section><section><header><h6 id="goal-dependent-tactics"><a href="#goal-dependent-tactics" class="anchor"></a>Goal-dependent tactics</h6></header><div class="spec module" id="module-Goal"><a href="#module-Goal" class="anchor"></a><code><span class="keyword">module</span> <a href="Goal/index.html">Goal</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h6 id="trace"><a href="#trace" class="anchor"></a>Trace</h6></header><div class="spec module" id="module-Trace"><a href="#module-Trace" class="anchor"></a><code><span class="keyword">module</span> <a href="Trace/index.html">Trace</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h6 id="non-logical-state"><a href="#non-logical-state" class="anchor"></a>Non-logical state</h6></header><dl><dt class="spec module" id="module-NonLogical"><a href="#module-NonLogical" class="anchor"></a><code><span class="keyword">module</span> <a href="NonLogical/index.html">NonLogical</a> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../Logic_monad/index.html#module-NonLogical">Logic_monad.NonLogical</a></code></dt><dd><p>The <code>NonLogical</code> module allows the execution of effects (including I/O) in tactics (non-logical side-effects are not discarded at failures).</p></dd></dl><dl><dt class="spec value" id="val-tclLIFT"><a href="#val-tclLIFT" class="anchor"></a><code><span class="keyword">val</span> tclLIFT : <span class="type-var">'a</span> <a href="../Logic_monad/NonLogical/index.html#type-t">NonLogical.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-tactic">tactic</a></code></dt><dd><p><code>tclLIFT c</code> is a tactic which behaves exactly as <code>c</code>.</p></dd></dl></section></div></body></html>