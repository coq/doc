<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Declarations (coq.Declarations)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">coq</a> &#x00BB; Declarations</nav><h1>Module <code>Declarations</code></h1><p>This module defines the internal representation of global declarations. This includes global constants/axioms, mutual inductive definitions, modules and module types</p><nav class="toc"><ul><li><a href="#representation-of-constants-(definition/axiom)">Representation of constants (Definition/Axiom)</a></li><li><a href="#representation-of-mutual-inductive-types-in-the-kernel">Representation of mutual inductive types in the kernel</a></li><li><a href="#module-declarations">Module declarations</a></li></ul></nav></header><dl><dt class="spec type" id="type-set_predicativity"><a href="#type-set_predicativity" class="anchor"></a><code><span class="keyword">type</span> set_predicativity</code><code> = </code><table class="variant"><tr id="type-set_predicativity.ImpredicativeSet" class="anchored"><td class="def constructor"><a href="#type-set_predicativity.ImpredicativeSet" class="anchor"></a><code>| </code><code><span class="constructor">ImpredicativeSet</span></code></td></tr><tr id="type-set_predicativity.PredicativeSet" class="anchored"><td class="def constructor"><a href="#type-set_predicativity.PredicativeSet" class="anchor"></a><code>| </code><code><span class="constructor">PredicativeSet</span></code></td></tr></table></dt><dt class="spec type" id="type-engagement"><a href="#type-engagement" class="anchor"></a><code><span class="keyword">type</span> engagement</code><code> = <a href="index.html#type-set_predicativity">set_predicativity</a></code></dt></dl><section><header><h6 id="representation-of-constants-(definition/axiom)"><a href="#representation-of-constants-(definition/axiom)" class="anchor"></a>Representation of constants (Definition/Axiom)</h6></header><aside><p>Non-universe polymorphic mode polymorphism (Coq 8.2+): inductives and constants hiding inductives are implicitly polymorphic when applied to parameters, on the universes appearing in the whnf of their parameters and their conclusion, in a template style.</p><p>In truly universe polymorphic mode, we always use RegularArity.</p></aside><dl><dt class="spec type" id="type-template_arity"><a href="#type-template_arity" class="anchor"></a><code><span class="keyword">type</span> template_arity</code><code> = </code><code>{</code><table class="record"><tr id="type-template_arity.template_param_levels" class="anchored"><td class="def field"><a href="#type-template_arity.template_param_levels" class="anchor"></a><code>template_param_levels : <a href="../Univ/Level/index.html#type-t">Univ.Level.t</a> option list;</code></td></tr><tr id="type-template_arity.template_level" class="anchored"><td class="def field"><a href="#type-template_arity.template_level" class="anchor"></a><code>template_level : <a href="../Univ/Universe/index.html#type-t">Univ.Universe.t</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-declaration_arity"><a href="#type-declaration_arity" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b) declaration_arity</code><code> = </code><table class="variant"><tr id="type-declaration_arity.RegularArity" class="anchored"><td class="def constructor"><a href="#type-declaration_arity.RegularArity" class="anchor"></a><code>| </code><code><span class="constructor">RegularArity</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-declaration_arity.TemplateArity" class="anchored"><td class="def constructor"><a href="#type-declaration_arity.TemplateArity" class="anchor"></a><code>| </code><code><span class="constructor">TemplateArity</span> <span class="keyword">of</span> <span class="type-var">'b</span></code></td></tr></table></dt></dl><aside><p>Inlining level of parameters at functor applications. None means no inlining</p></aside><dl><dt class="spec type" id="type-inline"><a href="#type-inline" class="anchor"></a><code><span class="keyword">type</span> inline</code><code> = int option</code></dt></dl><aside><p>A constant can have no body (axiom/parameter), or a transparent body, or an opaque one</p></aside><dl><dt class="spec type" id="type-constant_def"><a href="#type-constant_def" class="anchor"></a><code><span class="keyword">type</span> ('a, 'opaque) constant_def</code><code> = </code><table class="variant"><tr id="type-constant_def.Undef" class="anchored"><td class="def constructor"><a href="#type-constant_def.Undef" class="anchor"></a><code>| </code><code><span class="constructor">Undef</span> <span class="keyword">of</span> <a href="index.html#type-inline">inline</a></code></td><td class="doc"><p>a global assumption</p></td></tr><tr id="type-constant_def.Def" class="anchored"><td class="def constructor"><a href="#type-constant_def.Def" class="anchor"></a><code>| </code><code><span class="constructor">Def</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td><td class="doc"><p>or a transparent global definition</p></td></tr><tr id="type-constant_def.OpaqueDef" class="anchored"><td class="def constructor"><a href="#type-constant_def.OpaqueDef" class="anchor"></a><code>| </code><code><span class="constructor">OpaqueDef</span> <span class="keyword">of</span> <span class="type-var">'opaque</span></code></td><td class="doc"><p>or an opaque global definition</p></td></tr><tr id="type-constant_def.Primitive" class="anchored"><td class="def constructor"><a href="#type-constant_def.Primitive" class="anchor"></a><code>| </code><code><span class="constructor">Primitive</span> <span class="keyword">of</span> <a href="../CPrimitives/index.html#type-t">CPrimitives.t</a></code></td><td class="doc"><p>or a primitive operation</p></td></tr></table></dt><dt class="spec type" id="type-universes"><a href="#type-universes" class="anchor"></a><code><span class="keyword">type</span> universes</code><code> = </code><table class="variant"><tr id="type-universes.Monomorphic" class="anchored"><td class="def constructor"><a href="#type-universes.Monomorphic" class="anchor"></a><code>| </code><code><span class="constructor">Monomorphic</span> <span class="keyword">of</span> <a href="../Univ/ContextSet/index.html#type-t">Univ.ContextSet.t</a></code></td></tr><tr id="type-universes.Polymorphic" class="anchored"><td class="def constructor"><a href="#type-universes.Polymorphic" class="anchor"></a><code>| </code><code><span class="constructor">Polymorphic</span> <span class="keyword">of</span> <a href="../Univ/AUContext/index.html#type-t">Univ.AUContext.t</a></code></td></tr></table></dt><dt class="spec type" id="type-typing_flags"><a href="#type-typing_flags" class="anchor"></a><code><span class="keyword">type</span> typing_flags</code><code> = </code><code>{</code><table class="record"><tr id="type-typing_flags.check_guarded" class="anchored"><td class="def field"><a href="#type-typing_flags.check_guarded" class="anchor"></a><code>check_guarded : bool;</code></td><td class="doc"><p>If <code>false</code> then fixed points and co-fixed points are assumed to be total.</p></td></tr><tr id="type-typing_flags.check_positive" class="anchored"><td class="def field"><a href="#type-typing_flags.check_positive" class="anchor"></a><code>check_positive : bool;</code></td><td class="doc"><p>If <code>false</code> then inductive types are assumed positive and co-inductive types are assumed productive.</p></td></tr><tr id="type-typing_flags.check_universes" class="anchored"><td class="def field"><a href="#type-typing_flags.check_universes" class="anchor"></a><code>check_universes : bool;</code></td><td class="doc"><p>If <code>false</code> universe constraints are not checked</p></td></tr><tr id="type-typing_flags.conv_oracle" class="anchored"><td class="def field"><a href="#type-typing_flags.conv_oracle" class="anchor"></a><code>conv_oracle : <a href="../Conv_oracle/index.html#type-oracle">Conv_oracle.oracle</a>;</code></td><td class="doc"><p>Unfolding strategies for conversion</p></td></tr><tr id="type-typing_flags.share_reduction" class="anchored"><td class="def field"><a href="#type-typing_flags.share_reduction" class="anchor"></a><code>share_reduction : bool;</code></td><td class="doc"><p>Use by-need reduction algorithm</p></td></tr><tr id="type-typing_flags.enable_VM" class="anchored"><td class="def field"><a href="#type-typing_flags.enable_VM" class="anchor"></a><code>enable_VM : bool;</code></td><td class="doc"><p>If <code>false</code>, all VM conversions fall back to interpreted ones</p></td></tr><tr id="type-typing_flags.enable_native_compiler" class="anchored"><td class="def field"><a href="#type-typing_flags.enable_native_compiler" class="anchor"></a><code>enable_native_compiler : bool;</code></td><td class="doc"><p>If <code>false</code>, all native conversions fall back to VM ones</p></td></tr><tr id="type-typing_flags.indices_matter" class="anchored"><td class="def field"><a href="#type-typing_flags.indices_matter" class="anchor"></a><code>indices_matter : bool;</code></td><td class="doc"><p>The universe of an inductive type must be above that of its indices.</p></td></tr></table><code>}</code></dt><dd><p>The <code>typing_flags</code> are instructions to the type-checker which modify its behaviour. The typing flags used in the type-checking of a constant are tracked in their <a href="index.html#type-constant_body"><code>constant_body</code></a> so that they can be displayed to the user.</p></dd></dl><dl><dt class="spec type" id="type-constant_body"><a href="#type-constant_body" class="anchor"></a><code><span class="keyword">type</span> 'opaque constant_body</code><code> = </code><code>{</code><table class="record"><tr id="type-constant_body.const_hyps" class="anchored"><td class="def field"><a href="#type-constant_body.const_hyps" class="anchor"></a><code>const_hyps : <a href="../Constr/index.html#type-named_context">Constr.named_context</a>;</code></td><td class="doc"><p>New: younger hyp at top</p></td></tr><tr id="type-constant_body.const_body" class="anchored"><td class="def field"><a href="#type-constant_body.const_body" class="anchor"></a><code>const_body : (<a href="../Constr/index.html#type-t">Constr.t</a> <a href="../Mod_subst/index.html#type-substituted">Mod_subst.substituted</a>, <span class="type-var">'opaque</span>) <a href="index.html#type-constant_def">constant_def</a>;</code></td></tr><tr id="type-constant_body.const_type" class="anchored"><td class="def field"><a href="#type-constant_body.const_type" class="anchor"></a><code>const_type : <a href="../Constr/index.html#type-types">Constr.types</a>;</code></td></tr><tr id="type-constant_body.const_relevance" class="anchored"><td class="def field"><a href="#type-constant_body.const_relevance" class="anchor"></a><code>const_relevance : <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a>;</code></td></tr><tr id="type-constant_body.const_body_code" class="anchored"><td class="def field"><a href="#type-constant_body.const_body_code" class="anchor"></a><code>const_body_code : <a href="../Cemitcodes/index.html#type-to_patch_substituted">Cemitcodes.to_patch_substituted</a> option;</code></td></tr><tr id="type-constant_body.const_universes" class="anchored"><td class="def field"><a href="#type-constant_body.const_universes" class="anchor"></a><code>const_universes : <a href="index.html#type-universes">universes</a>;</code></td></tr><tr id="type-constant_body.const_inline_code" class="anchored"><td class="def field"><a href="#type-constant_body.const_inline_code" class="anchor"></a><code>const_inline_code : bool;</code></td></tr><tr id="type-constant_body.const_typing_flags" class="anchored"><td class="def field"><a href="#type-constant_body.const_typing_flags" class="anchor"></a><code>const_typing_flags : <a href="index.html#type-typing_flags">typing_flags</a>;</code></td><td class="doc"><p>The typing options which were used for type-checking.</p></td></tr></table><code>}</code></dt></dl></section><section><header><h6 id="representation-of-mutual-inductive-types-in-the-kernel"><a href="#representation-of-mutual-inductive-types-in-the-kernel" class="anchor"></a>Representation of mutual inductive types in the kernel</h6></header><dl><dt class="spec type" id="type-recarg"><a href="#type-recarg" class="anchor"></a><code><span class="keyword">type</span> recarg</code><code> = </code><table class="variant"><tr id="type-recarg.Norec" class="anchored"><td class="def constructor"><a href="#type-recarg.Norec" class="anchor"></a><code>| </code><code><span class="constructor">Norec</span></code></td></tr><tr id="type-recarg.Mrec" class="anchored"><td class="def constructor"><a href="#type-recarg.Mrec" class="anchor"></a><code>| </code><code><span class="constructor">Mrec</span> <span class="keyword">of</span> <a href="../Names/index.html#type-inductive">Names.inductive</a></code></td></tr><tr id="type-recarg.Imbr" class="anchored"><td class="def constructor"><a href="#type-recarg.Imbr" class="anchor"></a><code>| </code><code><span class="constructor">Imbr</span> <span class="keyword">of</span> <a href="../Names/index.html#type-inductive">Names.inductive</a></code></td></tr></table></dt><dt class="spec type" id="type-wf_paths"><a href="#type-wf_paths" class="anchor"></a><code><span class="keyword">type</span> wf_paths</code><code> = <a href="index.html#type-recarg">recarg</a> <a href="../Rtree/index.html#type-t">Rtree.t</a></code></dt></dl><aside><pre>   Inductive I1 (params) : U1 := c11 : T11 | ... | c1p1 : T1p1
   ...
   with      In (params) : Un := cn1 : Tn1 | ... | cnpn : Tnpn</pre></aside><aside><p>Record information: If the type is not a record, then NotRecord If the type is a non-primitive record, then FakeRecord If it is a primitive record, for every type in the block, we get:</p><ul><li>The identifier for the binder name of the record in primitive projections.</li><li>The constants associated to each projection.</li><li>The projection types (under parameters).</li></ul><p>The kernel does not exploit the difference between <code>NotRecord</code> and <code>FakeRecord</code>. It is mostly used by extraction, and should be extruded from the kernel at some point.</p></aside><dl><dt class="spec type" id="type-record_info"><a href="#type-record_info" class="anchor"></a><code><span class="keyword">type</span> record_info</code><code> = </code><table class="variant"><tr id="type-record_info.NotRecord" class="anchored"><td class="def constructor"><a href="#type-record_info.NotRecord" class="anchor"></a><code>| </code><code><span class="constructor">NotRecord</span></code></td></tr><tr id="type-record_info.FakeRecord" class="anchored"><td class="def constructor"><a href="#type-record_info.FakeRecord" class="anchor"></a><code>| </code><code><span class="constructor">FakeRecord</span></code></td></tr><tr id="type-record_info.PrimRecord" class="anchored"><td class="def constructor"><a href="#type-record_info.PrimRecord" class="anchor"></a><code>| </code><code><span class="constructor">PrimRecord</span> <span class="keyword">of</span> (<a href="../Names/Id/index.html#type-t">Names.Id.t</a> * <a href="../Names/Label/index.html#type-t">Names.Label.t</a> array * <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a> array * <a href="../Constr/index.html#type-types">Constr.types</a> array) array</code></td></tr></table></dt><dt class="spec type" id="type-regular_inductive_arity"><a href="#type-regular_inductive_arity" class="anchor"></a><code><span class="keyword">type</span> regular_inductive_arity</code><code> = </code><code>{</code><table class="record"><tr id="type-regular_inductive_arity.mind_user_arity" class="anchored"><td class="def field"><a href="#type-regular_inductive_arity.mind_user_arity" class="anchor"></a><code>mind_user_arity : <a href="../Constr/index.html#type-types">Constr.types</a>;</code></td></tr><tr id="type-regular_inductive_arity.mind_sort" class="anchored"><td class="def field"><a href="#type-regular_inductive_arity.mind_sort" class="anchor"></a><code>mind_sort : <a href="../Sorts/index.html#type-t">Sorts.t</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-inductive_arity"><a href="#type-inductive_arity" class="anchor"></a><code><span class="keyword">type</span> inductive_arity</code><code> = (<a href="index.html#type-regular_inductive_arity">regular_inductive_arity</a>, <a href="index.html#type-template_arity">template_arity</a>) <a href="index.html#type-declaration_arity">declaration_arity</a></code></dt><dt class="spec type" id="type-one_inductive_body"><a href="#type-one_inductive_body" class="anchor"></a><code><span class="keyword">type</span> one_inductive_body</code><code> = </code><code>{</code><table class="record"><tr id="type-one_inductive_body.mind_typename" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_typename" class="anchor"></a><code>mind_typename : <a href="../Names/Id/index.html#type-t">Names.Id.t</a>;</code></td><td class="doc"><p>Name of the type: <code>Ii</code></p></td></tr><tr id="type-one_inductive_body.mind_arity_ctxt" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_arity_ctxt" class="anchor"></a><code>mind_arity_ctxt : <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a>;</code></td><td class="doc"><p>Arity context of <code>Ii</code> with parameters: <code>forall params, Ui</code></p></td></tr><tr id="type-one_inductive_body.mind_arity" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_arity" class="anchor"></a><code>mind_arity : <a href="index.html#type-inductive_arity">inductive_arity</a>;</code></td><td class="doc"><p>Arity sort and original user arity</p></td></tr><tr id="type-one_inductive_body.mind_consnames" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_consnames" class="anchor"></a><code>mind_consnames : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> array;</code></td><td class="doc"><p>Names of the constructors: <code>cij</code></p></td></tr><tr id="type-one_inductive_body.mind_user_lc" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_user_lc" class="anchor"></a><code>mind_user_lc : <a href="../Constr/index.html#type-types">Constr.types</a> array;</code></td><td class="doc"><p>Types of the constructors with parameters: <code>forall params, Tij</code>, where the Ik are replaced by de Bruijn index in the context I1:forall params, U1 .. In:forall params, Un</p></td></tr><tr id="type-one_inductive_body.mind_nrealargs" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_nrealargs" class="anchor"></a><code>mind_nrealargs : int;</code></td><td class="doc"><p>Number of expected real arguments of the type (no let, no params)</p></td></tr><tr id="type-one_inductive_body.mind_nrealdecls" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_nrealdecls" class="anchor"></a><code>mind_nrealdecls : int;</code></td><td class="doc"><p>Length of realargs context (with let, no params)</p></td></tr><tr id="type-one_inductive_body.mind_kelim" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_kelim" class="anchor"></a><code>mind_kelim : <a href="../Sorts/index.html#type-family">Sorts.family</a>;</code></td><td class="doc"><p>Highest allowed elimination sort</p></td></tr><tr id="type-one_inductive_body.mind_nf_lc" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_nf_lc" class="anchor"></a><code>mind_nf_lc : (<a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-types">Constr.types</a>) array;</code></td><td class="doc"><p>Head normalized constructor types so that their conclusion exposes the inductive type</p></td></tr><tr id="type-one_inductive_body.mind_consnrealargs" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_consnrealargs" class="anchor"></a><code>mind_consnrealargs : int array;</code></td><td class="doc"><p>Number of expected proper arguments of the constructors (w/o params)</p></td></tr><tr id="type-one_inductive_body.mind_consnrealdecls" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_consnrealdecls" class="anchor"></a><code>mind_consnrealdecls : int array;</code></td><td class="doc"><p>Length of the signature of the constructors (with let, w/o params)</p></td></tr><tr id="type-one_inductive_body.mind_recargs" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_recargs" class="anchor"></a><code>mind_recargs : <a href="index.html#type-wf_paths">wf_paths</a>;</code></td><td class="doc"><p>Signature of recursive arguments in the constructors</p></td></tr><tr id="type-one_inductive_body.mind_relevance" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_relevance" class="anchor"></a><code>mind_relevance : <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a>;</code></td></tr><tr id="type-one_inductive_body.mind_nb_constant" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_nb_constant" class="anchor"></a><code>mind_nb_constant : int;</code></td><td class="doc"><p>number of constant constructor</p></td></tr><tr id="type-one_inductive_body.mind_nb_args" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_nb_args" class="anchor"></a><code>mind_nb_args : int;</code></td><td class="doc"><p>number of no constant constructor</p></td></tr><tr id="type-one_inductive_body.mind_reloc_tbl" class="anchored"><td class="def field"><a href="#type-one_inductive_body.mind_reloc_tbl" class="anchor"></a><code>mind_reloc_tbl : <a href="../Vmvalues/index.html#type-reloc_table">Vmvalues.reloc_table</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-recursivity_kind"><a href="#type-recursivity_kind" class="anchor"></a><code><span class="keyword">type</span> recursivity_kind</code><code> = </code><table class="variant"><tr id="type-recursivity_kind.Finite" class="anchored"><td class="def constructor"><a href="#type-recursivity_kind.Finite" class="anchor"></a><code>| </code><code><span class="constructor">Finite</span></code></td><td class="doc"><p>= inductive</p></td></tr><tr id="type-recursivity_kind.CoFinite" class="anchored"><td class="def constructor"><a href="#type-recursivity_kind.CoFinite" class="anchor"></a><code>| </code><code><span class="constructor">CoFinite</span></code></td><td class="doc"><p>= coinductive</p></td></tr><tr id="type-recursivity_kind.BiFinite" class="anchored"><td class="def constructor"><a href="#type-recursivity_kind.BiFinite" class="anchor"></a><code>| </code><code><span class="constructor">BiFinite</span></code></td><td class="doc"><p>= non-recursive, like in &quot;Record&quot; definitions</p></td></tr></table></dt><dt class="spec type" id="type-mutual_inductive_body"><a href="#type-mutual_inductive_body" class="anchor"></a><code><span class="keyword">type</span> mutual_inductive_body</code><code> = </code><code>{</code><table class="record"><tr id="type-mutual_inductive_body.mind_packets" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_packets" class="anchor"></a><code>mind_packets : <a href="index.html#type-one_inductive_body">one_inductive_body</a> array;</code></td><td class="doc"><p>The component of the mutual inductive block</p></td></tr><tr id="type-mutual_inductive_body.mind_record" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_record" class="anchor"></a><code>mind_record : <a href="index.html#type-record_info">record_info</a>;</code></td><td class="doc"><p>The record information</p></td></tr><tr id="type-mutual_inductive_body.mind_finite" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_finite" class="anchor"></a><code>mind_finite : <a href="index.html#type-recursivity_kind">recursivity_kind</a>;</code></td><td class="doc"><p>Whether the type is inductive or coinductive</p></td></tr><tr id="type-mutual_inductive_body.mind_ntypes" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_ntypes" class="anchor"></a><code>mind_ntypes : int;</code></td><td class="doc"><p>Number of types in the block</p></td></tr><tr id="type-mutual_inductive_body.mind_hyps" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_hyps" class="anchor"></a><code>mind_hyps : <a href="../Constr/index.html#type-named_context">Constr.named_context</a>;</code></td><td class="doc"><p>Section hypotheses on which the block depends</p></td></tr><tr id="type-mutual_inductive_body.mind_nparams" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_nparams" class="anchor"></a><code>mind_nparams : int;</code></td><td class="doc"><p>Number of expected parameters including non-uniform ones (i.e. length of mind_params_ctxt w/o let-in)</p></td></tr><tr id="type-mutual_inductive_body.mind_nparams_rec" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_nparams_rec" class="anchor"></a><code>mind_nparams_rec : int;</code></td><td class="doc"><p>Number of recursively uniform (i.e. ordinary) parameters</p></td></tr><tr id="type-mutual_inductive_body.mind_params_ctxt" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_params_ctxt" class="anchor"></a><code>mind_params_ctxt : <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a>;</code></td><td class="doc"><p>The context of parameters (includes let-in declaration)</p></td></tr><tr id="type-mutual_inductive_body.mind_universes" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_universes" class="anchor"></a><code>mind_universes : <a href="index.html#type-universes">universes</a>;</code></td><td class="doc"><p>Information about monomorphic/polymorphic/cumulative inductives and their universes</p></td></tr><tr id="type-mutual_inductive_body.mind_variance" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_variance" class="anchor"></a><code>mind_variance : <a href="../Univ/Variance/index.html#type-t">Univ.Variance.t</a> array option;</code></td><td class="doc"><p>Variance info, <code>None</code> when non-cumulative.</p></td></tr><tr id="type-mutual_inductive_body.mind_private" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_private" class="anchor"></a><code>mind_private : bool option;</code></td><td class="doc"><p>allow pattern-matching: Some true ok, Some false blocked</p></td></tr><tr id="type-mutual_inductive_body.mind_typing_flags" class="anchored"><td class="def field"><a href="#type-mutual_inductive_body.mind_typing_flags" class="anchor"></a><code>mind_typing_flags : <a href="index.html#type-typing_flags">typing_flags</a>;</code></td><td class="doc"><p>typing flags at the time of the inductive creation</p></td></tr></table><code>}</code></dt></dl></section><section><header><h6 id="module-declarations"><a href="#module-declarations" class="anchor"></a>Module declarations</h6></header><aside><p>Functor expressions are forced to be on top of other expressions</p></aside><dl><dt class="spec type" id="type-functorize"><a href="#type-functorize" class="anchor"></a><code><span class="keyword">type</span> ('ty, 'a) functorize</code><code> = </code><table class="variant"><tr id="type-functorize.NoFunctor" class="anchored"><td class="def constructor"><a href="#type-functorize.NoFunctor" class="anchor"></a><code>| </code><code><span class="constructor">NoFunctor</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-functorize.MoreFunctor" class="anchored"><td class="def constructor"><a href="#type-functorize.MoreFunctor" class="anchor"></a><code>| </code><code><span class="constructor">MoreFunctor</span> <span class="keyword">of</span> <a href="../Names/MBId/index.html#type-t">Names.MBId.t</a> * <span class="type-var">'ty</span> * (<span class="type-var">'ty</span>, <span class="type-var">'a</span>) <a href="index.html#type-functorize">functorize</a></code></td></tr></table></dt></dl><aside><p>The fully-algebraic module expressions : names, applications, 'with ...'. They correspond to the user entries of non-interactive modules. They will be later expanded into module structures in <code>Mod_typing</code>, and won't play any role into the kernel after that : they are kept only for short module printing and for extraction.</p></aside><dl><dt class="spec type" id="type-with_declaration"><a href="#type-with_declaration" class="anchor"></a><code><span class="keyword">type</span> with_declaration</code><code> = </code><table class="variant"><tr id="type-with_declaration.WithMod" class="anchored"><td class="def constructor"><a href="#type-with_declaration.WithMod" class="anchor"></a><code>| </code><code><span class="constructor">WithMod</span> <span class="keyword">of</span> <a href="../Names/Id/index.html#type-t">Names.Id.t</a> list * <a href="../Names/ModPath/index.html#type-t">Names.ModPath.t</a></code></td></tr><tr id="type-with_declaration.WithDef" class="anchored"><td class="def constructor"><a href="#type-with_declaration.WithDef" class="anchor"></a><code>| </code><code><span class="constructor">WithDef</span> <span class="keyword">of</span> <a href="../Names/Id/index.html#type-t">Names.Id.t</a> list * <a href="../Constr/index.html#type-constr">Constr.constr</a> * <a href="../Univ/AUContext/index.html#type-t">Univ.AUContext.t</a> option</code></td></tr></table></dt><dt class="spec type" id="type-module_alg_expr"><a href="#type-module_alg_expr" class="anchor"></a><code><span class="keyword">type</span> module_alg_expr</code><code> = </code><table class="variant"><tr id="type-module_alg_expr.MEident" class="anchored"><td class="def constructor"><a href="#type-module_alg_expr.MEident" class="anchor"></a><code>| </code><code><span class="constructor">MEident</span> <span class="keyword">of</span> <a href="../Names/ModPath/index.html#type-t">Names.ModPath.t</a></code></td></tr><tr id="type-module_alg_expr.MEapply" class="anchored"><td class="def constructor"><a href="#type-module_alg_expr.MEapply" class="anchor"></a><code>| </code><code><span class="constructor">MEapply</span> <span class="keyword">of</span> <a href="index.html#type-module_alg_expr">module_alg_expr</a> * <a href="../Names/ModPath/index.html#type-t">Names.ModPath.t</a></code></td></tr><tr id="type-module_alg_expr.MEwith" class="anchored"><td class="def constructor"><a href="#type-module_alg_expr.MEwith" class="anchor"></a><code>| </code><code><span class="constructor">MEwith</span> <span class="keyword">of</span> <a href="index.html#type-module_alg_expr">module_alg_expr</a> * <a href="index.html#type-with_declaration">with_declaration</a></code></td></tr></table></dt></dl><aside><p>A component of a module structure</p></aside><dl><dt class="spec type" id="type-structure_field_body"><a href="#type-structure_field_body" class="anchor"></a><code><span class="keyword">type</span> structure_field_body</code><code> = </code><table class="variant"><tr id="type-structure_field_body.SFBconst" class="anchored"><td class="def constructor"><a href="#type-structure_field_body.SFBconst" class="anchor"></a><code>| </code><code><span class="constructor">SFBconst</span> <span class="keyword">of</span> <a href="../Opaqueproof/index.html#type-opaque">Opaqueproof.opaque</a> <a href="index.html#type-constant_body">constant_body</a></code></td></tr><tr id="type-structure_field_body.SFBmind" class="anchored"><td class="def constructor"><a href="#type-structure_field_body.SFBmind" class="anchor"></a><code>| </code><code><span class="constructor">SFBmind</span> <span class="keyword">of</span> <a href="index.html#type-mutual_inductive_body">mutual_inductive_body</a></code></td></tr><tr id="type-structure_field_body.SFBmodule" class="anchored"><td class="def constructor"><a href="#type-structure_field_body.SFBmodule" class="anchor"></a><code>| </code><code><span class="constructor">SFBmodule</span> <span class="keyword">of</span> <a href="index.html#type-module_body">module_body</a></code></td></tr><tr id="type-structure_field_body.SFBmodtype" class="anchored"><td class="def constructor"><a href="#type-structure_field_body.SFBmodtype" class="anchor"></a><code>| </code><code><span class="constructor">SFBmodtype</span> <span class="keyword">of</span> <a href="index.html#type-module_type_body">module_type_body</a></code></td></tr></table></dt></dl><aside><p>A module structure is a list of labeled components.</p><p>Note : we may encounter now (at most) twice the same label in a <code>structure_body</code>, once for a module (<code>SFBmodule</code> or <code>SFBmodtype</code>) and once for an object (<code>SFBconst</code> or <code>SFBmind</code>)</p></aside><dl><dt class="spec type" id="type-structure_body"><a href="#type-structure_body" class="anchor"></a><code><span class="keyword">and</span> structure_body</code><code> = (<a href="../Names/Label/index.html#type-t">Names.Label.t</a> * <a href="index.html#type-structure_field_body">structure_field_body</a>) list</code></dt></dl><aside><p>A module signature is a structure, with possibly functors on top of it</p></aside><dl><dt class="spec type" id="type-module_signature"><a href="#type-module_signature" class="anchor"></a><code><span class="keyword">and</span> module_signature</code><code> = (<a href="index.html#type-module_type_body">module_type_body</a>, <a href="index.html#type-structure_body">structure_body</a>) <a href="index.html#type-functorize">functorize</a></code></dt></dl><aside><p>A module expression is an algebraic expression, possibly functorized.</p></aside><dl><dt class="spec type" id="type-module_expression"><a href="#type-module_expression" class="anchor"></a><code><span class="keyword">and</span> module_expression</code><code> = (<a href="index.html#type-module_type_body">module_type_body</a>, <a href="index.html#type-module_alg_expr">module_alg_expr</a>) <a href="index.html#type-functorize">functorize</a></code></dt><dt class="spec type" id="type-module_implementation"><a href="#type-module_implementation" class="anchor"></a><code><span class="keyword">and</span> module_implementation</code><code> = </code><table class="variant"><tr id="type-module_implementation.Abstract" class="anchored"><td class="def constructor"><a href="#type-module_implementation.Abstract" class="anchor"></a><code>| </code><code><span class="constructor">Abstract</span></code></td><td class="doc"><p>no accessible implementation</p></td></tr><tr id="type-module_implementation.Algebraic" class="anchored"><td class="def constructor"><a href="#type-module_implementation.Algebraic" class="anchor"></a><code>| </code><code><span class="constructor">Algebraic</span> <span class="keyword">of</span> <a href="index.html#type-module_expression">module_expression</a></code></td><td class="doc"><p>non-interactive algebraic expression</p></td></tr><tr id="type-module_implementation.Struct" class="anchored"><td class="def constructor"><a href="#type-module_implementation.Struct" class="anchor"></a><code>| </code><code><span class="constructor">Struct</span> <span class="keyword">of</span> <a href="index.html#type-module_signature">module_signature</a></code></td><td class="doc"><p>interactive body</p></td></tr><tr id="type-module_implementation.FullStruct" class="anchored"><td class="def constructor"><a href="#type-module_implementation.FullStruct" class="anchor"></a><code>| </code><code><span class="constructor">FullStruct</span></code></td><td class="doc"><p>special case of <code>Struct</code> : the body is exactly <code>mod_type</code></p></td></tr></table></dt><dt class="spec type" id="type-generic_module_body"><a href="#type-generic_module_body" class="anchor"></a><code><span class="keyword">and</span> 'a generic_module_body</code><code> = </code><code>{</code><table class="record"><tr id="type-generic_module_body.mod_mp" class="anchored"><td class="def field"><a href="#type-generic_module_body.mod_mp" class="anchor"></a><code>mod_mp : <a href="../Names/ModPath/index.html#type-t">Names.ModPath.t</a>;</code></td><td class="doc"><p>absolute path of the module</p></td></tr><tr id="type-generic_module_body.mod_expr" class="anchored"><td class="def field"><a href="#type-generic_module_body.mod_expr" class="anchor"></a><code>mod_expr : <span class="type-var">'a</span>;</code></td><td class="doc"><p>implementation</p></td></tr><tr id="type-generic_module_body.mod_type" class="anchored"><td class="def field"><a href="#type-generic_module_body.mod_type" class="anchor"></a><code>mod_type : <a href="index.html#type-module_signature">module_signature</a>;</code></td><td class="doc"><p>expanded type</p></td></tr><tr id="type-generic_module_body.mod_type_alg" class="anchored"><td class="def field"><a href="#type-generic_module_body.mod_type_alg" class="anchor"></a><code>mod_type_alg : <a href="index.html#type-module_expression">module_expression</a> option;</code></td><td class="doc"><p>algebraic type</p></td></tr><tr id="type-generic_module_body.mod_constraints" class="anchored"><td class="def field"><a href="#type-generic_module_body.mod_constraints" class="anchor"></a><code>mod_constraints : <a href="../Univ/ContextSet/index.html#type-t">Univ.ContextSet.t</a>;</code></td><td class="doc"><p>set of all universes constraints in the module</p></td></tr><tr id="type-generic_module_body.mod_delta" class="anchored"><td class="def field"><a href="#type-generic_module_body.mod_delta" class="anchor"></a><code>mod_delta : <a href="../Mod_subst/index.html#type-delta_resolver">Mod_subst.delta_resolver</a>;</code></td><td class="doc"><p>quotiented set of equivalent constants and inductive names</p></td></tr><tr id="type-generic_module_body.mod_retroknowledge" class="anchored"><td class="def field"><a href="#type-generic_module_body.mod_retroknowledge" class="anchor"></a><code>mod_retroknowledge : <span class="type-var">'a</span> <a href="index.html#type-module_retroknowledge">module_retroknowledge</a>;</code></td></tr></table><code>}</code></dt></dl><aside><p>For a module, there are five possible situations:</p><ul><li><code>Declare Module M : T</code> then <code>mod_expr = Abstract; mod_type_alg = Some T</code></li><li><code>Module M := E</code> then <code>mod_expr = Algebraic E; mod_type_alg = None</code></li><li><code>Module M : T := E</code> then <code>mod_expr = Algebraic E; mod_type_alg = Some T</code></li><li><code>Module M. ... End M</code> then <code>mod_expr = FullStruct; mod_type_alg = None</code></li><li><code>Module M : T. ... End M</code> then <code>mod_expr = Struct; mod_type_alg = Some T</code> And of course, all these situations may be functors or not.</li></ul></aside><dl><dt class="spec type" id="type-module_body"><a href="#type-module_body" class="anchor"></a><code><span class="keyword">and</span> module_body</code><code> = <a href="index.html#type-module_implementation">module_implementation</a> <a href="index.html#type-generic_module_body">generic_module_body</a></code></dt></dl><aside><p>A <code>module_type_body</code> is just a <code>module_body</code> with no implementation and also an empty <code>mod_retroknowledge</code>. Its <code>mod_type_alg</code> contains the algebraic definition of this module type, or <code>None</code> if it has been built interactively.</p></aside><dl><dt class="spec type" id="type-module_type_body"><a href="#type-module_type_body" class="anchor"></a><code><span class="keyword">and</span> module_type_body</code><code> = unit <a href="index.html#type-generic_module_body">generic_module_body</a></code></dt><dt class="spec type" id="type-module_retroknowledge"><a href="#type-module_retroknowledge" class="anchor"></a><code><span class="keyword">and</span> _ module_retroknowledge</code><code> = </code><table class="variant"><tr id="type-module_retroknowledge.ModBodyRK" class="anchored"><td class="def constructor"><a href="#type-module_retroknowledge.ModBodyRK" class="anchor"></a><code>| </code><code><span class="constructor">ModBodyRK</span> : <a href="../Retroknowledge/index.html#type-action">Retroknowledge.action</a> list <span>&#45;&gt;</span> <a href="index.html#type-module_implementation">module_implementation</a> <a href="index.html#type-module_retroknowledge">module_retroknowledge</a></code></td></tr><tr id="type-module_retroknowledge.ModTypeRK" class="anchored"><td class="def constructor"><a href="#type-module_retroknowledge.ModTypeRK" class="anchor"></a><code>| </code><code><span class="constructor">ModTypeRK</span> : unit <a href="index.html#type-module_retroknowledge">module_retroknowledge</a></code></td></tr></table></dt></dl><aside><p>Extra invariants :</p><ul><li>No <code>MEwith</code> inside a <code>mod_expr</code> implementation : the 'with' syntax is only supported for module types</li></ul><ul><li>A module application is atomic, for instance ((M N) P) : * the head of <code>MEapply</code> can only be another <code>MEapply</code> or a <code>MEident</code> * the argument of <code>MEapply</code> is now directly forced to be a <code>ModPath.t</code>.</li></ul></aside></section></div></body></html>