<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Constr (coq.Constr)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">coq</a> &#x00BB; Constr</nav><h1>Module <code>Constr</code></h1><p>This file defines the most important datatype of Coq, namely kernel terms, as well as a handful of generic manipulation functions.</p><nav class="toc"><ul><li><a href="#the-type-of-constructions">The type of constructions</a></li><li><a href="#functions-for-dealing-with-constr-terms.">Functions for dealing with constr terms.</a></li><li><a href="#term-constructors.">Term constructors.</a></li><li><a href="#concrete-type-for-making-pattern-matching.">Concrete type for making pattern-matching.</a></li><li><a href="#term-destructors">Term destructors</a></li><li><a href="#equality">Equality</a></li><li><a href="#extension-of-context-with-declarations-on-constr">Extension of Context with declarations on constr</a></li><li><a href="#relocation-and-substitution">Relocation and substitution</a></li><li><a href="#functionals-working-on-expressions-canonically-abstracted-over-a-local-context-(possibly-with-let-ins)">Functionals working on expressions canonically abstracted over a local context (possibly with let-ins)</a></li><li><a href="#functionals-working-on-the-immediate-subterm-of-a-construction">Functionals working on the immediate subterm of a construction</a></li><li><a href="#hashconsing">Hashconsing</a></li></ul></nav></header><dl><dt class="spec type" id="type-pconstant"><a href="#type-pconstant" class="anchor"></a><code><span class="keyword">type</span> pconstant</code><code> = <span><a href="../Names/Constant/index.html#type-t">Names.Constant.t</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a></span></code></dt><dd><h6 id="simply-type-aliases"><a href="#simply-type-aliases" class="anchor"></a>Simply type aliases</h6></dd></dl><dl><dt class="spec type" id="type-pinductive"><a href="#type-pinductive" class="anchor"></a><code><span class="keyword">type</span> pinductive</code><code> = <span><a href="../Names/index.html#type-inductive">Names.inductive</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a></span></code></dt><dt class="spec type" id="type-pconstructor"><a href="#type-pconstructor" class="anchor"></a><code><span class="keyword">type</span> pconstructor</code><code> = <span><a href="../Names/index.html#type-constructor">Names.constructor</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a></span></code></dt><dt class="spec type" id="type-metavariable"><a href="#type-metavariable" class="anchor"></a><code><span class="keyword">type</span> metavariable</code><code> = int</code></dt><dd><h6 id="existential-variables"><a href="#existential-variables" class="anchor"></a>Existential variables</h6></dd></dl><dl><dt class="spec type" id="type-case_style"><a href="#type-case_style" class="anchor"></a><code><span class="keyword">type</span> case_style</code><code> = </code><table class="variant"><tr id="type-case_style.LetStyle" class="anchored"><td class="def constructor"><a href="#type-case_style.LetStyle" class="anchor"></a><code>| </code><code><span class="constructor">LetStyle</span></code></td></tr><tr id="type-case_style.IfStyle" class="anchored"><td class="def constructor"><a href="#type-case_style.IfStyle" class="anchor"></a><code>| </code><code><span class="constructor">IfStyle</span></code></td></tr><tr id="type-case_style.LetPatternStyle" class="anchored"><td class="def constructor"><a href="#type-case_style.LetPatternStyle" class="anchor"></a><code>| </code><code><span class="constructor">LetPatternStyle</span></code></td></tr><tr id="type-case_style.MatchStyle" class="anchored"><td class="def constructor"><a href="#type-case_style.MatchStyle" class="anchor"></a><code>| </code><code><span class="constructor">MatchStyle</span></code></td></tr><tr id="type-case_style.RegularStyle" class="anchored"><td class="def constructor"><a href="#type-case_style.RegularStyle" class="anchor"></a><code>| </code><code><span class="constructor">RegularStyle</span></code></td><td class="doc"><p>infer printing form from number of constructor</p></td></tr></table></dt><dd><h6 id="case-annotation"><a href="#case-annotation" class="anchor"></a>Case annotation</h6></dd></dl><dl><dt class="spec type" id="type-case_printing"><a href="#type-case_printing" class="anchor"></a><code><span class="keyword">type</span> case_printing</code><code> = </code><code>{</code><table class="record"><tr id="type-case_printing.ind_tags" class="anchored"><td class="def field"><a href="#type-case_printing.ind_tags" class="anchor"></a><code>ind_tags : <span>bool list</span>;</code></td><td class="doc"><p>tell whether letin or lambda in the arity of the inductive type</p></td></tr><tr id="type-case_printing.cstr_tags" class="anchored"><td class="def field"><a href="#type-case_printing.cstr_tags" class="anchor"></a><code>cstr_tags : <span><span>bool list</span> array</span>;</code></td><td class="doc"><p>tell whether letin or lambda in the signature of each constructor</p></td></tr><tr id="type-case_printing.style" class="anchored"><td class="def field"><a href="#type-case_printing.style" class="anchor"></a><code>style : <a href="index.html#type-case_style">case_style</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-case_info"><a href="#type-case_info" class="anchor"></a><code><span class="keyword">type</span> case_info</code><code> = </code><code>{</code><table class="record"><tr id="type-case_info.ci_ind" class="anchored"><td class="def field"><a href="#type-case_info.ci_ind" class="anchor"></a><code>ci_ind : <a href="../Names/index.html#type-inductive">Names.inductive</a>;</code></td></tr><tr id="type-case_info.ci_npar" class="anchored"><td class="def field"><a href="#type-case_info.ci_npar" class="anchor"></a><code>ci_npar : int;</code></td></tr><tr id="type-case_info.ci_cstr_ndecls" class="anchored"><td class="def field"><a href="#type-case_info.ci_cstr_ndecls" class="anchor"></a><code>ci_cstr_ndecls : <span>int array</span>;</code></td></tr><tr id="type-case_info.ci_cstr_nargs" class="anchored"><td class="def field"><a href="#type-case_info.ci_cstr_nargs" class="anchor"></a><code>ci_cstr_nargs : <span>int array</span>;</code></td></tr><tr id="type-case_info.ci_relevance" class="anchored"><td class="def field"><a href="#type-case_info.ci_relevance" class="anchor"></a><code>ci_relevance : <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a>;</code></td></tr><tr id="type-case_info.ci_pp_info" class="anchored"><td class="def field"><a href="#type-case_info.ci_pp_info" class="anchor"></a><code>ci_pp_info : <a href="index.html#type-case_printing">case_printing</a>;</code></td></tr></table><code>}</code></dt></dl><section><header><h6 id="the-type-of-constructions"><a href="#the-type-of-constructions" class="anchor"></a>The type of constructions</h6></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dt class="spec type" id="type-constr"><a href="#type-constr" class="anchor"></a><code><span class="keyword">type</span> constr</code><code> = <a href="index.html#type-t">t</a></code></dt><dd><p><code>types</code> is the same as <code>constr</code> but is intended to be used for documentation to indicate that such or such function specifically works with <em>types</em> (i.e. terms of type a sort). (Rem:plurial form since <code>type</code> is a reserved ML keyword)</p></dd></dl><dl><dt class="spec type" id="type-types"><a href="#type-types" class="anchor"></a><code><span class="keyword">type</span> types</code><code> = <a href="index.html#type-constr">constr</a></code></dt></dl></section><section><header><h6 id="functions-for-dealing-with-constr-terms."><a href="#functions-for-dealing-with-constr-terms." class="anchor"></a>Functions for dealing with constr terms.</h6><p>The following functions are intended to simplify and to uniform the manipulation of terms. Some of these functions may be overlapped with previous ones.</p></header></section><section><header><h6 id="term-constructors."><a href="#term-constructors." class="anchor"></a>Term constructors.</h6></header><dl><dt class="spec value" id="val-mkRel"><a href="#val-mkRel" class="anchor"></a><code><span class="keyword">val</span> mkRel : int <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs a de Bruijn index (DB indices begin at 1)</p></dd></dl><dl><dt class="spec value" id="val-mkVar"><a href="#val-mkVar" class="anchor"></a><code><span class="keyword">val</span> mkVar : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs a Variable</p></dd></dl><dl><dt class="spec value" id="val-mkInt"><a href="#val-mkInt" class="anchor"></a><code><span class="keyword">val</span> mkInt : <a href="../Uint63/index.html#type-t">Uint63.t</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs a machine integer</p></dd></dl><dl><dt class="spec value" id="val-mkMeta"><a href="#val-mkMeta" class="anchor"></a><code><span class="keyword">val</span> mkMeta : <a href="index.html#type-metavariable">metavariable</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs an patvar named &quot;?n&quot;</p></dd></dl><dl><dt class="spec type" id="type-existential"><a href="#type-existential" class="anchor"></a><code><span class="keyword">type</span> existential</code><code> = <a href="../Evar/index.html#type-t">Evar.t</a> * <span><a href="index.html#type-constr">constr</a> array</span></code></dt><dd><p>Constructs an existential variable</p></dd></dl><dl><dt class="spec value" id="val-mkEvar"><a href="#val-mkEvar" class="anchor"></a><code><span class="keyword">val</span> mkEvar : <a href="index.html#type-existential">existential</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dt class="spec value" id="val-mkSort"><a href="#val-mkSort" class="anchor"></a><code><span class="keyword">val</span> mkSort : <a href="../Sorts/index.html#type-t">Sorts.t</a> <span>&#45;&gt;</span> <a href="index.html#type-types">types</a></code></dt><dd><p>Construct a sort</p></dd></dl><dl><dt class="spec value" id="val-mkSProp"><a href="#val-mkSProp" class="anchor"></a><code><span class="keyword">val</span> mkSProp : <a href="index.html#type-types">types</a></code></dt><dt class="spec value" id="val-mkProp"><a href="#val-mkProp" class="anchor"></a><code><span class="keyword">val</span> mkProp : <a href="index.html#type-types">types</a></code></dt><dt class="spec value" id="val-mkSet"><a href="#val-mkSet" class="anchor"></a><code><span class="keyword">val</span> mkSet : <a href="index.html#type-types">types</a></code></dt><dt class="spec value" id="val-mkType"><a href="#val-mkType" class="anchor"></a><code><span class="keyword">val</span> mkType : <a href="../Univ/Universe/index.html#type-t">Univ.Universe.t</a> <span>&#45;&gt;</span> <a href="index.html#type-types">types</a></code></dt></dl><dl><dt class="spec type" id="type-cast_kind"><a href="#type-cast_kind" class="anchor"></a><code><span class="keyword">type</span> cast_kind</code><code> = </code><table class="variant"><tr id="type-cast_kind.VMcast" class="anchored"><td class="def constructor"><a href="#type-cast_kind.VMcast" class="anchor"></a><code>| </code><code><span class="constructor">VMcast</span></code></td></tr><tr id="type-cast_kind.NATIVEcast" class="anchored"><td class="def constructor"><a href="#type-cast_kind.NATIVEcast" class="anchor"></a><code>| </code><code><span class="constructor">NATIVEcast</span></code></td></tr><tr id="type-cast_kind.DEFAULTcast" class="anchored"><td class="def constructor"><a href="#type-cast_kind.DEFAULTcast" class="anchor"></a><code>| </code><code><span class="constructor">DEFAULTcast</span></code></td></tr><tr id="type-cast_kind.REVERTcast" class="anchored"><td class="def constructor"><a href="#type-cast_kind.REVERTcast" class="anchor"></a><code>| </code><code><span class="constructor">REVERTcast</span></code></td></tr></table></dt><dd><p>This defines the strategy to use for verifiying a Cast</p></dd></dl><dl><dt class="spec value" id="val-mkCast"><a href="#val-mkCast" class="anchor"></a><code><span class="keyword">val</span> mkCast : <span>(<a href="index.html#type-constr">constr</a> * <a href="index.html#type-cast_kind">cast_kind</a> * <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs the term <code>t1::t2</code>, i.e. the term t<sub>1</sub> casted with the type t<sub>2</sub> (that means t2 is declared as the type of t1).</p></dd></dl><dl><dt class="spec value" id="val-mkProd"><a href="#val-mkProd" class="anchor"></a><code><span class="keyword">val</span> mkProd : <span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="index.html#type-types">types</a> * <a href="index.html#type-types">types</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-types">types</a></code></dt><dd><p>Constructs the product <code>(x:t1)t2</code></p></dd></dl><dl><dt class="spec value" id="val-mkLambda"><a href="#val-mkLambda" class="anchor"></a><code><span class="keyword">val</span> mkLambda : <span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="index.html#type-types">types</a> * <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs the abstraction [x:t<sub>1</sub>]t<sub>2</sub></p></dd></dl><dl><dt class="spec value" id="val-mkLetIn"><a href="#val-mkLetIn" class="anchor"></a><code><span class="keyword">val</span> mkLetIn : <span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="index.html#type-constr">constr</a> * <a href="index.html#type-types">types</a> * <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs the product <code>let x = t1 : t2 in t3</code></p></dd></dl><dl><dt class="spec value" id="val-mkApp"><a href="#val-mkApp" class="anchor"></a><code><span class="keyword">val</span> mkApp : <span>(<a href="index.html#type-constr">constr</a> * <span><a href="index.html#type-constr">constr</a> array</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p><code>mkApp (f, [|t1; ...; tN|]</code> constructs the application (f t<sub>1</sub> ... t<sub>n</sub>) <code>$(f~t_1\dots f_n)$</code>.</p></dd></dl><dl><dt class="spec value" id="val-map_puniverses"><a href="#val-map_puniverses" class="anchor"></a><code><span class="keyword">val</span> map_puniverses : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a></span></code></dt><dt class="spec value" id="val-mkConst"><a href="#val-mkConst" class="anchor"></a><code><span class="keyword">val</span> mkConst : <a href="../Names/Constant/index.html#type-t">Names.Constant.t</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs a Constant.t</p></dd></dl><dl><dt class="spec value" id="val-mkConstU"><a href="#val-mkConstU" class="anchor"></a><code><span class="keyword">val</span> mkConstU : <a href="index.html#type-pconstant">pconstant</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dt class="spec value" id="val-mkProj"><a href="#val-mkProj" class="anchor"></a><code><span class="keyword">val</span> mkProj : <span>(<a href="../Names/Projection/index.html#type-t">Names.Projection.t</a> * <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs a projection application</p></dd></dl><aside><p>Inductive types</p></aside><dl><dt class="spec value" id="val-mkInd"><a href="#val-mkInd" class="anchor"></a><code><span class="keyword">val</span> mkInd : <a href="../Names/index.html#type-inductive">Names.inductive</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs the ith (co)inductive type of the block named kn</p></dd></dl><dl><dt class="spec value" id="val-mkIndU"><a href="#val-mkIndU" class="anchor"></a><code><span class="keyword">val</span> mkIndU : <a href="index.html#type-pinductive">pinductive</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dt class="spec value" id="val-mkConstruct"><a href="#val-mkConstruct" class="anchor"></a><code><span class="keyword">val</span> mkConstruct : <a href="../Names/index.html#type-constructor">Names.constructor</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs the jth constructor of the ith (co)inductive type of the block named kn.</p></dd></dl><dl><dt class="spec value" id="val-mkConstructU"><a href="#val-mkConstructU" class="anchor"></a><code><span class="keyword">val</span> mkConstructU : <a href="index.html#type-pconstructor">pconstructor</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dt class="spec value" id="val-mkConstructUi"><a href="#val-mkConstructUi" class="anchor"></a><code><span class="keyword">val</span> mkConstructUi : <span>(<a href="index.html#type-pinductive">pinductive</a> * int)</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dt class="spec value" id="val-mkRef"><a href="#val-mkRef" class="anchor"></a><code><span class="keyword">val</span> mkRef : <span><a href="../Names/GlobRef/index.html#type-t">Names.GlobRef.t</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a></span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Make a constant, inductive, constructor or variable.</p></dd></dl><dl><dt class="spec value" id="val-mkCase"><a href="#val-mkCase" class="anchor"></a><code><span class="keyword">val</span> mkCase : <span>(<a href="index.html#type-case_info">case_info</a> * <a href="index.html#type-constr">constr</a> * <a href="index.html#type-constr">constr</a> * <span><a href="index.html#type-constr">constr</a> array</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Constructs a destructor of inductive type.</p><p><code>mkCase ci p c ac</code> stand for match <code>c</code> as <code>x</code> in <code>I args</code> return <code>p</code> with <code>ac</code> presented as describe in <code>ci</code>.</p><p><code>p</code> structure is <code>fun args x -&gt; &quot;return clause&quot;</code></p><p><code>ac</code><sup>ith</sup> element is ith constructor case presented as <em>lambda construct_args (without params). case_term</em></p></dd></dl><dl><dt class="spec type" id="type-prec_declaration"><a href="#type-prec_declaration" class="anchor"></a><code><span class="keyword">type</span> <span>('constr, 'types) prec_declaration</span></code><code> = <span><span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> array</span> * <span><span class="type-var">'types</span> array</span> * <span><span class="type-var">'constr</span> array</span></code></dt><dd><p>If <code>recindxs = [|i1,...in|]</code> <code>funnames = [|f1,.....fn|]</code> <code>typarray = [|t1,...tn|]</code> <code>bodies   = [|b1,.....bn|]</code> then <code>mkFix ((recindxs,i), funnames, typarray, bodies) </code> constructs the <code> $ </code>i<code> $ </code>th function of the block (counting from 0)</p><p><code>Fixpoint f1 [ctx1] = b1
     with     f2 [ctx2] = b2
     ...
     with     fn [ctxn] = bn.</code></p><p>where the length of the <code> $ </code>j<code> $ </code>th context is <code> $ </code>ij<code> $ </code>.</p></dd></dl><dl><dt class="spec type" id="type-pfixpoint"><a href="#type-pfixpoint" class="anchor"></a><code><span class="keyword">type</span> <span>('constr, 'types) pfixpoint</span></code><code> = <span>(<span>int array</span> * int)</span> * <span><span>(<span class="type-var">'constr</span>, <span class="type-var">'types</span>)</span> <a href="index.html#type-prec_declaration">prec_declaration</a></span></code></dt><dt class="spec type" id="type-pcofixpoint"><a href="#type-pcofixpoint" class="anchor"></a><code><span class="keyword">type</span> <span>('constr, 'types) pcofixpoint</span></code><code> = int * <span><span>(<span class="type-var">'constr</span>, <span class="type-var">'types</span>)</span> <a href="index.html#type-prec_declaration">prec_declaration</a></span></code></dt><dt class="spec type" id="type-rec_declaration"><a href="#type-rec_declaration" class="anchor"></a><code><span class="keyword">type</span> rec_declaration</code><code> = <span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-types">types</a>)</span> <a href="index.html#type-prec_declaration">prec_declaration</a></span></code></dt><dt class="spec type" id="type-fixpoint"><a href="#type-fixpoint" class="anchor"></a><code><span class="keyword">type</span> fixpoint</code><code> = <span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-types">types</a>)</span> <a href="index.html#type-pfixpoint">pfixpoint</a></span></code></dt></dl><dl><dt class="spec value" id="val-mkFix"><a href="#val-mkFix" class="anchor"></a><code><span class="keyword">val</span> mkFix : <a href="index.html#type-fixpoint">fixpoint</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl><dl><dt class="spec type" id="type-cofixpoint"><a href="#type-cofixpoint" class="anchor"></a><code><span class="keyword">type</span> cofixpoint</code><code> = <span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-types">types</a>)</span> <a href="index.html#type-pcofixpoint">pcofixpoint</a></span></code></dt><dd><p>If <code>funnames = [|f1,.....fn|]</code> <code>typarray = [|t1,...tn|]</code> <code>bodies   = [b1,.....bn]</code> then <code>mkCoFix (i, (funnames, typarray, bodies))</code> constructs the ith function of the block</p><p><code>CoFixpoint f1 = b1
     with       f2 = b2
     ...
     with       fn = bn.</code></p></dd></dl><dl><dt class="spec value" id="val-mkCoFix"><a href="#val-mkCoFix" class="anchor"></a><code><span class="keyword">val</span> mkCoFix : <a href="index.html#type-cofixpoint">cofixpoint</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl></section><section><header><h6 id="concrete-type-for-making-pattern-matching."><a href="#concrete-type-for-making-pattern-matching." class="anchor"></a>Concrete type for making pattern-matching.</h6></header><dl><dt class="spec type" id="type-pexistential"><a href="#type-pexistential" class="anchor"></a><code><span class="keyword">type</span> <span>'constr pexistential</span></code><code> = <a href="../Evar/index.html#type-t">Evar.t</a> * <span><span class="type-var">'constr</span> array</span></code></dt><dd><p><code>constr array</code> is an instance matching definitional <code>named_context</code> in the same order (i.e. last argument first)</p></dd></dl><dl><dt class="spec type" id="type-kind_of_term"><a href="#type-kind_of_term" class="anchor"></a><code><span class="keyword">type</span> <span>('constr, 'types, 'sort, 'univs) kind_of_term</span></code><code> = </code><table class="variant"><tr id="type-kind_of_term.Rel" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Rel" class="anchor"></a><code>| </code><code><span class="constructor">Rel</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>Gallina-variable introduced by <code>forall</code>, <code>fun</code>, <code>let-in</code>, <code>fix</code>, or <code>cofix</code>.</p></td></tr><tr id="type-kind_of_term.Var" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Var" class="anchor"></a><code>| </code><code><span class="constructor">Var</span> <span class="keyword">of</span> <a href="../Names/Id/index.html#type-t">Names.Id.t</a></code></td><td class="doc"><p>Gallina-variable that was introduced by Vernacular-command that extends the local context of the currently open section (i.e. <code>Variable</code> or <code>Let</code>).</p></td></tr><tr id="type-kind_of_term.Meta" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Meta" class="anchor"></a><code>| </code><code><span class="constructor">Meta</span> <span class="keyword">of</span> <a href="index.html#type-metavariable">metavariable</a></code></td></tr><tr id="type-kind_of_term.Evar" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Evar" class="anchor"></a><code>| </code><code><span class="constructor">Evar</span> <span class="keyword">of</span> <span><span class="type-var">'constr</span> <a href="index.html#type-pexistential">pexistential</a></span></code></td></tr><tr id="type-kind_of_term.Sort" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Sort" class="anchor"></a><code>| </code><code><span class="constructor">Sort</span> <span class="keyword">of</span> <span class="type-var">'sort</span></code></td></tr><tr id="type-kind_of_term.Cast" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Cast" class="anchor"></a><code>| </code><code><span class="constructor">Cast</span> <span class="keyword">of</span> <span class="type-var">'constr</span> * <a href="index.html#type-cast_kind">cast_kind</a> * <span class="type-var">'types</span></code></td></tr><tr id="type-kind_of_term.Prod" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Prod" class="anchor"></a><code>| </code><code><span class="constructor">Prod</span> <span class="keyword">of</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <span class="type-var">'types</span> * <span class="type-var">'types</span></code></td><td class="doc"><p>Concrete syntax <code>&quot;forall A:B,C&quot;</code> is represented as <code>Prod (A,B,C)</code>.</p></td></tr><tr id="type-kind_of_term.Lambda" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Lambda" class="anchor"></a><code>| </code><code><span class="constructor">Lambda</span> <span class="keyword">of</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <span class="type-var">'types</span> * <span class="type-var">'constr</span></code></td><td class="doc"><p>Concrete syntax <code>&quot;fun A:B =&gt; C&quot;</code> is represented as <code>Lambda (A,B,C)</code>.</p></td></tr><tr id="type-kind_of_term.LetIn" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.LetIn" class="anchor"></a><code>| </code><code><span class="constructor">LetIn</span> <span class="keyword">of</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <span class="type-var">'constr</span> * <span class="type-var">'types</span> * <span class="type-var">'constr</span></code></td><td class="doc"><p>Concrete syntax <code>&quot;let A:C := B in D&quot;</code> is represented as <code>LetIn (A,B,C,D)</code>.</p></td></tr><tr id="type-kind_of_term.App" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.App" class="anchor"></a><code>| </code><code><span class="constructor">App</span> <span class="keyword">of</span> <span class="type-var">'constr</span> * <span><span class="type-var">'constr</span> array</span></code></td><td class="doc"><p>Concrete syntax <code>&quot;(F P1 P2 ...  Pn)&quot;</code> is represented as <code>App (F, [|P1; P2; ...; Pn|])</code>.</p><p>The <a href="index.html#val-mkApp"><code>mkApp</code></a> constructor also enforces the following invariant:</p><ul><li><code>F</code> itself is not <a href="index.html#type-kind_of_term.App"><code>App</code></a></li><li>and <code>[|P1;..;Pn|]</code> is not empty.</li></ul></td></tr><tr id="type-kind_of_term.Const" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Const" class="anchor"></a><code>| </code><code><span class="constructor">Const</span> <span class="keyword">of</span> <a href="../Names/Constant/index.html#type-t">Names.Constant.t</a> * <span class="type-var">'univs</span></code></td><td class="doc"><p>Gallina-variable that was introduced by Vernacular-command that extends the global environment (i.e. <code>Parameter</code>, or <code>Axiom</code>, or <code>Definition</code>, or <code>Theorem</code> etc.)</p></td></tr><tr id="type-kind_of_term.Ind" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Ind" class="anchor"></a><code>| </code><code><span class="constructor">Ind</span> <span class="keyword">of</span> <a href="../Names/index.html#type-inductive">Names.inductive</a> * <span class="type-var">'univs</span></code></td><td class="doc"><p>A name of an inductive type defined by <code>Variant</code>, <code>Inductive</code> or <code>Record</code> Vernacular-commands.</p></td></tr><tr id="type-kind_of_term.Construct" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Construct" class="anchor"></a><code>| </code><code><span class="constructor">Construct</span> <span class="keyword">of</span> <a href="../Names/index.html#type-constructor">Names.constructor</a> * <span class="type-var">'univs</span></code></td><td class="doc"><p>A constructor of an inductive type defined by <code>Variant</code>, <code>Inductive</code> or <code>Record</code> Vernacular-commands.</p></td></tr><tr id="type-kind_of_term.Case" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Case" class="anchor"></a><code>| </code><code><span class="constructor">Case</span> <span class="keyword">of</span> <a href="index.html#type-case_info">case_info</a> * <span class="type-var">'constr</span> * <span class="type-var">'constr</span> * <span><span class="type-var">'constr</span> array</span></code></td></tr><tr id="type-kind_of_term.Fix" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Fix" class="anchor"></a><code>| </code><code><span class="constructor">Fix</span> <span class="keyword">of</span> <span><span>(<span class="type-var">'constr</span>, <span class="type-var">'types</span>)</span> <a href="index.html#type-pfixpoint">pfixpoint</a></span></code></td></tr><tr id="type-kind_of_term.CoFix" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.CoFix" class="anchor"></a><code>| </code><code><span class="constructor">CoFix</span> <span class="keyword">of</span> <span><span>(<span class="type-var">'constr</span>, <span class="type-var">'types</span>)</span> <a href="index.html#type-pcofixpoint">pcofixpoint</a></span></code></td></tr><tr id="type-kind_of_term.Proj" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Proj" class="anchor"></a><code>| </code><code><span class="constructor">Proj</span> <span class="keyword">of</span> <a href="../Names/Projection/index.html#type-t">Names.Projection.t</a> * <span class="type-var">'constr</span></code></td></tr><tr id="type-kind_of_term.Int" class="anchored"><td class="def constructor"><a href="#type-kind_of_term.Int" class="anchor"></a><code>| </code><code><span class="constructor">Int</span> <span class="keyword">of</span> <a href="../Uint63/index.html#type-t">Uint63.t</a></code></td></tr></table></dt></dl><aside><p>User view of <code>constr</code>. For <code>App</code>, it is ensured there is at least one argument and the function is not itself an applicative term</p></aside><dl><dt class="spec value" id="val-kind"><a href="#val-kind" class="anchor"></a><code><span class="keyword">val</span> kind : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-types">types</a>, <a href="../Sorts/index.html#type-t">Sorts.t</a>, <a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a>)</span> <a href="index.html#type-kind_of_term">kind_of_term</a></span></code></dt><dt class="spec value" id="val-of_kind"><a href="#val-of_kind" class="anchor"></a><code><span class="keyword">val</span> of_kind : <span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-types">types</a>, <a href="../Sorts/index.html#type-t">Sorts.t</a>, <a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a>)</span> <a href="index.html#type-kind_of_term">kind_of_term</a></span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dt class="spec value" id="val-kind_nocast_gen"><a href="#val-kind_nocast_gen" class="anchor"></a><code><span class="keyword">val</span> kind_nocast_gen : <span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="index.html#type-kind_of_term">kind_of_term</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="index.html#type-kind_of_term">kind_of_term</a></span></code></dt><dt class="spec value" id="val-kind_nocast"><a href="#val-kind_nocast" class="anchor"></a><code><span class="keyword">val</span> kind_nocast : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-types">types</a>, <a href="../Sorts/index.html#type-t">Sorts.t</a>, <a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a>)</span> <a href="index.html#type-kind_of_term">kind_of_term</a></span></code></dt><dt class="spec value" id="val-isRel"><a href="#val-isRel" class="anchor"></a><code><span class="keyword">val</span> isRel : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dd><h6 id="simple-case-analysis"><a href="#simple-case-analysis" class="anchor"></a>Simple case analysis</h6></dd></dl><dl><dt class="spec value" id="val-isRelN"><a href="#val-isRelN" class="anchor"></a><code><span class="keyword">val</span> isRelN : int <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isVar"><a href="#val-isVar" class="anchor"></a><code><span class="keyword">val</span> isVar : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isVarId"><a href="#val-isVarId" class="anchor"></a><code><span class="keyword">val</span> isVarId : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isInd"><a href="#val-isInd" class="anchor"></a><code><span class="keyword">val</span> isInd : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isEvar"><a href="#val-isEvar" class="anchor"></a><code><span class="keyword">val</span> isEvar : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isMeta"><a href="#val-isMeta" class="anchor"></a><code><span class="keyword">val</span> isMeta : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isEvar_or_Meta"><a href="#val-isEvar_or_Meta" class="anchor"></a><code><span class="keyword">val</span> isEvar_or_Meta : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isSort"><a href="#val-isSort" class="anchor"></a><code><span class="keyword">val</span> isSort : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isCast"><a href="#val-isCast" class="anchor"></a><code><span class="keyword">val</span> isCast : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isApp"><a href="#val-isApp" class="anchor"></a><code><span class="keyword">val</span> isApp : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isLambda"><a href="#val-isLambda" class="anchor"></a><code><span class="keyword">val</span> isLambda : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isLetIn"><a href="#val-isLetIn" class="anchor"></a><code><span class="keyword">val</span> isLetIn : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isProd"><a href="#val-isProd" class="anchor"></a><code><span class="keyword">val</span> isProd : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isConst"><a href="#val-isConst" class="anchor"></a><code><span class="keyword">val</span> isConst : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isConstruct"><a href="#val-isConstruct" class="anchor"></a><code><span class="keyword">val</span> isConstruct : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isFix"><a href="#val-isFix" class="anchor"></a><code><span class="keyword">val</span> isFix : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isCoFix"><a href="#val-isCoFix" class="anchor"></a><code><span class="keyword">val</span> isCoFix : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isCase"><a href="#val-isCase" class="anchor"></a><code><span class="keyword">val</span> isCase : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isProj"><a href="#val-isProj" class="anchor"></a><code><span class="keyword">val</span> isProj : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_Prop"><a href="#val-is_Prop" class="anchor"></a><code><span class="keyword">val</span> is_Prop : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_Set"><a href="#val-is_Set" class="anchor"></a><code><span class="keyword">val</span> is_Set : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-isprop"><a href="#val-isprop" class="anchor"></a><code><span class="keyword">val</span> isprop : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_Type"><a href="#val-is_Type" class="anchor"></a><code><span class="keyword">val</span> is_Type : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-iskind"><a href="#val-iskind" class="anchor"></a><code><span class="keyword">val</span> iskind : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_small"><a href="#val-is_small" class="anchor"></a><code><span class="keyword">val</span> is_small : <a href="../Sorts/index.html#type-t">Sorts.t</a> <span>&#45;&gt;</span> bool</code></dt></dl></section><section><header><h6 id="term-destructors"><a href="#term-destructors" class="anchor"></a>Term destructors</h6></header><aside><p>Destructor operations are partial functions and</p><dl><dt>raises DestKO</dt><dd><p>if the term has not the expected form.</p></dd></dl></aside><dl><dt class="spec exception" id="exception-DestKO"><a href="#exception-DestKO" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">DestKO</span></code></dt></dl><dl><dt class="spec value" id="val-destRel"><a href="#val-destRel" class="anchor"></a><code><span class="keyword">val</span> destRel : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Destructs a de Bruijn index</p></dd></dl><dl><dt class="spec value" id="val-destMeta"><a href="#val-destMeta" class="anchor"></a><code><span class="keyword">val</span> destMeta : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-metavariable">metavariable</a></code></dt><dd><p>Destructs an existential variable</p></dd></dl><dl><dt class="spec value" id="val-destVar"><a href="#val-destVar" class="anchor"></a><code><span class="keyword">val</span> destVar : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="../Names/Id/index.html#type-t">Names.Id.t</a></code></dt><dd><p>Destructs a variable</p></dd></dl><dl><dt class="spec value" id="val-destSort"><a href="#val-destSort" class="anchor"></a><code><span class="keyword">val</span> destSort : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="../Sorts/index.html#type-t">Sorts.t</a></code></dt><dd><p>Destructs a sort. <code>is_Prop</code> recognizes the sort <code>Prop</code>, whether <code>isprop</code> recognizes both <code>Prop</code> and <code>Set</code>.</p></dd></dl><dl><dt class="spec value" id="val-destCast"><a href="#val-destCast" class="anchor"></a><code><span class="keyword">val</span> destCast : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> * <a href="index.html#type-cast_kind">cast_kind</a> * <a href="index.html#type-constr">constr</a></code></dt><dd><p>Destructs a casted term</p></dd></dl><dl><dt class="spec value" id="val-destProd"><a href="#val-destProd" class="anchor"></a><code><span class="keyword">val</span> destProd : <a href="index.html#type-types">types</a> <span>&#45;&gt;</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="index.html#type-types">types</a> * <a href="index.html#type-types">types</a></code></dt><dd><p>Destructs the product <code> $ </code>(x:t_1)t_2<code> $ </code></p></dd></dl><dl><dt class="spec value" id="val-destLambda"><a href="#val-destLambda" class="anchor"></a><code><span class="keyword">val</span> destLambda : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="index.html#type-types">types</a> * <a href="index.html#type-constr">constr</a></code></dt><dd><p>Destructs the abstraction <code> $ </code><code>x:t_1</code>t_2<code> $ </code></p></dd></dl><dl><dt class="spec value" id="val-destLetIn"><a href="#val-destLetIn" class="anchor"></a><code><span class="keyword">val</span> destLetIn : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="index.html#type-constr">constr</a> * <a href="index.html#type-types">types</a> * <a href="index.html#type-constr">constr</a></code></dt><dd><p>Destructs the let <code> $ </code><code>x:=b:t_1</code>t_2<code> $ </code></p></dd></dl><dl><dt class="spec value" id="val-destApp"><a href="#val-destApp" class="anchor"></a><code><span class="keyword">val</span> destApp : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> * <span><a href="index.html#type-constr">constr</a> array</span></code></dt><dd><p>Destructs an application</p></dd></dl><dl><dt class="spec value" id="val-decompose_app"><a href="#val-decompose_app" class="anchor"></a><code><span class="keyword">val</span> decompose_app : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> * <span><a href="index.html#type-constr">constr</a> list</span></code></dt><dd><p>Decompose any term as an applicative term; the list of args can be empty</p></dd></dl><dl><dt class="spec value" id="val-decompose_appvect"><a href="#val-decompose_appvect" class="anchor"></a><code><span class="keyword">val</span> decompose_appvect : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> * <span><a href="index.html#type-constr">constr</a> array</span></code></dt><dd><p>Same as <code>decompose_app</code>, but returns an array.</p></dd></dl><dl><dt class="spec value" id="val-destConst"><a href="#val-destConst" class="anchor"></a><code><span class="keyword">val</span> destConst : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span><a href="../Names/Constant/index.html#type-t">Names.Constant.t</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a></span></code></dt><dd><p>Destructs a constant</p></dd></dl><dl><dt class="spec value" id="val-destEvar"><a href="#val-destEvar" class="anchor"></a><code><span class="keyword">val</span> destEvar : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-existential">existential</a></code></dt><dd><p>Destructs an existential variable</p></dd></dl><dl><dt class="spec value" id="val-destInd"><a href="#val-destInd" class="anchor"></a><code><span class="keyword">val</span> destInd : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span><a href="../Names/index.html#type-inductive">Names.inductive</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a></span></code></dt><dd><p>Destructs a (co)inductive type</p></dd></dl><dl><dt class="spec value" id="val-destConstruct"><a href="#val-destConstruct" class="anchor"></a><code><span class="keyword">val</span> destConstruct : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span><a href="../Names/index.html#type-constructor">Names.constructor</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a></span></code></dt><dd><p>Destructs a constructor</p></dd></dl><dl><dt class="spec value" id="val-destCase"><a href="#val-destCase" class="anchor"></a><code><span class="keyword">val</span> destCase : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-case_info">case_info</a> * <a href="index.html#type-constr">constr</a> * <a href="index.html#type-constr">constr</a> * <span><a href="index.html#type-constr">constr</a> array</span></code></dt><dd><p>Destructs a <code>match c as x in I args return P with ... |
Ci(...yij...) =&gt; ti | ... end</code> (or <code>let (..y1i..) := c as x in I args
return P in t1</code>, or <code>if c then t1 else t2</code>)</p><dl><dt>returns</dt><dd><p><code>(info,c,fun args x =&gt; P,[|...|fun yij =&gt; ti| ...|])</code> where <code>info</code> is pretty-printing information</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-destProj"><a href="#val-destProj" class="anchor"></a><code><span class="keyword">val</span> destProj : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="../Names/Projection/index.html#type-t">Names.Projection.t</a> * <a href="index.html#type-constr">constr</a></code></dt><dd><p>Destructs a projection</p></dd></dl><dl><dt class="spec value" id="val-destFix"><a href="#val-destFix" class="anchor"></a><code><span class="keyword">val</span> destFix : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-fixpoint">fixpoint</a></code></dt><dd><p>Destructs the <code> $ </code>i<code> $ </code>th function of the block <code>Fixpoint f{_ 1} ctx{_ 1} = b{_ 1}
    with    f{_ 2} ctx{_ 2} = b{_ 2}
    ...
    with    f{_ n} ctx{_ n} = b{_ n}</code>, where the length of the <code> $ </code>j<code> $ </code>th context is <code> $ </code>ij<code> $ </code>.</p></dd></dl><dl><dt class="spec value" id="val-destCoFix"><a href="#val-destCoFix" class="anchor"></a><code><span class="keyword">val</span> destCoFix : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-cofixpoint">cofixpoint</a></code></dt><dt class="spec value" id="val-destRef"><a href="#val-destRef" class="anchor"></a><code><span class="keyword">val</span> destRef : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span><a href="../Names/GlobRef/index.html#type-t">Names.GlobRef.t</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a></span></code></dt></dl></section><section><header><h6 id="equality"><a href="#equality" class="anchor"></a>Equality</h6></header><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal a b</code> is true if <code>a</code> equals <code>b</code> modulo alpha, casts, and application grouping</p></dd></dl><dl><dt class="spec value" id="val-eq_constr_univs"><a href="#val-eq_constr_univs" class="anchor"></a><code><span class="keyword">val</span> eq_constr_univs : <span><a href="index.html#type-constr">constr</a> <a href="../UGraph/index.html#type-check_function">UGraph.check_function</a></span></code></dt><dd><p><code>eq_constr_univs u a b</code> is <code>true</code> if <code>a</code> equals <code>b</code> modulo alpha, casts, application grouping and the universe equalities in <code>u</code>.</p></dd></dl><dl><dt class="spec value" id="val-leq_constr_univs"><a href="#val-leq_constr_univs" class="anchor"></a><code><span class="keyword">val</span> leq_constr_univs : <span><a href="index.html#type-constr">constr</a> <a href="../UGraph/index.html#type-check_function">UGraph.check_function</a></span></code></dt><dd><p><code>leq_constr_univs u a b</code> is <code>true</code> if <code>a</code> is convertible to <code>b</code> modulo alpha, casts, application grouping and the universe inequalities in <code>u</code>.</p></dd></dl><dl><dt class="spec value" id="val-eq_constr_univs_infer"><a href="#val-eq_constr_univs_infer" class="anchor"></a><code><span class="keyword">val</span> eq_constr_univs_infer : <a href="../UGraph/index.html#type-t">UGraph.t</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span>bool <a href="../Univ/index.html#type-constrained">Univ.constrained</a></span></code></dt><dd><p><code>eq_constr_univs u a b</code> is <code>true</code> if <code>a</code> equals <code>b</code> modulo alpha, casts, application grouping and the universe equalities in <code>u</code>.</p></dd></dl><dl><dt class="spec value" id="val-leq_constr_univs_infer"><a href="#val-leq_constr_univs_infer" class="anchor"></a><code><span class="keyword">val</span> leq_constr_univs_infer : <a href="../UGraph/index.html#type-t">UGraph.t</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span>bool <a href="../Univ/index.html#type-constrained">Univ.constrained</a></span></code></dt><dd><p><code>leq_constr_univs u a b</code> is <code>true</code> if <code>a</code> is convertible to <code>b</code> modulo alpha, casts, application grouping and the universe inequalities in <code>u</code>.</p></dd></dl><dl><dt class="spec value" id="val-eq_constr_nounivs"><a href="#val-eq_constr_nounivs" class="anchor"></a><code><span class="keyword">val</span> eq_constr_nounivs : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>eq_constr_univs a b</code> <code>true, c</code> if <code>a</code> equals <code>b</code> modulo alpha, casts, application grouping and ignoring universe instances.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Total ordering compatible with <code>equal</code></p></dd></dl></section><section><header><h6 id="extension-of-context-with-declarations-on-constr"><a href="#extension-of-context-with-declarations-on-constr" class="anchor"></a>Extension of Context with declarations on constr</h6></header><dl><dt class="spec type" id="type-rel_declaration"><a href="#type-rel_declaration" class="anchor"></a><code><span class="keyword">type</span> rel_declaration</code><code> = <span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-types">types</a>)</span> <a href="../Context/Rel/Declaration/index.html#type-pt">Context.Rel.Declaration.pt</a></span></code></dt><dt class="spec type" id="type-named_declaration"><a href="#type-named_declaration" class="anchor"></a><code><span class="keyword">type</span> named_declaration</code><code> = <span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-types">types</a>)</span> <a href="../Context/Named/Declaration/index.html#type-pt">Context.Named.Declaration.pt</a></span></code></dt><dt class="spec type" id="type-compacted_declaration"><a href="#type-compacted_declaration" class="anchor"></a><code><span class="keyword">type</span> compacted_declaration</code><code> = <span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-types">types</a>)</span> <a href="../Context/Compacted/Declaration/index.html#type-pt">Context.Compacted.Declaration.pt</a></span></code></dt><dt class="spec type" id="type-rel_context"><a href="#type-rel_context" class="anchor"></a><code><span class="keyword">type</span> rel_context</code><code> = <span><a href="index.html#type-rel_declaration">rel_declaration</a> list</span></code></dt><dt class="spec type" id="type-named_context"><a href="#type-named_context" class="anchor"></a><code><span class="keyword">type</span> named_context</code><code> = <span><a href="index.html#type-named_declaration">named_declaration</a> list</span></code></dt><dt class="spec type" id="type-compacted_context"><a href="#type-compacted_context" class="anchor"></a><code><span class="keyword">type</span> compacted_context</code><code> = <span><a href="index.html#type-compacted_declaration">compacted_declaration</a> list</span></code></dt></dl></section><section><header><h6 id="relocation-and-substitution"><a href="#relocation-and-substitution" class="anchor"></a>Relocation and substitution</h6></header><dl><dt class="spec value" id="val-exliftn"><a href="#val-exliftn" class="anchor"></a><code><span class="keyword">val</span> exliftn : <a href="../Esubst/index.html#type-lift">Esubst.lift</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p><code>exliftn el c</code> lifts <code>c</code> with lifting <code>el</code></p></dd></dl><dl><dt class="spec value" id="val-liftn"><a href="#val-liftn" class="anchor"></a><code><span class="keyword">val</span> liftn : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p><code>liftn n k c</code> lifts by <code>n</code> indexes above or equal to <code>k</code> in <code>c</code></p></dd></dl><dl><dt class="spec value" id="val-lift"><a href="#val-lift" class="anchor"></a><code><span class="keyword">val</span> lift : int <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p><code>lift n c</code> lifts by <code>n</code> the positive indexes in <code>c</code></p></dd></dl></section><section><header><h6 id="functionals-working-on-expressions-canonically-abstracted-over-a-local-context-(possibly-with-let-ins)"><a href="#functionals-working-on-expressions-canonically-abstracted-over-a-local-context-(possibly-with-let-ins)" class="anchor"></a>Functionals working on expressions canonically abstracted over a local context (possibly with let-ins)</h6></header><aside><p><code>map_under_context f l c</code> maps <code>f</code> on the immediate subterms of a term abstracted over a context of length <code>n</code> (local definitions are counted)</p></aside><dl><dt class="spec value" id="val-map_under_context"><a href="#val-map_under_context" class="anchor"></a><code><span class="keyword">val</span> map_under_context : <span>(<a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl><aside><p><code>map_branches f br</code> maps <code>f</code> on the immediate subterms of an array of &quot;match&quot; branches <code>br</code> in canonical eta-let-expanded form; it is not recursive and the order with which subterms are processed is not specified; it preserves sharing; the immediate subterms are the types and possibly terms occurring in the context of each branch as well as the body of each branch</p></aside><dl><dt class="spec value" id="val-map_branches"><a href="#val-map_branches" class="anchor"></a><code><span class="keyword">val</span> map_branches : <span>(<a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-case_info">case_info</a> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> array</span> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> array</span></code></dt></dl><aside><p><code>map_return_predicate f p</code> maps <code>f</code> on the immediate subterms of a return predicate of a &quot;match&quot; in canonical eta-let-expanded form; it is not recursive and the order with which subterms are processed is not specified; it preserves sharing; the immediate subterms are the types and possibly terms occurring in the context of each branch as well as the body of the predicate</p></aside><dl><dt class="spec value" id="val-map_return_predicate"><a href="#val-map_return_predicate" class="anchor"></a><code><span class="keyword">val</span> map_return_predicate : <span>(<a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-case_info">case_info</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl><aside><p><code>map_under_context_with_binders g f n l c</code> maps <code>f</code> on the immediate subterms of a term abstracted over a context of length <code>n</code> (local definitions are counted); it preserves sharing; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically add 1 to <code>n</code>) at each binder traversal</p></aside><dl><dt class="spec value" id="val-map_under_context_with_binders"><a href="#val-map_under_context_with_binders" class="anchor"></a><code><span class="keyword">val</span> map_under_context_with_binders : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl><aside><p><code>map_branches_with_binders f br</code> maps <code>f</code> on the immediate subterms of an array of &quot;match&quot; branches <code>br</code> in canonical eta-let-expanded form; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically adds 1 to <code>n</code>) at each binder traversal; it is not recursive and the order with which subterms are processed is not specified; it preserves sharing; the immediate subterms are the types and possibly terms occurring in the context of the branch as well as the body of the branch</p></aside><dl><dt class="spec value" id="val-map_branches_with_binders"><a href="#val-map_branches_with_binders" class="anchor"></a><code><span class="keyword">val</span> map_branches_with_binders : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-case_info">case_info</a> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> array</span> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> array</span></code></dt></dl><aside><p><code>map_return_predicate_with_binders f p</code> maps <code>f</code> on the immediate subterms of a return predicate of a &quot;match&quot; in canonical eta-let-expanded form; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically adds 1 to <code>n</code>) at each binder traversal; it is not recursive and the order with which subterms are processed is not specified; it preserves sharing; the immediate subterms are the types and possibly terms occurring in the context of each branch as well as the body of the predicate</p></aside><dl><dt class="spec value" id="val-map_return_predicate_with_binders"><a href="#val-map_return_predicate_with_binders" class="anchor"></a><code><span class="keyword">val</span> map_return_predicate_with_binders : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-case_info">case_info</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl><aside><p><code>map_under_context_with_full_binders g f n l c</code> is similar to <code>map_under_context_with_binders</code> except that <code>g</code> takes also a full binder as argument and that only the number of binders (and not their signature) is required</p></aside><dl><dt class="spec value" id="val-map_under_context_with_full_binders"><a href="#val-map_under_context_with_full_binders" class="anchor"></a><code><span class="keyword">val</span> map_under_context_with_full_binders : <span>(<span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-constr">constr</a>)</span> <a href="../Context/Rel/Declaration/index.html#type-pt">Context.Rel.Declaration.pt</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl><aside><p><code>map_branches_with_full_binders g f l br</code> is equivalent to <code>map_branches_with_binders</code> but using <code>map_under_context_with_full_binders</code></p></aside><dl><dt class="spec value" id="val-map_branches_with_full_binders"><a href="#val-map_branches_with_full_binders" class="anchor"></a><code><span class="keyword">val</span> map_branches_with_full_binders : <span>(<span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-constr">constr</a>)</span> <a href="../Context/Rel/Declaration/index.html#type-pt">Context.Rel.Declaration.pt</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-case_info">case_info</a> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> array</span> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> array</span></code></dt></dl><aside><p><code>map_return_predicate_with_full_binders g f l p</code> is equivalent to <code>map_return_predicate_with_binders</code> but using <code>map_under_context_with_full_binders</code></p></aside><dl><dt class="spec value" id="val-map_return_predicate_with_full_binders"><a href="#val-map_return_predicate_with_full_binders" class="anchor"></a><code><span class="keyword">val</span> map_return_predicate_with_full_binders : <span>(<span><span>(<a href="index.html#type-constr">constr</a>, <a href="index.html#type-constr">constr</a>)</span> <a href="../Context/Rel/Declaration/index.html#type-pt">Context.Rel.Declaration.pt</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-case_info">case_info</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl></section><section><header><h6 id="functionals-working-on-the-immediate-subterm-of-a-construction"><a href="#functionals-working-on-the-immediate-subterm-of-a-construction" class="anchor"></a>Functionals working on the immediate subterm of a construction</h6></header><aside><p><code>fold f acc c</code> folds <code>f</code> on the immediate subterms of <code>c</code> starting from <code>acc</code> and proceeding from left to right according to the usual representation of the constructions; it is not recursive</p></aside><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_with_full_binders"><a href="#val-fold_with_full_binders" class="anchor"></a><code><span class="keyword">val</span> fold_with_full_binders : <span>(<a href="index.html#type-rel_declaration">rel_declaration</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt></dl><aside><p><code>map f c</code> maps <code>f</code> on the immediate subterms of <code>c</code>; it is not recursive and the order with which subterms are processed is not specified</p></aside><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl><aside><p><code>map_user_view f c</code> maps <code>f</code> on the immediate subterms of <code>c</code>; it differs from <code>map f c</code> in that the typing context and body of the return predicate and of the branches of a <code>match</code> are considered as immediate subterm of a <code>match</code></p></aside><dl><dt class="spec value" id="val-map_user_view"><a href="#val-map_user_view" class="anchor"></a><code><span class="keyword">val</span> map_user_view : <span>(<a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl><aside><p>Like <a href="index.html#val-map"><code>map</code></a>, but also has an additional accumulator.</p></aside><dl><dt class="spec value" id="val-fold_map"><a href="#val-fold_map" class="anchor"></a><code><span class="keyword">val</span> fold_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <a href="index.html#type-constr">constr</a></code></dt></dl><aside><p><code>map_with_binders g f n c</code> maps <code>f n</code> on the immediate subterms of <code>c</code>; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically add 1 to <code>n</code>) at each binder traversal; it is not recursive and the order with which subterms are processed is not specified</p></aside><dl><dt class="spec value" id="val-map_with_binders"><a href="#val-map_with_binders" class="anchor"></a><code><span class="keyword">val</span> map_with_binders : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt></dl><aside><p><code>iter f c</code> iters <code>f</code> on the immediate subterms of <code>c</code>; it is not recursive and the order with which subterms are processed is not specified</p></aside><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> unit</code></dt></dl><aside><p><code>iter_with_binders g f n c</code> iters <code>f n</code> on the immediate subterms of <code>c</code>; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically add 1 to <code>n</code>) at each binder traversal; it is not recursive and the order with which subterms are processed is not specified</p></aside><dl><dt class="spec value" id="val-iter_with_binders"><a href="#val-iter_with_binders" class="anchor"></a><code><span class="keyword">val</span> iter_with_binders : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> unit</code></dt></dl><aside><p><code>iter_with_binders g f n c</code> iters <code>f n</code> on the immediate subterms of <code>c</code>; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically add 1 to <code>n</code>) at each binder traversal; it is not recursive and the order with which subterms are processed is not specified</p></aside><dl><dt class="spec value" id="val-fold_constr_with_binders"><a href="#val-fold_constr_with_binders" class="anchor"></a><code><span class="keyword">val</span> fold_constr_with_binders : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt></dl><dl><dt class="spec type" id="type-constr_compare_fn"><a href="#type-constr_compare_fn" class="anchor"></a><code><span class="keyword">type</span> <span>'constr constr_compare_fn</span></code><code> = int <span>&#45;&gt;</span> <span class="type-var">'constr</span> <span>&#45;&gt;</span> <span class="type-var">'constr</span> <span>&#45;&gt;</span> bool</code></dt></dl><aside><p><code>compare_head f c1 c2</code> compare <code>c1</code> and <code>c2</code> using <code>f</code> to compare the immediate subterms of <code>c1</code> of <code>c2</code> if needed; Cast's, binders name and Cases annotations are not taken into account</p></aside><dl><dt class="spec value" id="val-compare_head"><a href="#val-compare_head" class="anchor"></a><code><span class="keyword">val</span> compare_head : <span><a href="index.html#type-constr">constr</a> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span></code></dt></dl><dl><dt class="spec type" id="type-instance_compare_fn"><a href="#type-instance_compare_fn" class="anchor"></a><code><span class="keyword">type</span> <span>'univs instance_compare_fn</span></code><code> = <a href="../Names/GlobRef/index.html#type-t">Names.GlobRef.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'univs</span> <span>&#45;&gt;</span> <span class="type-var">'univs</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Convert a global reference applied to 2 instances. The int says how many arguments are given (as we can only use cumulativity for fully applied inductives/constructors) .</p></dd></dl><aside><p><code>compare_head_gen u s f c1 c2</code> compare <code>c1</code> and <code>c2</code> using <code>f</code> to compare the immediate subterms of <code>c1</code> of <code>c2</code> if needed, <code>u</code> to compare universe instances, <code>s</code> to compare sorts; Cast's, binders name and Cases annotations are not taken into account</p></aside><dl><dt class="spec value" id="val-compare_head_gen"><a href="#val-compare_head_gen" class="anchor"></a><code><span class="keyword">val</span> compare_head_gen : <span><a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> <a href="index.html#type-instance_compare_fn">instance_compare_fn</a></span> <span>&#45;&gt;</span> <span>(<a href="../Sorts/index.html#type-t">Sorts.t</a> <span>&#45;&gt;</span> <a href="../Sorts/index.html#type-t">Sorts.t</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span></code></dt><dt class="spec value" id="val-compare_head_gen_leq_with"><a href="#val-compare_head_gen_leq_with" class="anchor"></a><code><span class="keyword">val</span> compare_head_gen_leq_with : <span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="index.html#type-kind_of_term">kind_of_term</a></span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="index.html#type-kind_of_term">kind_of_term</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'univs</span> <a href="index.html#type-instance_compare_fn">instance_compare_fn</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'sort</span> <span>&#45;&gt;</span> <span class="type-var">'sort</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span></code></dt><dt class="spec value" id="val-compare_head_gen_with"><a href="#val-compare_head_gen_with" class="anchor"></a><code><span class="keyword">val</span> compare_head_gen_with : <span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="index.html#type-kind_of_term">kind_of_term</a></span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="index.html#type-kind_of_term">kind_of_term</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'univs</span> <a href="index.html#type-instance_compare_fn">instance_compare_fn</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'sort</span> <span>&#45;&gt;</span> <span class="type-var">'sort</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span></code></dt><dd><p><code>compare_head_gen_with k1 k2 u s f c1 c2</code> compares <code>c1</code> and <code>c2</code> like <code>compare_head_gen u s f c1 c2</code>, except that <code>k1</code> (resp. <code>k2</code>) is used,rather than <a href="index.html#val-kind"><code>kind</code></a>, to expose the immediate subterms of <code>c1</code> (resp. <code>c2</code>).</p></dd></dl><aside><p><code>compare_head_gen_leq u s f fle c1 c2</code> compare <code>c1</code> and <code>c2</code> using <code>f</code> to compare the immediate subterms of <code>c1</code> of <code>c2</code> for conversion, <code>fle</code> for cumulativity, <code>u</code> to compare universe instances (the first boolean tells if they belong to a Constant.t), <code>s</code> to compare sorts for for subtyping; Cast's, binders name and Cases annotations are not taken into account</p></aside><dl><dt class="spec value" id="val-compare_head_gen_leq"><a href="#val-compare_head_gen_leq" class="anchor"></a><code><span class="keyword">val</span> compare_head_gen_leq : <span><a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> <a href="index.html#type-instance_compare_fn">instance_compare_fn</a></span> <span>&#45;&gt;</span> <span>(<a href="../Sorts/index.html#type-t">Sorts.t</a> <span>&#45;&gt;</span> <a href="../Sorts/index.html#type-t">Sorts.t</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> <a href="index.html#type-constr_compare_fn">constr_compare_fn</a></span></code></dt></dl></section><section><header><h6 id="hashconsing"><a href="#hashconsing" class="anchor"></a>Hashconsing</h6></header><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-case_info_hash"><a href="#val-case_info_hash" class="anchor"></a><code><span class="keyword">val</span> case_info_hash : <a href="index.html#type-case_info">case_info</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-hcons"><a href="#val-hcons" class="anchor"></a><code><span class="keyword">val</span> hcons : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dt class="spec value" id="val-debug_print"><a href="#val-debug_print" class="anchor"></a><code><span class="keyword">val</span> debug_print : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="../Pp/index.html#type-t">Pp.t</a></code></dt><dt class="spec value" id="val-debug_print_fix"><a href="#val-debug_print_fix" class="anchor"></a><code><span class="keyword">val</span> debug_print_fix : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Pp/index.html#type-t">Pp.t</a>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-pfixpoint">pfixpoint</a></span> <span>&#45;&gt;</span> <a href="../Pp/index.html#type-t">Pp.t</a></code></dt></dl></section></div></body></html>