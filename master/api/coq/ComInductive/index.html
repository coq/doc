<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ComInductive (coq.ComInductive)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">coq</a> &#x00BB; ComInductive</nav><h1>Module <code>ComInductive</code></h1><h6 id="inductive-and-coinductive-types"><a href="#inductive-and-coinductive-types" class="anchor"></a>Inductive and coinductive types</h6></header><aside><p>Entry points for the vernacular commands Inductive and CoInductive</p></aside><dl><dt class="spec type" id="type-uniform_inductive_flag"><a href="#type-uniform_inductive_flag" class="anchor"></a><code><span class="keyword">type</span> uniform_inductive_flag</code><code> = </code><table class="variant"><tr id="type-uniform_inductive_flag.UniformParameters" class="anchored"><td class="def constructor"><a href="#type-uniform_inductive_flag.UniformParameters" class="anchor"></a><code>| </code><code><span class="constructor">UniformParameters</span></code></td></tr><tr id="type-uniform_inductive_flag.NonUniformParameters" class="anchored"><td class="def constructor"><a href="#type-uniform_inductive_flag.NonUniformParameters" class="anchor"></a><code>| </code><code><span class="constructor">NonUniformParameters</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-do_mutual_inductive"><a href="#val-do_mutual_inductive" class="anchor"></a><code><span class="keyword">val</span> do_mutual_inductive : <span>template:<span>bool option</span></span> <span>&#45;&gt;</span> <span><a href="../Constrexpr/index.html#type-universe_decl_expr">Constrexpr.universe_decl_expr</a> option</span> <span>&#45;&gt;</span> <span><span>(<a href="../Vernacexpr/index.html#type-one_inductive_expr">Vernacexpr.one_inductive_expr</a> * <span><a href="../Vernacexpr/index.html#type-decl_notation">Vernacexpr.decl_notation</a> list</span>)</span> list</span> <span>&#45;&gt;</span> <span>cumulative:bool</span> <span>&#45;&gt;</span> <span>poly:bool</span> <span>&#45;&gt;</span> <span>private_ind:bool</span> <span>&#45;&gt;</span> <span>uniform:<a href="index.html#type-uniform_inductive_flag">uniform_inductive_flag</a></span> <span>&#45;&gt;</span> <a href="../Declarations/index.html#type-recursivity_kind">Declarations.recursivity_kind</a> <span>&#45;&gt;</span> unit</code></dt></dl><aside><p>User-interface API</p></aside><aside><p>Prepare a &quot;match&quot; template for a given inductive type. For each branch of the match, we list the constructor name followed by enough pattern variables. <code>Not_found</code> is raised if the given string isn't the qualid of a known inductive type.</p></aside><dl><dt class="spec value" id="val-make_cases"><a href="#val-make_cases" class="anchor"></a><code><span class="keyword">val</span> make_cases : <a href="../Names/index.html#type-inductive">Names.inductive</a> <span>&#45;&gt;</span> <span><span>string list</span> list</span></code></dt><dt class="spec value" id="val-declare_mutual_inductive_with_eliminations"><a href="#val-declare_mutual_inductive_with_eliminations" class="anchor"></a><code><span class="keyword">val</span> declare_mutual_inductive_with_eliminations : <span>?&#8288;primitive_expected:bool</span> <span>&#45;&gt;</span> <a href="../Entries/index.html#type-mutual_inductive_entry">Entries.mutual_inductive_entry</a> <span>&#45;&gt;</span> <a href="../UnivNames/index.html#type-universe_binders">UnivNames.universe_binders</a> <span>&#45;&gt;</span> <span><a href="../DeclareInd/index.html#type-one_inductive_impls">DeclareInd.one_inductive_impls</a> list</span> <span>&#45;&gt;</span> <a href="../Names/MutInd/index.html#type-t">Names.MutInd.t</a></code></dt><dt class="spec value" id="val-interp_mutual_inductive_constr"><a href="#val-interp_mutual_inductive_constr" class="anchor"></a><code><span class="keyword">val</span> interp_mutual_inductive_constr : <span>sigma:<a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></span> <span>&#45;&gt;</span> <span>template:<span>bool option</span></span> <span>&#45;&gt;</span> <span>udecl:<a href="../UState/index.html#type-universe_decl">UState.universe_decl</a></span> <span>&#45;&gt;</span> <span>ctx_params:<span><span><span>(<a href="../EConstr/index.html#type-t">EConstr.t</a>, <a href="../EConstr/index.html#type-t">EConstr.t</a>)</span> <a href="../Context/Rel/Declaration/index.html#type-pt">Context.Rel.Declaration.pt</a></span> list</span></span> <span>&#45;&gt;</span> <span>indnames:<span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span></span> <span>&#45;&gt;</span> <span>arities:<span><a href="../EConstr/index.html#type-t">EConstr.t</a> list</span></span> <span>&#45;&gt;</span> <span>arityconcl:<span><span><span>(bool * <a href="../EConstr/ESorts/index.html#type-t">EConstr.ESorts.t</a>)</span> option</span> list</span></span> <span>&#45;&gt;</span> <span>constructors:<span><span>(<span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> * <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span>)</span> list</span></span> <span>&#45;&gt;</span> <span>env_ar_params:<a href="../Environ/index.html#type-env">Environ.env</a></span> <span>&#45;&gt;</span> <span>cumulative:bool</span> <span>&#45;&gt;</span> <span>poly:bool</span> <span>&#45;&gt;</span> <span>private_ind:bool</span> <span>&#45;&gt;</span> <span>finite:<a href="../Declarations/index.html#type-recursivity_kind">Declarations.recursivity_kind</a></span> <span>&#45;&gt;</span> <a href="../Entries/index.html#type-mutual_inductive_entry">Entries.mutual_inductive_entry</a> * <a href="../UnivNames/index.html#type-universe_binders">UnivNames.universe_binders</a></code></dt></dl><aside><p>Internal API, exported for Record</p></aside><dl><dt class="spec value" id="val-should_auto_template"><a href="#val-should_auto_template" class="anchor"></a><code><span class="keyword">val</span> should_auto_template : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> bool</code></dt><dd><p><code>should_auto_template x b</code> is <code>true</code> when <code>b</code> is <code>true</code> and we automatically use template polymorphism. <code>x</code> is the name of the inductive under consideration.</p></dd></dl><dl><dt class="spec value" id="val-template_polymorphism_candidate"><a href="#val-template_polymorphism_candidate" class="anchor"></a><code><span class="keyword">val</span> template_polymorphism_candidate : <span>template_check:bool</span> <span>&#45;&gt;</span> <span>ctor_levels:<a href="../Univ/LSet/index.html#type-t">Univ.LSet.t</a></span> <span>&#45;&gt;</span> <a href="../Entries/index.html#type-universes_entry">Entries.universes_entry</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span>&#45;&gt;</span> <span><a href="../Sorts/index.html#type-t">Sorts.t</a> option</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>template_polymorphism_candidate ~template_check ~ctor_levels uctx params
   conclsort</code> is <code>true</code> iff an inductive with params <code>params</code>, conclusion <code>conclsort</code> and universe levels appearing in the constructor arguments <code>ctor_levels</code> would be definable as template polymorphic. It should have at least one universe in its monomorphic universe context that can be made parametric in its conclusion sort, if one is given. If the <code>template_check</code> flag is false we just check that the conclusion sort is not small.</p></dd></dl></div></body></html>