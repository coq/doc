<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ComInductive (coq.ComInductive)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">coq</a> &#x00BB; ComInductive</nav><h1>Module <code>ComInductive</code></h1><nav class="toc"><ul><li><a href="#inductive-and-coinductive-types">Inductive and coinductive types</a></li></ul></nav></header><section><header><h6 id="inductive-and-coinductive-types"><a href="#inductive-and-coinductive-types" class="anchor"></a>Inductive and coinductive types</h6></header><aside><p>Entry points for the vernacular commands Inductive and CoInductive</p></aside><dl><dt class="spec type" id="type-uniform_inductive_flag"><a href="#type-uniform_inductive_flag" class="anchor"></a><code><span class="keyword">type</span> uniform_inductive_flag</code><code> = </code><table class="variant"><tr id="type-uniform_inductive_flag.UniformParameters" class="anchored"><td class="def constructor"><a href="#type-uniform_inductive_flag.UniformParameters" class="anchor"></a><code>| </code><code><span class="constructor">UniformParameters</span></code></td></tr><tr id="type-uniform_inductive_flag.NonUniformParameters" class="anchored"><td class="def constructor"><a href="#type-uniform_inductive_flag.NonUniformParameters" class="anchor"></a><code>| </code><code><span class="constructor">NonUniformParameters</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-do_mutual_inductive"><a href="#val-do_mutual_inductive" class="anchor"></a><code><span class="keyword">val</span> do_mutual_inductive : <span>template:<span>bool option</span></span> <span>&#45;&gt;</span> <span><a href="../Constrexpr/index.html#type-universe_decl_expr">Constrexpr.universe_decl_expr</a> option</span> <span>&#45;&gt;</span> <span><span>(<a href="../Vernacexpr/index.html#type-one_inductive_expr">Vernacexpr.one_inductive_expr</a> * <span><a href="../Vernacexpr/index.html#type-decl_notation">Vernacexpr.decl_notation</a> list</span>)</span> list</span> <span>&#45;&gt;</span> <span>cumulative:bool</span> <span>&#45;&gt;</span> <span>poly:bool</span> <span>&#45;&gt;</span> <span>private_ind:bool</span> <span>&#45;&gt;</span> <span>uniform:<a href="index.html#type-uniform_inductive_flag">uniform_inductive_flag</a></span> <span>&#45;&gt;</span> <a href="../Declarations/index.html#type-recursivity_kind">Declarations.recursivity_kind</a> <span>&#45;&gt;</span> unit</code></dt></dl><aside><p>User-interface API</p></aside><aside><p>Prepare a &quot;match&quot; template for a given inductive type. For each branch of the match, we list the constructor name followed by enough pattern variables. <code>Not_found</code> is raised if the given string isn't the qualid of a known inductive type.</p></aside><dl><dt class="spec value" id="val-make_cases"><a href="#val-make_cases" class="anchor"></a><code><span class="keyword">val</span> make_cases : <a href="../Names/index.html#type-inductive">Names.inductive</a> <span>&#45;&gt;</span> <span><span>string list</span> list</span></code></dt><dt class="spec value" id="val-declare_mutual_inductive_with_eliminations"><a href="#val-declare_mutual_inductive_with_eliminations" class="anchor"></a><code><span class="keyword">val</span> declare_mutual_inductive_with_eliminations : <span>?&#8288;primitive_expected:bool</span> <span>&#45;&gt;</span> <a href="../Entries/index.html#type-mutual_inductive_entry">Entries.mutual_inductive_entry</a> <span>&#45;&gt;</span> <a href="../UnivNames/index.html#type-universe_binders">UnivNames.universe_binders</a> <span>&#45;&gt;</span> <span><a href="../DeclareInd/index.html#type-one_inductive_impls">DeclareInd.one_inductive_impls</a> list</span> <span>&#45;&gt;</span> <a href="../Names/MutInd/index.html#type-t">Names.MutInd.t</a></code></dt><dt class="spec value" id="val-interp_mutual_inductive_constr"><a href="#val-interp_mutual_inductive_constr" class="anchor"></a><code><span class="keyword">val</span> interp_mutual_inductive_constr : <span>sigma:<a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></span> <span>&#45;&gt;</span> <span>template:<span>bool option</span></span> <span>&#45;&gt;</span> <span>udecl:<a href="../UState/index.html#type-universe_decl">UState.universe_decl</a></span> <span>&#45;&gt;</span> <span>ctx_params:<span><span><span>(<a href="../EConstr/index.html#type-t">EConstr.t</a>, <a href="../EConstr/index.html#type-t">EConstr.t</a>)</span> <a href="../Context/Rel/Declaration/index.html#type-pt">Context.Rel.Declaration.pt</a></span> list</span></span> <span>&#45;&gt;</span> <span>indnames:<span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span></span> <span>&#45;&gt;</span> <span>arities:<span><a href="../EConstr/index.html#type-t">EConstr.t</a> list</span></span> <span>&#45;&gt;</span> <span>arityconcl:<span><span><span>(bool * <a href="../EConstr/ESorts/index.html#type-t">EConstr.ESorts.t</a>)</span> option</span> list</span></span> <span>&#45;&gt;</span> <span>constructors:<span><span>(<span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> * <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span>)</span> list</span></span> <span>&#45;&gt;</span> <span>env_ar_params:<a href="../Environ/index.html#type-env">Environ.env</a></span> <span>&#45;&gt;</span> <span>cumulative:bool</span> <span>&#45;&gt;</span> <span>poly:bool</span> <span>&#45;&gt;</span> <span>private_ind:bool</span> <span>&#45;&gt;</span> <span>finite:<a href="../Declarations/index.html#type-recursivity_kind">Declarations.recursivity_kind</a></span> <span>&#45;&gt;</span> <a href="../Entries/index.html#type-mutual_inductive_entry">Entries.mutual_inductive_entry</a> * <a href="../UnivNames/index.html#type-universe_binders">UnivNames.universe_binders</a></code></dt></dl><aside><p>Internal API, exported for Record</p></aside><dl><dt class="spec value" id="val-should_auto_template"><a href="#val-should_auto_template" class="anchor"></a><code><span class="keyword">val</span> should_auto_template : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> bool</code></dt><dd><p><code>should_auto_template x b</code> is <code>true</code> when <code>b</code> is <code>true</code> and we automatically use template polymorphism. <code>x</code> is the name of the inductive under consideration.</p></dd></dl><dl><dt class="spec value" id="val-template_polymorphism_candidate"><a href="#val-template_polymorphism_candidate" class="anchor"></a><code><span class="keyword">val</span> template_polymorphism_candidate : <span>ctor_levels:<a href="../Univ/LSet/index.html#type-t">Univ.LSet.t</a></span> <span>&#45;&gt;</span> <a href="../Entries/index.html#type-universes_entry">Entries.universes_entry</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span>&#45;&gt;</span> <span><a href="../Sorts/index.html#type-t">Sorts.t</a> option</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>template_polymorphism_candidate ~ctor_levels uctx params
   conclsort</code> is <code>true</code> iff an inductive with params <code>params</code>, conclusion <code>conclsort</code> and universe levels appearing in the constructor arguments <code>ctor_levels</code> would be definable as template polymorphic. It should have at least one universe in its monomorphic universe context that can be made parametric in its conclusion sort, if one is given.</p></dd></dl><dl><dt class="spec value" id="val-maybe_unify_params_in"><a href="#val-maybe_unify_params_in" class="anchor"></a><code><span class="keyword">val</span> maybe_unify_params_in : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <span>ninds:int</span> <span>&#45;&gt;</span> <span>nparams:int</span> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-t">EConstr.t</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></code></dt><dd><p><code>nparams</code> is the number of parameters which aren't treated as uniform, ie the length of params (including letins) where the env is <code>uniform params, inductives, params</code>.</p></dd></dl></section></div></body></html>