<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ComInductive (coq.ComInductive)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; ComInductive</nav><h1>Module <code>ComInductive</code></h1><h6 id="inductive-and-coinductive-types"><a href="#inductive-and-coinductive-types" class="anchor"></a>Inductive and coinductive types</h6></header><aside><p>Entry points for the vernacular commands Inductive and CoInductive</p></aside><dl><dt class="spec type" id="type-uniform_inductive_flag"><a href="#type-uniform_inductive_flag" class="anchor"></a><code><span class="keyword">type</span> uniform_inductive_flag</code><code> = </code><table class="variant"><tr id="type-uniform_inductive_flag.UniformParameters" class="anchored"><td class="def constructor"><a href="#type-uniform_inductive_flag.UniformParameters" class="anchor"></a><code>| </code><code><span class="constructor">UniformParameters</span></code></td></tr><tr id="type-uniform_inductive_flag.NonUniformParameters" class="anchored"><td class="def constructor"><a href="#type-uniform_inductive_flag.NonUniformParameters" class="anchor"></a><code>| </code><code><span class="constructor">NonUniformParameters</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-do_mutual_inductive"><a href="#val-do_mutual_inductive" class="anchor"></a><code><span class="keyword">val</span> do_mutual_inductive : template:bool option <span>&#45;&gt;</span> <a href="../Constrexpr/index.html#type-universe_decl_expr">Constrexpr.universe_decl_expr</a> option <span>&#45;&gt;</span> (<a href="../Vernacexpr/index.html#type-one_inductive_expr">Vernacexpr.one_inductive_expr</a> * <a href="../Vernacexpr/index.html#type-decl_notation">Vernacexpr.decl_notation</a> list) list <span>&#45;&gt;</span> cumulative:bool <span>&#45;&gt;</span> poly:bool <span>&#45;&gt;</span> private_ind:bool <span>&#45;&gt;</span> uniform:<a href="index.html#type-uniform_inductive_flag">uniform_inductive_flag</a> <span>&#45;&gt;</span> <a href="../Declarations/index.html#type-recursivity_kind">Declarations.recursivity_kind</a> <span>&#45;&gt;</span> unit</code></dt></dl><aside><p>User-interface API</p></aside><aside><p>Prepare a &quot;match&quot; template for a given inductive type. For each branch of the match, we list the constructor name followed by enough pattern variables. <code>Not_found</code> is raised if the given string isn't the qualid of a known inductive type.</p></aside><dl><dt class="spec value" id="val-make_cases"><a href="#val-make_cases" class="anchor"></a><code><span class="keyword">val</span> make_cases : <a href="../Names/index.html#type-inductive">Names.inductive</a> <span>&#45;&gt;</span> string list list</code></dt></dl><aside><p>Internal API, exported for Record</p></aside><aside><p>Registering a mutual inductive definition together with its associated schemes</p></aside><dl><dt class="spec type" id="type-one_inductive_impls"><a href="#type-one_inductive_impls" class="anchor"></a><code><span class="keyword">type</span> one_inductive_impls</code><code> = <a href="../Impargs/index.html#type-manual_implicits">Impargs.manual_implicits</a> * <a href="../Impargs/index.html#type-manual_implicits">Impargs.manual_implicits</a> list</code></dt></dl><dl><dt class="spec value" id="val-declare_mutual_inductive_with_eliminations"><a href="#val-declare_mutual_inductive_with_eliminations" class="anchor"></a><code><span class="keyword">val</span> declare_mutual_inductive_with_eliminations : ?&#8288;primitive_expected:bool <span>&#45;&gt;</span> <a href="../Entries/index.html#type-mutual_inductive_entry">Entries.mutual_inductive_entry</a> <span>&#45;&gt;</span> <a href="../UnivNames/index.html#type-universe_binders">UnivNames.universe_binders</a> <span>&#45;&gt;</span> <a href="index.html#type-one_inductive_impls">one_inductive_impls</a> list <span>&#45;&gt;</span> <a href="../Names/MutInd/index.html#type-t">Names.MutInd.t</a></code></dt><dt class="spec value" id="val-should_auto_template"><a href="#val-should_auto_template" class="anchor"></a><code><span class="keyword">val</span> should_auto_template : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> bool</code></dt><dd><p><code>should_auto_template x b</code> is <code>true</code> when <code>b</code> is <code>true</code> and we automatically use template polymorphism. <code>x</code> is the name of the inductive under consideration.</p></dd></dl><dl><dt class="spec value" id="val-template_polymorphism_candidate"><a href="#val-template_polymorphism_candidate" class="anchor"></a><code><span class="keyword">val</span> template_polymorphism_candidate : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Entries/index.html#type-universes_entry">Entries.universes_entry</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span>&#45;&gt;</span> <a href="../Sorts/index.html#type-t">Sorts.t</a> option <span>&#45;&gt;</span> bool</code></dt><dd><p><code>template_polymorphism_candidate env uctx params conclsort</code> is <code>true</code> iff an inductive with params <code>params</code> and conclusion <code>conclsort</code> would be definable as template polymorphic. It should have at least one universe in its monomorphic universe context that can be made parametric in its conclusion sort, if one is given. If the <code>Template Check</code> flag is false we just check that the conclusion sort is not small.</p></dd></dl><dl><dt class="spec value" id="val-sign_level"><a href="#val-sign_level" class="anchor"></a><code><span class="keyword">val</span> sign_level : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> list <span>&#45;&gt;</span> <a href="../Univ/Universe/index.html#type-t">Univ.Universe.t</a></code></dt><dd><p><code>sign_level env sigma ctx</code> computes the universe level of the context <code>ctx</code> as the <code>sup</code> of its individual assumptions, which should be well-typed in <code>env</code> and <code>sigma</code></p></dd></dl></div></body></html>