<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Opaqueproof (coq.Opaqueproof)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Opaqueproof</nav><h1>Module <code>Opaqueproof</code></h1><p>This module implements the handling of opaque proof terms. Opaque proof terms are special since:</p><ul><li>they can be lazily computed and substituted</li><li>they are stored in an optionally loaded segment of .vo files An <code>opaque</code> proof terms holds the real data until fully discharged. In this case it is called <code>direct</code>. When it is <code>turn_indirect</code> the data is relocated to an opaque table and the <code>opaque</code> is turned into an index.</li></ul></header><dl><dt class="spec type" id="type-proofterm"><a href="#type-proofterm" class="anchor"></a><code><span class="keyword">type</span> proofterm</code><code> = (<a href="../Constr/index.html#type-constr">Constr.constr</a> * <a href="../Univ/ContextSet/index.html#type-t">Univ.ContextSet.t</a>) <a href="../Future/index.html#type-computation">Future.computation</a></code></dt><dt class="spec type" id="type-opaquetab"><a href="#type-opaquetab" class="anchor"></a><code><span class="keyword">type</span> opaquetab</code></dt><dt class="spec type" id="type-opaque"><a href="#type-opaque" class="anchor"></a><code><span class="keyword">type</span> opaque</code></dt></dl><dl><dt class="spec value" id="val-empty_opaquetab"><a href="#val-empty_opaquetab" class="anchor"></a><code><span class="keyword">val</span> empty_opaquetab : <a href="index.html#type-opaquetab">opaquetab</a></code></dt><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <a href="index.html#type-proofterm">proofterm</a> <span>&#45;&gt;</span> <a href="index.html#type-opaque">opaque</a></code></dt><dd><p>From a <code>proofterm</code> to some <code>opaque</code>.</p></dd></dl><dl><dt class="spec value" id="val-turn_indirect"><a href="#val-turn_indirect" class="anchor"></a><code><span class="keyword">val</span> turn_indirect : <a href="../Names/DirPath/index.html#type-t">Names.DirPath.t</a> <span>&#45;&gt;</span> <a href="index.html#type-opaque">opaque</a> <span>&#45;&gt;</span> <a href="index.html#type-opaquetab">opaquetab</a> <span>&#45;&gt;</span> <a href="index.html#type-opaque">opaque</a> * <a href="index.html#type-opaquetab">opaquetab</a></code></dt><dd><p>Turn a direct <code>opaque</code> into an indirect one. It is your responsibility to hashcons the inner term beforehand. The integer is an hint of the maximum id used so far</p></dd></dl><dl><dt class="spec type" id="type-indirect_accessor"><a href="#type-indirect_accessor" class="anchor"></a><code><span class="keyword">type</span> indirect_accessor</code><code> = </code><code>{</code><table class="record"><tr id="type-indirect_accessor.access_proof" class="anchored"><td class="def field"><a href="#type-indirect_accessor.access_proof" class="anchor"></a><code>access_proof : <a href="../Names/DirPath/index.html#type-t">Names.DirPath.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> option;</code></td></tr><tr id="type-indirect_accessor.access_constraints" class="anchored"><td class="def field"><a href="#type-indirect_accessor.access_constraints" class="anchor"></a><code>access_constraints : <a href="../Names/DirPath/index.html#type-t">Names.DirPath.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Univ/ContextSet/index.html#type-t">Univ.ContextSet.t</a> option;</code></td></tr></table><code>}</code></dt><dd><p>When stored indirectly, opaque terms are indexed by their library dirpath and an integer index. The two functions above activate this indirect storage, by telling how to retrieve terms.</p></dd></dl><dl><dt class="spec value" id="val-force_proof"><a href="#val-force_proof" class="anchor"></a><code><span class="keyword">val</span> force_proof : <a href="index.html#type-indirect_accessor">indirect_accessor</a> <span>&#45;&gt;</span> <a href="index.html#type-opaquetab">opaquetab</a> <span>&#45;&gt;</span> <a href="index.html#type-opaque">opaque</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>From a <code>opaque</code> back to a <code>constr</code>. This might use the indirect opaque accessor given as an argument.</p></dd></dl><dl><dt class="spec value" id="val-force_constraints"><a href="#val-force_constraints" class="anchor"></a><code><span class="keyword">val</span> force_constraints : <a href="index.html#type-indirect_accessor">indirect_accessor</a> <span>&#45;&gt;</span> <a href="index.html#type-opaquetab">opaquetab</a> <span>&#45;&gt;</span> <a href="index.html#type-opaque">opaque</a> <span>&#45;&gt;</span> <a href="../Univ/ContextSet/index.html#type-t">Univ.ContextSet.t</a></code></dt><dt class="spec value" id="val-get_direct_constraints"><a href="#val-get_direct_constraints" class="anchor"></a><code><span class="keyword">val</span> get_direct_constraints : <a href="index.html#type-opaque">opaque</a> <span>&#45;&gt;</span> <a href="../Univ/ContextSet/index.html#type-t">Univ.ContextSet.t</a> <a href="../Future/index.html#type-computation">Future.computation</a></code></dt><dt class="spec value" id="val-subst_opaque"><a href="#val-subst_opaque" class="anchor"></a><code><span class="keyword">val</span> subst_opaque : <a href="../Mod_subst/index.html#type-substitution">Mod_subst.substitution</a> <span>&#45;&gt;</span> <a href="index.html#type-opaque">opaque</a> <span>&#45;&gt;</span> <a href="index.html#type-opaque">opaque</a></code></dt></dl><dl><dt class="spec type" id="type-work_list"><a href="#type-work_list" class="anchor"></a><code><span class="keyword">type</span> work_list</code><code> = (<a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> * <a href="../Names/Id/index.html#type-t">Names.Id.t</a> array) <a href="../Names/Cmap/index.html#type-t">Names.Cmap.t</a> * (<a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> * <a href="../Names/Id/index.html#type-t">Names.Id.t</a> array) <a href="../Names/Mindmap/index.html#type-t">Names.Mindmap.t</a></code></dt><dt class="spec type" id="type-cooking_info"><a href="#type-cooking_info" class="anchor"></a><code><span class="keyword">type</span> cooking_info</code><code> = </code><code>{</code><table class="record"><tr id="type-cooking_info.modlist" class="anchored"><td class="def field"><a href="#type-cooking_info.modlist" class="anchor"></a><code>modlist : <a href="index.html#type-work_list">work_list</a>;</code></td></tr><tr id="type-cooking_info.abstract" class="anchored"><td class="def field"><a href="#type-cooking_info.abstract" class="anchor"></a><code>abstract : <a href="../Constr/index.html#type-named_context">Constr.named_context</a> * <a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> * <a href="../Univ/AUContext/index.html#type-t">Univ.AUContext.t</a>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-discharge_direct_opaque"><a href="#val-discharge_direct_opaque" class="anchor"></a><code><span class="keyword">val</span> discharge_direct_opaque : cook_constr:(<a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a>) <span>&#45;&gt;</span> <a href="index.html#type-cooking_info">cooking_info</a> <span>&#45;&gt;</span> <a href="index.html#type-opaque">opaque</a> <span>&#45;&gt;</span> <a href="index.html#type-opaque">opaque</a></code></dt><dt class="spec value" id="val-join_opaque"><a href="#val-join_opaque" class="anchor"></a><code><span class="keyword">val</span> join_opaque : ?&#8288;except:<a href="../Future/index.html#module-UUIDSet">Future.UUIDSet</a>.t <span>&#45;&gt;</span> <a href="index.html#type-opaquetab">opaquetab</a> <span>&#45;&gt;</span> <a href="index.html#type-opaque">opaque</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-dump"><a href="#val-dump" class="anchor"></a><code><span class="keyword">val</span> dump : ?&#8288;except:<a href="../Future/index.html#module-UUIDSet">Future.UUIDSet</a>.t <span>&#45;&gt;</span> <a href="index.html#type-opaquetab">opaquetab</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-t">Constr.t</a> option array * <a href="../Univ/ContextSet/index.html#type-t">Univ.ContextSet.t</a> option array * <a href="index.html#type-cooking_info">cooking_info</a> list array * int <a href="../Future/index.html#module-UUIDMap">Future.UUIDMap</a>.t</code></dt></dl></div></body></html>