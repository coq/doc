<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pcoq (coq.Pcoq)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">coq</a> &#x00BB; Pcoq</nav><h1>Module <code>Pcoq</code></h1><p>The parser of Coq</p><nav class="toc"><ul><li><a href="#extending-the-parser-without-synchronization">Extending the parser without synchronization</a></li><li><a href="#extending-the-parser-with-summary-synchronized-commands">Extending the parser with summary-synchronized commands</a></li><li><a href="#extension-with-parsing-rules">Extension with parsing rules</a></li><li><a href="#extension-with-parsing-entries">Extension with parsing entries</a></li><li><a href="#protection-w.r.t.-backtrack">Protection w.r.t. backtrack</a></li></ul></nav></header><div class="spec module" id="module-Parsable"><a href="#module-Parsable" class="anchor"></a><code><span class="keyword">module</span> <a href="Parsable/index.html">Parsable</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Entry"><a href="#module-Entry" class="anchor"></a><code><span class="keyword">module</span> <a href="Entry/index.html">Entry</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>The parser of Coq is built from three kinds of rule declarations:</p><ul><li>dynamic rules declared at the evaluation of Coq files (using e.g. Notation, Infix, or Tactic Notation)</li><li>static rules explicitly defined in files g_*.ml4</li><li>static rules macro-generated by ARGUMENT EXTEND, TACTIC EXTEND and VERNAC EXTEND (see e.g. file extratactics.ml4)</li></ul><p>Note that parsing a Coq document is in essence stateful: the parser needs to recognize commands that start proofs and use a different parsing entry point for them.</p><p>We thus provide two different interfaces: the &quot;raw&quot; parsing interface, in the style of camlp5, which provides more flexibility, and a more specialize &quot;parse_vernac&quot; one, which will indeed adjust the state as needed.</p></aside><aside><p>Dynamic extension of rules</p><p>For constr notations, dynamic addition of new rules is done in several steps:</p><ul><li>&quot;x + y&quot; (user gives a notation string of type Topconstr.notation) | (together with a constr entry level, e.g. 50, and indications of) | (subentries, e.g. x in constr next level and y constr same level) | | splitting into tokens by Metasyntax.split_notation_string V <code>String &quot;x&quot;; String &quot;+&quot;; String &quot;y&quot;</code> : symbol_token list | | interpreted as a mixed parsing/printing production | by Metasyntax.analyse_notation_tokens V <code>NonTerminal &quot;x&quot;; Terminal &quot;+&quot;; NonTerminal &quot;y&quot;</code> : symbol list | | translated to a parsing production by Metasyntax.make_production V <code>GramConstrNonTerminal (ETConstr (NextLevel,(BorderProd Left,LeftA)),
                              Some &quot;x&quot;);
       GramConstrTerminal (&quot;&quot;,&quot;+&quot;);
       GramConstrNonTerminal (ETConstr (NextLevel,(BorderProd Right,LeftA)),
                              Some &quot;y&quot;)</code> : grammar_constr_prod_item list | | Egrammar.make_constr_prod_item V Gramext.g_symbol list which is sent to camlp5</li></ul><p>For user level tactic notations, dynamic addition of new rules is also done in several steps:</p><ul><li>&quot;f&quot; constr(x) (user gives a Tactic Notation command) | | parsing V <code>TacTerm &quot;f&quot;; TacNonTerm (&quot;constr&quot;, Some &quot;x&quot;)</code> : grammar_tactic_prod_item_expr list | | Metasyntax.interp_prod_item V <code>GramTerminal &quot;f&quot;;
       GramNonTerminal (ConstrArgType, Aentry (&quot;constr&quot;,&quot;constr&quot;), Some &quot;x&quot;)</code> : grammar_prod_item list | | Egrammar.make_prod_item V Gramext.g_symbol list</li></ul><p>For TACTIC/VERNAC/ARGUMENT EXTEND, addition of new rules is done as follows:</p><ul><li>&quot;f&quot; constr(x) (developer gives an EXTEND rule) | | macro-generation in tacextend.ml4/vernacextend.ml4/argextend.ml4 V <code>GramTerminal &quot;f&quot;;
       GramNonTerminal (ConstrArgType, Aentry (&quot;constr&quot;,&quot;constr&quot;), Some &quot;x&quot;)</code> | | Egrammar.make_prod_item V Gramext.g_symbol list</li></ul></aside><aside><p>Parse a string</p></aside><dl><dt class="spec value" id="val-parse_string"><a href="#val-parse_string" class="anchor"></a><code><span class="keyword">val</span> parse_string : <span class="type-var">'a</span> <a href="Entry/index.html#type-t">Entry.t</a> <span>&#45;&gt;</span> ?&#8288;loc:<a href="../Loc/index.html#type-t">Loc.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-eoi_entry"><a href="#val-eoi_entry" class="anchor"></a><code><span class="keyword">val</span> eoi_entry : <span class="type-var">'a</span> <a href="Entry/index.html#type-t">Entry.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Entry/index.html#type-t">Entry.t</a></code></dt><dt class="spec value" id="val-map_entry"><a href="#val-map_entry" class="anchor"></a><code><span class="keyword">val</span> map_entry : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Entry/index.html#type-t">Entry.t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="Entry/index.html#type-t">Entry.t</a></code></dt></dl><dl><dt class="spec type" id="type-gram_universe"><a href="#type-gram_universe" class="anchor"></a><code><span class="keyword">type</span> gram_universe</code></dt></dl><dl><dt class="spec value" id="val-get_univ"><a href="#val-get_univ" class="anchor"></a><code><span class="keyword">val</span> get_univ : string <span>&#45;&gt;</span> <a href="index.html#type-gram_universe">gram_universe</a></code></dt><dt class="spec value" id="val-create_universe"><a href="#val-create_universe" class="anchor"></a><code><span class="keyword">val</span> create_universe : string <span>&#45;&gt;</span> <a href="index.html#type-gram_universe">gram_universe</a></code></dt><dt class="spec value" id="val-new_entry"><a href="#val-new_entry" class="anchor"></a><code><span class="keyword">val</span> new_entry : <a href="index.html#type-gram_universe">gram_universe</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Entry/index.html#type-t">Entry.t</a></code></dt><dt class="spec value" id="val-uprim"><a href="#val-uprim" class="anchor"></a><code><span class="keyword">val</span> uprim : <a href="index.html#type-gram_universe">gram_universe</a></code></dt><dt class="spec value" id="val-uconstr"><a href="#val-uconstr" class="anchor"></a><code><span class="keyword">val</span> uconstr : <a href="index.html#type-gram_universe">gram_universe</a></code></dt><dt class="spec value" id="val-utactic"><a href="#val-utactic" class="anchor"></a><code><span class="keyword">val</span> utactic : <a href="index.html#type-gram_universe">gram_universe</a></code></dt><dt class="spec value" id="val-register_grammar"><a href="#val-register_grammar" class="anchor"></a><code><span class="keyword">val</span> register_grammar : (<span class="type-var">'raw</span>, <span class="type-var">'glb</span>, <span class="type-var">'top</span>) <a href="../Genarg/index.html#type-genarg_type">Genarg.genarg_type</a> <span>&#45;&gt;</span> <span class="type-var">'raw</span> <a href="Entry/index.html#type-t">Entry.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-genarg_grammar"><a href="#val-genarg_grammar" class="anchor"></a><code><span class="keyword">val</span> genarg_grammar : (<span class="type-var">'raw</span>, <span class="type-var">'glb</span>, <span class="type-var">'top</span>) <a href="../Genarg/index.html#type-genarg_type">Genarg.genarg_type</a> <span>&#45;&gt;</span> <span class="type-var">'raw</span> <a href="Entry/index.html#type-t">Entry.t</a></code></dt><dt class="spec value" id="val-create_generic_entry"><a href="#val-create_generic_entry" class="anchor"></a><code><span class="keyword">val</span> create_generic_entry : <a href="index.html#type-gram_universe">gram_universe</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <a href="../Genarg/index.html#type-rlevel">Genarg.rlevel</a>) <a href="../Genarg/index.html#type-abstract_argument_type">Genarg.abstract_argument_type</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Entry/index.html#type-t">Entry.t</a></code></dt></dl><div class="spec module" id="module-Prim"><a href="#module-Prim" class="anchor"></a><code><span class="keyword">module</span> <a href="Prim/index.html">Prim</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Constr"><a href="#module-Constr" class="anchor"></a><code><span class="keyword">module</span> <a href="Constr/index.html">Constr</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Module"><a href="#module-Module" class="anchor"></a><code><span class="keyword">module</span> <a href="Module/index.html">Module</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-epsilon_value"><a href="#val-epsilon_value" class="anchor"></a><code><span class="keyword">val</span> epsilon_value : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'self</span>) <span>&#45;&gt;</span> (<span class="type-var">'self</span>, <span class="type-var">'a</span>) <a href="../Extend/index.html#type-symbol">Extend.symbol</a> <span>&#45;&gt;</span> <span class="type-var">'self</span> option</code></dt></dl><section><header><h6 id="extending-the-parser-without-synchronization"><a href="#extending-the-parser-without-synchronization" class="anchor"></a>Extending the parser without synchronization</h6></header><dl><dt class="spec type" id="type-gram_reinit"><a href="#type-gram_reinit" class="anchor"></a><code><span class="keyword">type</span> gram_reinit</code><code> = <a href="../Gramlib/Gramext/index.html#type-g_assoc">Gramlib.Gramext.g_assoc</a> * <a href="../Gramlib/Gramext/index.html#type-position">Gramlib.Gramext.position</a></code></dt><dd><p>Type of reinitialization data</p></dd></dl><dl><dt class="spec value" id="val-grammar_extend"><a href="#val-grammar_extend" class="anchor"></a><code><span class="keyword">val</span> grammar_extend : <span class="type-var">'a</span> <a href="Entry/index.html#type-t">Entry.t</a> <span>&#45;&gt;</span> <a href="index.html#type-gram_reinit">gram_reinit</a> option <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Extend/index.html#type-extend_statement">Extend.extend_statement</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Extend the grammar of Coq, without synchronizing it with the backtracking mechanism. This means that grammar extensions defined this way will survive an undo.</p></dd></dl></section><section><header><h6 id="extending-the-parser-with-summary-synchronized-commands"><a href="#extending-the-parser-with-summary-synchronized-commands" class="anchor"></a>Extending the parser with summary-synchronized commands</h6></header><dl><dt class="spec module" id="module-GramState"><a href="#module-GramState" class="anchor"></a><code><span class="keyword">module</span> <a href="GramState/index.html">GramState</a> : <a href="../Store/index.html#module-type-S">Store.S</a></code></dt><dd><p>Auxiliary state of the grammar. Any added data must be marshallable.</p></dd></dl></section><section><header><h6 id="extension-with-parsing-rules"><a href="#extension-with-parsing-rules" class="anchor"></a>Extension with parsing rules</h6></header><dl><dt class="spec type" id="type-grammar_command"><a href="#type-grammar_command" class="anchor"></a><code><span class="keyword">type</span> 'a grammar_command</code></dt><dd><p>Type of synchronized parsing extensions. The <code>'a</code> type should be marshallable.</p></dd></dl><dl><dt class="spec type" id="type-extend_rule"><a href="#type-extend_rule" class="anchor"></a><code><span class="keyword">type</span> extend_rule</code><code> = </code><table class="variant"><tr id="type-extend_rule.ExtendRule" class="anchored"><td class="def constructor"><a href="#type-extend_rule.ExtendRule" class="anchor"></a><code>| </code><code><span class="constructor">ExtendRule</span> : <span class="type-var">'a</span> <a href="Entry/index.html#type-t">Entry.t</a> * <a href="index.html#type-gram_reinit">gram_reinit</a> option * <span class="type-var">'a</span> <a href="../Extend/index.html#type-extend_statement">Extend.extend_statement</a> <span>&#45;&gt;</span> <a href="index.html#type-extend_rule">extend_rule</a></code></td></tr></table></dt><dt class="spec type" id="type-grammar_extension"><a href="#type-grammar_extension" class="anchor"></a><code><span class="keyword">type</span> 'a grammar_extension</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="GramState/index.html#type-t">GramState.t</a> <span>&#45;&gt;</span> <a href="index.html#type-extend_rule">extend_rule</a> list * <a href="GramState/index.html#type-t">GramState.t</a></code></dt><dd><p>Grammar extension entry point. Given some <code>'a</code> and a current grammar state, such a function must produce the list of grammar extensions that will be applied in the same order and kept synchronized w.r.t. the summary, together with a new state. It should be pure.</p></dd></dl><dl><dt class="spec value" id="val-create_grammar_command"><a href="#val-create_grammar_command" class="anchor"></a><code><span class="keyword">val</span> create_grammar_command : string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar_extension">grammar_extension</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar_command">grammar_command</a></code></dt><dd><p>Create a new grammar-modifying command with the given name. The extension function is called to generate the rules for a given data.</p></dd></dl><dl><dt class="spec value" id="val-extend_grammar_command"><a href="#val-extend_grammar_command" class="anchor"></a><code><span class="keyword">val</span> extend_grammar_command : <span class="type-var">'a</span> <a href="index.html#type-grammar_command">grammar_command</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Extend the grammar of Coq with the given data.</p></dd></dl></section><section><header><h6 id="extension-with-parsing-entries"><a href="#extension-with-parsing-entries" class="anchor"></a>Extension with parsing entries</h6></header><dl><dt class="spec type" id="type-entry_command"><a href="#type-entry_command" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b) entry_command</code></dt><dd><p>Type of synchronized entry creation. The <code>'a</code> type should be marshallable.</p></dd></dl><dl><dt class="spec type" id="type-entry_extension"><a href="#type-entry_extension" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b) entry_extension</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="GramState/index.html#type-t">GramState.t</a> <span>&#45;&gt;</span> string list * <a href="GramState/index.html#type-t">GramState.t</a></code></dt><dd><p>Entry extension entry point. Given some <code>'a</code> and a current grammar state, such a function must produce the list of entry extensions that will be created and kept synchronized w.r.t. the summary, together with a new state. It should be pure.</p></dd></dl><dl><dt class="spec value" id="val-create_entry_command"><a href="#val-create_entry_command" class="anchor"></a><code><span class="keyword">val</span> create_entry_command : string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-entry_extension">entry_extension</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-entry_command">entry_command</a></code></dt><dd><p>Create a new entry-creating command with the given name. The extension function is called to generate the new entries for a given data.</p></dd></dl><dl><dt class="spec value" id="val-extend_entry_command"><a href="#val-extend_entry_command" class="anchor"></a><code><span class="keyword">val</span> extend_entry_command : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-entry_command">entry_command</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="Entry/index.html#type-t">Entry.t</a> list</code></dt><dd><p>Create new synchronized entries using the provided data.</p></dd></dl><dl><dt class="spec value" id="val-find_custom_entry"><a href="#val-find_custom_entry" class="anchor"></a><code><span class="keyword">val</span> find_custom_entry : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-entry_command">entry_command</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="Entry/index.html#type-t">Entry.t</a></code></dt><dd><p>Find an entry generated by the synchronized system in the current state.</p><dl><dt>raises Not_found</dt><dd><p>if non-existent.</p></dd></dl></dd></dl></section><section><header><h6 id="protection-w.r.t.-backtrack"><a href="#protection-w.r.t.-backtrack" class="anchor"></a>Protection w.r.t. backtrack</h6></header><dl><dt class="spec value" id="val-with_grammar_rule_protection"><a href="#val-with_grammar_rule_protection" class="anchor"></a><code><span class="keyword">val</span> with_grammar_rule_protection : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt></dl><dl><dt class="spec type" id="type-frozen_t"><a href="#type-frozen_t" class="anchor"></a><code><span class="keyword">type</span> frozen_t</code></dt></dl><dl><dt class="spec value" id="val-parser_summary_tag"><a href="#val-parser_summary_tag" class="anchor"></a><code><span class="keyword">val</span> parser_summary_tag : <a href="index.html#type-frozen_t">frozen_t</a> <a href="../Summary/Dyn/index.html#type-tag">Summary.Dyn.tag</a></code></dt></dl><aside><p>Registering grammars by name</p></aside><dl><dt class="spec type" id="type-any_entry"><a href="#type-any_entry" class="anchor"></a><code><span class="keyword">type</span> any_entry</code><code> = </code><table class="variant"><tr id="type-any_entry.AnyEntry" class="anchored"><td class="def constructor"><a href="#type-any_entry.AnyEntry" class="anchor"></a><code>| </code><code><span class="constructor">AnyEntry</span> : <span class="type-var">'a</span> <a href="Entry/index.html#type-t">Entry.t</a> <span>&#45;&gt;</span> <a href="index.html#type-any_entry">any_entry</a></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-register_grammars_by_name"><a href="#val-register_grammars_by_name" class="anchor"></a><code><span class="keyword">val</span> register_grammars_by_name : string <span>&#45;&gt;</span> <a href="index.html#type-any_entry">any_entry</a> list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-find_grammars_by_name"><a href="#val-find_grammars_by_name" class="anchor"></a><code><span class="keyword">val</span> find_grammars_by_name : string <span>&#45;&gt;</span> <a href="index.html#type-any_entry">any_entry</a> list</code></dt><dt class="spec value" id="val-freeze"><a href="#val-freeze" class="anchor"></a><code><span class="keyword">val</span> freeze : marshallable:bool <span>&#45;&gt;</span> <a href="index.html#type-frozen_t">frozen_t</a></code></dt><dd><p>Parsing state handling</p></dd></dl><dl><dt class="spec value" id="val-unfreeze"><a href="#val-unfreeze" class="anchor"></a><code><span class="keyword">val</span> unfreeze : <a href="index.html#type-frozen_t">frozen_t</a> <span>&#45;&gt;</span> unit</code></dt></dl></section></div></body></html>