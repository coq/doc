<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Obligations (coq.Obligations)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Obligations</nav><h1>Module <code>Obligations</code></h1><nav class="toc"><ul><li><a href="#"></a></li><li><a href="#"></a></li></ul></nav></header><aside><p>Coq's Program mode support. This mode extends declarations of constants and fixpoints with <code>Program Definition</code> and <code>Program
   Fixpoint</code> to support incremental construction of terms using delayed proofs, called &quot;obligations&quot;</p><p>The mode also provides facilities for managing and auto-solving sets of obligations.</p><p>The basic code flow of programs/obligations is as follows:</p><ul><li><code>add_definition</code> / <code>add_mutual_definitions</code> are called from the respective <code>Program</code> vernacular command interpretation; at this point the only extra work we do is to prepare the new definition <code>d</code> using <code>RetrieveObl</code>, which consists in turning unsolved evars into obligations. <code>d</code> is not sent to the kernel yet, as it is not complete and cannot be typchecked, but saved in a special data-structure. Auto-solving of obligations is tried at this stage (see below)</li></ul><ul><li><code>next_obligation</code> will retrieve the next obligation (<code>RetrieveObl</code> sorts them by topological order) and will try to solve it. When all obligations are solved, the original constant <code>d</code> is grounded and sent to the kernel for addition to the global environment. Auto-solving of obligations is also triggered on obligation completion.</li></ul></aside><section><header><h3 id=""><a href="#" class="anchor"></a></h3><p>Solving of obligations: Solved obligations are stored as regular global declarations in the global environment, usually with name <code>constant_obligation_number</code> where <code>constant</code> is the original <code>constant</code> and <code>number</code> is the corresponding (internal) number.</p><p>Solving an obligation can trigger a bit of a complex cascaded callback path; closing an obligation can indeed allow all other obligations to be closed, which in turn may trigged the declaration of the original constant. Care must be taken, as this can modify <code>Global.env</code> in arbitrarily ways. Current code takes some care to refresh the <code>env</code> in the proper boundaries, but the invariants remain delicate.</p></header></section><section><header><h3 id=""><a href="#" class="anchor"></a></h3><p>Saving of obligations: as open obligations use the regular proof mode, a `Qed` will call `Lemmas.save_lemma` first. For this reason obligations code is split in two: this file, <code>Obligations</code>, taking care of the top-level vernac commands, and <code>DeclareObl</code>, which is called by `Lemmas` to close an obligation proof and eventually to declare the top-level <code>Program</code>ed constant.</p><p>There is little obligations-specific code in <code>DeclareObl</code>, so eventually that file should be integrated in the regular <code>Declare</code> path, as it gains better support for &quot;dependent_proofs&quot;.</p></header><dl><dt class="spec value" id="val-default_tactic"><a href="#val-default_tactic" class="anchor"></a><code><span class="keyword">val</span> default_tactic : <span><span>unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></span> Stdlib.ref</span></code></dt><dt class="spec value" id="val-add_definition"><a href="#val-add_definition" class="anchor"></a><code><span class="keyword">val</span> add_definition : <span>name:<a href="../Names/Id/index.html#type-t">Names.Id.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;term:<a href="../Constr/index.html#type-constr">Constr.constr</a></span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <span>uctx:<a href="../UState/index.html#type-t">UState.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;udecl:<a href="../UState/index.html#type-universe_decl">UState.universe_decl</a></span> <span>&#45;&gt;</span> <span>?&#8288;impargs:<a href="../Impargs/index.html#type-manual_implicits">Impargs.manual_implicits</a></span> <span>&#45;&gt;</span> <span>poly:bool</span> <span>&#45;&gt;</span> <span>?&#8288;scope:<a href="../Declare/index.html#type-locality">Declare.locality</a></span> <span>&#45;&gt;</span> <span>?&#8288;kind:<a href="../Decls/index.html#type-definition_object_kind">Decls.definition_object_kind</a></span> <span>&#45;&gt;</span> <span>?&#8288;tactic:<span>unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;reduce:<span>(<a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;hook:<a href="../Declare/Hook/index.html#type-t">Declare.Hook.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;opaque:bool</span> <span>&#45;&gt;</span> <a href="../RetrieveObl/index.html#type-obligation_info">RetrieveObl.obligation_info</a> <span>&#45;&gt;</span> <a href="../Declare/Obls/index.html#type-progress">Declare.Obls.progress</a></code></dt><dd><p>Start a <code>Program Definition c</code> proof. <code>uctx</code> <code>udecl</code> <code>impargs</code> <code>kind</code> <code>scope</code> <code>poly</code> etc... come from the interpretation of the vernacular; `obligation_info` was generated by <code>RetrieveObl</code> It will return whether all the obligations were solved; if so, it will also register <code>c</code> with the kernel.</p></dd></dl><dl><dt class="spec value" id="val-add_mutual_definitions"><a href="#val-add_mutual_definitions" class="anchor"></a><code><span class="keyword">val</span> add_mutual_definitions : <span><span>(<a href="../Declare/Recthm/index.html#type-t">Declare.Recthm.t</a> * <a href="../Constr/index.html#type-t">Constr.t</a> * <a href="../RetrieveObl/index.html#type-obligation_info">RetrieveObl.obligation_info</a>)</span> list</span> <span>&#45;&gt;</span> <span>uctx:<a href="../UState/index.html#type-t">UState.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;udecl:<a href="../UState/index.html#type-universe_decl">UState.universe_decl</a></span> <span>&#45;&gt;</span> <span>?&#8288;tactic:<span>unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></span></span> <span>&#45;&gt;</span> <span>poly:bool</span> <span>&#45;&gt;</span> <span>?&#8288;scope:<a href="../Declare/index.html#type-locality">Declare.locality</a></span> <span>&#45;&gt;</span> <span>?&#8288;kind:<a href="../Decls/index.html#type-definition_object_kind">Decls.definition_object_kind</a></span> <span>&#45;&gt;</span> <span>?&#8288;reduce:<span>(<a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;hook:<a href="../Declare/Hook/index.html#type-t">Declare.Hook.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;opaque:bool</span> <span>&#45;&gt;</span> <span><a href="../Vernacexpr/index.html#type-decl_notation">Vernacexpr.decl_notation</a> list</span> <span>&#45;&gt;</span> <a href="../Declare/Obls/index.html#type-fixpoint_kind">Declare.Obls.fixpoint_kind</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Start a <code>Program Fixpoint</code> declaration, similar to the above, except it takes a list now.</p></dd></dl><dl><dt class="spec value" id="val-obligation"><a href="#val-obligation" class="anchor"></a><code><span class="keyword">val</span> obligation : <span>(int * <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> option</span> * <span><a href="../Constrexpr/index.html#type-constr_expr">Constrexpr.constr_expr</a> option</span>)</span> <span>&#45;&gt;</span> <span><a href="../Genarg/index.html#type-glob_generic_argument">Genarg.glob_generic_argument</a> option</span> <span>&#45;&gt;</span> <a href="../Lemmas/index.html#type-t">Lemmas.t</a></code></dt><dd><p>Implementation of the <code>Obligation</code> command</p></dd></dl><dl><dt class="spec value" id="val-next_obligation"><a href="#val-next_obligation" class="anchor"></a><code><span class="keyword">val</span> next_obligation : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> option</span> <span>&#45;&gt;</span> <span><a href="../Genarg/index.html#type-glob_generic_argument">Genarg.glob_generic_argument</a> option</span> <span>&#45;&gt;</span> <a href="../Lemmas/index.html#type-t">Lemmas.t</a></code></dt><dd><p>Implementation of the <code>Next Obligation</code> command</p></dd></dl><dl><dt class="spec value" id="val-solve_obligations"><a href="#val-solve_obligations" class="anchor"></a><code><span class="keyword">val</span> solve_obligations : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> option</span> <span>&#45;&gt;</span> <span><span>unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></span> option</span> <span>&#45;&gt;</span> <a href="../Declare/Obls/index.html#type-progress">Declare.Obls.progress</a></code></dt><dd><p>Implementation of the <code>Solve Obligation</code> command</p></dd></dl><dl><dt class="spec value" id="val-solve_all_obligations"><a href="#val-solve_all_obligations" class="anchor"></a><code><span class="keyword">val</span> solve_all_obligations : <span><span>unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></span> option</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-try_solve_obligation"><a href="#val-try_solve_obligation" class="anchor"></a><code><span class="keyword">val</span> try_solve_obligation : int <span>&#45;&gt;</span> <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> option</span> <span>&#45;&gt;</span> <span><span>unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></span> option</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Number of remaining obligations to be solved for this program</p></dd></dl><dl><dt class="spec value" id="val-try_solve_obligations"><a href="#val-try_solve_obligations" class="anchor"></a><code><span class="keyword">val</span> try_solve_obligations : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> option</span> <span>&#45;&gt;</span> <span><span>unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></span> option</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-show_obligations"><a href="#val-show_obligations" class="anchor"></a><code><span class="keyword">val</span> show_obligations : <span>?&#8288;msg:bool</span> <span>&#45;&gt;</span> <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> option</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-show_term"><a href="#val-show_term" class="anchor"></a><code><span class="keyword">val</span> show_term : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> option</span> <span>&#45;&gt;</span> <a href="../Pp/index.html#type-t">Pp.t</a></code></dt><dt class="spec value" id="val-admit_obligations"><a href="#val-admit_obligations" class="anchor"></a><code><span class="keyword">val</span> admit_obligations : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> option</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-check_program_libraries"><a href="#val-check_program_libraries" class="anchor"></a><code><span class="keyword">val</span> check_program_libraries : unit <span>&#45;&gt;</span> unit</code></dt></dl></section></div></body></html>