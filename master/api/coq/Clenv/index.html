<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Clenv (coq.Clenv)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Clenv</nav><h1>Module <code>Clenv</code></h1><p>This file defines clausenv, which is a deprecated way to handle open terms in the proof engine. Most of the API here is legacy except for the evar-based clauses.</p><nav class="toc"><ul><li><a href="#the-type-of-constructions-clausale-environments.">The Type of Constructions clausale environments.</a></li><li><a href="#linking-of-clenvs">linking of clenvs</a></li><li><a href="#unification-with-clenvs">Unification with clenvs</a></li><li><a href="#bindings">Bindings</a></li><li><a href="#clenv-tactics">Clenv tactics</a></li><li><a href="#evar-based-clauses">Evar-based clauses</a></li></ul></nav></header><section><header><h6 id="the-type-of-constructions-clausale-environments."><a href="#the-type-of-constructions-clausale-environments." class="anchor"></a>The Type of Constructions clausale environments.</h6></header><dl><dt class="spec type" id="type-clausenv"><a href="#type-clausenv" class="anchor"></a><code><span class="keyword">type</span> clausenv</code><code> = </code><code>{</code><table class="record"><tr id="type-clausenv.env" class="anchored"><td class="def field"><a href="#type-clausenv.env" class="anchor"></a><code>env : <a href="../Environ/index.html#type-env">Environ.env</a>;</code></td><td class="doc"><p>the typing context</p></td></tr><tr id="type-clausenv.evd" class="anchored"><td class="def field"><a href="#type-clausenv.evd" class="anchor"></a><code>evd : <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a>;</code></td><td class="doc"><p>the mapping from metavar and evar numbers to their types and values</p></td></tr><tr id="type-clausenv.templval" class="anchored"><td class="def field"><a href="#type-clausenv.templval" class="anchor"></a><code>templval : <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <a href="../Evd/index.html#type-freelisted">Evd.freelisted</a></span>;</code></td><td class="doc"><p>the template which we are trying to fill out</p></td></tr><tr id="type-clausenv.templtyp" class="anchored"><td class="def field"><a href="#type-clausenv.templtyp" class="anchor"></a><code>templtyp : <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <a href="../Evd/index.html#type-freelisted">Evd.freelisted</a></span>;</code></td><td class="doc"><p>its type</p></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-clenv_value"><a href="#val-clenv_value" class="anchor"></a><code><span class="keyword">val</span> clenv_value : <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-constr">EConstr.constr</a></code></dt><dd><p>subject of clenv (instantiated)</p></dd></dl><dl><dt class="spec value" id="val-clenv_type"><a href="#val-clenv_type" class="anchor"></a><code><span class="keyword">val</span> clenv_type : <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-types">EConstr.types</a></code></dt><dd><p>type of clenv (instantiated)</p></dd></dl><dl><dt class="spec value" id="val-clenv_meta_type"><a href="#val-clenv_meta_type" class="anchor"></a><code><span class="keyword">val</span> clenv_meta_type : <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-metavariable">Constr.metavariable</a> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-types">EConstr.types</a></code></dt><dd><p>type of a meta in clenv context</p></dd></dl><dl><dt class="spec value" id="val-mk_clenv_from"><a href="#val-mk_clenv_from" class="anchor"></a><code><span class="keyword">val</span> mk_clenv_from : <a href="../Proofview/Goal/index.html#type-t">Proofview.Goal.t</a> <span>&#45;&gt;</span> <span>(<a href="../EConstr/index.html#type-constr">EConstr.constr</a> * <a href="../EConstr/index.html#type-types">EConstr.types</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt><dt class="spec value" id="val-mk_clenv_from_n"><a href="#val-mk_clenv_from_n" class="anchor"></a><code><span class="keyword">val</span> mk_clenv_from_n : <a href="../Proofview/Goal/index.html#type-t">Proofview.Goal.t</a> <span>&#45;&gt;</span> <span>int option</span> <span>&#45;&gt;</span> <span>(<a href="../EConstr/index.html#type-constr">EConstr.constr</a> * <a href="../EConstr/index.html#type-types">EConstr.types</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt><dt class="spec value" id="val-mk_clenv_from_env"><a href="#val-mk_clenv_from_env" class="anchor"></a><code><span class="keyword">val</span> mk_clenv_from_env : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <span>int option</span> <span>&#45;&gt;</span> <span>(<a href="../EConstr/index.html#type-constr">EConstr.constr</a> * <a href="../EConstr/index.html#type-types">EConstr.types</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt></dl></section><section><header><h6 id="linking-of-clenvs"><a href="#linking-of-clenvs" class="anchor"></a>linking of clenvs</h6></header><dl><dt class="spec value" id="val-clenv_fchain"><a href="#val-clenv_fchain" class="anchor"></a><code><span class="keyword">val</span> clenv_fchain : <span>?&#8288;with_univs:bool</span> <span>&#45;&gt;</span> <span>?&#8288;flags:<a href="../Unification/index.html#type-unify_flags">Unification.unify_flags</a></span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-metavariable">Constr.metavariable</a> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt></dl></section><section><header><h6 id="unification-with-clenvs"><a href="#unification-with-clenvs" class="anchor"></a>Unification with clenvs</h6></header><dl><dt class="spec value" id="val-clenv_unify"><a href="#val-clenv_unify" class="anchor"></a><code><span class="keyword">val</span> clenv_unify : <span>?&#8288;flags:<a href="../Unification/index.html#type-unify_flags">Unification.unify_flags</a></span> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-conv_pb">Evd.conv_pb</a> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt><dd><p>Unifies two terms in a clenv. The boolean is <code>allow_K</code> (see <code>Unification</code>)</p></dd></dl></section><section><header><h6 id="bindings"><a href="#bindings" class="anchor"></a>Bindings</h6></header><dl><dt class="spec value" id="val-clenv_independent"><a href="#val-clenv_independent" class="anchor"></a><code><span class="keyword">val</span> clenv_independent : <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-metavariable">Constr.metavariable</a> list</span></code></dt><dd><p>bindings where the key is the position in the template of the clenv (dependent or not). Positions can be negative meaning to start from the rightmost argument of the template.</p></dd></dl><dl><dt class="spec value" id="val-clenv_missing"><a href="#val-clenv_missing" class="anchor"></a><code><span class="keyword">val</span> clenv_missing : <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-metavariable">Constr.metavariable</a> list</span></code></dt></dl><dl><dt class="spec exception" id="exception-NoSuchBinding"><a href="#exception-NoSuchBinding" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">NoSuchBinding</span></code></dt><dd><p>for the purpose of inversion tactics</p></dd></dl><dl><dt class="spec value" id="val-clenv_constrain_last_binding"><a href="#val-clenv_constrain_last_binding" class="anchor"></a><code><span class="keyword">val</span> clenv_constrain_last_binding : <a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt><dt class="spec value" id="val-clenv_unify_meta_types"><a href="#val-clenv_unify_meta_types" class="anchor"></a><code><span class="keyword">val</span> clenv_unify_meta_types : <span>?&#8288;flags:<a href="../Unification/index.html#type-unify_flags">Unification.unify_flags</a></span> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt></dl><aside><p>start with a clenv to refine with a given term with bindings</p></aside><dl><dt class="spec value" id="val-make_clenv_binding_env_apply"><a href="#val-make_clenv_binding_env_apply" class="anchor"></a><code><span class="keyword">val</span> make_clenv_binding_env_apply : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <span>int option</span> <span>&#45;&gt;</span> <span>(<a href="../EConstr/index.html#type-constr">EConstr.constr</a> * <a href="../EConstr/index.html#type-constr">EConstr.constr</a>)</span> <span>&#45;&gt;</span> <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <a href="../Tactypes/index.html#type-bindings">Tactypes.bindings</a></span> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt><dd><p>the arity of the lemma is fixed the optional int tells how many prods of the lemma have to be used use all of them if None</p></dd></dl><dl><dt class="spec value" id="val-make_clenv_binding_apply"><a href="#val-make_clenv_binding_apply" class="anchor"></a><code><span class="keyword">val</span> make_clenv_binding_apply : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <span>int option</span> <span>&#45;&gt;</span> <span>(<a href="../EConstr/index.html#type-constr">EConstr.constr</a> * <a href="../EConstr/index.html#type-constr">EConstr.constr</a>)</span> <span>&#45;&gt;</span> <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <a href="../Tactypes/index.html#type-bindings">Tactypes.bindings</a></span> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt><dt class="spec value" id="val-make_clenv_binding_env"><a href="#val-make_clenv_binding_env" class="anchor"></a><code><span class="keyword">val</span> make_clenv_binding_env : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <span>(<a href="../EConstr/index.html#type-constr">EConstr.constr</a> * <a href="../EConstr/index.html#type-constr">EConstr.constr</a>)</span> <span>&#45;&gt;</span> <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <a href="../Tactypes/index.html#type-bindings">Tactypes.bindings</a></span> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt><dt class="spec value" id="val-make_clenv_binding"><a href="#val-make_clenv_binding" class="anchor"></a><code><span class="keyword">val</span> make_clenv_binding : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <span>(<a href="../EConstr/index.html#type-constr">EConstr.constr</a> * <a href="../EConstr/index.html#type-constr">EConstr.constr</a>)</span> <span>&#45;&gt;</span> <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <a href="../Tactypes/index.html#type-bindings">Tactypes.bindings</a></span> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt></dl><dl><dt class="spec exception" id="exception-NotExtensibleClause"><a href="#exception-NotExtensibleClause" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">NotExtensibleClause</span></code></dt><dd><p>if the clause is a product, add an extra meta for this product</p></dd></dl><dl><dt class="spec value" id="val-clenv_push_prod"><a href="#val-clenv_push_prod" class="anchor"></a><code><span class="keyword">val</span> clenv_push_prod : <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt></dl></section><section><header><h6 id="clenv-tactics"><a href="#clenv-tactics" class="anchor"></a>Clenv tactics</h6></header><dl><dt class="spec value" id="val-unify"><a href="#val-unify" class="anchor"></a><code><span class="keyword">val</span> unify : <span>?&#8288;flags:<a href="../Unification/index.html#type-unify_flags">Unification.unify_flags</a></span> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span>&#45;&gt;</span> <span>unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></span></code></dt><dt class="spec value" id="val-res_pf"><a href="#val-res_pf" class="anchor"></a><code><span class="keyword">val</span> res_pf : <span>?&#8288;with_evars:bool</span> <span>&#45;&gt;</span> <span>?&#8288;with_classes:bool</span> <span>&#45;&gt;</span> <span>?&#8288;flags:<a href="../Unification/index.html#type-unify_flags">Unification.unify_flags</a></span> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <span>unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></span></code></dt><dt class="spec value" id="val-clenv_pose_dependent_evars"><a href="#val-clenv_pose_dependent_evars" class="anchor"></a><code><span class="keyword">val</span> clenv_pose_dependent_evars : <span>?&#8288;with_evars:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="index.html#type-clausenv">clausenv</a></code></dt><dt class="spec value" id="val-clenv_value_cast_meta"><a href="#val-clenv_value_cast_meta" class="anchor"></a><code><span class="keyword">val</span> clenv_value_cast_meta : <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-constr">EConstr.constr</a></code></dt><dt class="spec value" id="val-pr_clenv"><a href="#val-pr_clenv" class="anchor"></a><code><span class="keyword">val</span> pr_clenv : <a href="index.html#type-clausenv">clausenv</a> <span>&#45;&gt;</span> <a href="../Pp/index.html#type-t">Pp.t</a></code></dt><dd><h6 id="pretty-print-(debug-only)"><a href="#pretty-print-(debug-only)" class="anchor"></a>Pretty-print (debug only)</h6></dd></dl></section><section><header><h6 id="evar-based-clauses"><a href="#evar-based-clauses" class="anchor"></a>Evar-based clauses</h6></header><aside><p>The following code is an adaptation of the <code>make_clenv_*</code> functions above, except that it uses evars instead of metas, and naturally fits in the new refinement monad. It should eventually replace all uses of the aforementioned functions.</p><p>A clause is constructed as follows: assume a type <code>t := forall (x1 : A1) ...
    (xn : An), T</code>, we instantiate all the <code>xi</code> with a fresh evar <code>ei</code> and return <code>T(xi := ei)</code> together with the <code>ei</code> enriched with a bit of additional data. This is the simple part done by <code>make_evar_clause</code>.</p><p>The problem lies in the fact we want to solve such holes with some <code>constr bindings</code>. This entails some subtleties, because the provided terms may only be well-typed up to a coercion, which we can only infer if we have enough typing information. The meta machinery could insert coercions through tricky instantiation delays. The only solution we have now is to delay the tentative resolution of clauses by providing the <code>solve_evar_clause</code> function, to be called at a smart enough time.</p></aside><dl><dt class="spec type" id="type-hole"><a href="#type-hole" class="anchor"></a><code><span class="keyword">type</span> hole</code><code> = </code><code>{</code><table class="record"><tr id="type-hole.hole_evar" class="anchored"><td class="def field"><a href="#type-hole.hole_evar" class="anchor"></a><code>hole_evar : <a href="../EConstr/index.html#type-constr">EConstr.constr</a>;</code></td><td class="doc"><p>The hole itself. Guaranteed to be an evar.</p></td></tr><tr id="type-hole.hole_type" class="anchored"><td class="def field"><a href="#type-hole.hole_type" class="anchor"></a><code>hole_type : <a href="../EConstr/index.html#type-types">EConstr.types</a>;</code></td><td class="doc"><p>Type of the hole in the current environment.</p></td></tr><tr id="type-hole.hole_deps" class="anchored"><td class="def field"><a href="#type-hole.hole_deps" class="anchor"></a><code>hole_deps : bool;</code></td><td class="doc"><p>Whether the remainder of the clause was dependent in the hole. Note that because let binders are substituted, it does not mean that it actually appears somewhere in the returned clause.</p></td></tr><tr id="type-hole.hole_name" class="anchored"><td class="def field"><a href="#type-hole.hole_name" class="anchor"></a><code>hole_name : <a href="../Names/Name/index.html#type-t">Names.Name.t</a>;</code></td><td class="doc"><p>Name of the hole coming from its binder.</p></td></tr></table><code>}</code></dt><dt class="spec type" id="type-clause"><a href="#type-clause" class="anchor"></a><code><span class="keyword">type</span> clause</code><code> = </code><code>{</code><table class="record"><tr id="type-clause.cl_holes" class="anchored"><td class="def field"><a href="#type-clause.cl_holes" class="anchor"></a><code>cl_holes : <span><a href="index.html#type-hole">hole</a> list</span>;</code></td></tr><tr id="type-clause.cl_concl" class="anchored"><td class="def field"><a href="#type-clause.cl_concl" class="anchor"></a><code>cl_concl : <a href="../EConstr/index.html#type-types">EConstr.types</a>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-make_evar_clause"><a href="#val-make_evar_clause" class="anchor"></a><code><span class="keyword">val</span> make_evar_clause : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <a href="../EConstr/index.html#type-types">EConstr.types</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="index.html#type-clause">clause</a></code></dt><dd><p>An evar version of <a href="index.html#val-make_clenv_binding"><code>make_clenv_binding</code></a>. Given a type <code>t</code>, <code>evar_environments env sigma ~len t bl</code> tries to eliminate at most <code>len</code> products of the type <code>t</code> by filling it with evars. It returns the resulting type together with the list of holes generated. Assumes that <code>t</code> is well-typed in the environment.</p></dd></dl><dl><dt class="spec value" id="val-solve_evar_clause"><a href="#val-solve_evar_clause" class="anchor"></a><code><span class="keyword">val</span> solve_evar_clause : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="index.html#type-clause">clause</a> <span>&#45;&gt;</span> <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <a href="../Tactypes/index.html#type-bindings">Tactypes.bindings</a></span> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></code></dt><dd><p><code>solve_evar_clause env sigma hyps cl bl</code> tries to solve the holes contained in <code>cl</code> according to the <code>bl</code> argument. Assumes that <code>bl</code> are well-typed in the environment. The boolean <code>hyps</code> is a compatibility flag that allows to consider arguments to be dependent only when they appear in hypotheses and not in the conclusion. This boolean is only used when <code>bl</code> is of the form <code>ImplicitBindings _</code>.</p></dd></dl></section></div></body></html>