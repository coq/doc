<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LinPoly (coq.Micromega_plugin__Polynomial.LinPoly)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">coq</a> &#x00BB; <a href="../index.html">Micromega_plugin__Polynomial</a> &#x00BB; LinPoly</nav><h1>Module <code>Micromega_plugin__Polynomial.LinPoly</code></h1></header><aside><p>Linear(ised) polynomials represented as a <code>Vect.t</code> i.e a sorted association list. The constant is the coefficient of the variable 0</p><p>Each linear polynomial can be interpreted as a multi-variate polynomial. There is a bijection mapping between a linear variable and a monomial (see module <code>MonT</code>)</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../../Micromega_plugin/Vect/index.html#type-t">Micromega_plugin.Vect.t</a></code></dt></dl><aside><p>Each variable of a linear polynomial is mapped to a monomial. This is done using the monomial tables of the module MonT.</p></aside><div class="spec module" id="module-MonT"><a href="#module-MonT" class="anchor"></a><code><span class="keyword">module</span> <a href="MonT/index.html">MonT</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-linpol_of_pol"><a href="#val-linpol_of_pol" class="anchor"></a><code><span class="keyword">val</span> linpol_of_pol : <a href="../Poly/index.html#type-t">Poly.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>linpol_of_pol p</code> linearise the polynomial p</p></dd></dl><dl><dt class="spec value" id="val-var"><a href="#val-var" class="anchor"></a><code><span class="keyword">val</span> var : <a href="../index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>var x</code></p><dl><dt>returns</dt><dd><p>1.y where y is the variable index of the monomial x^1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-coq_poly_of_linpol"><a href="#val-coq_poly_of_linpol" class="anchor"></a><code><span class="keyword">val</span> coq_poly_of_linpol : (Num.num <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../Micromega_plugin/Micromega/index.html#type-pExpr">Mc.pExpr</a></code></dt><dd><p><code>coq_poly_of_linpol c p</code></p><dl><dt>parameter p</dt><dd><p>is a multi-variate polynomial.</p></dd></dl><dl><dt>parameter c</dt><dd><p>maps a rational to a Coq polynomial coefficient.</p></dd></dl><dl><dt>returns</dt><dd><p>the coq expression corresponding to polynomial <code>p</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_monomial"><a href="#val-of_monomial" class="anchor"></a><code><span class="keyword">val</span> of_monomial : <a href="../Monomial/index.html#type-t">Monomial.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_monomial m</code> @returns 1.x where x is the variable (index) for monomial m</p></dd></dl><dl><dt class="spec value" id="val-of_vect"><a href="#val-of_vect" class="anchor"></a><code><span class="keyword">val</span> of_vect : <a href="../../Micromega_plugin/Vect/index.html#type-t">Micromega_plugin.Vect.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_vect v</code> @returns a1.x1 + ... + an.xn This is not the identity because xi is the variable index of xi^1</p></dd></dl><dl><dt class="spec value" id="val-variables"><a href="#val-variables" class="anchor"></a><code><span class="keyword">val</span> variables : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Micromega_plugin__Mutils/index.html#module-ISet">Micromega_plugin.Mutils.ISet</a>.t</code></dt><dd><p><code>variables p</code></p><dl><dt>returns</dt><dd><p>the set of variables of the polynomial p interpreted as a multi-variate polynomial</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_variable"><a href="#val-is_variable" class="anchor"></a><code><span class="keyword">val</span> is_variable : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-var">var</a> option</code></dt><dd><p><code>is_variable p</code></p><dl><dt>returns</dt><dd><p>Some x if p = a.x for a &gt;= 0</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_linear"><a href="#val-is_linear" class="anchor"></a><code><span class="keyword">val</span> is_linear : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_linear p</code></p><dl><dt>returns</dt><dd><p>whether the multi-variate polynomial is linear.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_linear_for"><a href="#val-is_linear_for" class="anchor"></a><code><span class="keyword">val</span> is_linear_for : <a href="../index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_linear_for x p</code></p><dl><dt>returns</dt><dd><p>true if the polynomial is linear in x i.e can be written c*x+r where c is a constant and r is independent from x</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-constant"><a href="#val-constant" class="anchor"></a><code><span class="keyword">val</span> constant : Num.num <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>constant c</code></p><dl><dt>returns</dt><dd><p>the constant polynomial c</p></dd></dl></dd></dl><aside><p><code>search_linear pred p</code></p><dl><dt>returns</dt><dd><p>a variable x such p = a.x + b such that p is linear in x i.e x does not occur in b and a is a constant such that <code>pred a</code></p></dd></dl></aside><dl><dt class="spec value" id="val-search_linear"><a href="#val-search_linear" class="anchor"></a><code><span class="keyword">val</span> search_linear : (Num.num <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-var">var</a> option</code></dt><dt class="spec value" id="val-search_all_linear"><a href="#val-search_all_linear" class="anchor"></a><code><span class="keyword">val</span> search_all_linear : (Num.num <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-var">var</a> list</code></dt><dd><p><code>search_all_linear pred p</code></p><dl><dt>returns</dt><dd><p>all the variables x such p = a.x + b such that p is linear in x i.e x does not occur in b and a is a constant such that <code>pred a</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-product"><a href="#val-product" class="anchor"></a><code><span class="keyword">val</span> product : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>product p q</code></p><dl><dt>returns</dt><dd><p>the product of the polynomial <code>p*q</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-factorise"><a href="#val-factorise" class="anchor"></a><code><span class="keyword">val</span> factorise : <a href="../index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>factorise x p</code></p><dl><dt>returns</dt><dd><p><code>a,b</code> such that <code>p = a.x + b</code> and <code>x</code> does not occur in <code>b</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-collect_square"><a href="#val-collect_square" class="anchor"></a><code><span class="keyword">val</span> collect_square : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Monomial/index.html#type-t">Monomial.t</a> <a href="../index.html#module-MonMap">MonMap</a>.t</code></dt><dd><p><code>collect_square p</code></p><dl><dt>returns</dt><dd><p>a mapping m such that m<code>s</code> = s^2 for every s^2 that is a monomial of <code>p</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_var"><a href="#val-pp_var" class="anchor"></a><code><span class="keyword">val</span> pp_var : Stdlib.out_channel <span>&#45;&gt;</span> <a href="../index.html#type-var">var</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_var o v</code> pretty-prints a monomial indexed by v.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Stdlib.out_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp o p</code> pretty-prints a polynomial.</p></dd></dl><dl><dt class="spec value" id="val-pp_goal"><a href="#val-pp_goal" class="anchor"></a><code><span class="keyword">val</span> pp_goal : string <span>&#45;&gt;</span> Stdlib.out_channel <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a> * <a href="../index.html#type-op">op</a>) list <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_goal typ o l</code> pretty-prints the list of constraints as a Coq goal.</p></dd></dl></div></body></html>