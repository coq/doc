<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Inductive (coq.Inductive)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Inductive</nav><h1>Module <code>Inductive</code></h1><h6 id="extracting-an-inductive-type-from-a-construction"><a href="#extracting-an-inductive-type-from-a-construction" class="anchor"></a>Extracting an inductive type from a construction</h6><nav class="toc"><ul><li><a href="#guard-conditions-for-fix-and-cofix-points.">Guard conditions for fix and cofix-points.</a></li><li><a href="#support-for-sort-polymorphic-inductive-types">Support for sort-polymorphic inductive types</a></li><li><a href="#debug">Debug</a></li></ul></nav></header><aside><p><code>find_m*type env sigma c</code> coerce <code>c</code> to an recursive type (I args). <code>find_rectype</code>, <code>find_inductive</code> and <code>find_coinductive</code> respectively accepts any recursive type, only an inductive type and only a coinductive type. They raise <code>Not_found</code> if not convertible to a recursive type.</p></aside><dl><dt class="spec value" id="val-find_rectype"><a href="#val-find_rectype" class="anchor"></a><code><span class="keyword">val</span> find_rectype : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a> list</code></dt><dt class="spec value" id="val-find_inductive"><a href="#val-find_inductive" class="anchor"></a><code><span class="keyword">val</span> find_inductive : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a> list</code></dt><dt class="spec value" id="val-find_coinductive"><a href="#val-find_coinductive" class="anchor"></a><code><span class="keyword">val</span> find_coinductive : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a> list</code></dt></dl><dl><dt class="spec type" id="type-mind_specif"><a href="#type-mind_specif" class="anchor"></a><code><span class="keyword">type</span> mind_specif</code><code> = <a href="../Declarations/index.html#type-mutual_inductive_body">Declarations.mutual_inductive_body</a> * <a href="../Declarations/index.html#type-one_inductive_body">Declarations.one_inductive_body</a></code></dt></dl><dl><dt class="spec value" id="val-lookup_mind_specif"><a href="#val-lookup_mind_specif" class="anchor"></a><code><span class="keyword">val</span> lookup_mind_specif : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Names/index.html#type-inductive">Names.inductive</a> <span>&#45;&gt;</span> <a href="index.html#type-mind_specif">mind_specif</a></code></dt><dd><p>Fetching information in the environment about an inductive type. Raises <code>Not_found</code> if the inductive type is not found.</p></dd></dl><dl><dt class="spec value" id="val-ind_subst"><a href="#val-ind_subst" class="anchor"></a><code><span class="keyword">val</span> ind_subst : <a href="../Names/MutInd/index.html#type-t">Names.MutInd.t</a> <span>&#45;&gt;</span> <a href="../Declarations/index.html#type-mutual_inductive_body">Declarations.mutual_inductive_body</a> <span>&#45;&gt;</span> <a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> list</code></dt><dd><h6 id="functions-to-build-standard-types-related-to-inductive"><a href="#functions-to-build-standard-types-related-to-inductive" class="anchor"></a>Functions to build standard types related to inductive</h6></dd></dl><dl><dt class="spec value" id="val-inductive_paramdecls"><a href="#val-inductive_paramdecls" class="anchor"></a><code><span class="keyword">val</span> inductive_paramdecls : <a href="../Declarations/index.html#type-mutual_inductive_body">Declarations.mutual_inductive_body</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></code></dt><dt class="spec value" id="val-instantiate_inductive_constraints"><a href="#val-instantiate_inductive_constraints" class="anchor"></a><code><span class="keyword">val</span> instantiate_inductive_constraints : <a href="../Declarations/index.html#type-mutual_inductive_body">Declarations.mutual_inductive_body</a> <span>&#45;&gt;</span> <a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> <span>&#45;&gt;</span> <a href="../Univ/index.html#module-Constraint">Univ.Constraint</a>.t</code></dt><dt class="spec value" id="val-constrained_type_of_inductive"><a href="#val-constrained_type_of_inductive" class="anchor"></a><code><span class="keyword">val</span> constrained_type_of_inductive : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="index.html#type-mind_specif">mind_specif</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <a href="../Univ/index.html#type-constrained">Univ.constrained</a></code></dt><dt class="spec value" id="val-constrained_type_of_inductive_knowing_parameters"><a href="#val-constrained_type_of_inductive_knowing_parameters" class="anchor"></a><code><span class="keyword">val</span> constrained_type_of_inductive_knowing_parameters : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="index.html#type-mind_specif">mind_specif</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> Stdlib.Lazy.t array <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <a href="../Univ/index.html#type-constrained">Univ.constrained</a></code></dt><dt class="spec value" id="val-relevance_of_inductive"><a href="#val-relevance_of_inductive" class="anchor"></a><code><span class="keyword">val</span> relevance_of_inductive : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Names/index.html#type-inductive">Names.inductive</a> <span>&#45;&gt;</span> <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a></code></dt><dt class="spec value" id="val-type_of_inductive"><a href="#val-type_of_inductive" class="anchor"></a><code><span class="keyword">val</span> type_of_inductive : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="index.html#type-mind_specif">mind_specif</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dt class="spec value" id="val-type_of_inductive_knowing_parameters"><a href="#val-type_of_inductive_knowing_parameters" class="anchor"></a><code><span class="keyword">val</span> type_of_inductive_knowing_parameters : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> ?&#8288;polyprop:bool <span>&#45;&gt;</span> <a href="index.html#type-mind_specif">mind_specif</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> Stdlib.Lazy.t array <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dt class="spec value" id="val-elim_sorts"><a href="#val-elim_sorts" class="anchor"></a><code><span class="keyword">val</span> elim_sorts : <a href="index.html#type-mind_specif">mind_specif</a> <span>&#45;&gt;</span> <a href="../Sorts/index.html#type-family">Sorts.family</a> list</code></dt><dt class="spec value" id="val-is_private"><a href="#val-is_private" class="anchor"></a><code><span class="keyword">val</span> is_private : <a href="index.html#type-mind_specif">mind_specif</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_primitive_record"><a href="#val-is_primitive_record" class="anchor"></a><code><span class="keyword">val</span> is_primitive_record : <a href="index.html#type-mind_specif">mind_specif</a> <span>&#45;&gt;</span> bool</code></dt></dl><aside><p>Return type as quoted by the user</p></aside><dl><dt class="spec value" id="val-constrained_type_of_constructor"><a href="#val-constrained_type_of_constructor" class="anchor"></a><code><span class="keyword">val</span> constrained_type_of_constructor : <a href="../Constr/index.html#type-pconstructor">Constr.pconstructor</a> <span>&#45;&gt;</span> <a href="index.html#type-mind_specif">mind_specif</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <a href="../Univ/index.html#type-constrained">Univ.constrained</a></code></dt><dt class="spec value" id="val-type_of_constructor"><a href="#val-type_of_constructor" class="anchor"></a><code><span class="keyword">val</span> type_of_constructor : <a href="../Constr/index.html#type-pconstructor">Constr.pconstructor</a> <span>&#45;&gt;</span> <a href="index.html#type-mind_specif">mind_specif</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dt class="spec value" id="val-arities_of_constructors"><a href="#val-arities_of_constructors" class="anchor"></a><code><span class="keyword">val</span> arities_of_constructors : <a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> <span>&#45;&gt;</span> <a href="index.html#type-mind_specif">mind_specif</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> array</code></dt><dd><p>Return constructor types in normal form</p></dd></dl><dl><dt class="spec value" id="val-type_of_constructors"><a href="#val-type_of_constructors" class="anchor"></a><code><span class="keyword">val</span> type_of_constructors : <a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> <span>&#45;&gt;</span> <a href="index.html#type-mind_specif">mind_specif</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> array</code></dt><dd><p>Return constructor types in user form</p></dd></dl><dl><dt class="spec value" id="val-arities_of_specif"><a href="#val-arities_of_specif" class="anchor"></a><code><span class="keyword">val</span> arities_of_specif : <a href="../Names/MutInd/index.html#type-t">Names.MutInd.t</a> <a href="../Univ/index.html#type-puniverses">Univ.puniverses</a> <span>&#45;&gt;</span> <a href="index.html#type-mind_specif">mind_specif</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> array</code></dt><dd><p>Transforms inductive specification into types (in nf)</p></dd></dl><dl><dt class="spec value" id="val-inductive_params"><a href="#val-inductive_params" class="anchor"></a><code><span class="keyword">val</span> inductive_params : <a href="index.html#type-mind_specif">mind_specif</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-type_case_branches"><a href="#val-type_case_branches" class="anchor"></a><code><span class="keyword">val</span> type_case_branches : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> (<a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a> list) <span>&#45;&gt;</span> <a href="../Environ/index.html#type-unsafe_judgment">Environ.unsafe_judgment</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> array * <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dd><p><code>type_case_branches env (I,args) (p:A) c</code> computes useful types about the following Cases expression: &lt;p&gt;Cases (c :: (I args)) of b1..bn end It computes the type of every branch (pattern variables are introduced by products), the type for the whole expression, and the universe constraints generated.</p></dd></dl><dl><dt class="spec value" id="val-build_branches_type"><a href="#val-build_branches_type" class="anchor"></a><code><span class="keyword">val</span> build_branches_type : <a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> <span>&#45;&gt;</span> (<a href="../Declarations/index.html#type-mutual_inductive_body">Declarations.mutual_inductive_body</a> * <a href="../Declarations/index.html#type-one_inductive_body">Declarations.one_inductive_body</a>) <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> list <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> array</code></dt><dt class="spec value" id="val-mind_arity"><a href="#val-mind_arity" class="anchor"></a><code><span class="keyword">val</span> mind_arity : <a href="../Declarations/index.html#type-one_inductive_body">Declarations.one_inductive_body</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Sorts/index.html#type-family">Sorts.family</a></code></dt><dd><p>Return the arity of an inductive type</p></dd></dl><dl><dt class="spec value" id="val-inductive_sort_family"><a href="#val-inductive_sort_family" class="anchor"></a><code><span class="keyword">val</span> inductive_sort_family : <a href="../Declarations/index.html#type-one_inductive_body">Declarations.one_inductive_body</a> <span>&#45;&gt;</span> <a href="../Sorts/index.html#type-family">Sorts.family</a></code></dt><dt class="spec value" id="val-check_case_info"><a href="#val-check_case_info" class="anchor"></a><code><span class="keyword">val</span> check_case_info : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> <span>&#45;&gt;</span> <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-case_info">Constr.case_info</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Check a <code>case_info</code> actually correspond to a Case expression on the given inductive type.</p></dd></dl><section><header><h6 id="guard-conditions-for-fix-and-cofix-points."><a href="#guard-conditions-for-fix-and-cofix-points." class="anchor"></a>Guard conditions for fix and cofix-points.</h6></header><dl><dt class="spec value" id="val-check_fix"><a href="#val-check_fix" class="anchor"></a><code><span class="keyword">val</span> check_fix : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-fixpoint">Constr.fixpoint</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>When <code>chk</code> is false, the guard condition is not actually checked.</p></dd></dl><dl><dt class="spec value" id="val-check_cofix"><a href="#val-check_cofix" class="anchor"></a><code><span class="keyword">val</span> check_cofix : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-cofixpoint">Constr.cofixpoint</a> <span>&#45;&gt;</span> unit</code></dt></dl></section><section><header><h6 id="support-for-sort-polymorphic-inductive-types"><a href="#support-for-sort-polymorphic-inductive-types" class="anchor"></a>Support for sort-polymorphic inductive types</h6></header><aside><p>The &quot;polyprop&quot; optional argument below controls the &quot;Prop-polymorphism&quot;. By default, it is allowed. But when &quot;polyprop=false&quot;, the following exception is raised when a polymorphic singleton inductive type becomes Prop due to parameter instantiation. This is used by the Ocaml extraction, which cannot handle (yet?) Prop-polymorphism.</p></aside><dl><dt class="spec exception" id="exception-SingletonInductiveBecomesProp"><a href="#exception-SingletonInductiveBecomesProp" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">SingletonInductiveBecomesProp</span> <span class="keyword">of</span> <a href="../Names/Id/index.html#type-t">Names.Id.t</a></code></dt></dl><dl><dt class="spec value" id="val-max_inductive_sort"><a href="#val-max_inductive_sort" class="anchor"></a><code><span class="keyword">val</span> max_inductive_sort : <a href="../Sorts/index.html#type-t">Sorts.t</a> array <span>&#45;&gt;</span> <a href="../Univ/Universe/index.html#type-t">Univ.Universe.t</a></code></dt><dt class="spec value" id="val-instantiate_universes"><a href="#val-instantiate_universes" class="anchor"></a><code><span class="keyword">val</span> instantiate_universes : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span>&#45;&gt;</span> <a href="../Declarations/index.html#type-template_arity">Declarations.template_arity</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> Stdlib.Lazy.t array <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Sorts/index.html#type-t">Sorts.t</a></code></dt></dl></section><section><header><h6 id="debug"><a href="#debug" class="anchor"></a>Debug</h6></header><dl><dt class="spec type" id="type-size"><a href="#type-size" class="anchor"></a><code><span class="keyword">type</span> size</code><code> = </code><table class="variant"><tr id="type-size.Large" class="anchored"><td class="def constructor"><a href="#type-size.Large" class="anchor"></a><code>| </code><code><span class="constructor">Large</span></code></td></tr><tr id="type-size.Strict" class="anchored"><td class="def constructor"><a href="#type-size.Strict" class="anchor"></a><code>| </code><code><span class="constructor">Strict</span></code></td></tr></table></dt><dt class="spec type" id="type-subterm_spec"><a href="#type-subterm_spec" class="anchor"></a><code><span class="keyword">type</span> subterm_spec</code><code> = </code><table class="variant"><tr id="type-subterm_spec.Subterm" class="anchored"><td class="def constructor"><a href="#type-subterm_spec.Subterm" class="anchor"></a><code>| </code><code><span class="constructor">Subterm</span> <span class="keyword">of</span> <a href="index.html#type-size">size</a> * <a href="../Declarations/index.html#type-wf_paths">Declarations.wf_paths</a></code></td></tr><tr id="type-subterm_spec.Dead_code" class="anchored"><td class="def constructor"><a href="#type-subterm_spec.Dead_code" class="anchor"></a><code>| </code><code><span class="constructor">Dead_code</span></code></td></tr><tr id="type-subterm_spec.Not_subterm" class="anchored"><td class="def constructor"><a href="#type-subterm_spec.Not_subterm" class="anchor"></a><code>| </code><code><span class="constructor">Not_subterm</span></code></td></tr></table></dt><dt class="spec type" id="type-guard_env"><a href="#type-guard_env" class="anchor"></a><code><span class="keyword">type</span> guard_env</code><code> = </code><code>{</code><table class="record"><tr id="type-guard_env.env" class="anchored"><td class="def field"><a href="#type-guard_env.env" class="anchor"></a><code>env : <a href="../Environ/index.html#type-env">Environ.env</a>;</code></td><td class="doc"><p>dB of last fixpoint</p></td></tr><tr id="type-guard_env.rel_min" class="anchored"><td class="def field"><a href="#type-guard_env.rel_min" class="anchor"></a><code>rel_min : int;</code></td><td class="doc"><p>dB of variables denoting subterms</p></td></tr><tr id="type-guard_env.genv" class="anchored"><td class="def field"><a href="#type-guard_env.genv" class="anchor"></a><code>genv : <a href="index.html#type-subterm_spec">subterm_spec</a> Stdlib.Lazy.t list;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-stack_element"><a href="#type-stack_element" class="anchor"></a><code><span class="keyword">type</span> stack_element</code><code> = </code><table class="variant"><tr id="type-stack_element.SClosure" class="anchored"><td class="def constructor"><a href="#type-stack_element.SClosure" class="anchor"></a><code>| </code><code><span class="constructor">SClosure</span> <span class="keyword">of</span> <a href="index.html#type-guard_env">guard_env</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a></code></td></tr><tr id="type-stack_element.SArg" class="anchored"><td class="def constructor"><a href="#type-stack_element.SArg" class="anchor"></a><code>| </code><code><span class="constructor">SArg</span> <span class="keyword">of</span> <a href="index.html#type-subterm_spec">subterm_spec</a> Stdlib.Lazy.t</code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-subterm_specif"><a href="#val-subterm_specif" class="anchor"></a><code><span class="keyword">val</span> subterm_specif : <a href="index.html#type-guard_env">guard_env</a> <span>&#45;&gt;</span> <a href="index.html#type-stack_element">stack_element</a> list <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="index.html#type-subterm_spec">subterm_spec</a></code></dt><dt class="spec value" id="val-lambda_implicit_lift"><a href="#val-lambda_implicit_lift" class="anchor"></a><code><span class="keyword">val</span> lambda_implicit_lift : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-abstract_mind_lc"><a href="#val-abstract_mind_lc" class="anchor"></a><code><span class="keyword">val</span> abstract_mind_lc : int <span>&#45;&gt;</span> <a href="../Int/index.html#type-t">Int.t</a> <span>&#45;&gt;</span> (<a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a>) array <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> array</code></dt></dl></section></div></body></html>