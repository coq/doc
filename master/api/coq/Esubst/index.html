<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Esubst (coq.Esubst)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">coq</a> &#x00BB; Esubst</nav><h1>Module <code>Esubst</code></h1><p>Explicit substitutions</p></header><dl><dt class="spec type" id="type-subs"><a href="#type-subs" class="anchor"></a><code><span class="keyword">type</span> <span>'a subs</span></code></dt><dd><p>Explicit substitutions for some type of terms <code>'a</code>.</p><p>Assuming terms enjoy a notion of typability Γ ⊢ t : A, where Γ is a telescope and A a type, substitutions can be typed as Γ ⊢ σ : Δ, where as a first approximation σ is a list of terms u₁; ...; uₙ s.t. Δ := (x₁ : A₁), ..., (xₙ : Aₙ) and Γ ⊢ uᵢ : Aᵢ<code>u₁...uᵢ₋₁</code> for all 1 ≤ i ≤ n.</p><p>Substitutions can be applied to terms as follows, and furthermore if Γ ⊢ σ : Δ and Δ ⊢ t : A, then Γ ⊢ t<code>σ</code> : A<code>σ</code>.</p><p>We make the typing rules explicit below, but we omit the explicit De Bruijn fidgetting and leave relocations implicit in terms and types.</p></dd></dl><aside><p>Derived constructors granting basic invariants</p></aside><dl><dt class="spec value" id="val-subs_id"><a href="#val-subs_id" class="anchor"></a><code><span class="keyword">val</span> subs_id : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span></code></dt><dd><p>Assuming |Γ| = n, Γ ⊢ subs_id n : Γ</p></dd></dl><dl><dt class="spec value" id="val-subs_cons"><a href="#val-subs_cons" class="anchor"></a><code><span class="keyword">val</span> subs_cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span></code></dt><dd><p>Assuming Γ ⊢ σ : Δ and Γ ⊢ t : A<code>σ</code>, then Γ ⊢ subs_cons t σ : Δ, A</p></dd></dl><dl><dt class="spec value" id="val-subs_shft"><a href="#val-subs_shft" class="anchor"></a><code><span class="keyword">val</span> subs_shft : <span>(int * <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span></code></dt><dd><p>Assuming Γ ⊢ σ : Δ and |Ξ| = n, then Γ, Ξ ⊢ subs_shft (n, σ) : Δ</p></dd></dl><dl><dt class="spec value" id="val-subs_lift"><a href="#val-subs_lift" class="anchor"></a><code><span class="keyword">val</span> subs_lift : <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span></code></dt><dd><p>Unary variant of <code>subst_liftn</code>.</p></dd></dl><dl><dt class="spec value" id="val-subs_liftn"><a href="#val-subs_liftn" class="anchor"></a><code><span class="keyword">val</span> subs_liftn : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span></code></dt><dd><p>Assuming Γ ⊢ σ : Δ and |Ξ| = n, then Γ, Ξ ⊢ subs_liftn n σ : Δ, Ξ</p></dd></dl><dl><dt class="spec value" id="val-expand_rel"><a href="#val-expand_rel" class="anchor"></a><code><span class="keyword">val</span> expand_rel : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span> <span>&#45;&gt;</span> <span><span>(int * <span class="type-var">'a</span>, int * <span>int option</span>)</span> <a href="../Util/index.html#type-union">Util.union</a></span></code></dt><dd><p><code>expand_rel k subs</code> expands de Bruijn <code>k</code> in the explicit substitution <code>subs</code>. The result is either (Inl(lams,v)) when the variable is substituted by value <code>v</code> under lams binders (i.e. v *has* to be shifted by lams), or (Inr (k',p)) when the variable k is just relocated as k'; p is None if the variable points inside subs and Some(k) if the variable points k bindings beyond subs (cf argument of ESID).</p></dd></dl><dl><dt class="spec value" id="val-is_subs_id"><a href="#val-is_subs_id" class="anchor"></a><code><span class="keyword">val</span> is_subs_id : <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Tests whether a substitution behaves like the identity</p></dd></dl><aside><p>Composition of substitutions: <code>comp mk_clos s1 s2</code> computes a substitution equivalent to applying s2 then s1. Argument mk_clos is used when a closure has to be created, i.e. when s1 is applied on an element of s2.</p></aside><dl><dt class="spec type" id="type-lift"><a href="#type-lift" class="anchor"></a><code><span class="keyword">type</span> lift</code><code> = <span class="keyword">private</span> </code><table class="variant"><tr id="type-lift.ELID" class="anchored"><td class="def constructor"><a href="#type-lift.ELID" class="anchor"></a><code>| </code><code><span class="constructor">ELID</span></code></td></tr><tr id="type-lift.ELSHFT" class="anchored"><td class="def constructor"><a href="#type-lift.ELSHFT" class="anchor"></a><code>| </code><code><span class="constructor">ELSHFT</span> <span class="keyword">of</span> <a href="index.html#type-lift">lift</a> * int</code></td></tr><tr id="type-lift.ELLFT" class="anchored"><td class="def constructor"><a href="#type-lift.ELLFT" class="anchor"></a><code>| </code><code><span class="constructor">ELLFT</span> <span class="keyword">of</span> int * <a href="index.html#type-lift">lift</a></code></td></tr></table></dt><dd><p>Compact representation of explicit relocations</p><ul><li><code>ELSHFT(l,n)</code> == lift of <code>n</code>, then apply <code>lift l</code>.</li><li><code>ELLFT(n,l)</code> == apply <code>l</code> to de Bruijn &gt; <code>n</code> i.e under n binders.</li></ul><p>Invariant ensured by the private flag: no lift contains two consecutive <code>ELSHFT</code> nor two consecutive <code>ELLFT</code>.</p><p>Relocations are a particular kind of substitutions that only contain variables. In particular, <code>el_*</code> enjoys the same typing rules as the equivalent substitution function <code>subs_*</code>.</p></dd></dl><dl><dt class="spec value" id="val-el_id"><a href="#val-el_id" class="anchor"></a><code><span class="keyword">val</span> el_id : <a href="index.html#type-lift">lift</a></code></dt><dt class="spec value" id="val-el_shft"><a href="#val-el_shft" class="anchor"></a><code><span class="keyword">val</span> el_shft : int <span>&#45;&gt;</span> <a href="index.html#type-lift">lift</a> <span>&#45;&gt;</span> <a href="index.html#type-lift">lift</a></code></dt><dt class="spec value" id="val-el_liftn"><a href="#val-el_liftn" class="anchor"></a><code><span class="keyword">val</span> el_liftn : int <span>&#45;&gt;</span> <a href="index.html#type-lift">lift</a> <span>&#45;&gt;</span> <a href="index.html#type-lift">lift</a></code></dt><dt class="spec value" id="val-el_lift"><a href="#val-el_lift" class="anchor"></a><code><span class="keyword">val</span> el_lift : <a href="index.html#type-lift">lift</a> <span>&#45;&gt;</span> <a href="index.html#type-lift">lift</a></code></dt><dt class="spec value" id="val-reloc_rel"><a href="#val-reloc_rel" class="anchor"></a><code><span class="keyword">val</span> reloc_rel : int <span>&#45;&gt;</span> <a href="index.html#type-lift">lift</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-is_lift_id"><a href="#val-is_lift_id" class="anchor"></a><code><span class="keyword">val</span> is_lift_id : <a href="index.html#type-lift">lift</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-lift_subst"><a href="#val-lift_subst" class="anchor"></a><code><span class="keyword">val</span> lift_subst : <span>(<a href="index.html#type-lift">lift</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-lift">lift</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-subs">subs</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-subs">subs</a></span></code></dt><dd><p>Lift applied to substitution: <code>lift_subst mk_clos el s</code> computes a substitution equivalent to applying el then s. Argument mk_clos is used when a closure has to be created, i.e. when el is applied on an element of s.</p><p>That is, if Γ ⊢ e : Δ and Δ ⊢ σ : Ξ, then Γ ⊢ lift_subst mk e σ : Ξ.</p></dd></dl><dl><dt class="spec module" id="module-Internal"><a href="#module-Internal" class="anchor"></a><code><span class="keyword">module</span> <a href="Internal/index.html">Internal</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Debugging utilities</p></dd></dl></div></body></html>