<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Term (coq.Term)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">coq</a> &#x00BB; Term</nav><h1>Module <code>Term</code></h1><h6 id="derived-constructors"><a href="#derived-constructors" class="anchor"></a>Derived constructors</h6><nav class="toc"><ul><li><a href="#other-term-constructors.">Other term constructors.</a></li><li><a href="#other-term-destructors.">Other term destructors.</a></li><li><a href="#...">...</a></li><li><a href="#kind-of-type">Kind of type</a></li></ul></nav></header><dl><dt class="spec value" id="val-mkArrow"><a href="#val-mkArrow" class="anchor"></a><code><span class="keyword">val</span> mkArrow : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>non-dependent product <code>t1 -&gt; t2</code>, an alias for <code>forall (_:t1), t2</code>. Beware <code>t_2</code> is NOT lifted. Eg: in context <code>A:Prop</code>, <code>A-&gt;A</code> is built by <code>(mkArrow (mkRel 1) (mkRel 2))</code></p></dd></dl><dl><dt class="spec value" id="val-mkArrowR"><a href="#val-mkArrowR" class="anchor"></a><code><span class="keyword">val</span> mkArrowR : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>For an always-relevant domain</p></dd></dl><dl><dt class="spec value" id="val-mkNamedLambda"><a href="#val-mkNamedLambda" class="anchor"></a><code><span class="keyword">val</span> mkNamedLambda : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Named version of the functions from <code>Term</code>.</p></dd></dl><dl><dt class="spec value" id="val-mkNamedLetIn"><a href="#val-mkNamedLetIn" class="anchor"></a><code><span class="keyword">val</span> mkNamedLetIn : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-mkNamedProd"><a href="#val-mkNamedProd" class="anchor"></a><code><span class="keyword">val</span> mkNamedProd : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dt class="spec value" id="val-mkProd_or_LetIn"><a href="#val-mkProd_or_LetIn" class="anchor"></a><code><span class="keyword">val</span> mkProd_or_LetIn : <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dd><p>Constructs either <code>(x:t)c</code> or <code>[x=b:t]c</code></p></dd></dl><dl><dt class="spec value" id="val-mkProd_wo_LetIn"><a href="#val-mkProd_wo_LetIn" class="anchor"></a><code><span class="keyword">val</span> mkProd_wo_LetIn : <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dt class="spec value" id="val-mkNamedProd_or_LetIn"><a href="#val-mkNamedProd_or_LetIn" class="anchor"></a><code><span class="keyword">val</span> mkNamedProd_or_LetIn : <a href="../Constr/index.html#type-named_declaration">Constr.named_declaration</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dt class="spec value" id="val-mkNamedProd_wo_LetIn"><a href="#val-mkNamedProd_wo_LetIn" class="anchor"></a><code><span class="keyword">val</span> mkNamedProd_wo_LetIn : <a href="../Constr/index.html#type-named_declaration">Constr.named_declaration</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dt class="spec value" id="val-mkLambda_or_LetIn"><a href="#val-mkLambda_or_LetIn" class="anchor"></a><code><span class="keyword">val</span> mkLambda_or_LetIn : <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Constructs either <code>[x:t]c</code> or <code>[x=b:t]c</code></p></dd></dl><dl><dt class="spec value" id="val-mkNamedLambda_or_LetIn"><a href="#val-mkNamedLambda_or_LetIn" class="anchor"></a><code><span class="keyword">val</span> mkNamedLambda_or_LetIn : <a href="../Constr/index.html#type-named_declaration">Constr.named_declaration</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt></dl><section><header><h6 id="other-term-constructors."><a href="#other-term-constructors." class="anchor"></a>Other term constructors.</h6></header><aside><p><code>applist (f,args)</code> and its variants work as <code>mkApp</code></p></aside><dl><dt class="spec value" id="val-applist"><a href="#val-applist" class="anchor"></a><code><span class="keyword">val</span> applist : <span>(<a href="../Constr/index.html#type-constr">Constr.constr</a> * <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span>)</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-applistc"><a href="#val-applistc" class="anchor"></a><code><span class="keyword">val</span> applistc : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-appvect"><a href="#val-appvect" class="anchor"></a><code><span class="keyword">val</span> appvect : <span>(<a href="../Constr/index.html#type-constr">Constr.constr</a> * <span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span>)</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-appvectc"><a href="#val-appvectc" class="anchor"></a><code><span class="keyword">val</span> appvectc : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-prodn"><a href="#val-prodn" class="anchor"></a><code><span class="keyword">val</span> prodn : int <span>&#45;&gt;</span> <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>prodn n l b</code> = <code>forall (x_1:T_1)...(x_n:T_n), b</code> where <code>l</code> is <code>(x_n,T_n)...(x_1,T_1)...</code>.</p></dd></dl><dl><dt class="spec value" id="val-compose_prod"><a href="#val-compose_prod" class="anchor"></a><code><span class="keyword">val</span> compose_prod : <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>compose_prod l b</code></p><dl><dt>returns</dt><dd><p><code>forall (x_1:T_1)...(x_n:T_n), b</code> where <code>l</code> is <code>(x_n,T_n)...(x_1,T_1)</code>. Inverse of <code>decompose_prod</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lamn"><a href="#val-lamn" class="anchor"></a><code><span class="keyword">val</span> lamn : int <span>&#45;&gt;</span> <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>lamn n l b</code></p><dl><dt>returns</dt><dd><p><code>fun (x_1:T_1)...(x_n:T_n) =&gt; b</code> where <code>l</code> is <code>(x_n,T_n)...(x_1,T_1)...</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-compose_lam"><a href="#val-compose_lam" class="anchor"></a><code><span class="keyword">val</span> compose_lam : <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>compose_lam l b</code></p><dl><dt>returns</dt><dd><p><code>fun (x_1:T_1)...(x_n:T_n) =&gt; b</code> where <code>l</code> is <code>(x_n,T_n)...(x_1,T_1)</code>. Inverse of <code>it_destLam</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_lambda"><a href="#val-to_lambda" class="anchor"></a><code><span class="keyword">val</span> to_lambda : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>to_lambda n l</code></p><dl><dt>returns</dt><dd><p><code>fun (x_1:T_1)...(x_n:T_n) =&gt; T</code> where <code>l</code> is <code>forall (x_1:T_1)...(x_n:T_n), T</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_prod"><a href="#val-to_prod" class="anchor"></a><code><span class="keyword">val</span> to_prod : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>to_prod n l</code></p><dl><dt>returns</dt><dd><p><code>forall (x_1:T_1)...(x_n:T_n), T</code> where <code>l</code> is <code>fun (x_1:T_1)...(x_n:T_n) =&gt; T</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-it_mkLambda_or_LetIn"><a href="#val-it_mkLambda_or_LetIn" class="anchor"></a><code><span class="keyword">val</span> it_mkLambda_or_LetIn : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-it_mkProd_or_LetIn"><a href="#val-it_mkProd_or_LetIn" class="anchor"></a><code><span class="keyword">val</span> it_mkProd_or_LetIn : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dt class="spec value" id="val-lambda_applist"><a href="#val-lambda_applist" class="anchor"></a><code><span class="keyword">val</span> lambda_applist : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>In <code>lambda_applist c args</code>, <code>c</code> is supposed to have the form <code>λΓ.c</code> with <code>Γ</code> without let-in; it returns <code>c</code> with the variables of <code>Γ</code> instantiated by <code>args</code>.</p></dd></dl><dl><dt class="spec value" id="val-lambda_appvect"><a href="#val-lambda_appvect" class="anchor"></a><code><span class="keyword">val</span> lambda_appvect : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-lambda_applist_assum"><a href="#val-lambda_applist_assum" class="anchor"></a><code><span class="keyword">val</span> lambda_applist_assum : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>In <code>lambda_applist_assum n c args</code>, <code>c</code> is supposed to have the form <code>λΓ.c</code> with <code>Γ</code> of length <code>n</code> and possibly with let-ins; it returns <code>c</code> with the assumptions of <code>Γ</code> instantiated by <code>args</code> and the local definitions of <code>Γ</code> expanded.</p></dd></dl><dl><dt class="spec value" id="val-lambda_appvect_assum"><a href="#val-lambda_appvect_assum" class="anchor"></a><code><span class="keyword">val</span> lambda_appvect_assum : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt></dl><aside><p>pseudo-reduction rule</p></aside><dl><dt class="spec value" id="val-prod_appvect"><a href="#val-prod_appvect" class="anchor"></a><code><span class="keyword">val</span> prod_appvect : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dd><p><code>prod_appvect</code> <code>forall (x1:B1;...;xn:Bn), B</code> <code>a1...an</code> </p><dl><dt>returns</dt><dd><p><code>B[a1...an]</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-prod_applist"><a href="#val-prod_applist" class="anchor"></a><code><span class="keyword">val</span> prod_applist : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dt class="spec value" id="val-prod_appvect_assum"><a href="#val-prod_appvect_assum" class="anchor"></a><code><span class="keyword">val</span> prod_appvect_assum : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dd><p>In <code>prod_appvect_assum n c args</code>, <code>c</code> is supposed to have the form <code>∀Γ.c</code> with <code>Γ</code> of length <code>n</code> and possibly with let-ins; it returns <code>c</code> with the assumptions of <code>Γ</code> instantiated by <code>args</code> and the local definitions of <code>Γ</code> expanded.</p></dd></dl><dl><dt class="spec value" id="val-prod_applist_assum"><a href="#val-prod_applist_assum" class="anchor"></a><code><span class="keyword">val</span> prod_applist_assum : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt></dl></section><section><header><h6 id="other-term-destructors."><a href="#other-term-destructors." class="anchor"></a>Other term destructors.</h6></header><dl><dt class="spec value" id="val-decompose_prod"><a href="#val-decompose_prod" class="anchor"></a><code><span class="keyword">val</span> decompose_prod : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> * <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Transforms a product term <code> $ </code>(x_1:T_1)..(x_n:T_n)T<code> $ </code> into the pair <code> $ </code>(<code>(x_n,T_n);...;(x_1,T_1)</code>,T)<code> $ </code>, where <code> $ </code>T<code> $ </code> is not a product.</p></dd></dl><dl><dt class="spec value" id="val-decompose_lam"><a href="#val-decompose_lam" class="anchor"></a><code><span class="keyword">val</span> decompose_lam : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> * <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Transforms a lambda term <code> $ </code><code>x_1:T_1</code>..<code>x_n:T_n</code>T<code> $ </code> into the pair <code> $ </code>(<code>(x_n,T_n);...;(x_1,T_1)</code>,T)<code> $ </code>, where <code> $ </code>T<code> $ </code> is not a lambda.</p></dd></dl><dl><dt class="spec value" id="val-decompose_prod_n"><a href="#val-decompose_prod_n" class="anchor"></a><code><span class="keyword">val</span> decompose_prod_n : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> * <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Given a positive integer n, decompose a product term <code> $ </code>(x_1:T_1)..(x_n:T_n)T<code> $ </code> into the pair <code> $ </code>(<code>(xn,Tn);...;(x1,T1)</code>,T)<code> $ </code>. Raise a user error if not enough products.</p></dd></dl><dl><dt class="spec value" id="val-decompose_lam_n"><a href="#val-decompose_lam_n" class="anchor"></a><code><span class="keyword">val</span> decompose_lam_n : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> * <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Given a positive integer <code> $ </code>n<code> $ </code>, decompose a lambda term <code> $ </code><code>x_1:T_1</code>..<code>x_n:T_n</code>T<code> $ </code> into the pair <code> $ </code>(<code>(x_n,T_n);...;(x_1,T_1)</code>,T)<code> $ </code>. Raise a user error if not enough lambdas.</p></dd></dl><dl><dt class="spec value" id="val-decompose_prod_assum"><a href="#val-decompose_prod_assum" class="anchor"></a><code><span class="keyword">val</span> decompose_prod_assum : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dd><p>Extract the premisses and the conclusion of a term of the form &quot;(xi:Ti) ... (xj:=cj:Tj) ..., T&quot; where T is not a product nor a let</p></dd></dl><dl><dt class="spec value" id="val-decompose_lam_assum"><a href="#val-decompose_lam_assum" class="anchor"></a><code><span class="keyword">val</span> decompose_lam_assum : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Idem with lambda's and let's</p></dd></dl><dl><dt class="spec value" id="val-decompose_prod_n_assum"><a href="#val-decompose_prod_n_assum" class="anchor"></a><code><span class="keyword">val</span> decompose_prod_n_assum : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dd><p>Idem but extract the first <code>n</code> premisses, counting let-ins.</p></dd></dl><dl><dt class="spec value" id="val-decompose_lam_n_assum"><a href="#val-decompose_lam_n_assum" class="anchor"></a><code><span class="keyword">val</span> decompose_lam_n_assum : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Idem for lambdas, _not_ counting let-ins</p></dd></dl><dl><dt class="spec value" id="val-decompose_lam_n_decls"><a href="#val-decompose_lam_n_decls" class="anchor"></a><code><span class="keyword">val</span> decompose_lam_n_decls : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Idem, counting let-ins</p></dd></dl><dl><dt class="spec value" id="val-prod_assum"><a href="#val-prod_assum" class="anchor"></a><code><span class="keyword">val</span> prod_assum : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></code></dt><dd><p>Return the premisses/parameters of a type/term (let-in included)</p></dd></dl><dl><dt class="spec value" id="val-lam_assum"><a href="#val-lam_assum" class="anchor"></a><code><span class="keyword">val</span> lam_assum : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></code></dt><dt class="spec value" id="val-prod_n_assum"><a href="#val-prod_n_assum" class="anchor"></a><code><span class="keyword">val</span> prod_n_assum : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></code></dt><dd><p>Return the first n-th premisses/parameters of a type (let included and counted)</p></dd></dl><dl><dt class="spec value" id="val-lam_n_assum"><a href="#val-lam_n_assum" class="anchor"></a><code><span class="keyword">val</span> lam_n_assum : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></code></dt><dd><p>Return the first n-th premisses/parameters of a term (let included but not counted)</p></dd></dl><dl><dt class="spec value" id="val-strip_prod"><a href="#val-strip_prod" class="anchor"></a><code><span class="keyword">val</span> strip_prod : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dd><p>Remove the premisses/parameters of a type/term</p></dd></dl><dl><dt class="spec value" id="val-strip_lam"><a href="#val-strip_lam" class="anchor"></a><code><span class="keyword">val</span> strip_lam : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-strip_prod_n"><a href="#val-strip_prod_n" class="anchor"></a><code><span class="keyword">val</span> strip_prod_n : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dd><p>Remove the first n-th premisses/parameters of a type/term</p></dd></dl><dl><dt class="spec value" id="val-strip_lam_n"><a href="#val-strip_lam_n" class="anchor"></a><code><span class="keyword">val</span> strip_lam_n : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-strip_prod_assum"><a href="#val-strip_prod_assum" class="anchor"></a><code><span class="keyword">val</span> strip_prod_assum : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dd><p>Remove the premisses/parameters of a type/term (including let-in)</p></dd></dl><dl><dt class="spec value" id="val-strip_lam_assum"><a href="#val-strip_lam_assum" class="anchor"></a><code><span class="keyword">val</span> strip_lam_assum : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt></dl></section><section><header><h6 id="..."><a href="#..." class="anchor"></a>...</h6></header><aside><p>An &quot;arity&quot; is a term of the form <code>[x1:T1]...[xn:Tn]s</code> with <code>s</code> a sort. Such a term can canonically be seen as the pair of a context of types and of a sort</p></aside><dl><dt class="spec type" id="type-arity"><a href="#type-arity" class="anchor"></a><code><span class="keyword">type</span> arity</code><code> = <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Sorts/index.html#type-t">Sorts.t</a></code></dt></dl><dl><dt class="spec value" id="val-mkArity"><a href="#val-mkArity" class="anchor"></a><code><span class="keyword">val</span> mkArity : <a href="index.html#type-arity">arity</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-types">Constr.types</a></code></dt><dd><p>Build an &quot;arity&quot; from its canonical form</p></dd></dl><dl><dt class="spec value" id="val-destArity"><a href="#val-destArity" class="anchor"></a><code><span class="keyword">val</span> destArity : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <a href="index.html#type-arity">arity</a></code></dt><dd><p>Destruct an &quot;arity&quot; into its canonical form</p></dd></dl><dl><dt class="spec value" id="val-isArity"><a href="#val-isArity" class="anchor"></a><code><span class="keyword">val</span> isArity : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Tell if a term has the form of an arity</p></dd></dl></section><section><header><h6 id="kind-of-type"><a href="#kind-of-type" class="anchor"></a>Kind of type</h6></header><dl><dt class="spec type" id="type-kind_of_type"><a href="#type-kind_of_type" class="anchor"></a><code><span class="keyword">type</span> <span>('constr, 'types) kind_of_type</span></code><code> = </code><table class="variant"><tr id="type-kind_of_type.SortType" class="anchored"><td class="def constructor"><a href="#type-kind_of_type.SortType" class="anchor"></a><code>| </code><code><span class="constructor">SortType</span> <span class="keyword">of</span> <a href="../Sorts/index.html#type-t">Sorts.t</a></code></td></tr><tr id="type-kind_of_type.CastType" class="anchored"><td class="def constructor"><a href="#type-kind_of_type.CastType" class="anchor"></a><code>| </code><code><span class="constructor">CastType</span> <span class="keyword">of</span> <span class="type-var">'types</span> * <span class="type-var">'types</span></code></td></tr><tr id="type-kind_of_type.ProdType" class="anchored"><td class="def constructor"><a href="#type-kind_of_type.ProdType" class="anchor"></a><code>| </code><code><span class="constructor">ProdType</span> <span class="keyword">of</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <span class="type-var">'types</span> * <span class="type-var">'types</span></code></td></tr><tr id="type-kind_of_type.LetInType" class="anchored"><td class="def constructor"><a href="#type-kind_of_type.LetInType" class="anchor"></a><code>| </code><code><span class="constructor">LetInType</span> <span class="keyword">of</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <span class="type-var">'constr</span> * <span class="type-var">'types</span> * <span class="type-var">'types</span></code></td></tr><tr id="type-kind_of_type.AtomicType" class="anchored"><td class="def constructor"><a href="#type-kind_of_type.AtomicType" class="anchor"></a><code>| </code><code><span class="constructor">AtomicType</span> <span class="keyword">of</span> <span class="type-var">'constr</span> * <span><span class="type-var">'constr</span> array</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-kind_of_type"><a href="#val-kind_of_type" class="anchor"></a><code><span class="keyword">val</span> kind_of_type : <a href="../Constr/index.html#type-types">Constr.types</a> <span>&#45;&gt;</span> <span><span>(<a href="../Constr/index.html#type-constr">Constr.constr</a>, <a href="../Constr/index.html#type-types">Constr.types</a>)</span> <a href="index.html#type-kind_of_type">kind_of_type</a></span></code></dt></dl><dl><dt class="spec type" id="type-sorts_family"><a href="#type-sorts_family" class="anchor"></a><code><span class="keyword">type</span> sorts_family</code><code> = <a href="../Sorts/index.html#type-family">Sorts.family</a></code><code> = </code><table class="variant"><tr id="type-sorts_family.InSProp" class="anchored"><td class="def constructor"><a href="#type-sorts_family.InSProp" class="anchor"></a><code>| </code><code><span class="constructor">InSProp</span></code></td></tr><tr id="type-sorts_family.InProp" class="anchored"><td class="def constructor"><a href="#type-sorts_family.InProp" class="anchor"></a><code>| </code><code><span class="constructor">InProp</span></code></td></tr><tr id="type-sorts_family.InSet" class="anchored"><td class="def constructor"><a href="#type-sorts_family.InSet" class="anchor"></a><code>| </code><code><span class="constructor">InSet</span></code></td></tr><tr id="type-sorts_family.InType" class="anchored"><td class="def constructor"><a href="#type-sorts_family.InType" class="anchor"></a><code>| </code><code><span class="constructor">InType</span></code></td></tr></table></dt><dt class="spec type" id="type-sorts"><a href="#type-sorts" class="anchor"></a><code><span class="keyword">type</span> sorts</code><code> = <span class="keyword">private</span> <a href="../Sorts/index.html#type-t">Sorts.t</a></code><code> = </code><table class="variant"><tr id="type-sorts.SProp" class="anchored"><td class="def constructor"><a href="#type-sorts.SProp" class="anchor"></a><code>| </code><code><span class="constructor">SProp</span></code></td></tr><tr id="type-sorts.Prop" class="anchored"><td class="def constructor"><a href="#type-sorts.Prop" class="anchor"></a><code>| </code><code><span class="constructor">Prop</span></code></td></tr><tr id="type-sorts.Set" class="anchored"><td class="def constructor"><a href="#type-sorts.Set" class="anchor"></a><code>| </code><code><span class="constructor">Set</span></code></td></tr><tr id="type-sorts.Type" class="anchored"><td class="def constructor"><a href="#type-sorts.Type" class="anchor"></a><code>| </code><code><span class="constructor">Type</span> <span class="keyword">of</span> <a href="../Univ/Universe/index.html#type-t">Univ.Universe.t</a></code></td><td class="doc"><p>Type</p></td></tr></table></dt></dl></section></div></body></html>