<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CObj (coq.CObj)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; CObj</nav><h1>Module <code>CObj</code></h1><h4 id="physical-size-of-an-ocaml-value."><a href="#physical-size-of-an-ocaml-value." class="anchor"></a>Physical size of an ocaml value.</h4><p>These functions explore objects recursively and may allocate a lot.</p><nav class="toc"><ul><li><a href="#physical-size-of-an-ocaml-value-with-sharing.">Physical size of an ocaml value with sharing.</a></li><li><a href="#logical-size-of-an-ocaml-value.">Logical size of an OCaml value.</a></li><li><a href="#total-size-of-the-allocated-ocaml-heap.">Total size of the allocated ocaml heap.</a></li></ul></nav></header><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val </span>size : <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p>Physical size of an object in words.</p></dd></dl><dl><dt class="spec value" id="val-size_b"><a href="#val-size_b" class="anchor"></a><code><span class="keyword">val </span>size_b : <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p>Same as <code>size</code> in bytes.</p></dd></dl><dl><dt class="spec value" id="val-size_kb"><a href="#val-size_kb" class="anchor"></a><code><span class="keyword">val </span>size_kb : <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p>Same as <code>size</code> in kilobytes.</p></dd></dl><section><header><h4 id="physical-size-of-an-ocaml-value-with-sharing."><a href="#physical-size-of-an-ocaml-value-with-sharing." class="anchor"></a>Physical size of an ocaml value with sharing.</h4></header><aside><p>This time, all the size of objects are computed with respect to a larger object containing them all, and we only count the new blocks not already seen earlier in the left-to-right visit of the englobing object.</p></aside><aside><p>Provides the global object in which we'll search shared sizes</p></aside><dl><dt class="spec value" id="val-register_shared_size"><a href="#val-register_shared_size" class="anchor"></a><code><span class="keyword">val </span>register_shared_size : <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt></dl><aside><p>Shared size (in word) of an object with respect to the global object given by the last <code>register_shared_size</code>.</p></aside><dl><dt class="spec value" id="val-shared_size_of_obj"><a href="#val-shared_size_of_obj" class="anchor"></a><code><span class="keyword">val </span>shared_size_of_obj : <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt></dl><aside><p>Same, with an object indicated by its occurrence in the global object. The very same object could have a zero size or not, depending of the occurrence we're considering in the englobing object. For speaking of occurrences, we use an <code>int list</code> for a path of field indexes (leftmost = deepest block, rightmost = top block of the global object).</p></aside><dl><dt class="spec value" id="val-shared_size_of_pos"><a href="#val-shared_size_of_pos" class="anchor"></a><code><span class="keyword">val </span>shared_size_of_pos : int list <span>&#45;&gt;</span> int</code></dt></dl></section><section><header><h4 id="logical-size-of-an-ocaml-value."><a href="#logical-size-of-an-ocaml-value." class="anchor"></a>Logical size of an OCaml value.</h4></header><dl><dt class="spec value" id="val-obj_stats"><a href="#val-obj_stats" class="anchor"></a><code><span class="keyword">val </span>obj_stats : <span class="type-var">'a</span> <span>&#45;&gt;</span> int<span class="keyword"> * </span>int<span class="keyword"> * </span>int</code></dt><dd><p>Return the (logical) value size, the string size, and the maximum depth of the object. This loops on cyclic structures.</p></dd></dl></section><section><header><h4 id="total-size-of-the-allocated-ocaml-heap."><a href="#total-size-of-the-allocated-ocaml-heap." class="anchor"></a>Total size of the allocated ocaml heap.</h4></header><dl><dt class="spec value" id="val-heap_size"><a href="#val-heap_size" class="anchor"></a><code><span class="keyword">val </span>heap_size : unit <span>&#45;&gt;</span> int</code></dt><dd><p>Heap size, in words.</p></dd></dl><dl><dt class="spec value" id="val-heap_size_kb"><a href="#val-heap_size_kb" class="anchor"></a><code><span class="keyword">val </span>heap_size_kb : unit <span>&#45;&gt;</span> int</code></dt><dd><p>Heap size, in kilobytes.</p></dd></dl></section></div></body></html>