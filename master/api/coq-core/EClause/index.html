<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>EClause (coq-core.EClause)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">coq-core</a> &#x00BB; EClause</nav><header class="odoc-preamble"><h1>Module <code><span>EClause</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#evar-based-clauses">Evar-based clauses</a></li></ul></nav><div class="odoc-content"><h6 id="evar-based-clauses"><a href="#evar-based-clauses" class="anchor"></a>Evar-based clauses</h6><p>The following code is an adaptation of the <code>Clenv.make_clenv_*</code> functions, except that it uses evars instead of metas, and naturally fits in the new refinement monad. It should eventually replace all uses of the aforementioned functions.</p><p>A clause is constructed as follows: assume a type <code>t := forall (x1 : A1) ...
    (xn : An), T</code>, we instantiate all the <code>xi</code> with a fresh evar <code>ei</code> and return <code>T(xi := ei)</code> together with the <code>ei</code> enriched with a bit of additional data. This is the simple part done by <code>make_evar_clause</code>.</p><p>The problem lies in the fact we want to solve such holes with some <code>constr bindings</code>. This entails some subtleties, because the provided terms may only be well-typed up to a coercion, which we can only infer if we have enough typing information. The meta machinery could insert coercions through tricky instantiation delays. The only solution we have now is to delay the tentative resolution of clauses by providing the <code>solve_evar_clause</code> function, to be called at a smart enough time.</p><div class="odoc-spec"><div class="spec type" id="type-hole" class="anchored"><a href="#type-hole" class="anchor"></a><code><span><span class="keyword">type</span> hole</span><span> = </span><span>{</span></code><table><tr id="type-hole.hole_evar" class="anchored"><td class="def record field"><a href="#type-hole.hole_evar" class="anchor"></a><code><span>hole_evar : <a href="../EConstr/index.html#type-constr">EConstr.constr</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The hole itself. Guaranteed to be an evar.</p><span class="comment-delim">*)</span></td></tr><tr id="type-hole.hole_type" class="anchored"><td class="def record field"><a href="#type-hole.hole_type" class="anchor"></a><code><span>hole_type : <a href="../EConstr/index.html#type-types">EConstr.types</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Type of the hole in the current environment.</p><span class="comment-delim">*)</span></td></tr><tr id="type-hole.hole_deps" class="anchored"><td class="def record field"><a href="#type-hole.hole_deps" class="anchor"></a><code><span>hole_deps : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Whether the remainder of the clause was dependent in the hole. Note that because let binders are substituted, it does not mean that it actually appears somewhere in the returned clause.</p><span class="comment-delim">*)</span></td></tr><tr id="type-hole.hole_name" class="anchored"><td class="def record field"><a href="#type-hole.hole_name" class="anchor"></a><code><span>hole_name : <a href="../Names/Name/index.html#type-t">Names.Name.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Name of the hole coming from its binder.</p><span class="comment-delim">*)</span></td></tr><tr id="type-hole.hole_evar_key" class="anchored"><td class="def record field"><a href="#type-hole.hole_evar_key" class="anchor"></a><code><span>hole_evar_key : <a href="../Evar/index.html#type-t">Evar.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Internal evar key of the hole.</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-clause" class="anchored"><a href="#type-clause" class="anchor"></a><code><span><span class="keyword">type</span> clause</span><span> = </span><span>{</span></code><table><tr id="type-clause.cl_holes" class="anchored"><td class="def record field"><a href="#type-clause.cl_holes" class="anchor"></a><code><span>cl_holes : <span><a href="#type-hole">hole</a> list</span>;</span></code></td></tr><tr id="type-clause.cl_concl" class="anchored"><td class="def record field"><a href="#type-clause.cl_concl" class="anchor"></a><code><span>cl_concl : <a href="../EConstr/index.html#type-types">EConstr.types</a>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-make_evar_clause" class="anchored"><a href="#val-make_evar_clause" class="anchor"></a><code><span><span class="keyword">val</span> make_evar_clause : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../EConstr/index.html#type-types">EConstr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="#type-clause">clause</a></span></code></div><div class="spec-doc"><p>An evar version of <code>make_clenv_binding</code>. Given a type <code>t</code>, <code>evar_environments env sigma ~len t bl</code> tries to eliminate at most <code>len</code> products of the type <code>t</code> by filling it with evars. It returns the resulting type together with the list of holes generated. Assumes that <code>t</code> is well-typed in the environment.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-solve_evar_clause" class="anchored"><a href="#val-solve_evar_clause" class="anchor"></a><code><span><span class="keyword">val</span> solve_evar_clause : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-clause">clause</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <a href="../Tactypes/index.html#type-bindings">Tactypes.bindings</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></span></code></div><div class="spec-doc"><p><code>solve_evar_clause env sigma hyps cl bl</code> tries to solve the holes contained in <code>cl</code> according to the <code>bl</code> argument. Assumes that <code>bl</code> are well-typed in the environment. The boolean <code>hyps</code> is a compatibility flag that allows to consider arguments to be dependent only when they appear in hypotheses and not in the conclusion. This boolean is only used when <code>bl</code> is of the form <code>ImplicitBindings _</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_bindings" class="anchored"><a href="#val-check_bindings" class="anchor"></a><code><span><span class="keyword">val</span> check_bindings : <span><span><span class="type-var">'a</span> <a href="../Tactypes/index.html#type-explicit_bindings">Tactypes.explicit_bindings</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-explain_no_such_bound_variable" class="anchored"><a href="#val-explain_no_such_bound_variable" class="anchor"></a><code><span><span class="keyword">val</span> explain_no_such_bound_variable : <span><span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <a href="../CAst/index.html#type-t">CAst.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-error_not_right_number_missing_arguments" class="anchored"><a href="#val-error_not_right_number_missing_arguments" class="anchor"></a><code><span><span class="keyword">val</span> error_not_right_number_missing_arguments : <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-check_evar_clause" class="anchored"><a href="#val-check_evar_clause" class="anchor"></a><code><span><span class="keyword">val</span> check_evar_clause : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-clause">clause</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></div></body></html>