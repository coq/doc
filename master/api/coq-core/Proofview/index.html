<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Proofview (coq-core.Proofview)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">coq-core</a> &#x00BB; Proofview</nav><header class="odoc-preamble"><h1>Module <code><span>Proofview</span></code></h1><p>This files defines the basic mechanism of proofs: the <code>proofview</code> type is the state which tactics manipulate (a global state for existential variables, together with the list of goals), and the type <code>'a tactic</code> is the (abstract) type of tactics modifying the proof state and returning a value of type <code>'a</code>.</p></header><nav class="odoc-toc"><ul><li><a href="#starting-and-querying-a-proof-view">Starting and querying a proof view</a></li><li><a href="#focusing-commands">Focusing commands</a></li><li><a href="#the-tactic-monad">The tactic monad</a></li><li><a href="#monadic-primitives">Monadic primitives</a></li><li><a href="#failure-and-backtracking">Failure and backtracking</a></li><li><a href="#focusing-tactics">Focusing tactics</a></li><li><a href="#dispatching-on-goals">Dispatching on goals</a></li><li><a href="#goal-manipulation">Goal manipulation</a></li><li><a href="#access-primitives">Access primitives</a></li><li><a href="#put-like-primitives">Put-like primitives</a></li><li><a href="#control-primitives">Control primitives</a></li><li><a href="#unsafe-primitives">Unsafe primitives</a></li><li><a href="#goal-dependent-tactics">Goal-dependent tactics</a></li><li><a href="#trace">Trace</a></li><li><a href="#non-logical-state">Non-logical state</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-proofview" class="anchored"><a href="#type-proofview" class="anchor"></a><code><span><span class="keyword">type</span> proofview</span></code></div><div class="spec-doc"><p>Main state of tactics</p></div></div><div class="odoc-spec"><div class="spec value" id="val-proofview" class="anchored"><a href="#val-proofview" class="anchor"></a><code><span><span class="keyword">val</span> proofview : <span><a href="#type-proofview">proofview</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evar/index.html#type-t">Evar.t</a> list</span> * <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></span></code></div><div class="spec-doc"><p>Returns a stylised view of a proofview for use by, for instance, ide-s.</p></div></div><h6 id="starting-and-querying-a-proof-view"><a href="#starting-and-querying-a-proof-view" class="anchor"></a>Starting and querying a proof view</h6><div class="odoc-spec"><div class="spec type" id="type-entry" class="anchored"><a href="#type-entry" class="anchor"></a><code><span><span class="keyword">type</span> entry</span></code></div><div class="spec-doc"><p>Abstract representation of the initial goals of a proof.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compact" class="anchored"><a href="#val-compact" class="anchor"></a><code><span><span class="keyword">val</span> compact : <span><a href="#type-entry">entry</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-proofview">proofview</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-entry">entry</a> * <a href="#type-proofview">proofview</a></span></code></div><div class="spec-doc"><p>Optimize memory consumption</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../Environ/index.html#type-env">Environ.env</a> * <a href="../EConstr/index.html#type-types">EConstr.types</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-entry">entry</a> * <a href="#type-proofview">proofview</a></span></code></div><div class="spec-doc"><p>Initialises a proofview, the main argument is a list of environments (including a <code>named_context</code> which are used as hypotheses) pair with conclusion types, creating accordingly many initial goals. Because a proof does not necessarily starts in an empty <code>evar_map</code> (indeed a proof can be triggered by an incomplete pretyping), <code>init</code> takes an additional argument to represent the initial <code>evar_map</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-telescope" class="anchored"><a href="#type-telescope" class="anchor"></a><code><span><span class="keyword">type</span> telescope</span><span> = </span></code><table><tr id="type-telescope.TNil" class="anchored"><td class="def variant constructor"><a href="#type-telescope.TNil" class="anchor"></a><code><span>| </span><span><span class="constructor">TNil</span> <span class="keyword">of</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></span></code></td></tr><tr id="type-telescope.TCons" class="anchored"><td class="def variant constructor"><a href="#type-telescope.TCons" class="anchor"></a><code><span>| </span><span><span class="constructor">TCons</span> <span class="keyword">of</span> <a href="../Environ/index.html#type-env">Environ.env</a> * <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../EConstr/index.html#type-types">EConstr.types</a> * <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-telescope">telescope</a></span></code></td></tr></table></div><div class="spec-doc"><p>A <code>telescope</code> is a list of environment and conclusion like in <a href="#val-init"><code>init</code></a>, except that each element may depend on the previous goals. The telescope passes the goals in the form of a <code>Term.constr</code> which represents the goal as an <code>evar</code>. The <code>evar_map</code> is threaded in state passing style.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dependent_init" class="anchored"><a href="#val-dependent_init" class="anchor"></a><code><span><span class="keyword">val</span> dependent_init : <span><a href="#type-telescope">telescope</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-entry">entry</a> * <a href="#type-proofview">proofview</a></span></code></div><div class="spec-doc"><p>Like <a href="#val-init"><code>init</code></a>, but goals are allowed to be dependent on one another. Dependencies between goals is represented with the type <code>telescope</code> instead of <code>list</code>. Note that the first <code>evar_map</code> of the telescope plays the role of the <code>evar_map</code> argument in <code>init</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-finished" class="anchored"><a href="#val-finished" class="anchor"></a><code><span><span class="keyword">val</span> finished : <span><a href="#type-proofview">proofview</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>finished pv</code> is <code>true</code> if and only if <code>pv</code> is complete. That is, if it has an empty list of focused goals. There could still be unsolved subgoals, but they would then be out of focus.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><a href="#type-proofview">proofview</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a></span></code></div><div class="spec-doc"><p>Returns the current <code>evar</code> state.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partial_proof" class="anchored"><a href="#val-partial_proof" class="anchor"></a><code><span><span class="keyword">val</span> partial_proof : <span><a href="#type-entry">entry</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-proofview">proofview</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-initial_goals" class="anchored"><a href="#val-initial_goals" class="anchor"></a><code><span><span class="keyword">val</span> initial_goals : <span><a href="#type-entry">entry</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../Environ/index.html#type-named_context_val">Environ.named_context_val</a> * <a href="../EConstr/index.html#type-constr">EConstr.constr</a> * <a href="../EConstr/index.html#type-types">EConstr.types</a>)</span> list</span></span></code></div></div><p>goal &lt;-&gt; goal_with_state</p><div class="odoc-spec"><div class="spec value" id="val-with_empty_state" class="anchored"><a href="#val-with_empty_state" class="anchor"></a><code><span><span class="keyword">val</span> with_empty_state : <span><a href="../Proofview_monad/index.html#type-goal">Proofview_monad.goal</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Proofview_monad/index.html#type-goal_with_state">Proofview_monad.goal_with_state</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_state" class="anchored"><a href="#val-drop_state" class="anchor"></a><code><span><span class="keyword">val</span> drop_state : <span><a href="../Proofview_monad/index.html#type-goal_with_state">Proofview_monad.goal_with_state</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Proofview_monad/index.html#type-goal">Proofview_monad.goal</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-goal_with_state" class="anchored"><a href="#val-goal_with_state" class="anchor"></a><code><span><span class="keyword">val</span> goal_with_state : <span><a href="../Proofview_monad/index.html#type-goal">Proofview_monad.goal</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Proofview_monad/StateStore/index.html#type-t">Proofview_monad.StateStore.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Proofview_monad/index.html#type-goal_with_state">Proofview_monad.goal_with_state</a></span></code></div></div><h6 id="focusing-commands"><a href="#focusing-commands" class="anchor"></a>Focusing commands</h6><div class="odoc-spec"><div class="spec type" id="type-focus_context" class="anchored"><a href="#type-focus_context" class="anchor"></a><code><span><span class="keyword">type</span> focus_context</span></code></div><div class="spec-doc"><p>A <code>focus_context</code> represents the part of the proof view which has been removed by a focusing action, it can be used to unfocus later on.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-focus_context" class="anchored"><a href="#val-focus_context" class="anchor"></a><code><span><span class="keyword">val</span> focus_context : <span><a href="#type-focus_context">focus_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evar/index.html#type-t">Evar.t</a> list</span> * <span><a href="../Evar/index.html#type-t">Evar.t</a> list</span></span></code></div><div class="spec-doc"><p>Returns a stylised view of a focus_context for use by, for instance, ide-s.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-focus" class="anchored"><a href="#val-focus" class="anchor"></a><code><span><span class="keyword">val</span> focus : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-proofview">proofview</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-proofview">proofview</a> * <a href="#type-focus_context">focus_context</a></span></code></div><div class="spec-doc"><p><code>focus i j</code> focuses a proofview on the goals from index <code>i</code> to index <code>j</code> (inclusive, goals are indexed from <code>1</code>). I.e. goals number <code>i</code> to <code>j</code> become the only focused goals of the returned proofview. It returns the focused proofview, and a context for the focus stack.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfocus" class="anchored"><a href="#val-unfocus" class="anchor"></a><code><span><span class="keyword">val</span> unfocus : <span><a href="#type-focus_context">focus_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-proofview">proofview</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-proofview">proofview</a></span></code></div><div class="spec-doc"><p>Unfocuses a proofview with respect to a context.</p></div></div><h6 id="the-tactic-monad"><a href="#the-tactic-monad" class="anchor"></a>The tactic monad</h6><ul><li>Tactics are objects which apply a transformation to all the subgoals of the current view at the same time. By opposition to the old vision of applying it to a single goal. It allows tactics such as <code>shelve_unifiable</code>, tactics to reorder the focused goals, or global automation tactic for dependent subgoals (instantiating an evar has influences on the other goals of the proof in progress, not being able to take that into account causes the current eauto tactic to fail on some instances where it could succeed). Another benefit is that it is possible to write tactics that can be executed even if there are no focused goals.</li><li>Tactics form a monad <code>'a tactic</code>, in a sense a tactic can be seen as a function (without argument) which returns a value of type 'a and modifies the environment (in our case: the view). Tactics of course have arguments, but these are given at the meta-level as OCaml functions. Most tactics in the sense we are used to return <code>()</code>, that is no really interesting values. But some might pass information around. The tactics seen in Coq's Ltac are (for now at least) only <code>unit tactic</code>, the return values are kept for the OCaml toolkit. The operation or the monad are <code>Proofview.tclUNIT</code> (which is the &quot;return&quot; of the tactic monad) <code>Proofview.tclBIND</code> (which is the &quot;bind&quot;) and <code>Proofview.tclTHEN</code> (which is a specialized bind on unit-returning tactics).</li><li>Tactics have support for full-backtracking. Tactics can be seen having multiple success: if after returning the first success a failure is encountered, the tactic can backtrack and use a second success if available. The state is backtracked to its previous value, except the non-logical state defined in the <a href="NonLogical/index.html"><code>NonLogical</code></a> module below.</li></ul><div class="odoc-spec"><div class="spec type" id="type-tactic" class="anchored"><a href="#type-tactic" class="anchor"></a><code><span><span class="keyword">type</span> <span>+'a tactic</span></span></code></div><div class="spec-doc"><p>The abstract type of tactics</p></div></div><div class="odoc-spec"><div class="spec value" id="val-apply" class="anchored"><a href="#val-apply" class="anchor"></a><code><span><span class="keyword">val</span> apply : <span>name:<a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span>poly:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-proofview">proofview</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <a href="#type-proofview">proofview</a> * bool * <a href="../Proofview_monad/Info/index.html#type-tree">Proofview_monad.Info.tree</a></span></code></div><div class="spec-doc"><p>Applies a tactic to the current proofview. Returns a tuple <code>a,pv,(b,sh,gu)</code> where <code>a</code> is the return value of the tactic, <code>pv</code> is the updated proofview, <code>b</code> a boolean which is <code>true</code> if the tactic has not done any action considered unsafe (such as admitting a lemma), <code>sh</code> is the list of goals which have been shelved by the tactic, and <code>gu</code> the list of goals on which the tactic has given up. In case of multiple success the first one is selected. If there is no success, fails with <a href="../Logic_monad/index.html#exception-TacticFailure"><code>Logic_monad.TacticFailure</code></a></p></div></div><h6 id="monadic-primitives"><a href="#monadic-primitives" class="anchor"></a>Monadic primitives</h6><div class="odoc-spec"><div class="spec value" id="val-tclUNIT" class="anchored"><a href="#val-tclUNIT" class="anchor"></a><code><span><span class="keyword">val</span> tclUNIT : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p>Unit of the tactic monad.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclBIND" class="anchored"><a href="#val-tclBIND" class="anchor"></a><code><span><span class="keyword">val</span> tclBIND : <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-tactic">tactic</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p>Bind operation of the tactic monad.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclTHEN" class="anchored"><a href="#val-tclTHEN" class="anchor"></a><code><span><span class="keyword">val</span> tclTHEN : <span><span>unit <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p>Interprets the &quot;;&quot; (semicolon) of Ltac. As a monadic operation, it's a specialized &quot;bind&quot;.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclIGNORE" class="anchored"><a href="#val-tclIGNORE" class="anchor"></a><code><span><span class="keyword">val</span> tclIGNORE : <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclIGNORE t</code> has the same operational content as <code>t</code>, but drops the returned value.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Monad" class="anchored"><a href="#module-Monad" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Monad/index.html">Monad</a></span><span> : <a href="../Monad/module-type-S/index.html">Monad.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>+'a <a href="../Monad/module-type-S/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></span></code></div><div class="spec-doc"><p>Generic monadic combinators for tactics.</p></div></div><h6 id="failure-and-backtracking"><a href="#failure-and-backtracking" class="anchor"></a>Failure and backtracking</h6><div class="odoc-spec"><div class="spec value" id="val-tclZERO" class="anchored"><a href="#val-tclZERO" class="anchor"></a><code><span><span class="keyword">val</span> tclZERO : <span>?info:<a href="../Exninfo/index.html#type-info">Exninfo.info</a> <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclZERO e</code> fails with exception <code>e</code>. It has no success. Exception is supposed to be non critical</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclOR" class="anchored"><a href="#val-tclOR" class="anchor"></a><code><span><span class="keyword">val</span> tclOR : <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Exninfo/index.html#type-iexn">Exninfo.iexn</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclOR t1 t2</code> behaves like <code>t1</code> as long as <code>t1</code> succeeds. Whenever the successes of <code>t1</code> have been depleted and it failed with <code>e</code>, then it behaves as <code>t2 e</code>. In other words, <code>tclOR</code> inserts a backtracking point. In <code>t2</code>, exception can be assumed non critical.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclORELSE" class="anchored"><a href="#val-tclORELSE" class="anchor"></a><code><span><span class="keyword">val</span> tclORELSE : <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Exninfo/index.html#type-iexn">Exninfo.iexn</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclORELSE t1 t2</code> is equal to <code>t1</code> if <code>t1</code> has at least one success or <code>t2 e</code> if <code>t1</code> fails with <code>e</code>. It is analogous to <code>try/with</code> handler of exception in that it is not a backtracking point. In <code>t2</code>, exception can be assumed non critical.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclIFCATCH" class="anchored"><a href="#val-tclIFCATCH" class="anchor"></a><code><span><span class="keyword">val</span> tclIFCATCH : <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-tactic">tactic</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Exninfo/index.html#type-iexn">Exninfo.iexn</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-tactic">tactic</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclIFCATCH a s f</code> is a generalisation of <a href="#val-tclORELSE"><code>tclORELSE</code></a>: if <code>a</code> succeeds at least once then it behaves as <code>tclBIND a s</code> otherwise, if <code>a</code> fails with <code>e</code>, then it behaves as <code>f e</code>. In <code>f</code> exception can be assumed non critical.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclONCE" class="anchored"><a href="#val-tclONCE" class="anchor"></a><code><span><span class="keyword">val</span> tclONCE : <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclONCE t</code> behave like <code>t</code> except it has at most one success: <code>tclONCE t</code> stops after the first success of <code>t</code>. If <code>t</code> fails with <code>e</code>, <code>tclONCE t</code> also fails with <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-MoreThanOneSuccess" class="anchored"><a href="#exception-MoreThanOneSuccess" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">MoreThanOneSuccess</span></span></code></div><div class="spec-doc"><p><code>tclEXACTLY_ONCE e t</code> succeeds as <code>t</code> if <code>t</code> has exactly one success. Otherwise it fails. The tactic <code>t</code> is run until its first success, then a failure with exception <code>e</code> is simulated (<code>e</code> has to be non critical). If <code>t</code> yields another success, then <code>tclEXACTLY_ONCE e t</code> fails with <code>MoreThanOneSuccess</code> (it is a user error). Otherwise, <code>tclEXACTLY_ONCE e t</code> succeeds with the first success of <code>t</code>. Notice that the choice of <code>e</code> is relevant, as the presence of further successes may depend on <code>e</code> (see <a href="#val-tclOR"><code>tclOR</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclEXACTLY_ONCE" class="anchored"><a href="#val-tclEXACTLY_ONCE" class="anchor"></a><code><span><span class="keyword">val</span> tclEXACTLY_ONCE : <span>exn <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-case" class="anchored"><a href="#type-case" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a case</span></span><span> = </span></code><table><tr id="type-case.Fail" class="anchored"><td class="def variant constructor"><a href="#type-case.Fail" class="anchor"></a><code><span>| </span><span><span class="constructor">Fail</span> <span class="keyword">of</span> <a href="../Exninfo/index.html#type-iexn">Exninfo.iexn</a></span></code></td></tr><tr id="type-case.Next" class="anchored"><td class="def variant constructor"><a href="#type-case.Next" class="anchor"></a><code><span>| </span><span><span class="constructor">Next</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><a href="../Exninfo/index.html#type-iexn">Exninfo.iexn</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></td></tr></table></div><div class="spec-doc"><p><code>tclCASE t</code> splits <code>t</code> into its first success and a continuation. It is the most general primitive to control backtracking.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclCASE" class="anchored"><a href="#val-tclCASE" class="anchor"></a><code><span><span class="keyword">val</span> tclCASE : <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-case">case</a></span> <a href="#type-tactic">tactic</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tclBREAK" class="anchored"><a href="#val-tclBREAK" class="anchor"></a><code><span><span class="keyword">val</span> tclBREAK : <span><span>(<span><a href="../Exninfo/index.html#type-iexn">Exninfo.iexn</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Exninfo/index.html#type-iexn">Exninfo.iexn</a> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclBREAK p t</code> is a generalization of <code>tclONCE t</code>. Instead of stopping after the first success, it succeeds like <code>t</code> until a failure with an exception <code>e</code> such that <code>p e = Some e'</code> is raised. At which point it drops the remaining successes, failing with <code>e'</code>. <code>tclONCE t</code> is equivalent to <code>tclBREAK (fun e -&gt; Some e) t</code>.</p></div></div><h6 id="focusing-tactics"><a href="#focusing-tactics" class="anchor"></a>Focusing tactics</h6><div class="odoc-spec"><div class="spec exception" id="exception-NoSuchGoals" class="anchored"><a href="#exception-NoSuchGoals" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">NoSuchGoals</span> <span class="keyword">of</span> int</span></code></div><div class="spec-doc"><p><code>tclFOCUS i j t</code> applies <code>t</code> after focusing on the goals number <code>i</code> to <code>j</code> (see <a href="#val-focus"><code>focus</code></a>). The rest of the goals is restored after the tactic action. If the specified range doesn't correspond to existing goals, fails with the <code>nosuchgoal</code> argument, by default raising <code>NoSuchGoals</code> (a user error). This exception is caught at toplevel with a default message.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclFOCUS" class="anchored"><a href="#val-tclFOCUS" class="anchor"></a><code><span><span class="keyword">val</span> tclFOCUS : <span>?nosuchgoal:<span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tclFOCUSLIST" class="anchored"><a href="#val-tclFOCUSLIST" class="anchor"></a><code><span><span class="keyword">val</span> tclFOCUSLIST : <span>?nosuchgoal:<span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(int * int)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclFOCUSLIST li t</code> applies <code>t</code> on the list of focused goals described by <code>li</code>. Each element of <code>li</code> is a pair <code>(i, j)</code> denoting the goals numbered from <code>i</code> to <code>j</code> (inclusive, starting from 1). It will try to apply <code>t</code> to all the valid goals in any of these intervals. If the set of such goals is not a single range, then it will move goals such that it is a single range. (So, for instance, <code>[1, 3-5]; idtac.</code> is not the identity.) If the set of such goals is empty, it will fail with <code>nosuchgoal</code>, by default raising <code>NoSuchGoals 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclFOCUSID" class="anchored"><a href="#val-tclFOCUSID" class="anchor"></a><code><span><span class="keyword">val</span> tclFOCUSID : <span>?nosuchgoal:<span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclFOCUSID x t</code> applies <code>t</code> on a (single) focused goal like <a href="#val-tclFOCUS"><code>tclFOCUS</code></a>. The goal is found by its name rather than its number. Fails with <code>nosuchgoal</code>, by default raising <code>NoSuchGoals 1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclTRYFOCUS" class="anchored"><a href="#val-tclTRYFOCUS" class="anchor"></a><code><span><span class="keyword">val</span> tclTRYFOCUS : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>unit <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclTRYFOCUS i j t</code> behaves like <a href="#val-tclFOCUS"><code>tclFOCUS</code></a>, except that if the specified range doesn't correspond to existing goals, behaves like <code>tclUNIT ()</code> instead of failing.</p></div></div><h6 id="dispatching-on-goals"><a href="#dispatching-on-goals" class="anchor"></a>Dispatching on goals</h6><div class="odoc-spec"><div class="spec exception" id="exception-SizeMismatch" class="anchored"><a href="#exception-SizeMismatch" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">SizeMismatch</span> <span class="keyword">of</span> int * int</span></code></div><div class="spec-doc"><p>Dispatch tacticals are used to apply a different tactic to each goal under focus. They come in two flavours: <code>tclDISPATCH</code> takes a list of <code>unit tactic</code>-s and build a <code>unit tactic</code>. <code>tclDISPATCHL</code> takes a list of <code>'a tactic</code> and returns an <code>'a list tactic</code>.</p><p>They both work by applying each of the tactic in a focus restricted to the corresponding goal (starting with the first goal). In the case of <code>tclDISPATCHL</code>, the tactic returns a list of the same size as the argument list (of tactics), each element being the result of the tactic executed in the corresponding goal.</p><p>When the length of the tactic list is not the number of goal, raises <code>SizeMismatch (g,t)</code> where <code>g</code> is the number of available goals, and <code>t</code> the number of tactics passed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclDISPATCH" class="anchored"><a href="#val-tclDISPATCH" class="anchor"></a><code><span><span class="keyword">val</span> tclDISPATCH : <span><span><span>unit <a href="#type-tactic">tactic</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-tactic">tactic</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tclDISPATCHL" class="anchored"><a href="#val-tclDISPATCHL" class="anchor"></a><code><span><span class="keyword">val</span> tclDISPATCHL : <span><span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-tactic">tactic</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tclEXTEND" class="anchored"><a href="#val-tclEXTEND" class="anchor"></a><code><span><span class="keyword">val</span> tclEXTEND : <span><span><span>unit <a href="#type-tactic">tactic</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>unit <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>unit <a href="#type-tactic">tactic</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclEXTEND b r e</code> is a variant of <a href="#val-tclDISPATCH"><code>tclDISPATCH</code></a>, where the <code>r</code> tactic is &quot;repeated&quot; enough time such that every goal has a tactic assigned to it (<code>b</code> is the list of tactics applied to the first goals, <code>e</code> to the last goals, and <code>r</code> is applied to every goal in between).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclINDEPENDENT" class="anchored"><a href="#val-tclINDEPENDENT" class="anchor"></a><code><span><span class="keyword">val</span> tclINDEPENDENT : <span><span>unit <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclINDEPENDENT tac</code> runs <code>tac</code> on each goal successively, from the first one to the last one. Backtracking in one goal is independent of backtracking in another. It is equivalent to <code>tclEXTEND [] tac []</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclINDEPENDENTL" class="anchored"><a href="#val-tclINDEPENDENTL" class="anchor"></a><code><span><span class="keyword">val</span> tclINDEPENDENTL : <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-tactic">tactic</a></span></span></code></div></div><h6 id="goal-manipulation"><a href="#goal-manipulation" class="anchor"></a>Goal manipulation</h6><div class="odoc-spec"><div class="spec value" id="val-shelve" class="anchored"><a href="#val-shelve" class="anchor"></a><code><span><span class="keyword">val</span> shelve : <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p>Shelves all the goals under focus. The goals are placed on the shelf for later use (or being solved by side-effects).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-shelve_goals" class="anchored"><a href="#val-shelve_goals" class="anchor"></a><code><span><span class="keyword">val</span> shelve_goals : <span><span><a href="../Evar/index.html#type-t">Evar.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p>Shelves the given list of goals, which might include some that are under focus and some that aren't. All the goals are placed on the shelf for later use (or being solved by side-effects).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unifiable" class="anchored"><a href="#val-unifiable" class="anchor"></a><code><span><span class="keyword">val</span> unifiable : <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evar/index.html#type-t">Evar.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Evar/index.html#type-t">Evar.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>unifiable sigma g l</code> checks whether <code>g</code> appears in another subgoal of <code>l</code>. The list <code>l</code> may contain <code>g</code>, but it does not affect the result. Used by <code>shelve_unifiable</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-shelve_unifiable" class="anchored"><a href="#val-shelve_unifiable" class="anchor"></a><code><span><span class="keyword">val</span> shelve_unifiable : <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p>Shelves the unifiable goals under focus, i.e. the goals which appear in other goals under focus (the unfocused goals are not considered).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-guard_no_unifiable" class="anchored"><a href="#val-guard_no_unifiable" class="anchor"></a><code><span><span class="keyword">val</span> guard_no_unifiable : <span><span><span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> list</span> option</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>guard_no_unifiable</code> returns the list of unifiable goals if some goals are unifiable (see <a href="#val-shelve_unifiable"><code>shelve_unifiable</code></a>) in the current focus.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unshelve" class="anchored"><a href="#val-unshelve" class="anchor"></a><code><span><span class="keyword">val</span> unshelve : <span><span><a href="../Evar/index.html#type-t">Evar.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-proofview">proofview</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-proofview">proofview</a></span></code></div><div class="spec-doc"><p><code>unshelve l p</code> moves all the goals in <code>l</code> from the shelf and put them at the end of the focused goals of p, if they are still undefined after <code>advance</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_shelf" class="anchored"><a href="#val-filter_shelf" class="anchor"></a><code><span><span class="keyword">val</span> filter_shelf : <span><span>(<span><a href="../Evar/index.html#type-t">Evar.t</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-proofview">proofview</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-proofview">proofview</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-depends_on" class="anchored"><a href="#val-depends_on" class="anchor"></a><code><span><span class="keyword">val</span> depends_on : <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evar/index.html#type-t">Evar.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evar/index.html#type-t">Evar.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>depends_on g1 g2 sigma</code> checks if g1 occurs in the type/ctx of g2</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_shelf" class="anchored"><a href="#val-with_shelf" class="anchor"></a><code><span><span class="keyword">val</span> with_shelf : <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Evar/index.html#type-t">Evar.t</a> list</span> * <span class="type-var">'a</span>)</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>with_shelf tac</code> executes <code>tac</code> and returns its result together with the set of goals shelved by <code>tac</code>. The current shelf is unchanged and the returned list contains only unsolved goals.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cycle" class="anchored"><a href="#val-cycle" class="anchor"></a><code><span><span class="keyword">val</span> cycle : <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p>If <code>n</code> is positive, <code>cycle n</code> puts the <code>n</code> first goal last. If <code>n</code> is negative, then it puts the <code>n</code> last goals first.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-swap" class="anchored"><a href="#val-swap" class="anchor"></a><code><span><span class="keyword">val</span> swap : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>swap i j</code> swaps the position of goals number <code>i</code> and <code>j</code> (negative numbers can be used to address goals from the end. Goals are indexed from <code>1</code>. For simplicity index <code>0</code> corresponds to goal <code>1</code> as well, rather than raising an error.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-revgoals" class="anchored"><a href="#val-revgoals" class="anchor"></a><code><span><span class="keyword">val</span> revgoals : <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>revgoals</code> reverses the list of focused goals.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-numgoals" class="anchored"><a href="#val-numgoals" class="anchor"></a><code><span><span class="keyword">val</span> numgoals : <span>int <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>numgoals</code> returns the number of goals under focus.</p></div></div><h6 id="access-primitives"><a href="#access-primitives" class="anchor"></a>Access primitives</h6><div class="odoc-spec"><div class="spec value" id="val-tclEVARMAP" class="anchored"><a href="#val-tclEVARMAP" class="anchor"></a><code><span><span class="keyword">val</span> tclEVARMAP : <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclEVARMAP</code> doesn't affect the proof, it returns the current <code>evar_map</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclENV" class="anchored"><a href="#val-tclENV" class="anchor"></a><code><span><span class="keyword">val</span> tclENV : <span><a href="../Environ/index.html#type-env">Environ.env</a> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclENV</code> doesn't affect the proof, it returns the current environment. It is not the environment of a particular goal, rather the &quot;global&quot; environment of the proof. The goal-wise environment is obtained via <a href="Goal/index.html#val-env"><code>Proofview.Goal.env</code></a>.</p></div></div><h6 id="put-like-primitives"><a href="#put-like-primitives" class="anchor"></a>Put-like primitives</h6><div class="odoc-spec"><div class="spec value" id="val-tclEFFECTS" class="anchored"><a href="#val-tclEFFECTS" class="anchor"></a><code><span><span class="keyword">val</span> tclEFFECTS : <span><a href="../Evd/index.html#type-side_effects">Evd.side_effects</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclEFFECTS eff</code> add the effects <code>eff</code> to the current state.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mark_as_unsafe" class="anchored"><a href="#val-mark_as_unsafe" class="anchor"></a><code><span><span class="keyword">val</span> mark_as_unsafe : <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>mark_as_unsafe</code> declares the current tactic is unsafe.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-give_up" class="anchored"><a href="#val-give_up" class="anchor"></a><code><span><span class="keyword">val</span> give_up : <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p>Gives up on the goal under focus. Reports an unsafe status. Proofs with given up goals cannot be closed.</p></div></div><h6 id="control-primitives"><a href="#control-primitives" class="anchor"></a>Control primitives</h6><div class="odoc-spec"><div class="spec value" id="val-tclPROGRESS" class="anchored"><a href="#val-tclPROGRESS" class="anchor"></a><code><span><span class="keyword">val</span> tclPROGRESS : <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclPROGRESS t</code> checks the state of the proof after <code>t</code>. It it is identical to the state before, then <code>tclPROGRESS t</code> fails, otherwise it succeeds like <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Progress" class="anchored"><a href="#module-Progress" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Progress/index.html">Progress</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tclCHECKINTERRUPT" class="anchored"><a href="#val-tclCHECKINTERRUPT" class="anchor"></a><code><span><span class="keyword">val</span> tclCHECKINTERRUPT : <span>unit <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p>Checks for interrupts</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclTIMEOUTF" class="anchored"><a href="#val-tclTIMEOUTF" class="anchor"></a><code><span><span class="keyword">val</span> tclTIMEOUTF : <span>float <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclTIMEOUT n t</code> can have only one success. In case of timeout it fails with <code>tclZERO Tac_Timeout</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclTIMEOUT" class="anchored"><a href="#val-tclTIMEOUT" class="anchor"></a><code><span><span class="keyword">val</span> tclTIMEOUT : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tclTIME" class="anchored"><a href="#val-tclTIME" class="anchor"></a><code><span><span class="keyword">val</span> tclTIME : <span><span>string option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclTIME s t</code> displays time for each atomic call to t, using s as an identifying annotation if present</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclProofInfo" class="anchored"><a href="#val-tclProofInfo" class="anchor"></a><code><span><span class="keyword">val</span> tclProofInfo : <span><span>(<a href="../Names/Id/index.html#type-t">Names.Id.t</a> * bool)</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p>Internal, don't use.</p></div></div><h6 id="unsafe-primitives"><a href="#unsafe-primitives" class="anchor"></a>Unsafe primitives</h6><div class="odoc-spec"><div class="spec module" id="module-Unsafe" class="anchored"><a href="#module-Unsafe" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Unsafe/index.html">Unsafe</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The primitives in the <code>Unsafe</code> module should be avoided as much as possible, since they can make the proof state inconsistent. They are nevertheless helpful, in particular when interfacing the pretyping and the proof engine.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-UnsafeRepr" class="anchored"><a href="#module-UnsafeRepr" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="UnsafeRepr/index.html">UnsafeRepr</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This module gives access to the innards of the monad. Its use is restricted to very specific cases.</p></div></div><h6 id="goal-dependent-tactics"><a href="#goal-dependent-tactics" class="anchor"></a>Goal-dependent tactics</h6><div class="odoc-spec"><div class="spec module" id="module-Goal" class="anchored"><a href="#module-Goal" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Goal/index.html">Goal</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h6 id="trace"><a href="#trace" class="anchor"></a>Trace</h6><div class="odoc-spec"><div class="spec module" id="module-Trace" class="anchored"><a href="#module-Trace" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Trace/index.html">Trace</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h6 id="non-logical-state"><a href="#non-logical-state" class="anchor"></a>Non-logical state</h6><div class="odoc-spec"><div class="spec module" id="module-NonLogical" class="anchored"><a href="#module-NonLogical" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="NonLogical/index.html">NonLogical</a></span><span> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../Logic_monad/NonLogical/index.html">Logic_monad.NonLogical</a></span></code></div><div class="spec-doc"><p>The <code>NonLogical</code> module allows the execution of effects (including I/O) in tactics (non-logical side-effects are not discarded at failures).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tclLIFT" class="anchored"><a href="#val-tclLIFT" class="anchor"></a><code><span><span class="keyword">val</span> tclLIFT : <span><span><span class="type-var">'a</span> <a href="NonLogical/index.html#type-t">NonLogical.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div><div class="spec-doc"><p><code>tclLIFT c</code> is a tactic which behaves exactly as <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-wrap_exceptions" class="anchored"><a href="#val-wrap_exceptions" class="anchor"></a><code><span><span class="keyword">val</span> wrap_exceptions : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-tactic">tactic</a></span></span></code></div></div></div></body></html>