<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Constr (coq-core.Constr)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">coq-core</a> &#x00BB; Constr</nav><header class="odoc-preamble"><h1>Module <code><span>Constr</span></code></h1><p>This file defines the most important datatype of Coq, namely kernel terms, as well as a handful of generic manipulation functions.</p></header><nav class="odoc-toc"><ul><li><a href="#the-type-of-constructions">The type of constructions</a></li><li><a href="#functions-for-dealing-with-constr-terms.">Functions for dealing with constr terms.</a></li><li><a href="#term-constructors.">Term constructors.</a></li><li><a href="#concrete-type-for-making-pattern-matching.">Concrete type for making pattern-matching.</a></li><li><a href="#term-destructors">Term destructors</a></li><li><a href="#equality">Equality</a></li><li><a href="#extension-of-context-with-declarations-on-constr">Extension of Context with declarations on constr</a></li><li><a href="#relocation-and-substitution">Relocation and substitution</a></li><li><a href="#functionals-working-on-expressions-canonically-abstracted-over-a-local-context-(possibly-with-let-ins)">Functionals working on expressions canonically abstracted over a local context (possibly with let-ins)</a></li><li><a href="#functionals-working-on-the-immediate-subterm-of-a-construction">Functionals working on the immediate subterm of a construction</a></li><li><a href="#hashconsing">Hashconsing</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-pconstant" class="anchored"><a href="#type-pconstant" class="anchor"></a><code><span><span class="keyword">type</span> pconstant</span><span> = <span><a href="../Names/Constant/index.html#type-t">Names.Constant.t</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span></span></code></div><div class="spec-doc"><p>Simply type aliases</p></div></div><div class="odoc-spec"><div class="spec type" id="type-pinductive" class="anchored"><a href="#type-pinductive" class="anchor"></a><code><span><span class="keyword">type</span> pinductive</span><span> = <span><a href="../Names/index.html#type-inductive">Names.inductive</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-pconstructor" class="anchored"><a href="#type-pconstructor" class="anchor"></a><code><span><span class="keyword">type</span> pconstructor</span><span> = <span><a href="../Names/index.html#type-constructor">Names.constructor</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-metavariable" class="anchored"><a href="#type-metavariable" class="anchor"></a><code><span><span class="keyword">type</span> metavariable</span><span> = int</span></code></div><div class="spec-doc"><p>Existential variables</p></div></div><div class="odoc-spec"><div class="spec type" id="type-case_style" class="anchored"><a href="#type-case_style" class="anchor"></a><code><span><span class="keyword">type</span> case_style</span><span> = </span></code><table><tr id="type-case_style.LetStyle" class="anchored"><td class="def variant constructor"><a href="#type-case_style.LetStyle" class="anchor"></a><code><span>| </span><span><span class="constructor">LetStyle</span></span></code></td></tr><tr id="type-case_style.IfStyle" class="anchored"><td class="def variant constructor"><a href="#type-case_style.IfStyle" class="anchor"></a><code><span>| </span><span><span class="constructor">IfStyle</span></span></code></td></tr><tr id="type-case_style.LetPatternStyle" class="anchored"><td class="def variant constructor"><a href="#type-case_style.LetPatternStyle" class="anchor"></a><code><span>| </span><span><span class="constructor">LetPatternStyle</span></span></code></td></tr><tr id="type-case_style.MatchStyle" class="anchored"><td class="def variant constructor"><a href="#type-case_style.MatchStyle" class="anchor"></a><code><span>| </span><span><span class="constructor">MatchStyle</span></span></code></td></tr><tr id="type-case_style.RegularStyle" class="anchored"><td class="def variant constructor"><a href="#type-case_style.RegularStyle" class="anchor"></a><code><span>| </span><span><span class="constructor">RegularStyle</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>infer printing form from number of constructor</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Case annotation</p></div></div><div class="odoc-spec"><div class="spec type" id="type-case_printing" class="anchored"><a href="#type-case_printing" class="anchor"></a><code><span><span class="keyword">type</span> case_printing</span><span> = </span><span>{</span></code><table><tr id="type-case_printing.ind_tags" class="anchored"><td class="def record field"><a href="#type-case_printing.ind_tags" class="anchor"></a><code><span>ind_tags : <span>bool list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>tell whether letin or lambda in the arity of the inductive type</p><span class="comment-delim">*)</span></td></tr><tr id="type-case_printing.cstr_tags" class="anchored"><td class="def record field"><a href="#type-case_printing.cstr_tags" class="anchor"></a><code><span>cstr_tags : <span><span>bool list</span> array</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>tell whether letin or lambda in the signature of each constructor</p><span class="comment-delim">*)</span></td></tr><tr id="type-case_printing.style" class="anchored"><td class="def record field"><a href="#type-case_printing.style" class="anchor"></a><code><span>style : <a href="#type-case_style">case_style</a>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-case_info" class="anchored"><a href="#type-case_info" class="anchor"></a><code><span><span class="keyword">type</span> case_info</span><span> = </span><span>{</span></code><table><tr id="type-case_info.ci_ind" class="anchored"><td class="def record field"><a href="#type-case_info.ci_ind" class="anchor"></a><code><span>ci_ind : <a href="../Names/index.html#type-inductive">Names.inductive</a>;</span></code></td></tr><tr id="type-case_info.ci_npar" class="anchored"><td class="def record field"><a href="#type-case_info.ci_npar" class="anchor"></a><code><span>ci_npar : int;</span></code></td></tr><tr id="type-case_info.ci_cstr_ndecls" class="anchored"><td class="def record field"><a href="#type-case_info.ci_cstr_ndecls" class="anchor"></a><code><span>ci_cstr_ndecls : <span>int array</span>;</span></code></td></tr><tr id="type-case_info.ci_cstr_nargs" class="anchored"><td class="def record field"><a href="#type-case_info.ci_cstr_nargs" class="anchor"></a><code><span>ci_cstr_nargs : <span>int array</span>;</span></code></td></tr><tr id="type-case_info.ci_pp_info" class="anchored"><td class="def record field"><a href="#type-case_info.ci_pp_info" class="anchor"></a><code><span>ci_pp_info : <a href="#type-case_printing">case_printing</a>;</span></code></td></tr></table><code><span>}</span></code></div></div><h6 id="the-type-of-constructions"><a href="#the-type-of-constructions" class="anchor"></a>The type of constructions</h6><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-constr" class="anchored"><a href="#type-constr" class="anchor"></a><code><span><span class="keyword">type</span> constr</span><span> = <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>types</code> is the same as <code>constr</code> but is intended to be used for documentation to indicate that such or such function specifically works with <em>types</em> (i.e. terms of type a sort). (Rem:plurial form since <code>type</code> is a reserved ML keyword)</p></div></div><div class="odoc-spec"><div class="spec type" id="type-types" class="anchored"><a href="#type-types" class="anchor"></a><code><span><span class="keyword">type</span> types</span><span> = <a href="#type-constr">constr</a></span></code></div></div><h6 id="functions-for-dealing-with-constr-terms."><a href="#functions-for-dealing-with-constr-terms." class="anchor"></a>Functions for dealing with constr terms.</h6><p>The following functions are intended to simplify and to uniform the manipulation of terms. Some of these functions may be overlapped with previous ones.</p><h6 id="term-constructors."><a href="#term-constructors." class="anchor"></a>Term constructors.</h6><div class="odoc-spec"><div class="spec value" id="val-mkRel" class="anchored"><a href="#val-mkRel" class="anchor"></a><code><span><span class="keyword">val</span> mkRel : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs a de Bruijn index (DB indices begin at 1)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkVar" class="anchored"><a href="#val-mkVar" class="anchor"></a><code><span><span class="keyword">val</span> mkVar : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs a Variable</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkInt" class="anchored"><a href="#val-mkInt" class="anchor"></a><code><span><span class="keyword">val</span> mkInt : <span><a href="../Uint63/index.html#type-t">Uint63.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs a machine integer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkArray" class="anchored"><a href="#val-mkArray" class="anchor"></a><code><span><span class="keyword">val</span> mkArray : <span><span>(<a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a> * <span><a href="#type-constr">constr</a> array</span> * <a href="#type-constr">constr</a> * <a href="#type-types">types</a>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs an array</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkFloat" class="anchored"><a href="#val-mkFloat" class="anchor"></a><code><span><span class="keyword">val</span> mkFloat : <span><a href="../Float64/index.html#type-t">Float64.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs a machine float number</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkMeta" class="anchored"><a href="#val-mkMeta" class="anchor"></a><code><span><span class="keyword">val</span> mkMeta : <span><a href="#type-metavariable">metavariable</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs an patvar named &quot;?n&quot;</p></div></div><div class="odoc-spec"><div class="spec type" id="type-existential" class="anchored"><a href="#type-existential" class="anchor"></a><code><span><span class="keyword">type</span> existential</span><span> = <a href="../Evar/index.html#type-t">Evar.t</a> * <span><a href="#type-constr">constr</a> <a href="../SList/index.html#type-t">SList.t</a></span></span></code></div><div class="spec-doc"><p>Constructs an existential variable</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkEvar" class="anchored"><a href="#val-mkEvar" class="anchor"></a><code><span><span class="keyword">val</span> mkEvar : <span><a href="#type-existential">existential</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkSort" class="anchored"><a href="#val-mkSort" class="anchor"></a><code><span><span class="keyword">val</span> mkSort : <span><a href="../Sorts/index.html#type-t">Sorts.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-types">types</a></span></code></div><div class="spec-doc"><p>Construct a sort</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkSProp" class="anchored"><a href="#val-mkSProp" class="anchor"></a><code><span><span class="keyword">val</span> mkSProp : <a href="#type-types">types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkProp" class="anchored"><a href="#val-mkProp" class="anchor"></a><code><span><span class="keyword">val</span> mkProp : <a href="#type-types">types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkSet" class="anchored"><a href="#val-mkSet" class="anchor"></a><code><span><span class="keyword">val</span> mkSet : <a href="#type-types">types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkType" class="anchored"><a href="#val-mkType" class="anchor"></a><code><span><span class="keyword">val</span> mkType : <span><a href="../Univ/Universe/index.html#type-t">Univ.Universe.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-types">types</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-cast_kind" class="anchored"><a href="#type-cast_kind" class="anchor"></a><code><span><span class="keyword">type</span> cast_kind</span><span> = </span></code><table><tr id="type-cast_kind.VMcast" class="anchored"><td class="def variant constructor"><a href="#type-cast_kind.VMcast" class="anchor"></a><code><span>| </span><span><span class="constructor">VMcast</span></span></code></td></tr><tr id="type-cast_kind.NATIVEcast" class="anchored"><td class="def variant constructor"><a href="#type-cast_kind.NATIVEcast" class="anchor"></a><code><span>| </span><span><span class="constructor">NATIVEcast</span></span></code></td></tr><tr id="type-cast_kind.DEFAULTcast" class="anchored"><td class="def variant constructor"><a href="#type-cast_kind.DEFAULTcast" class="anchor"></a><code><span>| </span><span><span class="constructor">DEFAULTcast</span></span></code></td></tr></table></div><div class="spec-doc"><p>This defines the strategy to use for verifiying a Cast</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkCast" class="anchored"><a href="#val-mkCast" class="anchor"></a><code><span><span class="keyword">val</span> mkCast : <span><span>(<a href="#type-constr">constr</a> * <a href="#type-cast_kind">cast_kind</a> * <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs the term <code>t1::t2</code>, i.e. the term t<sub>1</sub> casted with the type t<sub>2</sub> (that means t2 is declared as the type of t1).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkProd" class="anchored"><a href="#val-mkProd" class="anchor"></a><code><span><span class="keyword">val</span> mkProd : <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="#type-types">types</a> * <a href="#type-types">types</a>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-types">types</a></span></code></div><div class="spec-doc"><p>Constructs the product <code>(x:t1)t2</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkLambda" class="anchored"><a href="#val-mkLambda" class="anchor"></a><code><span><span class="keyword">val</span> mkLambda : <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="#type-types">types</a> * <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs the abstraction [x:t<sub>1</sub>]t<sub>2</sub></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkLetIn" class="anchored"><a href="#val-mkLetIn" class="anchor"></a><code><span><span class="keyword">val</span> mkLetIn : <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="#type-constr">constr</a> * <a href="#type-types">types</a> * <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs the product <code>let x = t1 : t2 in t3</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkApp" class="anchored"><a href="#val-mkApp" class="anchor"></a><code><span><span class="keyword">val</span> mkApp : <span><span>(<a href="#type-constr">constr</a> * <span><a href="#type-constr">constr</a> array</span>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p><code>mkApp (f, [|t1; ...; tN|]</code> constructs the application (f t<sub>1</sub> ... t<sub>n</sub>) .</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_puniverses" class="anchored"><a href="#val-map_puniverses" class="anchor"></a><code><span><span class="keyword">val</span> map_puniverses : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkConstU" class="anchored"><a href="#val-mkConstU" class="anchor"></a><code><span><span class="keyword">val</span> mkConstU : <span><a href="#type-pconstant">pconstant</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs a Constant.t</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkProj" class="anchored"><a href="#val-mkProj" class="anchor"></a><code><span><span class="keyword">val</span> mkProj : <span><span>(<a href="../Names/Projection/index.html#type-t">Names.Projection.t</a> * <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a> * <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs a projection application</p></div></div><p>Inductive types</p><div class="odoc-spec"><div class="spec value" id="val-mkIndU" class="anchored"><a href="#val-mkIndU" class="anchor"></a><code><span><span class="keyword">val</span> mkIndU : <span><a href="#type-pinductive">pinductive</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs the ith (co)inductive type of the block named kn</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkConstructU" class="anchored"><a href="#val-mkConstructU" class="anchor"></a><code><span><span class="keyword">val</span> mkConstructU : <span><a href="#type-pconstructor">pconstructor</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Constructs the jth constructor of the ith (co)inductive type of the block named kn.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkConstructUi" class="anchored"><a href="#val-mkConstructUi" class="anchor"></a><code><span><span class="keyword">val</span> mkConstructUi : <span><span>(<a href="#type-pinductive">pinductive</a> * int)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkRef" class="anchored"><a href="#val-mkRef" class="anchor"></a><code><span><span class="keyword">val</span> mkRef : <span><span><a href="../Names/GlobRef/index.html#type-t">Names.GlobRef.t</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Make a constant, inductive, constructor or variable.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-UnsafeMonomorphic" class="anchored"><a href="#module-UnsafeMonomorphic" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="UnsafeMonomorphic/index.html">UnsafeMonomorphic</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Constructs a destructor of inductive type.</p><p><code>mkCase ci params p c ac</code> stand for match <code>c</code> as <code>x</code> in <code>I args</code> return <code>p</code> with <code>ac</code> presented as describe in <code>ci</code>.</p><p><code>p</code> structure is <code>args x |- &quot;return clause&quot;</code></p><p><code>ac</code><sup>ith</sup> element is ith constructor case presented as <em>construct_args |- case_term</em></p><div class="odoc-spec"><div class="spec type" id="type-pcase_branch" class="anchored"><a href="#type-pcase_branch" class="anchor"></a><code><span><span class="keyword">type</span> <span>'constr pcase_branch</span></span><span> = <span><span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> array</span> * <span class="type-var">'constr</span></span></code></div><div class="spec-doc"><p>Names bound by matching the constructor for this branch.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-pcase_return" class="anchored"><a href="#type-pcase_return" class="anchor"></a><code><span><span class="keyword">type</span> <span>'types pcase_return</span></span><span> = <span>(<span><span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> array</span> * <span class="type-var">'types</span>)</span> * <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a></span></code></div><div class="spec-doc"><p>Names of the indices + name of self</p></div></div><div class="odoc-spec"><div class="spec type" id="type-pcase_invert" class="anchored"><a href="#type-pcase_invert" class="anchor"></a><code><span><span class="keyword">type</span> <span>'constr pcase_invert</span></span><span> = </span></code><table><tr id="type-pcase_invert.NoInvert" class="anchored"><td class="def variant constructor"><a href="#type-pcase_invert.NoInvert" class="anchor"></a><code><span>| </span><span><span class="constructor">NoInvert</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Normal reduction: match when the scrutinee is a constructor.</p><span class="comment-delim">*)</span></td></tr><tr id="type-pcase_invert.CaseInvert" class="anchored"><td class="def variant constructor"><a href="#type-pcase_invert.CaseInvert" class="anchor"></a><code><span>| </span><span><span class="constructor">CaseInvert</span> <span class="keyword">of</span> </span><span>{</span></code><table><tr id="type-pcase_invert.indices" class="anchored"><td class="def record field"><a href="#type-pcase_invert.indices" class="anchor"></a><code><span>indices : <span><span class="type-var">'constr</span> array</span>;</span></code></td></tr></table><code><span>}</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Reduce when the indices match those of the unique constructor. (SProp to non SProp only)</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-pcase" class="anchored"><a href="#type-pcase" class="anchor"></a><code><span><span class="keyword">type</span> <span>('constr, 'types, 'univs) pcase</span></span><span> = <a href="#type-case_info">case_info</a> * <span class="type-var">'univs</span> * <span><span class="type-var">'constr</span> array</span> * <span><span class="type-var">'types</span> <a href="#type-pcase_return">pcase_return</a></span> * <span><span class="type-var">'constr</span> <a href="#type-pcase_invert">pcase_invert</a></span> * <span class="type-var">'constr</span> * <span><span><span class="type-var">'constr</span> <a href="#type-pcase_branch">pcase_branch</a></span> array</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-case_invert" class="anchored"><a href="#type-case_invert" class="anchor"></a><code><span><span class="keyword">type</span> case_invert</span><span> = <span><a href="#type-constr">constr</a> <a href="#type-pcase_invert">pcase_invert</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-case_return" class="anchored"><a href="#type-case_return" class="anchor"></a><code><span><span class="keyword">type</span> case_return</span><span> = <span><a href="#type-types">types</a> <a href="#type-pcase_return">pcase_return</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-case_branch" class="anchored"><a href="#type-case_branch" class="anchor"></a><code><span><span class="keyword">type</span> case_branch</span><span> = <span><a href="#type-constr">constr</a> <a href="#type-pcase_branch">pcase_branch</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-case" class="anchored"><a href="#type-case" class="anchor"></a><code><span><span class="keyword">type</span> case</span><span> = <span><span>(<a href="#type-constr">constr</a>, <a href="#type-types">types</a>, <a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a>)</span> <a href="#type-pcase">pcase</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkCase" class="anchored"><a href="#val-mkCase" class="anchor"></a><code><span><span class="keyword">val</span> mkCase : <span><a href="#type-case">case</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-prec_declaration" class="anchored"><a href="#type-prec_declaration" class="anchor"></a><code><span><span class="keyword">type</span> <span>('constr, 'types) prec_declaration</span></span><span> = <span><span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> array</span> * <span><span class="type-var">'types</span> array</span> * <span><span class="type-var">'constr</span> array</span></span></code></div><div class="spec-doc"><p>If <code>recindxs = [|i1,...in|]</code> <code>funnames = [|f1,.....fn|]</code> <code>typarray = [|t1,...tn|]</code> <code>bodies   = [|b1,.....bn|]</code> then <code>mkFix ((recindxs,i), funnames, typarray, bodies) </code> constructs the <code> $ </code>i<code> $ </code>th function of the block (counting from 0)</p><p><code>Fixpoint f1 [ctx1] = b1
     with     f2 [ctx2] = b2
     ...
     with     fn [ctxn] = bn.</code></p><p>where the length of the <code> $ </code>j<code> $ </code>th context is <code> $ </code>ij<code> $ </code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-pfixpoint" class="anchored"><a href="#type-pfixpoint" class="anchor"></a><code><span><span class="keyword">type</span> <span>('constr, 'types) pfixpoint</span></span><span> = <span>(<span>int array</span> * int)</span> * <span><span>(<span class="type-var">'constr</span>, <span class="type-var">'types</span>)</span> <a href="#type-prec_declaration">prec_declaration</a></span></span></code></div><div class="spec-doc"><p>The array of <code>int</code>'s tells for each component of the array of mutual fixpoints the number of lambdas to skip before finding the recursive argument (e.g., value is 2 in &quot;fix f (x:A) (y:=t) (z:B) (v:=u) (w:I) <code>struct w</code>&quot;), telling to skip x and z and that w is the recursive argument); The second component <code>int</code> tells which component of the block is returned</p></div></div><div class="odoc-spec"><div class="spec type" id="type-pcofixpoint" class="anchored"><a href="#type-pcofixpoint" class="anchor"></a><code><span><span class="keyword">type</span> <span>('constr, 'types) pcofixpoint</span></span><span> = int * <span><span>(<span class="type-var">'constr</span>, <span class="type-var">'types</span>)</span> <a href="#type-prec_declaration">prec_declaration</a></span></span></code></div><div class="spec-doc"><p>The component <code>int</code> tells which component of the block of cofixpoint is returned</p></div></div><div class="odoc-spec"><div class="spec type" id="type-rec_declaration" class="anchored"><a href="#type-rec_declaration" class="anchor"></a><code><span><span class="keyword">type</span> rec_declaration</span><span> = <span><span>(<a href="#type-constr">constr</a>, <a href="#type-types">types</a>)</span> <a href="#type-prec_declaration">prec_declaration</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-fixpoint" class="anchored"><a href="#type-fixpoint" class="anchor"></a><code><span><span class="keyword">type</span> fixpoint</span><span> = <span><span>(<a href="#type-constr">constr</a>, <a href="#type-types">types</a>)</span> <a href="#type-pfixpoint">pfixpoint</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkFix" class="anchored"><a href="#val-mkFix" class="anchor"></a><code><span><span class="keyword">val</span> mkFix : <span><a href="#type-fixpoint">fixpoint</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-cofixpoint" class="anchored"><a href="#type-cofixpoint" class="anchor"></a><code><span><span class="keyword">type</span> cofixpoint</span><span> = <span><span>(<a href="#type-constr">constr</a>, <a href="#type-types">types</a>)</span> <a href="#type-pcofixpoint">pcofixpoint</a></span></span></code></div><div class="spec-doc"><p>If <code>funnames = [|f1,.....fn|]</code> <code>typarray = [|t1,...tn|]</code> <code>bodies   = [b1,.....bn]</code> then <code>mkCoFix (i, (funnames, typarray, bodies))</code> constructs the ith function of the block</p><p><code>CoFixpoint f1 = b1
     with       f2 = b2
     ...
     with       fn = bn.</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkCoFix" class="anchored"><a href="#val-mkCoFix" class="anchor"></a><code><span><span class="keyword">val</span> mkCoFix : <span><a href="#type-cofixpoint">cofixpoint</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><h6 id="concrete-type-for-making-pattern-matching."><a href="#concrete-type-for-making-pattern-matching." class="anchor"></a>Concrete type for making pattern-matching.</h6><div class="odoc-spec"><div class="spec type" id="type-pexistential" class="anchored"><a href="#type-pexistential" class="anchor"></a><code><span><span class="keyword">type</span> <span>'constr pexistential</span></span><span> = <a href="../Evar/index.html#type-t">Evar.t</a> * <span><span class="type-var">'constr</span> <a href="../SList/index.html#type-t">SList.t</a></span></span></code></div><div class="spec-doc"><p><code>constr list</code> is an instance matching definitional <code>named_context</code> in the same order (i.e. last argument first)</p></div></div><div class="odoc-spec"><div class="spec type" id="type-kind_of_term" class="anchored"><a href="#type-kind_of_term" class="anchor"></a><code><span><span class="keyword">type</span> <span>('constr, 'types, 'sort, 'univs) kind_of_term</span></span><span> = </span></code><table><tr id="type-kind_of_term.Rel" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Rel" class="anchor"></a><code><span>| </span><span><span class="constructor">Rel</span> <span class="keyword">of</span> int</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Gallina-variable introduced by <code>forall</code>, <code>fun</code>, <code>let-in</code>, <code>fix</code>, or <code>cofix</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.Var" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Var" class="anchor"></a><code><span>| </span><span><span class="constructor">Var</span> <span class="keyword">of</span> <a href="../Names/Id/index.html#type-t">Names.Id.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Gallina-variable that was introduced by Vernacular-command that extends the local context of the currently open section (i.e. <code>Variable</code> or <code>Let</code>).</p><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.Meta" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Meta" class="anchor"></a><code><span>| </span><span><span class="constructor">Meta</span> <span class="keyword">of</span> <a href="#type-metavariable">metavariable</a></span></code></td></tr><tr id="type-kind_of_term.Evar" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Evar" class="anchor"></a><code><span>| </span><span><span class="constructor">Evar</span> <span class="keyword">of</span> <span><span class="type-var">'constr</span> <a href="#type-pexistential">pexistential</a></span></span></code></td></tr><tr id="type-kind_of_term.Sort" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Sort" class="anchor"></a><code><span>| </span><span><span class="constructor">Sort</span> <span class="keyword">of</span> <span class="type-var">'sort</span></span></code></td></tr><tr id="type-kind_of_term.Cast" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Cast" class="anchor"></a><code><span>| </span><span><span class="constructor">Cast</span> <span class="keyword">of</span> <span class="type-var">'constr</span> * <a href="#type-cast_kind">cast_kind</a> * <span class="type-var">'types</span></span></code></td></tr><tr id="type-kind_of_term.Prod" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Prod" class="anchor"></a><code><span>| </span><span><span class="constructor">Prod</span> <span class="keyword">of</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <span class="type-var">'types</span> * <span class="type-var">'types</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Concrete syntax <code>&quot;forall A:B,C&quot;</code> is represented as <code>Prod (A,B,C)</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.Lambda" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Lambda" class="anchor"></a><code><span>| </span><span><span class="constructor">Lambda</span> <span class="keyword">of</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <span class="type-var">'types</span> * <span class="type-var">'constr</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Concrete syntax <code>&quot;fun A:B =&gt; C&quot;</code> is represented as <code>Lambda (A,B,C)</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.LetIn" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.LetIn" class="anchor"></a><code><span>| </span><span><span class="constructor">LetIn</span> <span class="keyword">of</span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <span class="type-var">'constr</span> * <span class="type-var">'types</span> * <span class="type-var">'constr</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Concrete syntax <code>&quot;let A:C := B in D&quot;</code> is represented as <code>LetIn (A,B,C,D)</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.App" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.App" class="anchor"></a><code><span>| </span><span><span class="constructor">App</span> <span class="keyword">of</span> <span class="type-var">'constr</span> * <span><span class="type-var">'constr</span> array</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Concrete syntax <code>&quot;(F P1 P2 ...  Pn)&quot;</code> is represented as <code>App (F, [|P1; P2; ...; Pn|])</code>. The <a href="#val-mkApp"><code>mkApp</code></a> constructor also enforces the following invariant:</p><ul><li><code>F</code> itself is not <a href="#type-kind_of_term.App"><code>App</code></a></li><li>and <code>[|P1;..;Pn|]</code> is not empty.</li></ul><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.Const" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Const" class="anchor"></a><code><span>| </span><span><span class="constructor">Const</span> <span class="keyword">of</span> <a href="../Names/Constant/index.html#type-t">Names.Constant.t</a> * <span class="type-var">'univs</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Gallina-variable that was introduced by Vernacular-command that extends the global environment (i.e. <code>Parameter</code>, or <code>Axiom</code>, or <code>Definition</code>, or <code>Theorem</code> etc.)</p><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.Ind" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Ind" class="anchor"></a><code><span>| </span><span><span class="constructor">Ind</span> <span class="keyword">of</span> <a href="../Names/index.html#type-inductive">Names.inductive</a> * <span class="type-var">'univs</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A name of an inductive type defined by <code>Variant</code>, <code>Inductive</code> or <code>Record</code> Vernacular-commands.</p><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.Construct" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Construct" class="anchor"></a><code><span>| </span><span><span class="constructor">Construct</span> <span class="keyword">of</span> <a href="../Names/index.html#type-constructor">Names.constructor</a> * <span class="type-var">'univs</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A constructor of an inductive type defined by <code>Variant</code>, <code>Inductive</code> or <code>Record</code> Vernacular-commands.</p><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.Case" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Case" class="anchor"></a><code><span>| </span><span><span class="constructor">Case</span> <span class="keyword">of</span> <a href="#type-case_info">case_info</a> * <span class="type-var">'univs</span> * <span><span class="type-var">'constr</span> array</span> * <span><span class="type-var">'types</span> <a href="#type-pcase_return">pcase_return</a></span> * <span><span class="type-var">'constr</span> <a href="#type-pcase_invert">pcase_invert</a></span> * <span class="type-var">'constr</span> * <span><span><span class="type-var">'constr</span> <a href="#type-pcase_branch">pcase_branch</a></span> array</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>Case (ci,u,params,p,iv,c,brs)</code> is a <code>match c return p with brs</code> expression. <code>c</code> lives in inductive <code>ci.ci_ind</code> at universe instance <code>u</code> and parameters <code>params</code>. If this match has case inversion (ie match on a 1 constructor SProp inductive with proof relevant return type) the indices are in <code>iv</code>.</p><p>The names in <code>p</code> are the names of the bound indices and inductive value (ie the <code>in</code> and <code>as</code> clauses).</p><p>The names in the <code>brs</code> are the names of the variables bound in the respective branch.</p><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.Fix" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Fix" class="anchor"></a><code><span>| </span><span><span class="constructor">Fix</span> <span class="keyword">of</span> <span><span>(<span class="type-var">'constr</span>, <span class="type-var">'types</span>)</span> <a href="#type-pfixpoint">pfixpoint</a></span></span></code></td></tr><tr id="type-kind_of_term.CoFix" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.CoFix" class="anchor"></a><code><span>| </span><span><span class="constructor">CoFix</span> <span class="keyword">of</span> <span><span>(<span class="type-var">'constr</span>, <span class="type-var">'types</span>)</span> <a href="#type-pcofixpoint">pcofixpoint</a></span></span></code></td></tr><tr id="type-kind_of_term.Proj" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Proj" class="anchor"></a><code><span>| </span><span><span class="constructor">Proj</span> <span class="keyword">of</span> <a href="../Names/Projection/index.html#type-t">Names.Projection.t</a> * <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a> * <span class="type-var">'constr</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The relevance is the relevance of the whole term</p><span class="comment-delim">*)</span></td></tr><tr id="type-kind_of_term.Int" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Int" class="anchor"></a><code><span>| </span><span><span class="constructor">Int</span> <span class="keyword">of</span> <a href="../Uint63/index.html#type-t">Uint63.t</a></span></code></td></tr><tr id="type-kind_of_term.Float" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Float" class="anchor"></a><code><span>| </span><span><span class="constructor">Float</span> <span class="keyword">of</span> <a href="../Float64/index.html#type-t">Float64.t</a></span></code></td></tr><tr id="type-kind_of_term.Array" class="anchored"><td class="def variant constructor"><a href="#type-kind_of_term.Array" class="anchor"></a><code><span>| </span><span><span class="constructor">Array</span> <span class="keyword">of</span> <span class="type-var">'univs</span> * <span><span class="type-var">'constr</span> array</span> * <span class="type-var">'constr</span> * <span class="type-var">'types</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>Array (u,vals,def,t)</code> is an array of <code>vals</code> in type <code>t</code> with default value <code>def</code>. <code>u</code> is a universe containing <code>t</code>.</p><span class="comment-delim">*)</span></td></tr></table></div></div><p>User view of <code>constr</code>. For <code>App</code>, it is ensured there is at least one argument and the function is not itself an applicative term</p><div class="odoc-spec"><div class="spec value" id="val-kind" class="anchored"><a href="#val-kind" class="anchor"></a><code><span><span class="keyword">val</span> kind : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-constr">constr</a>, <a href="#type-types">types</a>, <a href="../Sorts/index.html#type-t">Sorts.t</a>, <a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a>)</span> <a href="#type-kind_of_term">kind_of_term</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-of_kind" class="anchored"><a href="#val-of_kind" class="anchor"></a><code><span><span class="keyword">val</span> of_kind : <span><span><span>(<a href="#type-constr">constr</a>, <a href="#type-types">types</a>, <a href="../Sorts/index.html#type-t">Sorts.t</a>, <a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a>)</span> <a href="#type-kind_of_term">kind_of_term</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-kind_nocast_gen" class="anchored"><a href="#val-kind_nocast_gen" class="anchor"></a><code><span><span class="keyword">val</span> kind_nocast_gen : <span><span>(<span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="#type-kind_of_term">kind_of_term</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="#type-kind_of_term">kind_of_term</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-kind_nocast" class="anchored"><a href="#val-kind_nocast" class="anchor"></a><code><span><span class="keyword">val</span> kind_nocast : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-constr">constr</a>, <a href="#type-types">types</a>, <a href="../Sorts/index.html#type-t">Sorts.t</a>, <a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a>)</span> <a href="#type-kind_of_term">kind_of_term</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isRel" class="anchored"><a href="#val-isRel" class="anchor"></a><code><span><span class="keyword">val</span> isRel : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Simple case analysis</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isRelN" class="anchored"><a href="#val-isRelN" class="anchor"></a><code><span><span class="keyword">val</span> isRelN : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isVar" class="anchored"><a href="#val-isVar" class="anchor"></a><code><span><span class="keyword">val</span> isVar : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isVarId" class="anchored"><a href="#val-isVarId" class="anchor"></a><code><span><span class="keyword">val</span> isVarId : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isRef" class="anchored"><a href="#val-isRef" class="anchor"></a><code><span><span class="keyword">val</span> isRef : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isRefX" class="anchored"><a href="#val-isRefX" class="anchor"></a><code><span><span class="keyword">val</span> isRefX : <span><a href="../Names/GlobRef/index.html#type-t">Names.GlobRef.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isInd" class="anchored"><a href="#val-isInd" class="anchor"></a><code><span><span class="keyword">val</span> isInd : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isEvar" class="anchored"><a href="#val-isEvar" class="anchor"></a><code><span><span class="keyword">val</span> isEvar : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isMeta" class="anchored"><a href="#val-isMeta" class="anchor"></a><code><span><span class="keyword">val</span> isMeta : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isEvar_or_Meta" class="anchored"><a href="#val-isEvar_or_Meta" class="anchor"></a><code><span><span class="keyword">val</span> isEvar_or_Meta : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isSort" class="anchored"><a href="#val-isSort" class="anchor"></a><code><span><span class="keyword">val</span> isSort : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isCast" class="anchored"><a href="#val-isCast" class="anchor"></a><code><span><span class="keyword">val</span> isCast : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isApp" class="anchored"><a href="#val-isApp" class="anchor"></a><code><span><span class="keyword">val</span> isApp : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isLambda" class="anchored"><a href="#val-isLambda" class="anchor"></a><code><span><span class="keyword">val</span> isLambda : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isLetIn" class="anchored"><a href="#val-isLetIn" class="anchor"></a><code><span><span class="keyword">val</span> isLetIn : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isProd" class="anchored"><a href="#val-isProd" class="anchor"></a><code><span><span class="keyword">val</span> isProd : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isConst" class="anchored"><a href="#val-isConst" class="anchor"></a><code><span><span class="keyword">val</span> isConst : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isConstruct" class="anchored"><a href="#val-isConstruct" class="anchor"></a><code><span><span class="keyword">val</span> isConstruct : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isFix" class="anchored"><a href="#val-isFix" class="anchor"></a><code><span><span class="keyword">val</span> isFix : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isCoFix" class="anchored"><a href="#val-isCoFix" class="anchor"></a><code><span><span class="keyword">val</span> isCoFix : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isCase" class="anchored"><a href="#val-isCase" class="anchor"></a><code><span><span class="keyword">val</span> isCase : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isProj" class="anchored"><a href="#val-isProj" class="anchor"></a><code><span><span class="keyword">val</span> isProj : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_Prop" class="anchored"><a href="#val-is_Prop" class="anchor"></a><code><span><span class="keyword">val</span> is_Prop : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_Set" class="anchored"><a href="#val-is_Set" class="anchor"></a><code><span><span class="keyword">val</span> is_Set : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-isprop" class="anchored"><a href="#val-isprop" class="anchor"></a><code><span><span class="keyword">val</span> isprop : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_Type" class="anchored"><a href="#val-is_Type" class="anchor"></a><code><span><span class="keyword">val</span> is_Type : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-iskind" class="anchored"><a href="#val-iskind" class="anchor"></a><code><span><span class="keyword">val</span> iskind : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_small" class="anchored"><a href="#val-is_small" class="anchor"></a><code><span><span class="keyword">val</span> is_small : <span><a href="../Sorts/index.html#type-t">Sorts.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><h6 id="term-destructors"><a href="#term-destructors" class="anchor"></a>Term destructors</h6><p>Destructor operations are partial functions and</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">DestKO</span> <p>if the term has not the expected form.</p></li></ul><div class="odoc-spec"><div class="spec exception" id="exception-DestKO" class="anchored"><a href="#exception-DestKO" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">DestKO</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-destRel" class="anchored"><a href="#val-destRel" class="anchor"></a><code><span><span class="keyword">val</span> destRel : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Destructs a de Bruijn index</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destMeta" class="anchored"><a href="#val-destMeta" class="anchor"></a><code><span><span class="keyword">val</span> destMeta : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-metavariable">metavariable</a></span></code></div><div class="spec-doc"><p>Destructs an existential variable</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destVar" class="anchored"><a href="#val-destVar" class="anchor"></a><code><span><span class="keyword">val</span> destVar : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Names/Id/index.html#type-t">Names.Id.t</a></span></code></div><div class="spec-doc"><p>Destructs a variable</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destSort" class="anchored"><a href="#val-destSort" class="anchor"></a><code><span><span class="keyword">val</span> destSort : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Sorts/index.html#type-t">Sorts.t</a></span></code></div><div class="spec-doc"><p>Destructs a sort. <code>is_Prop</code> recognizes the sort <code>Prop</code>, whether <code>isprop</code> recognizes both <code>Prop</code> and <code>Set</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destCast" class="anchored"><a href="#val-destCast" class="anchor"></a><code><span><span class="keyword">val</span> destCast : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a> * <a href="#type-cast_kind">cast_kind</a> * <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Destructs a casted term</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destProd" class="anchored"><a href="#val-destProd" class="anchor"></a><code><span><span class="keyword">val</span> destProd : <span><a href="#type-types">types</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="#type-types">types</a> * <a href="#type-types">types</a></span></code></div><div class="spec-doc"><p>Destructs the product <code> $ </code>(x:t_1)t_2<code> $ </code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-destLambda" class="anchored"><a href="#val-destLambda" class="anchor"></a><code><span><span class="keyword">val</span> destLambda : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="#type-types">types</a> * <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Destructs the abstraction <code> $ </code><code>x:t_1</code>t_2<code> $ </code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-destLetIn" class="anchored"><a href="#val-destLetIn" class="anchor"></a><code><span><span class="keyword">val</span> destLetIn : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="#type-constr">constr</a> * <a href="#type-types">types</a> * <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Destructs the let <code> $ </code><code>x:=b:t_1</code>t_2<code> $ </code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-destApp" class="anchored"><a href="#val-destApp" class="anchor"></a><code><span><span class="keyword">val</span> destApp : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a> * <span><a href="#type-constr">constr</a> array</span></span></code></div><div class="spec-doc"><p>Destructs an application</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_app_list" class="anchored"><a href="#val-decompose_app_list" class="anchor"></a><code><span><span class="keyword">val</span> decompose_app_list : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a> * <span><a href="#type-constr">constr</a> list</span></span></code></div><div class="spec-doc"><p>Decompose any term as an applicative term; the list of args can be empty</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_app" class="anchored"><a href="#val-decompose_app" class="anchor"></a><code><span><span class="keyword">val</span> decompose_app : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a> * <span><a href="#type-constr">constr</a> array</span></span></code></div><div class="spec-doc"><p>Same as <code>decompose_app</code>, but returns an array.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destConst" class="anchored"><a href="#val-destConst" class="anchor"></a><code><span><span class="keyword">val</span> destConst : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/Constant/index.html#type-t">Names.Constant.t</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span></span></code></div><div class="spec-doc"><p>Destructs a constant</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destEvar" class="anchored"><a href="#val-destEvar" class="anchor"></a><code><span><span class="keyword">val</span> destEvar : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-existential">existential</a></span></code></div><div class="spec-doc"><p>Destructs an existential variable</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destInd" class="anchored"><a href="#val-destInd" class="anchor"></a><code><span><span class="keyword">val</span> destInd : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/index.html#type-inductive">Names.inductive</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span></span></code></div><div class="spec-doc"><p>Destructs a (co)inductive type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destConstruct" class="anchored"><a href="#val-destConstruct" class="anchor"></a><code><span><span class="keyword">val</span> destConstruct : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/index.html#type-constructor">Names.constructor</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span></span></code></div><div class="spec-doc"><p>Destructs a constructor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destCase" class="anchored"><a href="#val-destCase" class="anchor"></a><code><span><span class="keyword">val</span> destCase : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-case">case</a></span></code></div><div class="spec-doc"><p>Destructs a <code>match c as x in I args return P with ... |
Ci(...yij...) =&gt; ti | ... end</code> (or <code>let (..y1i..) := c as x in I args
return P in t1</code>, or <code>if c then t1 else t2</code>)</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>(info,c,fun args x =&gt; P,[|...|fun yij =&gt; ti| ...|])</code> where <code>info</code> is pretty-printing information</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-destProj" class="anchored"><a href="#val-destProj" class="anchor"></a><code><span><span class="keyword">val</span> destProj : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Names/Projection/index.html#type-t">Names.Projection.t</a> * <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a> * <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Destructs a projection</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destFix" class="anchored"><a href="#val-destFix" class="anchor"></a><code><span><span class="keyword">val</span> destFix : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-fixpoint">fixpoint</a></span></code></div><div class="spec-doc"><p>Destructs the <code> $ </code>i<code> $ </code>th function of the block <code>Fixpoint f{_ 1} ctx{_ 1} = b{_ 1}
    with    f{_ 2} ctx{_ 2} = b{_ 2}
    ...
    with    f{_ n} ctx{_ n} = b{_ n}</code>, where the length of the <code> $ </code>j<code> $ </code>th context is <code> $ </code>ij<code> $ </code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destCoFix" class="anchored"><a href="#val-destCoFix" class="anchor"></a><code><span><span class="keyword">val</span> destCoFix : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-cofixpoint">cofixpoint</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-destRef" class="anchored"><a href="#val-destRef" class="anchor"></a><code><span><span class="keyword">val</span> destRef : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/GlobRef/index.html#type-t">Names.GlobRef.t</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span></span></code></div></div><h6 id="equality"><a href="#equality" class="anchor"></a>Equality</h6><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal a b</code> is true if <code>a</code> equals <code>b</code> modulo alpha, casts, and application grouping</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eq_constr_univs" class="anchored"><a href="#val-eq_constr_univs" class="anchor"></a><code><span><span class="keyword">val</span> eq_constr_univs : <span><a href="#type-constr">constr</a> <a href="../UGraph/index.html#type-check_function">UGraph.check_function</a></span></span></code></div><div class="spec-doc"><p><code>eq_constr_univs u a b</code> is <code>true</code> if <code>a</code> equals <code>b</code> modulo alpha, casts, application grouping and the universe equalities in <code>u</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-leq_constr_univs" class="anchored"><a href="#val-leq_constr_univs" class="anchor"></a><code><span><span class="keyword">val</span> leq_constr_univs : <span><a href="#type-constr">constr</a> <a href="../UGraph/index.html#type-check_function">UGraph.check_function</a></span></span></code></div><div class="spec-doc"><p><code>leq_constr_univs u a b</code> is <code>true</code> if <code>a</code> is convertible to <code>b</code> modulo alpha, casts, application grouping and the universe inequalities in <code>u</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eq_constr_nounivs" class="anchored"><a href="#val-eq_constr_nounivs" class="anchor"></a><code><span><span class="keyword">val</span> eq_constr_nounivs : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>eq_constr_univs a b</code> <code>true, c</code> if <code>a</code> equals <code>b</code> modulo alpha, casts, application grouping and ignoring universe instances.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Total ordering compatible with <code>equal</code></p></div></div><h6 id="extension-of-context-with-declarations-on-constr"><a href="#extension-of-context-with-declarations-on-constr" class="anchor"></a>Extension of Context with declarations on constr</h6><div class="odoc-spec"><div class="spec type" id="type-rel_declaration" class="anchored"><a href="#type-rel_declaration" class="anchor"></a><code><span><span class="keyword">type</span> rel_declaration</span><span> = <span><span>(<a href="#type-constr">constr</a>, <a href="#type-types">types</a>)</span> <a href="../Context/Rel/Declaration/index.html#type-pt">Context.Rel.Declaration.pt</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-named_declaration" class="anchored"><a href="#type-named_declaration" class="anchor"></a><code><span><span class="keyword">type</span> named_declaration</span><span> = <span><span>(<a href="#type-constr">constr</a>, <a href="#type-types">types</a>)</span> <a href="../Context/Named/Declaration/index.html#type-pt">Context.Named.Declaration.pt</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-compacted_declaration" class="anchored"><a href="#type-compacted_declaration" class="anchor"></a><code><span><span class="keyword">type</span> compacted_declaration</span><span> = <span><span>(<a href="#type-constr">constr</a>, <a href="#type-types">types</a>)</span> <a href="../Context/Compacted/Declaration/index.html#type-pt">Context.Compacted.Declaration.pt</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-rel_context" class="anchored"><a href="#type-rel_context" class="anchor"></a><code><span><span class="keyword">type</span> rel_context</span><span> = <span><a href="#type-rel_declaration">rel_declaration</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-named_context" class="anchored"><a href="#type-named_context" class="anchor"></a><code><span><span class="keyword">type</span> named_context</span><span> = <span><a href="#type-named_declaration">named_declaration</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-compacted_context" class="anchored"><a href="#type-compacted_context" class="anchor"></a><code><span><span class="keyword">type</span> compacted_context</span><span> = <span><a href="#type-compacted_declaration">compacted_declaration</a> list</span></span></code></div></div><h6 id="relocation-and-substitution"><a href="#relocation-and-substitution" class="anchor"></a>Relocation and substitution</h6><div class="odoc-spec"><div class="spec value" id="val-exliftn" class="anchored"><a href="#val-exliftn" class="anchor"></a><code><span><span class="keyword">val</span> exliftn : <span><a href="../Esubst/index.html#type-lift">Esubst.lift</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p><code>exliftn el c</code> lifts <code>c</code> with lifting <code>el</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-liftn" class="anchored"><a href="#val-liftn" class="anchor"></a><code><span><span class="keyword">val</span> liftn : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p><code>liftn n k c</code> lifts by <code>n</code> indexes above or equal to <code>k</code> in <code>c</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-lift" class="anchored"><a href="#val-lift" class="anchor"></a><code><span><span class="keyword">val</span> lift : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p><code>lift n c</code> lifts by <code>n</code> the positive indexes in <code>c</code></p></div></div><h6 id="functionals-working-on-expressions-canonically-abstracted-over-a-local-context-(possibly-with-let-ins)"><a href="#functionals-working-on-expressions-canonically-abstracted-over-a-local-context-(possibly-with-let-ins)" class="anchor"></a>Functionals working on expressions canonically abstracted over a local context (possibly with let-ins)</h6><p><code>map_branches f br</code> maps <code>f</code> on the immediate subterms of an array of &quot;match&quot; branches <code>br</code> in canonical eta-let-expanded form; it is not recursive and the order with which subterms are processed is not specified; it preserves sharing; the immediate subterms are the types and possibly terms occurring in the context of each branch as well as the body of each branch</p><div class="odoc-spec"><div class="spec value" id="val-map_branches" class="anchored"><a href="#val-map_branches" class="anchor"></a><code><span><span class="keyword">val</span> map_branches : <span><span>(<span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-case_branch">case_branch</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-case_branch">case_branch</a> array</span></span></code></div></div><p><code>map_return_predicate f p</code> maps <code>f</code> on the immediate subterms of a return predicate of a &quot;match&quot; in canonical eta-let-expanded form; it is not recursive and the order with which subterms are processed is not specified; it preserves sharing; the immediate subterms are the types and possibly terms occurring in the context of each branch as well as the body of the predicate</p><div class="odoc-spec"><div class="spec value" id="val-map_return_predicate" class="anchored"><a href="#val-map_return_predicate" class="anchor"></a><code><span><span class="keyword">val</span> map_return_predicate : <span><span>(<span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-case_return">case_return</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-case_return">case_return</a></span></code></div></div><p><code>map_branches_with_binders f br</code> maps <code>f</code> on the immediate subterms of an array of &quot;match&quot; branches <code>br</code> in canonical eta-let-expanded form; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically adds 1 to <code>n</code>) at each binder traversal; it is not recursive and the order with which subterms are processed is not specified; it preserves sharing; the immediate subterms are the types and possibly terms occurring in the context of the branch as well as the body of the branch</p><div class="odoc-spec"><div class="spec value" id="val-map_branches_with_binders" class="anchored"><a href="#val-map_branches_with_binders" class="anchor"></a><code><span><span class="keyword">val</span> map_branches_with_binders : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-case_branch">case_branch</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-case_branch">case_branch</a> array</span></span></code></div></div><p><code>map_return_predicate_with_binders f p</code> maps <code>f</code> on the immediate subterms of a return predicate of a &quot;match&quot; in canonical eta-let-expanded form; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically adds 1 to <code>n</code>) at each binder traversal; it is not recursive and the order with which subterms are processed is not specified; it preserves sharing; the immediate subterms are the types and possibly terms occurring in the context of each branch as well as the body of the predicate</p><div class="odoc-spec"><div class="spec value" id="val-map_return_predicate_with_binders" class="anchored"><a href="#val-map_return_predicate_with_binders" class="anchor"></a><code><span><span class="keyword">val</span> map_return_predicate_with_binders : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-case_return">case_return</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-case_return">case_return</a></span></code></div></div><h6 id="functionals-working-on-the-immediate-subterm-of-a-construction"><a href="#functionals-working-on-the-immediate-subterm-of-a-construction" class="anchor"></a>Functionals working on the immediate subterm of a construction</h6><p><code>fold f acc c</code> folds <code>f</code> on the immediate subterms of <code>c</code> starting from <code>acc</code> and proceeding from left to right according to the usual representation of the constructions; it is not recursive</p><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_invert" class="anchored"><a href="#val-fold_invert" class="anchor"></a><code><span><span class="keyword">val</span> fold_invert : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-pcase_invert">pcase_invert</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><p><code>map f c</code> maps <code>f</code> on the immediate subterms of <code>c</code>; it is not recursive and the order with which subterms are processed is not specified</p><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-map_invert" class="anchored"><a href="#val-map_invert" class="anchor"></a><code><span><span class="keyword">val</span> map_invert : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-pcase_invert">pcase_invert</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-pcase_invert">pcase_invert</a></span></span></code></div></div><p>Like <a href="#val-map"><code>map</code></a>, but also has an additional accumulator.</p><div class="odoc-spec"><div class="spec value" id="val-fold_map" class="anchored"><a href="#val-fold_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <a href="#type-constr">constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_map_invert" class="anchored"><a href="#val-fold_map_invert" class="anchor"></a><code><span><span class="keyword">val</span> fold_map_invert : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-pcase_invert">pcase_invert</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span><span class="type-var">'b</span> <a href="#type-pcase_invert">pcase_invert</a></span></span></code></div></div><p><code>map_with_binders g f n c</code> maps <code>f n</code> on the immediate subterms of <code>c</code>; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically add 1 to <code>n</code>) at each binder traversal; it is not recursive and the order with which subterms are processed is not specified</p><div class="odoc-spec"><div class="spec value" id="val-map_with_binders" class="anchored"><a href="#val-map_with_binders" class="anchor"></a><code><span><span class="keyword">val</span> map_with_binders : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><p><code>iter f c</code> iters <code>f</code> on the immediate subterms of <code>c</code>; it is not recursive and the order with which subterms are processed is not specified</p><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_invert" class="anchored"><a href="#val-iter_invert" class="anchor"></a><code><span><span class="keyword">val</span> iter_invert : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-pcase_invert">pcase_invert</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><p><code>iter_with_binders g f n c</code> iters <code>f n</code> on the immediate subterms of <code>c</code>; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically add 1 to <code>n</code>) at each binder traversal; it is not recursive and the order with which subterms are processed is not specified</p><div class="odoc-spec"><div class="spec value" id="val-iter_with_binders" class="anchored"><a href="#val-iter_with_binders" class="anchor"></a><code><span><span class="keyword">val</span> iter_with_binders : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><p><code>iter_with_binders g f n c</code> iters <code>f n</code> on the immediate subterms of <code>c</code>; it carries an extra data <code>n</code> (typically a lift index) which is processed by <code>g</code> (which typically add 1 to <code>n</code>) at each binder traversal; it is not recursive and the order with which subterms are processed is not specified</p><div class="odoc-spec"><div class="spec value" id="val-fold_constr_with_binders" class="anchored"><a href="#val-fold_constr_with_binders" class="anchor"></a><code><span><span class="keyword">val</span> fold_constr_with_binders : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-constr_compare_fn" class="anchored"><a href="#type-constr_compare_fn" class="anchor"></a><code><span><span class="keyword">type</span> <span>'constr constr_compare_fn</span></span><span> = <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'constr</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'constr</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><p><code>compare_head f c1 c2</code> compare <code>c1</code> and <code>c2</code> using <code>f</code> to compare the immediate subterms of <code>c1</code> of <code>c2</code> if needed; Cast's, binders name and Cases annotations are not taken into account</p><div class="odoc-spec"><div class="spec value" id="val-compare_head" class="anchored"><a href="#val-compare_head" class="anchor"></a><code><span><span class="keyword">val</span> compare_head : <span><span>(<span><a href="#type-existential">existential</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-existential">existential</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-constr">constr</a> <a href="#type-constr_compare_fn">constr_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <a href="#type-constr_compare_fn">constr_compare_fn</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-instance_compare_fn" class="anchored"><a href="#type-instance_compare_fn" class="anchor"></a><code><span><span class="keyword">type</span> <span>'univs instance_compare_fn</span></span><span> = <span><span><span>(<a href="../Names/GlobRef/index.html#type-t">Names.GlobRef.t</a> * int)</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'univs</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'univs</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Convert a global reference applied to 2 instances. The int says how many arguments are given (as we can only use cumulativity for fully applied inductives/constructors) .</p></div></div><p><code>compare_head_gen u s f c1 c2</code> compare <code>c1</code> and <code>c2</code> using <code>f</code> to compare the immediate subterms of <code>c1</code> of <code>c2</code> if needed, <code>u</code> to compare universe instances, <code>s</code> to compare sorts; Cast's, binders name and Cases annotations are not taken into account</p><div class="odoc-spec"><div class="spec value" id="val-compare_head_gen" class="anchored"><a href="#val-compare_head_gen" class="anchor"></a><code><span><span class="keyword">val</span> compare_head_gen : <span><span><a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a> <a href="#type-instance_compare_fn">instance_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Sorts/index.html#type-t">Sorts.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sorts/index.html#type-t">Sorts.t</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-existential">existential</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-existential">existential</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-constr">constr</a> <a href="#type-constr_compare_fn">constr_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <a href="#type-constr_compare_fn">constr_compare_fn</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_head_gen_leq_with" class="anchored"><a href="#val-compare_head_gen_leq_with" class="anchor"></a><code><span><span class="keyword">val</span> compare_head_gen_leq_with : <span><span>(<span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="#type-kind_of_term">kind_of_term</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="#type-kind_of_term">kind_of_term</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'univs</span> <a href="#type-instance_compare_fn">instance_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'sort</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'sort</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'v</span> <a href="#type-pexistential">pexistential</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'v</span> <a href="#type-pexistential">pexistential</a></span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'v</span> <a href="#type-constr_compare_fn">constr_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'v</span> <a href="#type-constr_compare_fn">constr_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v</span> <a href="#type-constr_compare_fn">constr_compare_fn</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_head_gen_with" class="anchored"><a href="#val-compare_head_gen_with" class="anchor"></a><code><span><span class="keyword">val</span> compare_head_gen_with : <span><span>(<span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="#type-kind_of_term">kind_of_term</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'v</span>, <span class="type-var">'sort</span>, <span class="type-var">'univs</span>)</span> <a href="#type-kind_of_term">kind_of_term</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'univs</span> <a href="#type-instance_compare_fn">instance_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'sort</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'sort</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'v</span> <a href="#type-pexistential">pexistential</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'v</span> <a href="#type-pexistential">pexistential</a></span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'v</span> <a href="#type-constr_compare_fn">constr_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v</span> <a href="#type-constr_compare_fn">constr_compare_fn</a></span></span></code></div><div class="spec-doc"><p><code>compare_head_gen_with k1 k2 u s f c1 c2</code> compares <code>c1</code> and <code>c2</code> like <code>compare_head_gen u s f c1 c2</code>, except that <code>k1</code> (resp. <code>k2</code>) is used,rather than <a href="#val-kind"><code>kind</code></a>, to expose the immediate subterms of <code>c1</code> (resp. <code>c2</code>).</p></div></div><p><code>compare_head_gen_leq u s f fle c1 c2</code> compare <code>c1</code> and <code>c2</code> using <code>f</code> to compare the immediate subterms of <code>c1</code> of <code>c2</code> for conversion, <code>fle</code> for cumulativity, <code>u</code> to compare universe instances (the first boolean tells if they belong to a Constant.t), <code>s</code> to compare sorts for for subtyping; Cast's, binders name and Cases annotations are not taken into account</p><div class="odoc-spec"><div class="spec value" id="val-compare_head_gen_leq" class="anchored"><a href="#val-compare_head_gen_leq" class="anchor"></a><code><span><span class="keyword">val</span> compare_head_gen_leq : <span><span><a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a> <a href="#type-instance_compare_fn">instance_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Sorts/index.html#type-t">Sorts.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sorts/index.html#type-t">Sorts.t</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-existential">existential</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-existential">existential</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-constr">constr</a> <a href="#type-constr_compare_fn">constr_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-constr">constr</a> <a href="#type-constr_compare_fn">constr_compare_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <a href="#type-constr_compare_fn">constr_compare_fn</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-eq_invert" class="anchored"><a href="#val-eq_invert" class="anchor"></a><code><span><span class="keyword">val</span> eq_invert : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-pcase_invert">pcase_invert</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-pcase_invert">pcase_invert</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><h6 id="hashconsing"><a href="#hashconsing" class="anchor"></a>Hashconsing</h6><div class="odoc-spec"><div class="spec value" id="val-hash" class="anchored"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-case_info_hash" class="anchored"><a href="#val-case_info_hash" class="anchor"></a><code><span><span class="keyword">val</span> case_info_hash : <span><a href="#type-case_info">case_info</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-hcons" class="anchored"><a href="#val-hcons" class="anchor"></a><code><span><span class="keyword">val</span> hcons : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-debug_print" class="anchored"><a href="#val-debug_print" class="anchor"></a><code><span><span class="keyword">val</span> debug_print : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Pp/index.html#type-t">Pp.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-debug_print_fix" class="anchored"><a href="#val-debug_print_fix" class="anchor"></a><code><span><span class="keyword">val</span> debug_print_fix : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Pp/index.html#type-t">Pp.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="#type-pfixpoint">pfixpoint</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Pp/index.html#type-t">Pp.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkConst" class="anchored"><a href="#val-mkConst" class="anchor"></a><code><span><span class="keyword">val</span> mkConst : <span><a href="../Names/Constant/index.html#type-t">Names.Constant.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkInd" class="anchored"><a href="#val-mkInd" class="anchor"></a><code><span><span class="keyword">val</span> mkInd : <span><a href="../Names/index.html#type-inductive">Names.inductive</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkConstruct" class="anchored"><a href="#val-mkConstruct" class="anchor"></a><code><span><span class="keyword">val</span> mkConstruct : <span><a href="../Names/index.html#type-constructor">Names.constructor</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div></div></div></body></html>