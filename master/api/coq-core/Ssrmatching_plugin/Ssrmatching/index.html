<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ssrmatching (coq-core.Ssrmatching_plugin.Ssrmatching)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">coq-core</a> &#x00BB; <a href="../index.html">Ssrmatching_plugin</a> &#x00BB; Ssrmatching</nav><header class="odoc-preamble"><h1>Module <code><span>Ssrmatching_plugin.Ssrmatching</span></code></h1><p>******** Small Scale Reflection pattern matching facilities *************</p></header><div class="odoc-content"><p>Pattern parsing</p><div class="odoc-spec"><div class="spec type" id="type-ssrtermkind" class="anchored"><a href="#type-ssrtermkind" class="anchor"></a><code><span><span class="keyword">type</span> ssrtermkind</span><span> = </span></code><table><tr id="type-ssrtermkind.InParens" class="anchored"><td class="def variant constructor"><a href="#type-ssrtermkind.InParens" class="anchor"></a><code><span>| </span><span><span class="constructor">InParens</span></span></code></td></tr><tr id="type-ssrtermkind.WithAt" class="anchored"><td class="def variant constructor"><a href="#type-ssrtermkind.WithAt" class="anchor"></a><code><span>| </span><span><span class="constructor">WithAt</span></span></code></td></tr><tr id="type-ssrtermkind.NoFlag" class="anchored"><td class="def variant constructor"><a href="#type-ssrtermkind.NoFlag" class="anchor"></a><code><span>| </span><span><span class="constructor">NoFlag</span></span></code></td></tr><tr id="type-ssrtermkind.Cpattern" class="anchored"><td class="def variant constructor"><a href="#type-ssrtermkind.Cpattern" class="anchor"></a><code><span>| </span><span><span class="constructor">Cpattern</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-cpattern" class="anchored"><a href="#type-cpattern" class="anchor"></a><code><span><span class="keyword">type</span> cpattern</span><span> = </span><span>{</span></code><table><tr id="type-cpattern.kind" class="anchored"><td class="def record field"><a href="#type-cpattern.kind" class="anchor"></a><code><span>kind : <a href="#type-ssrtermkind">ssrtermkind</a>;</span></code></td></tr><tr id="type-cpattern.pattern" class="anchored"><td class="def record field"><a href="#type-cpattern.pattern" class="anchor"></a><code><span>pattern : <a href="../../Genintern/index.html#type-glob_constr_and_expr">Genintern.glob_constr_and_expr</a>;</span></code></td></tr><tr id="type-cpattern.interpretation" class="anchored"><td class="def record field"><a href="#type-cpattern.interpretation" class="anchor"></a><code><span>interpretation : <span><a href="../../Geninterp/index.html#type-interp_sign">Geninterp.interp_sign</a> option</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The type of context patterns, the patterns of the <code>set</code> tactic and <code>:</code> tactical. These are patterns that identify a precise subterm.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pr_cpattern" class="anchored"><a href="#val-pr_cpattern" class="anchor"></a><code><span><span class="keyword">val</span> pr_cpattern : <span><a href="#type-cpattern">cpattern</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Pp/index.html#type-t">Pp.t</a></span></code></div></div><p>Pattern interpretation and matching</p><div class="odoc-spec"><div class="spec exception" id="exception-NoMatch" class="anchored"><a href="#exception-NoMatch" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">NoMatch</span></span></code></div></div><div class="odoc-spec"><div class="spec exception" id="exception-NoProgress" class="anchored"><a href="#exception-NoProgress" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">NoProgress</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-ssrpattern" class="anchored"><a href="#type-ssrpattern" class="anchor"></a><code><span><span class="keyword">type</span> <span>('ident, 'term) ssrpattern</span></span><span> = </span></code><table><tr id="type-ssrpattern.T" class="anchored"><td class="def variant constructor"><a href="#type-ssrpattern.T" class="anchor"></a><code><span>| </span><span><span class="constructor">T</span> <span class="keyword">of</span> <span class="type-var">'term</span></span></code></td></tr><tr id="type-ssrpattern.In_T" class="anchored"><td class="def variant constructor"><a href="#type-ssrpattern.In_T" class="anchor"></a><code><span>| </span><span><span class="constructor">In_T</span> <span class="keyword">of</span> <span class="type-var">'term</span></span></code></td></tr><tr id="type-ssrpattern.X_In_T" class="anchored"><td class="def variant constructor"><a href="#type-ssrpattern.X_In_T" class="anchor"></a><code><span>| </span><span><span class="constructor">X_In_T</span> <span class="keyword">of</span> <span class="type-var">'ident</span> * <span class="type-var">'term</span></span></code></td></tr><tr id="type-ssrpattern.In_X_In_T" class="anchored"><td class="def variant constructor"><a href="#type-ssrpattern.In_X_In_T" class="anchor"></a><code><span>| </span><span><span class="constructor">In_X_In_T</span> <span class="keyword">of</span> <span class="type-var">'ident</span> * <span class="type-var">'term</span></span></code></td></tr><tr id="type-ssrpattern.E_In_X_In_T" class="anchored"><td class="def variant constructor"><a href="#type-ssrpattern.E_In_X_In_T" class="anchor"></a><code><span>| </span><span><span class="constructor">E_In_X_In_T</span> <span class="keyword">of</span> <span class="type-var">'term</span> * <span class="type-var">'ident</span> * <span class="type-var">'term</span></span></code></td></tr><tr id="type-ssrpattern.E_As_X_In_T" class="anchored"><td class="def variant constructor"><a href="#type-ssrpattern.E_As_X_In_T" class="anchor"></a><code><span>| </span><span><span class="constructor">E_As_X_In_T</span> <span class="keyword">of</span> <span class="type-var">'term</span> * <span class="type-var">'ident</span> * <span class="type-var">'term</span></span></code></td></tr></table></div><div class="spec-doc"><p>AST for <code>rpattern</code> (and consequently <code>cpattern</code>)</p></div></div><div class="odoc-spec"><div class="spec type" id="type-pattern" class="anchored"><a href="#type-pattern" class="anchor"></a><code><span><span class="keyword">type</span> pattern</span><span> = <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <span><span>(<a href="../../EConstr/index.html#type-existential">EConstr.existential</a>, <a href="../../EConstr/index.html#type-t">EConstr.t</a>)</span> <a href="#type-ssrpattern">ssrpattern</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_pattern" class="anchored"><a href="#val-pp_pattern" class="anchor"></a><code><span><span class="keyword">val</span> pp_pattern : <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Pp/index.html#type-t">Pp.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-rpattern" class="anchored"><a href="#type-rpattern" class="anchor"></a><code><span><span class="keyword">type</span> rpattern</span><span> = <span><span>(<a href="#type-cpattern">cpattern</a>, <a href="#type-cpattern">cpattern</a>)</span> <a href="#type-ssrpattern">ssrpattern</a></span></span></code></div><div class="spec-doc"><p>The type of rewrite patterns, the patterns of the <code>rewrite</code> tactic. These patterns also include patterns that identify all the subterms of a context (i.e. &quot;in&quot; prefix)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pr_rpattern" class="anchored"><a href="#val-pr_rpattern" class="anchor"></a><code><span><span class="keyword">val</span> pr_rpattern : <span><a href="#type-rpattern">rpattern</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Pp/index.html#type-t">Pp.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-redex_of_pattern" class="anchored"><a href="#val-redex_of_pattern" class="anchor"></a><code><span><span class="keyword">val</span> redex_of_pattern : <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a>)</span> option</span></span></code></div><div class="spec-doc"><p>Extracts the redex and applies to it the substitution part of the pattern.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Anomaly</span> <p>if called on <code>In_T</code> or <code>In_X_In_T</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-interp_rpattern" class="anchored"><a href="#val-interp_rpattern" class="anchor"></a><code><span><span class="keyword">val</span> interp_rpattern : <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-rpattern">rpattern</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-pattern">pattern</a></span></code></div><div class="spec-doc"><p><code>interp_rpattern ise gl rpat</code> &quot;internalizes&quot; and &quot;interprets&quot; <code>rpat</code> in the current <code>Ltac</code> interpretation signature <code>ise</code> and tactic input <code>gl</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-interp_cpattern" class="anchored"><a href="#val-interp_cpattern" class="anchor"></a><code><span><span class="keyword">val</span> interp_cpattern : <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-cpattern">cpattern</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../../Genintern/index.html#type-glob_constr_and_expr">Genintern.glob_constr_and_expr</a> * <a href="../../Geninterp/index.html#type-interp_sign">Geninterp.interp_sign</a>)</span> option</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-pattern">pattern</a></span></code></div><div class="spec-doc"><p><code>interp_cpattern ise gl cpat ty</code> &quot;internalizes&quot; and &quot;interprets&quot; <code>cpat</code> in the current <code>Ltac</code> interpretation signature <code>ise</code> and tactic input <code>gl</code>. <code>ty</code> is an optional type for the redex of <code>cpat</code></p></div></div><div class="odoc-spec"><div class="spec type" id="type-occ" class="anchored"><a href="#type-occ" class="anchor"></a><code><span><span class="keyword">type</span> occ</span><span> = <span><span>(bool * <span>int list</span>)</span> option</span></span></code></div><div class="spec-doc"><p>The set of occurrences to be matched. The boolean is set to true * to signal the complement of this set (i.e. {-1 3})</p></div></div><div class="odoc-spec"><div class="spec type" id="type-subst" class="anchored"><a href="#type-subst" class="anchor"></a><code><span><span class="keyword">type</span> subst</span><span> = <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-t">EConstr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-t">EConstr.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="../../EConstr/index.html#type-t">EConstr.t</a></span></code></div><div class="spec-doc"><p><code>subst e p t i</code>. <code>i</code> is the number of binders traversed so far, <code>p</code> the term from the pattern, <code>t</code> the matched one</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eval_pattern" class="anchored"><a href="#val-eval_pattern" class="anchor"></a><code><span><span class="keyword">val</span> eval_pattern : <span>?raise_NoMatch:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-t">EConstr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-pattern">pattern</a> option</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-occ">occ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../EConstr/index.html#type-t">EConstr.t</a></span></code></div><div class="spec-doc"><p><code>eval_pattern b env sigma t pat occ subst</code> maps <code>t</code> calling <code>subst</code> on every <code>occ</code> occurrence of <code>pat</code>. The <code>int</code> argument is the number of binders traversed. If <code>pat</code> is <code>None</code> then then subst is called on <code>t</code>. <code>t</code> must live in <code>env</code> and <code>sigma</code>, <code>pat</code> must have been interpreted in (an extension of) <code>sigma</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">NoMatch</span> <p>if <code>pat</code> has no occurrence and <code>b</code> is <code>true</code> (default <code>false</code>)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>t</code> where all <code>occ</code> occurrences of <code>pat</code> have been mapped using <code>subst</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fill_occ_pattern" class="anchored"><a href="#val-fill_occ_pattern" class="anchor"></a><code><span><span class="keyword">val</span> fill_occ_pattern : <span>?raise_NoMatch:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-t">EConstr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-occ">occ</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-t">EConstr.t</a> <a href="../../Evd/index.html#type-in_evar_universe_context">Evd.in_evar_universe_context</a></span> * <a href="../../EConstr/index.html#type-t">EConstr.t</a></span></code></div><div class="spec-doc"><p><code>fill_occ_pattern b env sigma t pat occ h</code> is a simplified version of <code>eval_pattern</code>. It replaces all <code>occ</code> occurrences of <code>pat</code> in <code>t</code> with Rel <code>h</code>. <code>t</code> must live in <code>env</code> and <code>sigma</code>, <code>pat</code> must have been interpreted in (an extension of) <code>sigma</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">NoMatch</span> <p>if <code>pat</code> has no occurrence and <code>b</code> is <code>true</code> (default <code>false</code>)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the instance of the redex of <code>pat</code> that was matched and <code>t</code> transformed as described above.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fill_rel_occ_pattern" class="anchored"><a href="#val-fill_rel_occ_pattern" class="anchor"></a><code><span><span class="keyword">val</span> fill_rel_occ_pattern : <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-t">EConstr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-occ">occ</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a></span></code></div><div class="spec-doc"><p>Variant of the above function where we fix <code>h := 1</code> and return <code>redex_of_pattern pat</code> if <code>pat</code> has no occurrence.</p></div></div><p>*************************** Low level APIs ******************************</p><div class="odoc-spec"><div class="spec type" id="type-ssrdir" class="anchored"><a href="#type-ssrdir" class="anchor"></a><code><span><span class="keyword">type</span> ssrdir</span><span> = </span></code><table><tr id="type-ssrdir.L2R" class="anchored"><td class="def variant constructor"><a href="#type-ssrdir.L2R" class="anchor"></a><code><span>| </span><span><span class="constructor">L2R</span></span></code></td></tr><tr id="type-ssrdir.R2L" class="anchored"><td class="def variant constructor"><a href="#type-ssrdir.R2L" class="anchor"></a><code><span>| </span><span><span class="constructor">R2L</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-pr_dir_side" class="anchored"><a href="#val-pr_dir_side" class="anchor"></a><code><span><span class="keyword">val</span> pr_dir_side : <span><a href="#type-ssrdir">ssrdir</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Pp/index.html#type-t">Pp.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-tpattern" class="anchored"><a href="#type-tpattern" class="anchor"></a><code><span><span class="keyword">type</span> tpattern</span></code></div><div class="spec-doc"><p>a pattern for a term with wildcards</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_tpattern" class="anchored"><a href="#val-mk_tpattern" class="anchor"></a><code><span><span class="keyword">val</span> mk_tpattern : <span>?p_origin:<span>(<a href="#type-ssrdir">ssrdir</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?ok:<span>(<span><a href="../../EConstr/index.html#type-t">EConstr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>rigid:<span>(<span><a href="../../Evar/index.html#type-t">Evar.t</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
<span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ssrdir">ssrdir</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-t">EConstr.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="#type-tpattern">tpattern</a></span></code></div><div class="spec-doc"><p><code>mk_tpattern env sigma0 sigma_p ok p_origin dir t</code> compiles a term <code>t</code> living in <code>env</code> <code>sigma</code> (an extension of <code>sigma0</code>) intro a <code>tpattern</code>. The <code>tpattern</code> can hold a (proof) term <code>p</code> and a diction <code>dir</code>. The <code>ok</code> callback is used to filter occurrences.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the compiled <code>tpattern</code> and its <code>evar_map</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">UserEerror</span> <p>is the pattern is a wildcard</p></li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-find_P" class="anchored"><a href="#type-find_P" class="anchor"></a><code><span><span class="keyword">type</span> find_P</span><span> = <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-t">EConstr.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>k:<a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../EConstr/index.html#type-t">EConstr.t</a></span></code></div><div class="spec-doc"><p><code>findP env t i k</code> is a stateful function that finds the next occurrence of a tpattern and calls the callback <code>k</code> to map the subterm matched. The <code>int</code> argument passed to <code>k</code> is the number of binders traversed so far plus the initial value <code>i</code>.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>t</code> where the subterms identified by the selected occurrences of the patter have been mapped using <code>k</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">NoMatch</span> <p>if the raise_NoMatch flag given to <code>mk_tpattern_matcher</code> is <code>true</code> and if the pattern did not match</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">UserEerror</span> <p>if the raise_NoMatch flag given to <code>mk_tpattern_matcher</code> is <code>false</code> and if the pattern did not match</p></li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-conclude" class="anchored"><a href="#type-conclude" class="anchor"></a><code><span><span class="keyword">type</span> conclude</span><span> = <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="../../EConstr/index.html#type-t">EConstr.t</a> * <a href="#type-ssrdir">ssrdir</a> * <span>(bool * <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../../UState/index.html#type-t">UState.t</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a>)</span></span></code></div><div class="spec-doc"><p><code>conclude ()</code> asserts that all mentioned occurrences have been visited.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the instance of the pattern, the evarmap after the pattern instantiation, the proof term and the ssrdit stored in the tpattern</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">UserEerror</span> <p>if too many occurrences were specified</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_tpattern_matcher" class="anchored"><a href="#val-mk_tpattern_matcher" class="anchor"></a><code><span><span class="keyword">val</span> mk_tpattern_matcher : <span>?all_instances:bool <span class="arrow">&#45;&gt;</span></span> <span>?raise_NoMatch:bool <span class="arrow">&#45;&gt;</span></span>
<span>?upats_origin:<span>(<a href="#type-ssrdir">ssrdir</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-occ">occ</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <span><a href="#type-tpattern">tpattern</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-find_P">find_P</a> * <a href="#type-conclude">conclude</a></span></code></div><div class="spec-doc"><p><code>mk_tpattern_matcher b o sigma0 occ sigma_tplist</code> creates a pair a function <code>find_P</code> and <code>conclude</code> with the behaviour explained above. The flag <code>b</code> (default <code>false</code>) changes the error reporting behaviour of <code>find_P</code> if none of the <code>tpattern</code> matches. The argument <code>o</code> can be passed to tune the <code>UserError</code> eventually raised (useful if the pattern is coming from the LHS/RHS of an equation)</p></div></div><p>Example of <code>mk_tpattern_matcher</code> to implement <code>rewrite \{occ\}[in t]rules</code>. It first matches &quot;in t&quot; (called <code>pat</code>), then in all matched subterms it matches the LHS of the rules using <code>find_R</code>. <code>concl0</code> is the initial goal, <code>concl</code> will be the goal where some terms are replaced by a De Bruijn index. The <code>rw_progress</code> extra check selects only occurrences that are not rewritten to themselves (e.g. an occurrence &quot;x + x&quot; rewritten with the commutativity law of addition is skipped) </p><pre><code>let find_R, conclude = match pat with
| Some (_, In_T _) -&gt;
    let aux (sigma, pats) (d, r, lhs, rhs) =
      let sigma, pat =
        mk_tpattern env0 sigma0 (sigma, r) (rw_progress rhs) d lhs in
      sigma, pats @ [pat] in
    let rpats = List.fold_left aux (r_sigma, []) rules in
    let find_R, end_R = mk_tpattern_matcher sigma0 occ rpats in
    find_R ~k:(fun _ _ h -&gt; mkRel h),
    fun cl -&gt; let rdx, d, r = end_R () in (d,r),rdx
| _ -&gt; ... in
let concl = eval_pattern env0 sigma0 concl0 pat occ find_R in
let (d, r), rdx = conclude concl in </code></pre><div class="odoc-spec"><div class="spec value" id="val-fill_occ_term" class="anchored"><a href="#val-fill_occ_term" class="anchor"></a><code><span><span class="keyword">val</span> fill_occ_term : <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-t">EConstr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-occ">occ</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="../../EConstr/index.html#type-t">EConstr.t</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a></span></code></div></div><p>Helpers to make stateful closures. Example: a <code>find_P</code> function may be called many times, but the pattern instantiation phase is performed only the first time. The corresponding <code>conclude</code> has to return the instantiated pattern redex. Since it is up to <code>find_P</code> to raise <code>NoMatch</code> if the pattern has no instance, <code>conclude</code> considers it an anomaly if the pattern did not match</p><div class="odoc-spec"><div class="spec value" id="val-do_once" class="anchored"><a href="#val-do_once" class="anchor"></a><code><span><span class="keyword">val</span> do_once : <span><span><span><span class="type-var">'a</span> option</span> <span class="xref-unresolved">Stdlib</span>.ref</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>do_once r f</code> calls <code>f</code> and updates the ref only once</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assert_done" class="anchored"><a href="#val-assert_done" class="anchor"></a><code><span><span class="keyword">val</span> assert_done : <span><span><span><span class="type-var">'a</span> option</span> <span class="xref-unresolved">Stdlib</span>.ref</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>assert_done r</code> return the content of r. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Anomaly</span> <p>is r is <code>None</code></p></li></ul></div></div><p>Very low level APIs. these are calls to evarconv's <code>the_conv_x</code> followed by <code>solve_unif_constraints_with_heuristics</code>. In case of failure they raise <code>NoMatch</code></p><div class="odoc-spec"><div class="spec value" id="val-unify_HO" class="anchored"><a href="#val-unify_HO" class="anchor"></a><code><span><span class="keyword">val</span> unify_HO : <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-constr">EConstr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../EConstr/index.html#type-constr">EConstr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tag_of_cpattern" class="anchored"><a href="#val-tag_of_cpattern" class="anchor"></a><code><span><span class="keyword">val</span> tag_of_cpattern : <span><a href="#type-cpattern">cpattern</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ssrtermkind">ssrtermkind</a></span></code></div><div class="spec-doc"><p>Some more low level functions needed to implement the full SSR language on top of the former APIs</p></div></div><div class="odoc-spec"><div class="spec value" id="val-loc_of_cpattern" class="anchored"><a href="#val-loc_of_cpattern" class="anchor"></a><code><span><span class="keyword">val</span> loc_of_cpattern : <span><a href="#type-cpattern">cpattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Loc/index.html#type-t">Loc.t</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-id_of_pattern" class="anchored"><a href="#val-id_of_pattern" class="anchor"></a><code><span><span class="keyword">val</span> id_of_pattern : <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Names/Id/index.html#type-t">Names.Id.t</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_wildcard" class="anchored"><a href="#val-is_wildcard" class="anchor"></a><code><span><span class="keyword">val</span> is_wildcard : <span><a href="#type-cpattern">cpattern</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-cpattern_of_id" class="anchored"><a href="#val-cpattern_of_id" class="anchor"></a><code><span><span class="keyword">val</span> cpattern_of_id : <span><a href="../../Names/Id/index.html#type-t">Names.Id.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-cpattern">cpattern</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pr_constr_pat" class="anchored"><a href="#val-pr_constr_pat" class="anchor"></a><code><span><span class="keyword">val</span> pr_constr_pat : <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Pp/index.html#type-t">Pp.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pr_econstr_pat" class="anchored"><a href="#val-pr_econstr_pat" class="anchor"></a><code><span><span class="keyword">val</span> pr_econstr_pat : <span><a href="../../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Evd/index.html#type-econstr">Evd.econstr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Pp/index.html#type-t">Pp.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-debug" class="anchored"><a href="#val-debug" class="anchor"></a><code><span><span class="keyword">val</span> debug : <span>bool <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-ssrinstancesof" class="anchored"><a href="#val-ssrinstancesof" class="anchor"></a><code><span><span class="keyword">val</span> ssrinstancesof : <span><a href="#type-cpattern">cpattern</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../Proofview/index.html#type-tactic">Proofview.tactic</a></span></span></code></div></div><p>Functions used for grammar extensions. Do not use.</p><div class="odoc-spec"><div class="spec module" id="module-Internal" class="anchored"><a href="#module-Internal" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Internal/index.html">Internal</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>