<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rtree (coq-core.Rtree)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">coq-core</a> &#x00BB; Rtree</nav><header class="odoc-preamble"><h1>Module <code><span>Rtree</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>Type of regular tree with nodes labelled by values of type 'a The implementation uses de Bruijn indices, so binding capture is avoided by the lift operator (see example below).</p><p>Note that it differs from standard regular trees by accepting vectors of vectors in nodes, which is useful for encoding disjunctive-conjunctive recursive trees such as inductive types. Standard regular trees can however easily be simulated by using singletons of vectors</p></div></div><p>Building trees</p><div class="odoc-spec"><div class="spec value" id="val-mk_node" class="anchored"><a href="#val-mk_node" class="anchor"></a><code><span><span class="keyword">val</span> mk_node : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> array</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Build a node given a label and a vector of vectors of sons</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_rec_calls" class="anchored"><a href="#val-mk_rec_calls" class="anchor"></a><code><span><span class="keyword">val</span> mk_rec_calls : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> array</span></span></code></div><div class="spec-doc"><p>Build mutually recursive trees: X_1 = f_1(X_1,..,X_n) ... X_n = f_n(X_1,..,X_n) is obtained by the following pseudo-code let vx = mk_rec_calls n in let <code>|x_1;..;x_n|</code> = mk_rec<code>|f_1(vx.(0),..,vx.(n-1);..;f_n(vx.(0),..,vx.(n-1))|</code></p><p>First example: build rec X = a(X,Y) and Y = b(X,Y,Y) let <code>|vx;vy|</code> = mk_rec_calls 2 in let <code>|x;y|</code> = mk_rec <code>|mk_node a [|[|vx;vy|]|]; mk_node b [|[|vx;vy;vy|]|]|</code></p><p>Another example: nested recursive trees rec Y = b(rec X = a(X,Y),Y,Y) let <code>|vy|</code> = mk_rec_calls 1 in let <code>|vx|</code> = mk_rec_calls 1 in let <code>|x|</code> = mk_rec<code>|mk_node a [|[|vx;lift 1 vy|]|]|</code> let <code>|y|</code> = mk_rec<code>|mk_node b [|[|x;vy;vy|]|]|</code> (note the lift so that Y links to the &quot;rec Y&quot; skipping the &quot;rec X&quot;)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_rec" class="anchored"><a href="#val-mk_rec" class="anchor"></a><code><span><span class="keyword">val</span> mk_rec : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> array</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lift" class="anchored"><a href="#val-lift" class="anchor"></a><code><span><span class="keyword">val</span> lift : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>lift k t</code> increases of <code>k</code> the free parameters of <code>t</code>. Needed to avoid captures when a tree appears under <code>mk_rec</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_node" class="anchored"><a href="#val-is_node" class="anchor"></a><code><span><span class="keyword">val</span> is_node : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dest_node" class="anchored"><a href="#val-dest_node" class="anchor"></a><code><span><span class="keyword">val</span> dest_node : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> array</span> array</span></span></code></div><div class="spec-doc"><p>Destructors (recursive calls are expanded)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dest_var" class="anchored"><a href="#val-dest_var" class="anchor"></a><code><span><span class="keyword">val</span> dest_var : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p>dest_var is not needed for closed trees (i.e. with no free variable)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_infinite" class="anchored"><a href="#val-is_infinite" class="anchor"></a><code><span><span class="keyword">val</span> is_infinite : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Tells if a tree has an infinite branch. The first arg is a comparison used to detect already seen elements, hence loops</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equiv" class="anchored"><a href="#val-equiv" class="anchor"></a><code><span><span class="keyword">val</span> equiv : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>Rtree.equiv eq eqlab t1 t2</code> compares t1 t2 (top-down). If t1 and t2 are both nodes, <code>eqlab</code> is called on their labels, in case of success deeper nodes are examined. In case of loop (detected via structural equality parametrized by <code>eq</code>), then the comparison is successful.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>Rtree.equal eq t1 t2</code> compares t1 and t2, first via physical equality, then by structural equality (using <code>eq</code> on elements), then by logical equivalence <code>Rtree.equiv eq eq</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-inter" class="anchored"><a href="#val-inter" class="anchor"></a><code><span><span class="keyword">val</span> inter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-incl" class="anchored"><a href="#val-incl" class="anchor"></a><code><span><span class="keyword">val</span> incl : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><p>Iterators</p><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>See also <code>Smart.map</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-pr_tree" class="anchored"><a href="#val-pr_tree" class="anchor"></a><code><span><span class="keyword">val</span> pr_tree : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Pp/index.html#type-t">Pp.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Pp/index.html#type-t">Pp.t</a></span></code></div><div class="spec-doc"><p>Pretty-printer</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Smart" class="anchored"><a href="#module-Smart" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Smart/index.html">Smart</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>