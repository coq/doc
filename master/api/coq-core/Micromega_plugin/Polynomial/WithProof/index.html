<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>WithProof (coq-core.Micromega_plugin.Polynomial.WithProof)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">coq-core</a> &#x00BB; <a href="../../index.html">Micromega_plugin</a> &#x00BB; <a href="../index.html">Polynomial</a> &#x00BB; WithProof</nav><header class="odoc-preamble"><h1>Module <code><span>Polynomial.WithProof</span></code></h1><p><code>module WithProof</code> constructs polynomials packed with the proof that their sign is correct.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec exception" id="exception-InvalidProof" class="anchored"><a href="#exception-InvalidProof" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">InvalidProof</span></span></code></div><div class="spec-doc"><p><code>InvalidProof</code> is raised if the operation is invalid.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-repr" class="anchored"><a href="#val-repr" class="anchor"></a><code><span><span class="keyword">val</span> repr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>(<a href="../LinPoly/index.html#type-t">LinPoly.t</a> * <a href="../index.html#type-op">op</a>)</span> * <a href="../ProofFormat/index.html#type-prf_rule">ProofFormat.prf_rule</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-proof" class="anchored"><a href="#val-proof" class="anchor"></a><code><span><span class="keyword">val</span> proof : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../ProofFormat/index.html#type-prf_rule">ProofFormat.prf_rule</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-polynomial" class="anchored"><a href="#val-polynomial" class="anchor"></a><code><span><span class="keyword">val</span> polynomial : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../LinPoly/index.html#type-t">LinPoly.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-annot" class="anchored"><a href="#val-annot" class="anchor"></a><code><span><span class="keyword">val</span> annot : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-of_cstr" class="anchored"><a href="#val-of_cstr" class="anchor"></a><code><span><span class="keyword">val</span> of_cstr : <span><span>(<a href="../index.html#type-cstr">cstr</a> * <a href="../ProofFormat/index.html#type-prf_rule">ProofFormat.prf_rule</a>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-output" class="anchored"><a href="#val-output" class="anchor"></a><code><span><span class="keyword">val</span> output : <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>out_channel chan c</code> pretty-prints the constraint <code>c</code> over the channel <code>chan</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-output_sys" class="anchored"><a href="#val-output_sys" class="anchor"></a><code><span><span class="keyword">val</span> output_sys : <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-zero" class="anchored"><a href="#val-zero" class="anchor"></a><code><span><span class="keyword">val</span> zero : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>zero</code> represents the tautology (0=0)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const" class="anchored"><a href="#val-const" class="anchor"></a><code><span><span class="keyword">val</span> const : <span><a href="../../../Micromega_core_plugin/NumCompat/Q/index.html#type-t">Micromega_core_plugin.NumCompat.Q.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>const n</code> represents the tautology (n&gt;=0)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-product" class="anchored"><a href="#val-product" class="anchor"></a><code><span><span class="keyword">val</span> product : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>product p q</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the polynomial p*q with its sign and proof</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-addition" class="anchored"><a href="#val-addition" class="anchor"></a><code><span><span class="keyword">val</span> addition : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>addition p q</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the polynomial p+q with its sign and proof</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-neg" class="anchored"><a href="#val-neg" class="anchor"></a><code><span><span class="keyword">val</span> neg : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>neg p</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the polynomial -p with its sign and proof</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">an</span> <p>error if this not an equality</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-mul_cst" class="anchored"><a href="#val-mul_cst" class="anchor"></a><code><span><span class="keyword">val</span> mul_cst : <span><a href="../../../Micromega_core_plugin/NumCompat/Q/index.html#type-t">Micromega_core_plugin.NumCompat.Q.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>mul_cst c q</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the polynomial c * q with its sign and proof.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-def" class="anchored"><a href="#val-def" class="anchor"></a><code><span><span class="keyword">val</span> def : <span><a href="../LinPoly/index.html#type-t">LinPoly.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-op">op</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>def p op i</code> creates an alias with the variable index <code>i</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-square" class="anchored"><a href="#val-square" class="anchor"></a><code><span><span class="keyword">val</span> square : <span><a href="../LinPoly/index.html#type-t">LinPoly.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../LinPoly/index.html#type-t">LinPoly.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>square p q</code> is q = p^2 &gt;= 0</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkhyp" class="anchored"><a href="#val-mkhyp" class="anchor"></a><code><span><span class="keyword">val</span> mkhyp : <span><a href="../LinPoly/index.html#type-t">LinPoly.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-op">op</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>mkhyp p op i</code> binds p to hypothesis <code>i</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-cutting_plane" class="anchored"><a href="#val-cutting_plane" class="anchor"></a><code><span><span class="keyword">val</span> cutting_plane : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>cutting_plane p</code> does integer reasoning and adjust the constant to be integral</p></div></div><div class="odoc-spec"><div class="spec value" id="val-linear_pivot" class="anchored"><a href="#val-linear_pivot" class="anchor"></a><code><span><span class="keyword">val</span> linear_pivot : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Vect/index.html#type-var">Vect.var</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>linear_pivot sys p x q</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the polynomial <code>q</code> where <code>x</code> is eliminated using the polynomial <code>p</code> The pivoting operation is only defined if</p><ul><li>p is linear in x i.e p = a.x+b and x neither occurs in a and b</li><li>The pivoting also requires some sign conditions for <code>a</code></li></ul></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-simple_pivot" class="anchored"><a href="#val-simple_pivot" class="anchor"></a><code><span><span class="keyword">val</span> simple_pivot : <span><span>(<a href="../../../Micromega_core_plugin/NumCompat/Q/index.html#type-t">Micromega_core_plugin.NumCompat.Q.t</a> * <a href="../index.html#type-var">var</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>simple_pivot (c,x) p q</code> performs a pivoting over the variable <code>x</code> where p = c+a1.x1+....+c.x+...an.xn and c &lt;&gt; 0</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort" class="anchored"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>(int * <span>(<a href="../../../Micromega_core_plugin/NumCompat/Q/index.html#type-t">Micromega_core_plugin.NumCompat.Q.t</a> * <a href="../index.html#type-var">var</a>)</span>)</span> * <a href="#type-t">t</a>)</span> list</span></span></code></div><div class="spec-doc"><p><code>sort sys</code> sorts constraints according to the lexicographic order (number of variables, size of the smallest coefficient</p></div></div><p><code>subst sys</code> performs the equivalent of the 'subst' tactic of Coq. For every p=0 \in sys such that p is linear in x with coefficient +/- 1 i.e. p = 0 &lt;-&gt; x = e and x \notin e. Replace x by e in sys</p><p>NB: performing this transformation may hinders the non-linear prover to find a proof. <code>elim_simple_linear_equality</code> is much more careful.</p><div class="odoc-spec"><div class="spec value" id="val-subst" class="anchored"><a href="#val-subst" class="anchor"></a><code><span><span class="keyword">val</span> subst : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-subst_constant" class="anchored"><a href="#val-subst_constant" class="anchor"></a><code><span><span class="keyword">val</span> subst_constant : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>subst_constant b sys</code> performs the equivalent of the 'subst' tactic of Coq only if there is an equation a.x = c for a,c a constant and a divides c if b= true</p></div></div><div class="odoc-spec"><div class="spec value" id="val-saturate_subst" class="anchored"><a href="#val-saturate_subst" class="anchor"></a><code><span><span class="keyword">val</span> saturate_subst : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div></div></div></body></html>