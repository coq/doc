<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Declarations (coq-core.Declarations)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">coq-core</a> &#x00BB; Declarations</nav><header class="odoc-preamble"><h1>Module <code><span>Declarations</span></code></h1><p>This module defines the internal representation of global declarations. This includes global constants/axioms, mutual inductive definitions, modules and module types</p></header><nav class="odoc-toc"><ul><li><a href="#representation-of-constants-(definition/axiom)">Representation of constants (Definition/Axiom)</a></li><li><a href="#representation-of-definitions/assumptions-in-the-kernel">Representation of definitions/assumptions in the kernel</a></li><li><a href="#datas-associated-to-a-full-block-of-mutually-inductive-types">Datas associated to a full block of mutually inductive types</a></li><li><a href="#module-declarations">Module declarations</a></li></ul></nav><div class="odoc-content"><h6 id="representation-of-constants-(definition/axiom)"><a href="#representation-of-constants-(definition/axiom)" class="anchor"></a>Representation of constants (Definition/Axiom)</h6><p>Non-universe polymorphic mode polymorphism (Coq 8.2+): inductives and constants hiding inductives are implicitly polymorphic when applied to parameters, on the universes appearing in the whnf of their parameters and their conclusion, in a template style.</p><p>In truly universe polymorphic mode, we always use RegularArity.</p><div class="odoc-spec"><div class="spec type" id="type-template_arity" class="anchored"><a href="#type-template_arity" class="anchor"></a><code><span><span class="keyword">type</span> template_arity</span><span> = </span><span>{</span></code><table><tr id="type-template_arity.template_level" class="anchored"><td class="def record field"><a href="#type-template_arity.template_level" class="anchor"></a><code><span>template_level : <a href="../Sorts/index.html#type-t">Sorts.t</a>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-template_universes" class="anchored"><a href="#type-template_universes" class="anchor"></a><code><span><span class="keyword">type</span> template_universes</span><span> = </span><span>{</span></code><table><tr id="type-template_universes.template_param_levels" class="anchored"><td class="def record field"><a href="#type-template_universes.template_param_levels" class="anchor"></a><code><span>template_param_levels : <span><span><a href="../Univ/Level/index.html#type-t">Univ.Level.t</a> option</span> list</span>;</span></code></td></tr><tr id="type-template_universes.template_context" class="anchored"><td class="def record field"><a href="#type-template_universes.template_context" class="anchor"></a><code><span>template_context : <a href="../Univ/ContextSet/index.html#type-t">Univ.ContextSet.t</a>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-declaration_arity" class="anchored"><a href="#type-declaration_arity" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) declaration_arity</span></span><span> = </span></code><table><tr id="type-declaration_arity.RegularArity" class="anchored"><td class="def variant constructor"><a href="#type-declaration_arity.RegularArity" class="anchor"></a><code><span>| </span><span><span class="constructor">RegularArity</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td></tr><tr id="type-declaration_arity.TemplateArity" class="anchored"><td class="def variant constructor"><a href="#type-declaration_arity.TemplateArity" class="anchor"></a><code><span>| </span><span><span class="constructor">TemplateArity</span> <span class="keyword">of</span> <span class="type-var">'b</span></span></code></td></tr></table></div></div><p>Inlining level of parameters at functor applications. None means no inlining</p><div class="odoc-spec"><div class="spec type" id="type-inline" class="anchored"><a href="#type-inline" class="anchor"></a><code><span><span class="keyword">type</span> inline</span><span> = <span>int option</span></span></code></div></div><p>A constant can have no body (axiom/parameter), or a transparent body, or an opaque one</p><div class="odoc-spec"><div class="spec type" id="type-constant_def" class="anchored"><a href="#type-constant_def" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'opaque) constant_def</span></span><span> = </span></code><table><tr id="type-constant_def.Undef" class="anchored"><td class="def variant constructor"><a href="#type-constant_def.Undef" class="anchor"></a><code><span>| </span><span><span class="constructor">Undef</span> <span class="keyword">of</span> <a href="#type-inline">inline</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>a global assumption</p><span class="comment-delim">*)</span></td></tr><tr id="type-constant_def.Def" class="anchored"><td class="def variant constructor"><a href="#type-constant_def.Def" class="anchor"></a><code><span>| </span><span><span class="constructor">Def</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>or a transparent global definition</p><span class="comment-delim">*)</span></td></tr><tr id="type-constant_def.OpaqueDef" class="anchored"><td class="def variant constructor"><a href="#type-constant_def.OpaqueDef" class="anchor"></a><code><span>| </span><span><span class="constructor">OpaqueDef</span> <span class="keyword">of</span> <span class="type-var">'opaque</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>or an opaque global definition</p><span class="comment-delim">*)</span></td></tr><tr id="type-constant_def.Primitive" class="anchored"><td class="def variant constructor"><a href="#type-constant_def.Primitive" class="anchor"></a><code><span>| </span><span><span class="constructor">Primitive</span> <span class="keyword">of</span> <a href="../CPrimitives/index.html#type-t">CPrimitives.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>or a primitive operation</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-universes" class="anchored"><a href="#type-universes" class="anchor"></a><code><span><span class="keyword">type</span> universes</span><span> = </span></code><table><tr id="type-universes.Monomorphic" class="anchored"><td class="def variant constructor"><a href="#type-universes.Monomorphic" class="anchor"></a><code><span>| </span><span><span class="constructor">Monomorphic</span></span></code></td></tr><tr id="type-universes.Polymorphic" class="anchored"><td class="def variant constructor"><a href="#type-universes.Polymorphic" class="anchor"></a><code><span>| </span><span><span class="constructor">Polymorphic</span> <span class="keyword">of</span> <a href="../UVars/AbstractContext/index.html#type-t">UVars.AbstractContext.t</a></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-typing_flags" class="anchored"><a href="#type-typing_flags" class="anchor"></a><code><span><span class="keyword">type</span> typing_flags</span><span> = </span><span>{</span></code><table><tr id="type-typing_flags.check_guarded" class="anchored"><td class="def record field"><a href="#type-typing_flags.check_guarded" class="anchor"></a><code><span>check_guarded : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>If <code>false</code> then fixed points and co-fixed points are assumed to be total.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typing_flags.check_positive" class="anchored"><td class="def record field"><a href="#type-typing_flags.check_positive" class="anchor"></a><code><span>check_positive : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>If <code>false</code> then inductive types are assumed positive and co-inductive types are assumed productive.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typing_flags.check_universes" class="anchored"><td class="def record field"><a href="#type-typing_flags.check_universes" class="anchor"></a><code><span>check_universes : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>If <code>false</code> universe constraints are not checked</p><span class="comment-delim">*)</span></td></tr><tr id="type-typing_flags.conv_oracle" class="anchored"><td class="def record field"><a href="#type-typing_flags.conv_oracle" class="anchor"></a><code><span>conv_oracle : <a href="../Conv_oracle/index.html#type-oracle">Conv_oracle.oracle</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Unfolding strategies for conversion</p><span class="comment-delim">*)</span></td></tr><tr id="type-typing_flags.share_reduction" class="anchored"><td class="def record field"><a href="#type-typing_flags.share_reduction" class="anchor"></a><code><span>share_reduction : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Use by-need reduction algorithm</p><span class="comment-delim">*)</span></td></tr><tr id="type-typing_flags.enable_VM" class="anchored"><td class="def record field"><a href="#type-typing_flags.enable_VM" class="anchor"></a><code><span>enable_VM : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>If <code>false</code>, all VM conversions fall back to interpreted ones</p><span class="comment-delim">*)</span></td></tr><tr id="type-typing_flags.enable_native_compiler" class="anchored"><td class="def record field"><a href="#type-typing_flags.enable_native_compiler" class="anchor"></a><code><span>enable_native_compiler : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>If <code>false</code>, all native conversions fall back to VM ones</p><span class="comment-delim">*)</span></td></tr><tr id="type-typing_flags.indices_matter" class="anchored"><td class="def record field"><a href="#type-typing_flags.indices_matter" class="anchor"></a><code><span>indices_matter : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The universe of an inductive type must be above that of its indices.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typing_flags.impredicative_set" class="anchored"><td class="def record field"><a href="#type-typing_flags.impredicative_set" class="anchor"></a><code><span>impredicative_set : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Predicativity of the <code>Set</code> universe.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typing_flags.sprop_allowed" class="anchored"><td class="def record field"><a href="#type-typing_flags.sprop_allowed" class="anchor"></a><code><span>sprop_allowed : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>If <code>false</code>, error when encountering <code>SProp</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typing_flags.allow_uip" class="anchored"><td class="def record field"><a href="#type-typing_flags.allow_uip" class="anchor"></a><code><span>allow_uip : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Allow definitional UIP (breaks termination)</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The <code>typing_flags</code> are instructions to the type-checker which modify its behaviour. The typing flags used in the type-checking of a constant are tracked in their <a href="#type-constant_body"><code>constant_body</code></a> so that they can be displayed to the user.</p></div></div><h6 id="representation-of-definitions/assumptions-in-the-kernel"><a href="#representation-of-definitions/assumptions-in-the-kernel" class="anchor"></a>Representation of definitions/assumptions in the kernel</h6><div class="odoc-spec"><div class="spec type" id="type-pconstant_body" class="anchored"><a href="#type-pconstant_body" class="anchor"></a><code><span><span class="keyword">type</span> <span>'opaque pconstant_body</span></span><span> = </span><span>{</span></code><table><tr id="type-pconstant_body.const_hyps" class="anchored"><td class="def record field"><a href="#type-pconstant_body.const_hyps" class="anchor"></a><code><span>const_hyps : <a href="../Constr/index.html#type-named_context">Constr.named_context</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>younger hyp at top</p><span class="comment-delim">*)</span></td></tr><tr id="type-pconstant_body.const_univ_hyps" class="anchored"><td class="def record field"><a href="#type-pconstant_body.const_univ_hyps" class="anchor"></a><code><span>const_univ_hyps : <a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a>;</span></code></td></tr><tr id="type-pconstant_body.const_body" class="anchored"><td class="def record field"><a href="#type-pconstant_body.const_body" class="anchor"></a><code><span>const_body : <span><span>(<a href="../Constr/index.html#type-t">Constr.t</a>,Â <span class="type-var">'opaque</span>)</span> <a href="#type-constant_def">constant_def</a></span>;</span></code></td></tr><tr id="type-pconstant_body.const_type" class="anchored"><td class="def record field"><a href="#type-pconstant_body.const_type" class="anchor"></a><code><span>const_type : <a href="../Constr/index.html#type-types">Constr.types</a>;</span></code></td></tr><tr id="type-pconstant_body.const_relevance" class="anchored"><td class="def record field"><a href="#type-pconstant_body.const_relevance" class="anchor"></a><code><span>const_relevance : <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a>;</span></code></td></tr><tr id="type-pconstant_body.const_body_code" class="anchored"><td class="def record field"><a href="#type-pconstant_body.const_body_code" class="anchor"></a><code><span>const_body_code : <span><a href="../Vmemitcodes/index.html#type-body_code">Vmemitcodes.body_code</a> option</span>;</span></code></td></tr><tr id="type-pconstant_body.const_universes" class="anchored"><td class="def record field"><a href="#type-pconstant_body.const_universes" class="anchor"></a><code><span>const_universes : <a href="#type-universes">universes</a>;</span></code></td></tr><tr id="type-pconstant_body.const_inline_code" class="anchored"><td class="def record field"><a href="#type-pconstant_body.const_inline_code" class="anchor"></a><code><span>const_inline_code : bool;</span></code></td></tr><tr id="type-pconstant_body.const_typing_flags" class="anchored"><td class="def record field"><a href="#type-pconstant_body.const_typing_flags" class="anchor"></a><code><span>const_typing_flags : <a href="#type-typing_flags">typing_flags</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The typing options which were used for type-checking.</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-constant_body" class="anchored"><a href="#type-constant_body" class="anchor"></a><code><span><span class="keyword">type</span> constant_body</span><span> = <span><a href="../Opaqueproof/index.html#type-opaque">Opaqueproof.opaque</a> <a href="#type-pconstant_body">pconstant_body</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-nested_type" class="anchored"><a href="#type-nested_type" class="anchor"></a><code><span><span class="keyword">type</span> nested_type</span><span> = </span></code><table><tr id="type-nested_type.NestedInd" class="anchored"><td class="def variant constructor"><a href="#type-nested_type.NestedInd" class="anchor"></a><code><span>| </span><span><span class="constructor">NestedInd</span> <span class="keyword">of</span> <a href="../Names/index.html#type-inductive">Names.inductive</a></span></code></td></tr><tr id="type-nested_type.NestedPrimitive" class="anchored"><td class="def variant constructor"><a href="#type-nested_type.NestedPrimitive" class="anchor"></a><code><span>| </span><span><span class="constructor">NestedPrimitive</span> <span class="keyword">of</span> <a href="../Names/Constant/index.html#type-t">Names.Constant.t</a></span></code></td></tr></table></div><div class="spec-doc"><p>Representation of mutual inductive types in the kernel</p></div></div><div class="odoc-spec"><div class="spec type" id="type-recarg" class="anchored"><a href="#type-recarg" class="anchor"></a><code><span><span class="keyword">type</span> recarg</span><span> = </span></code><table><tr id="type-recarg.Norec" class="anchored"><td class="def variant constructor"><a href="#type-recarg.Norec" class="anchor"></a><code><span>| </span><span><span class="constructor">Norec</span></span></code></td></tr><tr id="type-recarg.Mrec" class="anchored"><td class="def variant constructor"><a href="#type-recarg.Mrec" class="anchor"></a><code><span>| </span><span><span class="constructor">Mrec</span> <span class="keyword">of</span> <a href="../Names/index.html#type-inductive">Names.inductive</a></span></code></td></tr><tr id="type-recarg.Nested" class="anchored"><td class="def variant constructor"><a href="#type-recarg.Nested" class="anchor"></a><code><span>| </span><span><span class="constructor">Nested</span> <span class="keyword">of</span> <a href="#type-nested_type">nested_type</a></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-wf_paths" class="anchored"><a href="#type-wf_paths" class="anchor"></a><code><span><span class="keyword">type</span> wf_paths</span><span> = <span><a href="#type-recarg">recarg</a> <a href="../Rtree/index.html#type-t">Rtree.t</a></span></span></code></div></div><pre>   Inductive I1 (params) : U1 := c11 : T11 | ... | c1p1 : T1p1
   ...
   with      In (params) : Un := cn1 : Tn1 | ... | cnpn : Tnpn</pre><p>Record information: If the type is not a record, then NotRecord If the type is a non-primitive record, then FakeRecord If it is a primitive record, for every type in the block, we get:</p><ul><li>The identifier for the binder name of the record in primitive projections.</li><li>The constants associated to each projection.</li><li>The projection types (under parameters).</li></ul><p>The kernel does not exploit the difference between <code>NotRecord</code> and <code>FakeRecord</code>. It is mostly used by extraction, and should be extruded from the kernel at some point.</p><div class="odoc-spec"><div class="spec type" id="type-record_info" class="anchored"><a href="#type-record_info" class="anchor"></a><code><span><span class="keyword">type</span> record_info</span><span> = </span></code><table><tr id="type-record_info.NotRecord" class="anchored"><td class="def variant constructor"><a href="#type-record_info.NotRecord" class="anchor"></a><code><span>| </span><span><span class="constructor">NotRecord</span></span></code></td></tr><tr id="type-record_info.FakeRecord" class="anchored"><td class="def variant constructor"><a href="#type-record_info.FakeRecord" class="anchor"></a><code><span>| </span><span><span class="constructor">FakeRecord</span></span></code></td></tr><tr id="type-record_info.PrimRecord" class="anchored"><td class="def variant constructor"><a href="#type-record_info.PrimRecord" class="anchor"></a><code><span>| </span><span><span class="constructor">PrimRecord</span> <span class="keyword">of</span> <span><span>(<a href="../Names/Id/index.html#type-t">Names.Id.t</a> * <span><a href="../Names/Label/index.html#type-t">Names.Label.t</a> array</span> * <span><a href="../Sorts/index.html#type-relevance">Sorts.relevance</a> array</span> * <span><a href="../Constr/index.html#type-types">Constr.types</a> array</span>)</span> array</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-regular_inductive_arity" class="anchored"><a href="#type-regular_inductive_arity" class="anchor"></a><code><span><span class="keyword">type</span> regular_inductive_arity</span><span> = </span><span>{</span></code><table><tr id="type-regular_inductive_arity.mind_user_arity" class="anchored"><td class="def record field"><a href="#type-regular_inductive_arity.mind_user_arity" class="anchor"></a><code><span>mind_user_arity : <a href="../Constr/index.html#type-types">Constr.types</a>;</span></code></td></tr><tr id="type-regular_inductive_arity.mind_sort" class="anchored"><td class="def record field"><a href="#type-regular_inductive_arity.mind_sort" class="anchor"></a><code><span>mind_sort : <a href="../Sorts/index.html#type-t">Sorts.t</a>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-inductive_arity" class="anchored"><a href="#type-inductive_arity" class="anchor"></a><code><span><span class="keyword">type</span> inductive_arity</span><span> = <span><span>(<a href="#type-regular_inductive_arity">regular_inductive_arity</a>,Â <a href="#type-template_arity">template_arity</a>)</span> <a href="#type-declaration_arity">declaration_arity</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-squash_info" class="anchored"><a href="#type-squash_info" class="anchor"></a><code><span><span class="keyword">type</span> squash_info</span><span> = </span></code><table><tr id="type-squash_info.AlwaysSquashed" class="anchored"><td class="def variant constructor"><a href="#type-squash_info.AlwaysSquashed" class="anchor"></a><code><span>| </span><span><span class="constructor">AlwaysSquashed</span></span></code></td></tr><tr id="type-squash_info.SometimesSquashed" class="anchored"><td class="def variant constructor"><a href="#type-squash_info.SometimesSquashed" class="anchor"></a><code><span>| </span><span><span class="constructor">SometimesSquashed</span> <span class="keyword">of</span> <a href="../Sorts/Quality/Set/index.html#type-t">Sorts.Quality.Set.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A sort polymorphic inductive <code>I@{...|...|...} : ... -&gt; Type@{ s|...}</code> is squashed at a given instantiation if any quality in the list is not smaller than <code>s</code>.</p><p>NB: if <code>s</code> is a variable SometimesSquashed contains SProp ie non ground instantiations are squashed.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-one_inductive_body" class="anchored"><a href="#type-one_inductive_body" class="anchor"></a><code><span><span class="keyword">type</span> one_inductive_body</span><span> = </span><span>{</span></code><table><tr id="type-one_inductive_body.mind_typename" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_typename" class="anchor"></a><code><span>mind_typename : <a href="../Names/Id/index.html#type-t">Names.Id.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Name of the type: <code>Ii</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_arity_ctxt" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_arity_ctxt" class="anchor"></a><code><span>mind_arity_ctxt : <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Arity context of <code>Ii</code>. It includes the context of parameters, that is, it has the form <code>paramdecls, realdecls_i</code> such that <code>Ui</code> (see above) is <code>forall realdecls_i, si</code> for some sort <code>si</code> and such that <code>Ii</code> has thus type <code>forall paramdecls, forall
     realdecls_i, si</code>. The context itself is represented internally as a list in reverse order <code>[realdecl_i{r_i};...;realdecl_i1;paramdecl_m;...;paramdecl_1]</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_arity" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_arity" class="anchor"></a><code><span>mind_arity : <a href="#type-inductive_arity">inductive_arity</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Arity sort and original user arity</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_consnames" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_consnames" class="anchor"></a><code><span>mind_consnames : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> array</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Names of the constructors: <code>cij</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_user_lc" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_user_lc" class="anchor"></a><code><span>mind_user_lc : <span><a href="../Constr/index.html#type-types">Constr.types</a> array</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Types of the constructors with parameters: <code>forall params, Tij</code>, where the recursive occurrences of the inductive types in <code>Tij</code> (i.e. in the type of the j-th constructor of the i-th types of the block a shown above) have the form <code>Ind ((mind,0),u)</code>, ..., <code>Ind ((mind,n-1),u)</code> for <code>u</code> the canonical abstract instance associated to <code>mind_universes</code> and <code>mind</code> the name to which the inductive block is bound in the environment.</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_nrealargs" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_nrealargs" class="anchor"></a><code><span>mind_nrealargs : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Number of expected real arguments of the type (no let, no params)</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_nrealdecls" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_nrealdecls" class="anchor"></a><code><span>mind_nrealdecls : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Length of realargs context (with let, no params)</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_squashed" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_squashed" class="anchor"></a><code><span>mind_squashed : <span><a href="#type-squash_info">squash_info</a> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Is elimination restricted to the inductive's sort?</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_nf_lc" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_nf_lc" class="anchor"></a><code><span>mind_nf_lc : <span><span>(<a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-types">Constr.types</a>)</span> array</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Head normalized constructor types so that their conclusion exposes the inductive type. It includes the parameters, i.e. each component of the array has the form <code>(decls_ij, Ii params realargs_ij)</code> where <code>decls_ij</code> is the concatenation of the context of parameters (possibly with let-ins) and of the arguments of the constructor (possibly with let-ins). This context is internally represented as a list <code>[cstrdecl_ij{q_ij};...;cstrdecl_ij1;paramdecl_m;...;paramdecl_1]</code> such that the constructor in fine has type <code>forall paramdecls,
     forall cstrdecls_ij, Ii params realargs_ij</code> with <code>params</code> referring to the assumptions of <code>paramdecls</code> and <code>realargs_ij</code> being the &quot;indices&quot; specific to the constructor.</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_consnrealargs" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_consnrealargs" class="anchor"></a><code><span>mind_consnrealargs : <span>int array</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Number of expected proper arguments of the constructors (w/o params)</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_consnrealdecls" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_consnrealdecls" class="anchor"></a><code><span>mind_consnrealdecls : <span>int array</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Length of the signature of the constructors (with let, w/o params)</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_recargs" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_recargs" class="anchor"></a><code><span>mind_recargs : <a href="#type-wf_paths">wf_paths</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Signature of recursive arguments in the constructors</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_relevance" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_relevance" class="anchor"></a><code><span>mind_relevance : <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a>;</span></code></td></tr><tr id="type-one_inductive_body.mind_nb_constant" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_nb_constant" class="anchor"></a><code><span>mind_nb_constant : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>number of constant constructor</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_nb_args" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_nb_args" class="anchor"></a><code><span>mind_nb_args : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>number of no constant constructor</p><span class="comment-delim">*)</span></td></tr><tr id="type-one_inductive_body.mind_reloc_tbl" class="anchored"><td class="def record field"><a href="#type-one_inductive_body.mind_reloc_tbl" class="anchor"></a><code><span>mind_reloc_tbl : <a href="../Vmvalues/index.html#type-reloc_table">Vmvalues.reloc_table</a>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Datas specific to a single type of a block of mutually inductive type</p></div></div><div class="odoc-spec"><div class="spec type" id="type-recursivity_kind" class="anchored"><a href="#type-recursivity_kind" class="anchor"></a><code><span><span class="keyword">type</span> recursivity_kind</span><span> = </span></code><table><tr id="type-recursivity_kind.Finite" class="anchored"><td class="def variant constructor"><a href="#type-recursivity_kind.Finite" class="anchor"></a><code><span>| </span><span><span class="constructor">Finite</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>= inductive</p><span class="comment-delim">*)</span></td></tr><tr id="type-recursivity_kind.CoFinite" class="anchored"><td class="def variant constructor"><a href="#type-recursivity_kind.CoFinite" class="anchor"></a><code><span>| </span><span><span class="constructor">CoFinite</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>= coinductive</p><span class="comment-delim">*)</span></td></tr><tr id="type-recursivity_kind.BiFinite" class="anchored"><td class="def variant constructor"><a href="#type-recursivity_kind.BiFinite" class="anchor"></a><code><span>| </span><span><span class="constructor">BiFinite</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>= non-recursive, like in &quot;Record&quot; definitions</p><span class="comment-delim">*)</span></td></tr></table></div></div><h6 id="datas-associated-to-a-full-block-of-mutually-inductive-types"><a href="#datas-associated-to-a-full-block-of-mutually-inductive-types" class="anchor"></a>Datas associated to a full block of mutually inductive types</h6><div class="odoc-spec"><div class="spec type" id="type-mutual_inductive_body" class="anchored"><a href="#type-mutual_inductive_body" class="anchor"></a><code><span><span class="keyword">type</span> mutual_inductive_body</span><span> = </span><span>{</span></code><table><tr id="type-mutual_inductive_body.mind_packets" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_packets" class="anchor"></a><code><span>mind_packets : <span><a href="#type-one_inductive_body">one_inductive_body</a> array</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The component of the mutual inductive block</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_record" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_record" class="anchor"></a><code><span>mind_record : <a href="#type-record_info">record_info</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The record information</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_finite" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_finite" class="anchor"></a><code><span>mind_finite : <a href="#type-recursivity_kind">recursivity_kind</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Whether the type is inductive, coinductive or non-recursive</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_ntypes" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_ntypes" class="anchor"></a><code><span>mind_ntypes : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Number of types in the block</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_hyps" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_hyps" class="anchor"></a><code><span>mind_hyps : <a href="../Constr/index.html#type-named_context">Constr.named_context</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Section hypotheses on which the block depends</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_univ_hyps" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_univ_hyps" class="anchor"></a><code><span>mind_univ_hyps : <a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Section polymorphic universes.</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_nparams" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_nparams" class="anchor"></a><code><span>mind_nparams : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Number of expected parameters including non-uniform ones (i.e. length of mind_params_ctxt w/o let-in)</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_nparams_rec" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_nparams_rec" class="anchor"></a><code><span>mind_nparams_rec : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Number of recursively uniform (i.e. ordinary) parameters</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_params_ctxt" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_params_ctxt" class="anchor"></a><code><span>mind_params_ctxt : <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The context of parameters (includes let-in declaration)</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_universes" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_universes" class="anchor"></a><code><span>mind_universes : <a href="#type-universes">universes</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Information about monomorphic/polymorphic/cumulative inductives and their universes</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_template" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_template" class="anchor"></a><code><span>mind_template : <span><a href="#type-template_universes">template_universes</a> option</span>;</span></code></td></tr><tr id="type-mutual_inductive_body.mind_variance" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_variance" class="anchor"></a><code><span>mind_variance : <span><span><a href="../UVars/Variance/index.html#type-t">UVars.Variance.t</a> array</span> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Variance info, <code>None</code> when non-cumulative.</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_sec_variance" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_sec_variance" class="anchor"></a><code><span>mind_sec_variance : <span><span><a href="../UVars/Variance/index.html#type-t">UVars.Variance.t</a> array</span> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Variance info for section polymorphic universes. <code>None</code> outside sections. The final variance once all sections are discharged is <code>mind_sec_variance ++ mind_variance</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_private" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_private" class="anchor"></a><code><span>mind_private : <span>bool option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>allow pattern-matching: Some true ok, Some false blocked</p><span class="comment-delim">*)</span></td></tr><tr id="type-mutual_inductive_body.mind_typing_flags" class="anchored"><td class="def record field"><a href="#type-mutual_inductive_body.mind_typing_flags" class="anchor"></a><code><span>mind_typing_flags : <a href="#type-typing_flags">typing_flags</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>typing flags at the time of the inductive creation</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-mind_specif" class="anchored"><a href="#type-mind_specif" class="anchor"></a><code><span><span class="keyword">type</span> mind_specif</span><span> = <a href="#type-mutual_inductive_body">mutual_inductive_body</a> * <a href="#type-one_inductive_body">one_inductive_body</a></span></code></div></div><h6 id="module-declarations"><a href="#module-declarations" class="anchor"></a>Module declarations</h6><p>Functor expressions are forced to be on top of other expressions</p><div class="odoc-spec"><div class="spec type" id="type-functorize" class="anchored"><a href="#type-functorize" class="anchor"></a><code><span><span class="keyword">type</span> <span>('ty, 'a) functorize</span></span><span> = </span></code><table><tr id="type-functorize.NoFunctor" class="anchored"><td class="def variant constructor"><a href="#type-functorize.NoFunctor" class="anchor"></a><code><span>| </span><span><span class="constructor">NoFunctor</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td></tr><tr id="type-functorize.MoreFunctor" class="anchored"><td class="def variant constructor"><a href="#type-functorize.MoreFunctor" class="anchor"></a><code><span>| </span><span><span class="constructor">MoreFunctor</span> <span class="keyword">of</span> <a href="../Names/MBId/index.html#type-t">Names.MBId.t</a> * <span class="type-var">'ty</span> * <span><span>(<span class="type-var">'ty</span>,Â <span class="type-var">'a</span>)</span> <a href="#type-functorize">functorize</a></span></span></code></td></tr></table></div></div><p>The fully-algebraic module expressions : names, applications, 'with ...'. They correspond to the user entries of non-interactive modules. They will be later expanded into module structures in <code>Mod_typing</code>, and won't play any role into the kernel after that : they are kept only for short module printing and for extraction.</p><div class="odoc-spec"><div class="spec type" id="type-with_declaration" class="anchored"><a href="#type-with_declaration" class="anchor"></a><code><span><span class="keyword">type</span> <span>'uconstr with_declaration</span></span><span> = </span></code><table><tr id="type-with_declaration.WithMod" class="anchored"><td class="def variant constructor"><a href="#type-with_declaration.WithMod" class="anchor"></a><code><span>| </span><span><span class="constructor">WithMod</span> <span class="keyword">of</span> <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> * <a href="../Names/ModPath/index.html#type-t">Names.ModPath.t</a></span></code></td></tr><tr id="type-with_declaration.WithDef" class="anchored"><td class="def variant constructor"><a href="#type-with_declaration.WithDef" class="anchor"></a><code><span>| </span><span><span class="constructor">WithDef</span> <span class="keyword">of</span> <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> * <span class="type-var">'uconstr</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-module_alg_expr" class="anchored"><a href="#type-module_alg_expr" class="anchor"></a><code><span><span class="keyword">type</span> <span>'uconstr module_alg_expr</span></span><span> = </span></code><table><tr id="type-module_alg_expr.MEident" class="anchored"><td class="def variant constructor"><a href="#type-module_alg_expr.MEident" class="anchor"></a><code><span>| </span><span><span class="constructor">MEident</span> <span class="keyword">of</span> <a href="../Names/ModPath/index.html#type-t">Names.ModPath.t</a></span></code></td></tr><tr id="type-module_alg_expr.MEapply" class="anchored"><td class="def variant constructor"><a href="#type-module_alg_expr.MEapply" class="anchor"></a><code><span>| </span><span><span class="constructor">MEapply</span> <span class="keyword">of</span> <span><span class="type-var">'uconstr</span> <a href="#type-module_alg_expr">module_alg_expr</a></span> * <a href="../Names/ModPath/index.html#type-t">Names.ModPath.t</a></span></code></td></tr><tr id="type-module_alg_expr.MEwith" class="anchored"><td class="def variant constructor"><a href="#type-module_alg_expr.MEwith" class="anchor"></a><code><span>| </span><span><span class="constructor">MEwith</span> <span class="keyword">of</span> <span><span class="type-var">'uconstr</span> <a href="#type-module_alg_expr">module_alg_expr</a></span> * <span><span class="type-var">'uconstr</span> <a href="#type-with_declaration">with_declaration</a></span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-functor_alg_expr" class="anchored"><a href="#type-functor_alg_expr" class="anchor"></a><code><span><span class="keyword">type</span> <span>'uconstr functor_alg_expr</span></span><span> = </span></code><table><tr id="type-functor_alg_expr.MENoFunctor" class="anchored"><td class="def variant constructor"><a href="#type-functor_alg_expr.MENoFunctor" class="anchor"></a><code><span>| </span><span><span class="constructor">MENoFunctor</span> <span class="keyword">of</span> <span><span class="type-var">'uconstr</span> <a href="#type-module_alg_expr">module_alg_expr</a></span></span></code></td></tr><tr id="type-functor_alg_expr.MEMoreFunctor" class="anchored"><td class="def variant constructor"><a href="#type-functor_alg_expr.MEMoreFunctor" class="anchor"></a><code><span>| </span><span><span class="constructor">MEMoreFunctor</span> <span class="keyword">of</span> <span><span class="type-var">'uconstr</span> <a href="#type-functor_alg_expr">functor_alg_expr</a></span></span></code></td></tr></table></div></div><p>A module expression is an algebraic expression, possibly functorized.</p><div class="odoc-spec"><div class="spec type" id="type-module_expression" class="anchored"><a href="#type-module_expression" class="anchor"></a><code><span><span class="keyword">type</span> module_expression</span><span> = <span><span>(<a href="../Constr/index.html#type-constr">Constr.constr</a> * <span><a href="../UVars/AbstractContext/index.html#type-t">UVars.AbstractContext.t</a> option</span>)</span> <a href="#type-functor_alg_expr">functor_alg_expr</a></span></span></code></div></div><p>A component of a module structure</p><div class="odoc-spec"><div class="spec type" id="type-structure_field_body" class="anchored"><a href="#type-structure_field_body" class="anchor"></a><code><span><span class="keyword">type</span> structure_field_body</span><span> = </span></code><table><tr id="type-structure_field_body.SFBconst" class="anchored"><td class="def variant constructor"><a href="#type-structure_field_body.SFBconst" class="anchor"></a><code><span>| </span><span><span class="constructor">SFBconst</span> <span class="keyword">of</span> <a href="#type-constant_body">constant_body</a></span></code></td></tr><tr id="type-structure_field_body.SFBmind" class="anchored"><td class="def variant constructor"><a href="#type-structure_field_body.SFBmind" class="anchor"></a><code><span>| </span><span><span class="constructor">SFBmind</span> <span class="keyword">of</span> <a href="#type-mutual_inductive_body">mutual_inductive_body</a></span></code></td></tr><tr id="type-structure_field_body.SFBmodule" class="anchored"><td class="def variant constructor"><a href="#type-structure_field_body.SFBmodule" class="anchor"></a><code><span>| </span><span><span class="constructor">SFBmodule</span> <span class="keyword">of</span> <a href="#type-module_body">module_body</a></span></code></td></tr><tr id="type-structure_field_body.SFBmodtype" class="anchored"><td class="def variant constructor"><a href="#type-structure_field_body.SFBmodtype" class="anchor"></a><code><span>| </span><span><span class="constructor">SFBmodtype</span> <span class="keyword">of</span> <a href="#type-module_type_body">module_type_body</a></span></code></td></tr></table></div></div><p>A module structure is a list of labeled components.</p><p>Note : we may encounter now (at most) twice the same label in a <code>structure_body</code>, once for a module (<code>SFBmodule</code> or <code>SFBmodtype</code>) and once for an object (<code>SFBconst</code> or <code>SFBmind</code>)</p><div class="odoc-spec"><div class="spec type" id="type-structure_body" class="anchored"><a href="#type-structure_body" class="anchor"></a><code><span><span class="keyword">and</span> structure_body</span><span> = <span><span>(<a href="../Names/Label/index.html#type-t">Names.Label.t</a> * <a href="#type-structure_field_body">structure_field_body</a>)</span> list</span></span></code></div></div><p>A module signature is a structure, with possibly functors on top of it</p><div class="odoc-spec"><div class="spec type" id="type-module_signature" class="anchored"><a href="#type-module_signature" class="anchor"></a><code><span><span class="keyword">and</span> module_signature</span><span> = <span><span>(<a href="#type-module_type_body">module_type_body</a>,Â <a href="#type-structure_body">structure_body</a>)</span> <a href="#type-functorize">functorize</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-module_implementation" class="anchored"><a href="#type-module_implementation" class="anchor"></a><code><span><span class="keyword">and</span> module_implementation</span><span> = </span></code><table><tr id="type-module_implementation.Abstract" class="anchored"><td class="def variant constructor"><a href="#type-module_implementation.Abstract" class="anchor"></a><code><span>| </span><span><span class="constructor">Abstract</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>no accessible implementation</p><span class="comment-delim">*)</span></td></tr><tr id="type-module_implementation.Algebraic" class="anchored"><td class="def variant constructor"><a href="#type-module_implementation.Algebraic" class="anchor"></a><code><span>| </span><span><span class="constructor">Algebraic</span> <span class="keyword">of</span> <a href="#type-module_expression">module_expression</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>non-interactive algebraic expression</p><span class="comment-delim">*)</span></td></tr><tr id="type-module_implementation.Struct" class="anchored"><td class="def variant constructor"><a href="#type-module_implementation.Struct" class="anchor"></a><code><span>| </span><span><span class="constructor">Struct</span> <span class="keyword">of</span> <a href="#type-structure_body">structure_body</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>interactive body living in the parameter context of <code>mod_type</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-module_implementation.FullStruct" class="anchored"><td class="def variant constructor"><a href="#type-module_implementation.FullStruct" class="anchor"></a><code><span>| </span><span><span class="constructor">FullStruct</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>special case of <code>Struct</code> : the body is exactly <code>mod_type</code></p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-generic_module_body" class="anchored"><a href="#type-generic_module_body" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a generic_module_body</span></span><span> = </span><span>{</span></code><table><tr id="type-generic_module_body.mod_mp" class="anchored"><td class="def record field"><a href="#type-generic_module_body.mod_mp" class="anchor"></a><code><span>mod_mp : <a href="../Names/ModPath/index.html#type-t">Names.ModPath.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>absolute path of the module</p><span class="comment-delim">*)</span></td></tr><tr id="type-generic_module_body.mod_expr" class="anchored"><td class="def record field"><a href="#type-generic_module_body.mod_expr" class="anchor"></a><code><span>mod_expr : <span class="type-var">'a</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>implementation</p><span class="comment-delim">*)</span></td></tr><tr id="type-generic_module_body.mod_type" class="anchored"><td class="def record field"><a href="#type-generic_module_body.mod_type" class="anchor"></a><code><span>mod_type : <a href="#type-module_signature">module_signature</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>expanded type</p><span class="comment-delim">*)</span></td></tr><tr id="type-generic_module_body.mod_type_alg" class="anchored"><td class="def record field"><a href="#type-generic_module_body.mod_type_alg" class="anchor"></a><code><span>mod_type_alg : <span><a href="#type-module_expression">module_expression</a> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>algebraic type</p><span class="comment-delim">*)</span></td></tr><tr id="type-generic_module_body.mod_delta" class="anchored"><td class="def record field"><a href="#type-generic_module_body.mod_delta" class="anchor"></a><code><span>mod_delta : <a href="../Mod_subst/index.html#type-delta_resolver">Mod_subst.delta_resolver</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>quotiented set of equivalent constants and inductive names</p><span class="comment-delim">*)</span></td></tr><tr id="type-generic_module_body.mod_retroknowledge" class="anchored"><td class="def record field"><a href="#type-generic_module_body.mod_retroknowledge" class="anchor"></a><code><span>mod_retroknowledge : <span><span class="type-var">'a</span> <a href="#type-module_retroknowledge">module_retroknowledge</a></span>;</span></code></td></tr></table><code><span>}</span></code></div></div><p>For a module, there are five possible situations:</p><ul><li><code>Declare Module M : T</code> then <code>mod_expr = Abstract; mod_type_alg = Some T</code></li><li><code>Module M := E</code> then <code>mod_expr = Algebraic E; mod_type_alg = None</code></li><li><code>Module M : T := E</code> then <code>mod_expr = Algebraic E; mod_type_alg = Some T</code></li><li><code>Module M. ... End M</code> then <code>mod_expr = FullStruct; mod_type_alg = None</code></li><li><code>Module M : T. ... End M</code> then <code>mod_expr = Struct; mod_type_alg = Some T</code> And of course, all these situations may be functors or not.</li></ul><div class="odoc-spec"><div class="spec type" id="type-module_body" class="anchored"><a href="#type-module_body" class="anchor"></a><code><span><span class="keyword">and</span> module_body</span><span> = <span><a href="#type-module_implementation">module_implementation</a> <a href="#type-generic_module_body">generic_module_body</a></span></span></code></div></div><p>A <code>module_type_body</code> is just a <code>module_body</code> with no implementation and also an empty <code>mod_retroknowledge</code>. Its <code>mod_type_alg</code> contains the algebraic definition of this module type, or <code>None</code> if it has been built interactively.</p><div class="odoc-spec"><div class="spec type" id="type-module_type_body" class="anchored"><a href="#type-module_type_body" class="anchor"></a><code><span><span class="keyword">and</span> module_type_body</span><span> = <span>unit <a href="#type-generic_module_body">generic_module_body</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-module_retroknowledge" class="anchored"><a href="#type-module_retroknowledge" class="anchor"></a><code><span><span class="keyword">and</span> <span>_ module_retroknowledge</span></span><span> = </span></code><table><tr id="type-module_retroknowledge.ModBodyRK" class="anchored"><td class="def variant constructor"><a href="#type-module_retroknowledge.ModBodyRK" class="anchor"></a><code><span>| </span><span><span class="constructor">ModBodyRK</span> : <span><a href="../Retroknowledge/index.html#type-action">Retroknowledge.action</a> list</span> <span class="arrow">&#45;&gt;</span> <span><a href="#type-module_implementation">module_implementation</a> <a href="#type-module_retroknowledge">module_retroknowledge</a></span></span></code></td></tr><tr id="type-module_retroknowledge.ModTypeRK" class="anchored"><td class="def variant constructor"><a href="#type-module_retroknowledge.ModTypeRK" class="anchor"></a><code><span>| </span><span><span class="constructor">ModTypeRK</span> : <span>unit <a href="#type-module_retroknowledge">module_retroknowledge</a></span></span></code></td></tr></table></div></div><p>Extra invariants :</p><ul><li>No <code>MEwith</code> inside a <code>mod_expr</code> implementation : the 'with' syntax is only supported for module types</li></ul><ul><li>A module application is atomic, for instance ((M N) P) : * the head of <code>MEapply</code> can only be another <code>MEapply</code> or a <code>MEident</code> * the argument of <code>MEapply</code> is now directly forced to be a <code>ModPath.t</code>.</li></ul></div></body></html>