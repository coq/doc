<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pcoq (coq-core.Pcoq)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">coq-core</a> &#x00BB; Pcoq</nav><header class="odoc-preamble"><h1>Module <code><span>Pcoq</span></code></h1><p>Deprecated alias for Procq</p></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="../Procq/index.html">Procq</a> <span class="keyword">end</span></span></code></summary><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Gramlib/Grammar/module-type-S/index.html">Gramlib.Grammar.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Gramlib/Grammar/module-type-S/index.html#type-keyword_state">keyword_state</a> := <a href="../CLexer/index.html#type-keyword_state">CLexer.keyword_state</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Gramlib/Grammar/module-type-S/index.html#type-te">te</a> := <a href="../Tok/index.html#type-t">Tok.t</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="../Gramlib/Grammar/module-type-S/index.html#type-pattern">pattern</a></span> := <span><span class="type-var">'a</span> <a href="../Tok/index.html#type-p">Tok.p</a></span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="../Gramlib/Grammar/module-type-S/index.html#type-with_gstate">with_gstate</a></span>
:= <span class="type-var">'a</span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="../Gramlib/Grammar/module-type-S/index.html#type-with_kwstate">with_kwstate</a></span> := <span class="type-var">'a</span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="../Gramlib/Grammar/module-type-S/index.html#type-with_estate">with_estate</a></span> := <span class="type-var">'a</span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="../Gramlib/Grammar/module-type-S/index.html#type-mod_estate">mod_estate</a></span> := <span class="type-var">'a</span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-ty_pattern" class="anchored"><a href="#type-ty_pattern" class="anchor"></a><code><span><span class="keyword">type</span> ty_pattern</span><span> = <a href="../Procq/index.html#type-ty_pattern">Procq.ty_pattern</a></span><span> = </span></code><table><tr id="type-ty_pattern.TPattern" class="anchored"><td class="def variant constructor"><a href="#type-ty_pattern.TPattern" class="anchor"></a><code><span>| </span><span><span class="constructor">TPattern</span> : <span><span class="type-var">'a</span> <a href="../Tok/index.html#type-p">Tok.p</a></span> <span class="arrow">&#45;&gt;</span> <a href="#type-ty_pattern">ty_pattern</a></span></code></td></tr></table></div></div><p>Type combinators to factor the module type between explicit state passing in Grammar and global state in Procq</p><div class="odoc-spec"><div class="spec module" id="module-Parsable" class="anchored"><a href="#module-Parsable" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Parsable</span><span> = <a href="../Procq/Parsable/index.html">Procq.Parsable</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Entry" class="anchored"><a href="#module-Entry" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Entry</span><span> = <a href="../Procq/Entry/index.html">Procq.Entry</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Symbol" class="anchored"><a href="#module-Symbol" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Symbol</span><span> = <a href="../Procq/Symbol/index.html">Procq.Symbol</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Rule" class="anchored"><a href="#module-Rule" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Rule</span><span> = <a href="../Procq/Rule/index.html">Procq.Rule</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Rules" class="anchored"><a href="#module-Rules" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Rules</span><span> = <a href="../Procq/Rules/index.html">Procq.Rules</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Production" class="anchored"><a href="#module-Production" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Production</span><span> = <a href="../Procq/Production/index.html">Procq.Production</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-single_extend_statement" class="anchored"><a href="#type-single_extend_statement" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a single_extend_statement</span></span><span> = <span>string option</span> * <span><a href="../Gramlib/Gramext/index.html#type-g_assoc">Gramlib.Gramext.g_assoc</a> option</span> * <span><span><span class="type-var">'a</span> <a href="../Procq/Production/index.html#type-t">Production.t</a></span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-extend_statement" class="anchored"><a href="#type-extend_statement" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a extend_statement</span></span><span> = <span><span class="type-var">'a</span> <a href="../Procq/index.html#type-extend_statement">Procq.extend_statement</a></span></span><span> = </span></code><table><tr id="type-extend_statement.Reuse" class="anchored"><td class="def variant constructor"><a href="#type-extend_statement.Reuse" class="anchor"></a><code><span>| </span><span><span class="constructor">Reuse</span> <span class="keyword">of</span> <span>string option</span> * <span><span><span class="type-var">'a</span> <a href="../Procq/Production/index.html#type-t">Production.t</a></span> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Extend an existing level by its optional given name. If None, picks the topmost level.</p><span class="comment-delim">*)</span></td></tr><tr id="type-extend_statement.Fresh" class="anchored"><td class="def variant constructor"><a href="#type-extend_statement.Fresh" class="anchor"></a><code><span>| </span><span><span class="constructor">Fresh</span> <span class="keyword">of</span> <a href="../Gramlib/Gramext/index.html#type-position">Gramlib.Gramext.position</a> * <span><span><span class="type-var">'a</span> <a href="#type-single_extend_statement">single_extend_statement</a></span> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Create a level at the given position.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-generalize_symbol" class="anchored"><a href="#val-generalize_symbol" class="anchor"></a><code><span><span class="keyword">val</span> generalize_symbol : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'tr</span>, <span class="type-var">'c</span>)</span> <a href="../Procq/Symbol/index.html#type-t">Symbol.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <a href="../Gramlib/Grammar/index.html#type-norec">Gramlib.Grammar.norec</a>, <span class="type-var">'c</span>)</span> <a href="../Procq/Symbol/index.html#type-t">Symbol.t</a></span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-level_of_nonterm" class="anchored"><a href="#val-level_of_nonterm" class="anchor"></a><code><span><span class="keyword">val</span> level_of_nonterm : <span><span><span>(<span class="type-var">'a</span>, <a href="../Gramlib/Grammar/index.html#type-norec">Gramlib.Grammar.norec</a>, <span class="type-var">'c</span>)</span> <a href="../Procq/Symbol/index.html#type-t">Symbol.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div></div></details></div><div class="odoc-spec"><div class="spec module" id="module-Lookahead" class="anchored"><a href="#module-Lookahead" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Lookahead</span><span> = <a href="../Procq/Lookahead/index.html">Procq.Lookahead</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-terminal" class="anchored"><a href="#val-terminal" class="anchor"></a><code><span><span class="keyword">val</span> terminal : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../Tok/index.html#type-p">Tok.p</a></span></span></code></div><div class="spec-doc"><p>When string is not an ident, returns a keyword.</p></div></div><p>The parser of Coq is built from three kinds of rule declarations:</p><ul><li>dynamic rules declared at the evaluation of Coq files (using e.g. Notation, Infix, or Tactic Notation)</li><li>static rules explicitly defined in files g_*.mlg</li><li>static rules macro-generated by ARGUMENT EXTEND, TACTIC EXTEND and VERNAC EXTEND (see e.g. file extratactics.mlg)</li></ul><p>Note that parsing a Coq document is in essence stateful: the parser needs to recognize commands that start proofs and use a different parsing entry point for them.</p><p>We thus provide two different interfaces: the &quot;raw&quot; parsing interface, in the style of camlp5, which provides more flexibility, and a more specialize &quot;parse_vernac&quot; one, which will indeed adjust the state as needed.</p><p>Dynamic extension of rules</p><p>For constr notations, dynamic addition of new rules is done in several steps:</p><ul><li>&quot;x + y&quot; (user gives a notation string of type Topconstr.notation) | (together with a constr entry level, e.g. 50, and indications of) | (subentries, e.g. x in constr next level and y constr same level) | | splitting into tokens by Metasyntax.split_notation_string V <code>String &quot;x&quot;; String &quot;+&quot;; String &quot;y&quot;</code> : symbol_token list | | interpreted as a mixed parsing/printing production | by Metasyntax.analyse_notation_tokens V <code>NonTerminal &quot;x&quot;; Terminal &quot;+&quot;; NonTerminal &quot;y&quot;</code> : symbol list | | translated to a parsing production by Metasyntax.make_production V <code>GramConstrNonTerminal (ETConstr (NextLevel,(BorderProd Left,LeftA)),
                              Some &quot;x&quot;);
       GramConstrTerminal (&quot;&quot;,&quot;+&quot;);
       GramConstrNonTerminal (ETConstr (NextLevel,(BorderProd Right,LeftA)),
                              Some &quot;y&quot;)</code> : grammar_constr_prod_item list | | Egrammar.make_constr_prod_item V Gramext.g_symbol list which is sent to camlp5</li></ul><p>For user level tactic notations, dynamic addition of new rules is also done in several steps:</p><ul><li>&quot;f&quot; constr(x) (user gives a Tactic Notation command) | | parsing V <code>TacTerm &quot;f&quot;; TacNonTerm (&quot;constr&quot;, Some &quot;x&quot;)</code> : grammar_tactic_prod_item_expr list | | Metasyntax.interp_prod_item V <code>GramTerminal &quot;f&quot;;
       GramNonTerminal (ConstrArgType, Aentry (&quot;constr&quot;,&quot;constr&quot;), Some &quot;x&quot;)</code> : grammar_prod_item list | | Egrammar.make_prod_item V Gramext.g_symbol list</li></ul><p>For TACTIC/VERNAC/ARGUMENT EXTEND, addition of new rules is done as follows:</p><ul><li>&quot;f&quot; constr(x) (developer gives an EXTEND rule) | | macro-generation in tacextend.mlg/vernacextend.mlg/argextend.mlg V <code>GramTerminal &quot;f&quot;;
       GramNonTerminal (ConstrArgType, Aentry (&quot;constr&quot;,&quot;constr&quot;), Some &quot;x&quot;)</code> | | Egrammar.make_prod_item V Gramext.g_symbol list</li></ul><p>Parse a string</p><div class="odoc-spec"><div class="spec value" id="val-parse_string" class="anchored"><a href="#val-parse_string" class="anchor"></a><code><span><span class="keyword">val</span> parse_string : <span><span><span class="type-var">'a</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?loc:<a href="../Loc/index.html#type-t">Loc.t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-eoi_entry" class="anchored"><a href="#val-eoi_entry" class="anchor"></a><code><span><span class="keyword">val</span> eoi_entry : <span><span><span class="type-var">'a</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create_generic_entry2" class="anchored"><a href="#val-create_generic_entry2" class="anchor"></a><code><span><span class="keyword">val</span> create_generic_entry2 : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <a href="../Genarg/index.html#type-rlevel">Genarg.rlevel</a>)</span> <a href="../Genarg/index.html#type-abstract_argument_type">Genarg.abstract_argument_type</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-register_grammar" class="anchored"><a href="#val-register_grammar" class="anchor"></a><code><span><span class="keyword">val</span> register_grammar : <span><span><span>(<span class="type-var">'raw</span>, <span class="type-var">'glb</span>, <span class="type-var">'top</span>)</span> <a href="../Genarg/index.html#type-genarg_type">Genarg.genarg_type</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'raw</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-genarg_grammar" class="anchored"><a href="#val-genarg_grammar" class="anchor"></a><code><span><span class="keyword">val</span> genarg_grammar : <span><span><span>(<span class="type-var">'raw</span>, <span class="type-var">'glb</span>, <span class="type-var">'top</span>)</span> <a href="../Genarg/index.html#type-genarg_type">Genarg.genarg_type</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'raw</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Prim" class="anchored"><a href="#module-Prim" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Prim</span><span> = <a href="../Procq/Prim/index.html">Procq.Prim</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Constr" class="anchored"><a href="#module-Constr" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Constr</span><span> = <a href="../Procq/Constr/index.html">Procq.Constr</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Module" class="anchored"><a href="#module-Module" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Module</span><span> = <a href="../Procq/Module/index.html">Procq.Module</a></span></code></div></div><h6 id="type-safe-grammar-extension"><a href="#type-safe-grammar-extension" class="anchor"></a>Type-safe grammar extension</h6><div class="odoc-spec"><div class="spec value" id="val-epsilon_value" class="anchored"><a href="#val-epsilon_value" class="anchor"></a><code><span><span class="keyword">val</span> epsilon_value : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'self</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'self</span>, <span class="type-var">_</span>, <span class="type-var">'a</span>)</span> <a href="../Procq/Symbol/index.html#type-t">Symbol.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'self</span> option</span></span></code></div></div><h6 id="extending-the-parser-without-synchronization"><a href="#extending-the-parser-without-synchronization" class="anchor"></a>Extending the parser without synchronization</h6><div class="odoc-spec"><div class="spec value" id="val-grammar_extend" class="anchored"><a href="#val-grammar_extend" class="anchor"></a><code><span><span class="keyword">val</span> grammar_extend : <span><span><span class="type-var">'a</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-extend_statement">extend_statement</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Extend the grammar of Coq, without synchronizing it with the backtracking mechanism. This means that grammar extensions defined this way will survive an undo.</p></div></div><h6 id="extending-the-parser-with-summary-synchronized-commands"><a href="#extending-the-parser-with-summary-synchronized-commands" class="anchor"></a>Extending the parser with summary-synchronized commands</h6><div class="odoc-spec"><div class="spec module" id="module-GramState" class="anchored"><a href="#module-GramState" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>GramState</span><span> = <a href="../Procq/GramState/index.html">Procq.GramState</a></span></code></div><div class="spec-doc"><p>Auxiliary state of the grammar. Any added data must be marshallable.</p></div></div><h6 id="extension-with-parsing-rules"><a href="#extension-with-parsing-rules" class="anchor"></a>Extension with parsing rules</h6><div class="odoc-spec"><div class="spec type" id="type-grammar_command" class="anchored"><a href="#type-grammar_command" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a grammar_command</span></span><span> = <span><span class="type-var">'a</span> <a href="../Procq/index.html#type-grammar_command">Procq.grammar_command</a></span></span></code></div><div class="spec-doc"><p>Type of synchronized parsing extensions. The <code>'a</code> type should be marshallable.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-gram_reinit" class="anchored"><a href="#type-gram_reinit" class="anchor"></a><code><span><span class="keyword">type</span> gram_reinit</span><span> = <a href="../Gramlib/Gramext/index.html#type-g_assoc">Gramlib.Gramext.g_assoc</a> * <a href="../Gramlib/Gramext/index.html#type-position">Gramlib.Gramext.position</a></span></code></div><div class="spec-doc"><p>Type of reinitialization data</p></div></div><div class="odoc-spec"><div class="spec type" id="type-extend_rule" class="anchored"><a href="#type-extend_rule" class="anchor"></a><code><span><span class="keyword">type</span> extend_rule</span><span> = <a href="../Procq/index.html#type-extend_rule">Procq.extend_rule</a></span><span> = </span></code><table><tr id="type-extend_rule.ExtendRule" class="anchored"><td class="def variant constructor"><a href="#type-extend_rule.ExtendRule" class="anchor"></a><code><span>| </span><span><span class="constructor">ExtendRule</span> : <span><span class="type-var">'a</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span> * <span><span class="type-var">'a</span> <a href="#type-extend_statement">extend_statement</a></span> <span class="arrow">&#45;&gt;</span> <a href="#type-extend_rule">extend_rule</a></span></code></td></tr><tr id="type-extend_rule.ExtendRuleReinit" class="anchored"><td class="def variant constructor"><a href="#type-extend_rule.ExtendRuleReinit" class="anchor"></a><code><span>| </span><span><span class="constructor">ExtendRuleReinit</span> : <span><span class="type-var">'a</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span> * <a href="#type-gram_reinit">gram_reinit</a> * <span><span class="type-var">'a</span> <a href="#type-extend_statement">extend_statement</a></span> <span class="arrow">&#45;&gt;</span> <a href="#type-extend_rule">extend_rule</a></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-grammar_extension" class="anchored"><a href="#type-grammar_extension" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a grammar_extension</span></span><span> = <span><span class="type-var">'a</span> <a href="../Procq/index.html#type-grammar_extension">Procq.grammar_extension</a></span></span><span> = </span><span>{</span></code><table><tr id="type-grammar_extension.gext_fun" class="anchored"><td class="def record field"><a href="#type-grammar_extension.gext_fun" class="anchor"></a><code><span>gext_fun : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Procq/GramState/index.html#type-t">GramState.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-extend_rule">extend_rule</a> list</span> * <a href="../Procq/GramState/index.html#type-t">GramState.t</a>;</span></code></td></tr><tr id="type-grammar_extension.gext_eq" class="anchored"><td class="def record field"><a href="#type-grammar_extension.gext_eq" class="anchor"></a><code><span>gext_eq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Grammar extension entry point. Given some <code>'a</code> and a current grammar state, such a function must produce the list of grammar extensions that will be applied in the same order and kept synchronized w.r.t. the summary, together with a new state. It should be pure.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_grammar_command" class="anchored"><a href="#val-create_grammar_command" class="anchor"></a><code><span><span class="keyword">val</span> create_grammar_command : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-grammar_extension">grammar_extension</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-grammar_command">grammar_command</a></span></span></code></div><div class="spec-doc"><p>Create a new grammar-modifying command with the given name. The extension function is called to generate the rules for a given data.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extend_grammar_command" class="anchored"><a href="#val-extend_grammar_command" class="anchor"></a><code><span><span class="keyword">val</span> extend_grammar_command : <span><span><span class="type-var">'a</span> <a href="#type-grammar_command">grammar_command</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Extend the grammar of Coq with the given data.</p></div></div><h6 id="extension-with-parsing-entries"><a href="#extension-with-parsing-entries" class="anchor"></a>Extension with parsing entries</h6><div class="odoc-spec"><div class="spec type" id="type-entry_command" class="anchored"><a href="#type-entry_command" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) entry_command</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Procq/index.html#type-entry_command">Procq.entry_command</a></span></span></code></div><div class="spec-doc"><p>Type of synchronized entry creation. The <code>'a</code> type should be marshallable.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-entry_extension" class="anchored"><a href="#type-entry_extension" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) entry_extension</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Procq/index.html#type-entry_extension">Procq.entry_extension</a></span></span><span> = </span><span>{</span></code><table><tr id="type-entry_extension.eext_fun" class="anchored"><td class="def record field"><a href="#type-entry_extension.eext_fun" class="anchor"></a><code><span>eext_fun : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Procq/GramState/index.html#type-t">GramState.t</a> <span class="arrow">&#45;&gt;</span></span> <span>string list</span> * <a href="../Procq/GramState/index.html#type-t">GramState.t</a>;</span></code></td></tr><tr id="type-entry_extension.eext_eq" class="anchored"><td class="def record field"><a href="#type-entry_extension.eext_eq" class="anchor"></a><code><span>eext_eq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Entry extension entry point. Given some <code>'a</code> and a current grammar state, such a function must produce the list of entry extensions that will be created and kept synchronized w.r.t. the summary, together with a new state. It should be pure.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_entry_command" class="anchored"><a href="#val-create_entry_command" class="anchor"></a><code><span><span class="keyword">val</span> create_entry_command : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-entry_extension">entry_extension</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-entry_command">entry_command</a></span></span></code></div><div class="spec-doc"><p>Create a new entry-creating command with the given name. The extension function is called to generate the new entries for a given data.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extend_entry_command" class="anchored"><a href="#val-extend_entry_command" class="anchor"></a><code><span><span class="keyword">val</span> extend_entry_command : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-entry_command">entry_command</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span> list</span></span></code></div><div class="spec-doc"><p>Create new synchronized entries using the provided data.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_custom_entry" class="anchored"><a href="#val-find_custom_entry" class="anchor"></a><code><span><span class="keyword">val</span> find_custom_entry : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-entry_command">entry_command</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Procq/Entry/index.html#type-t">Entry.t</a></span></span></code></div><div class="spec-doc"><p>Find an entry generated by the synchronized system in the current state.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if non-existent.</p></li></ul></div></div><h6 id="protection-w.r.t.-backtrack"><a href="#protection-w.r.t.-backtrack" class="anchor"></a>Protection w.r.t. backtrack</h6><div class="odoc-spec"><div class="spec value" id="val-with_grammar_rule_protection" class="anchored"><a href="#val-with_grammar_rule_protection" class="anchor"></a><code><span><span class="keyword">val</span> with_grammar_rule_protection : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-frozen_t" class="anchored"><a href="#type-frozen_t" class="anchor"></a><code><span><span class="keyword">type</span> frozen_t</span><span> = <a href="../Procq/index.html#type-frozen_t">Procq.frozen_t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-parser_summary_tag" class="anchored"><a href="#val-parser_summary_tag" class="anchor"></a><code><span><span class="keyword">val</span> parser_summary_tag : <span><a href="#type-frozen_t">frozen_t</a> <a href="../Summary/Dyn/index.html#type-tag">Summary.Dyn.tag</a></span></span></code></div></div><p>Registering grammars by name</p><div class="odoc-spec"><div class="spec value" id="val-register_grammars_by_name" class="anchored"><a href="#val-register_grammars_by_name" class="anchor"></a><code><span><span class="keyword">val</span> register_grammars_by_name : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Procq/Entry/index.html#type-any_t">Entry.any_t</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-find_grammars_by_name" class="anchored"><a href="#val-find_grammars_by_name" class="anchor"></a><code><span><span class="keyword">val</span> find_grammars_by_name : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="../Procq/Entry/index.html#type-any_t">Entry.any_t</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-freeze" class="anchored"><a href="#val-freeze" class="anchor"></a><code><span><span class="keyword">val</span> freeze : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-frozen_t">frozen_t</a></span></code></div><div class="spec-doc"><p>Parsing state handling</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfreeze" class="anchored"><a href="#val-unfreeze" class="anchor"></a><code><span><span class="keyword">val</span> unfreeze : <span><a href="#type-frozen_t">frozen_t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-get_keyword_state" class="anchored"><a href="#val-get_keyword_state" class="anchor"></a><code><span><span class="keyword">val</span> get_keyword_state : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="../CLexer/index.html#type-keyword_state">CLexer.keyword_state</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-set_keyword_state" class="anchored"><a href="#val-set_keyword_state" class="anchor"></a><code><span><span class="keyword">val</span> set_keyword_state : <span><a href="../CLexer/index.html#type-keyword_state">CLexer.keyword_state</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></details></div></div></body></html>