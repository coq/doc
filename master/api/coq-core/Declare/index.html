<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Declare (coq-core.Declare)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq-core</a> &#x00BB; Declare</nav><h1>Module <code>Declare</code></h1><nav class="toc"><ul><li><a href="#one-go,-non-interactive-declaration-api">One-go, non-interactive declaration API</a></li><li><a href="#declaration-of-interactive-constants">Declaration of interactive constants</a></li><li><a href="#low-level,-internal-api,-avoid-using-unless-you-have-special-needs">low-level, internal API, avoid using unless you have special needs</a></li><li><a href="#program-mode-api">Program mode API</a></li><li><a href="#"></a></li><li><a href="#"></a><ul><li><a href="#for-internal-support,-do-not-use">For internal support, do not use</a></li></ul></li></ul></nav></header><aside><p>This module provides the functions to declare new variables, parameters, constants and inductive types in the global environment. It also updates some accesory tables such as <code>Nametab</code> (name resolution), <code>Impargs</code>, and <code>Notations</code>.</p></aside><aside><p>We provide three main entry points:</p><ul><li>one-go functions, that will register a constant in one go, suited for non-interactive definitions where the term is given.</li></ul><ul><li>two-phase <code>start/save</code> functions which will create an interactive proof, allow its modification using tactics, and saving when complete.</li></ul><ul><li>program mode API, that allow to declare a constant with holes, to be fullfilled later.</li></ul><p>Note that the API in this file is still in a state of flux, don't hesitate to contact the maintainers if you have any question.</p><p>Additionally, this file does contain some low-level functions, marked as such; these functions are unstable and should not be used unless you already know what they are doing.</p></aside><dl><dt class="spec module" id="module-Hook"><a href="#module-Hook" class="anchor"></a><code><span class="keyword">module</span> <a href="Hook/index.html">Hook</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Declaration hooks, to be run when a constant is saved. Use with care, as imperative effects may become not supported in the future.</p></dd></dl><section><header><h3 id="one-go,-non-interactive-declaration-api"><a href="#one-go,-non-interactive-declaration-api" class="anchor"></a>One-go, non-interactive declaration API</h3></header><dl><dt class="spec module" id="module-CInfo"><a href="#module-CInfo" class="anchor"></a><code><span class="keyword">module</span> <a href="CInfo/index.html">CInfo</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Information for a single top-level named constant</p></dd></dl><dl><dt class="spec module" id="module-Info"><a href="#module-Info" class="anchor"></a><code><span class="keyword">module</span> <a href="Info/index.html">Info</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Information for a declaration, interactive or not, includes parameters shared by mutual constants</p></dd></dl><dl><dt class="spec value" id="val-declare_definition"><a href="#val-declare_definition" class="anchor"></a><code><span class="keyword">val</span> declare_definition : <span>info:<a href="Info/index.html#type-t">Info.t</a></span> <span>&#45;&gt;</span> <span>cinfo:<span><span><a href="../EConstr/index.html#type-t">EConstr.t</a> option</span> <a href="CInfo/index.html#type-t">CInfo.t</a></span></span> <span>&#45;&gt;</span> <span>opaque:bool</span> <span>&#45;&gt;</span> <span>body:<a href="../EConstr/index.html#type-t">EConstr.t</a></span> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../Names/GlobRef/index.html#type-t">Names.GlobRef.t</a></code></dt><dd><p>Declares a non-interactive constant; <code>body</code> and <code>types</code> will be normalized w.r.t. the passed <code>evar_map</code> <code>sigma</code>. Universes should be handled properly, including minimization and restriction. Note that <code>sigma</code> is checked for unresolved evars, thus you should be careful not to submit open terms</p></dd></dl><dl><dt class="spec type" id="type-lemma_possible_guards"><a href="#type-lemma_possible_guards" class="anchor"></a><code><span class="keyword">type</span> lemma_possible_guards</code><code> = <span><span>int list</span> list</span></code></dt></dl><dl><dt class="spec value" id="val-declare_mutually_recursive"><a href="#val-declare_mutually_recursive" class="anchor"></a><code><span class="keyword">val</span> declare_mutually_recursive : <span>info:<a href="Info/index.html#type-t">Info.t</a></span> <span>&#45;&gt;</span> <span>cinfo:<span><span><a href="../Constr/index.html#type-t">Constr.t</a> <a href="CInfo/index.html#type-t">CInfo.t</a></span> list</span></span> <span>&#45;&gt;</span> <span>opaque:bool</span> <span>&#45;&gt;</span> <span>ntns:<span><a href="../Metasyntax/index.html#type-where_decl_notation">Metasyntax.where_decl_notation</a> list</span></span> <span>&#45;&gt;</span> <span>uctx:<a href="../UState/index.html#type-t">UState.t</a></span> <span>&#45;&gt;</span> <span>rec_declaration:<a href="../Constr/index.html#type-rec_declaration">Constr.rec_declaration</a></span> <span>&#45;&gt;</span> <span>possible_indexes:<span><a href="index.html#type-lemma_possible_guards">lemma_possible_guards</a> option</span></span> <span>&#45;&gt;</span> <span><a href="../Names/GlobRef/index.html#type-t">Names.GlobRef.t</a> list</span></code></dt></dl></section><section><header><h3 id="declaration-of-interactive-constants"><a href="#declaration-of-interactive-constants" class="anchor"></a>Declaration of interactive constants</h3></header><dl><dt class="spec module" id="module-OblState"><a href="#module-OblState" class="anchor"></a><code><span class="keyword">module</span> <a href="OblState/index.html">OblState</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>save</code> / <code>save_admitted</code> can update obligations state, so we need to expose the state here</p></dd></dl><dl><dt class="spec module" id="module-Proof"><a href="#module-Proof" class="anchor"></a><code><span class="keyword">module</span> <a href="Proof/index.html">Proof</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Declare.Proof.t</code> Construction of constants using interactive proofs.</p></dd></dl></section><section><header><h3 id="low-level,-internal-api,-avoid-using-unless-you-have-special-needs"><a href="#low-level,-internal-api,-avoid-using-unless-you-have-special-needs" class="anchor"></a>low-level, internal API, avoid using unless you have special needs</h3></header><dl><dt class="spec type" id="type-proof_entry"><a href="#type-proof_entry" class="anchor"></a><code><span class="keyword">type</span> <span>'a proof_entry</span></code></dt><dd><p>Proof entries represent a proof that has been finished, but still not registered with the kernel.</p><p>XXX: This is an internal, low-level API and could become scheduled for removal from the public API, use higher-level declare APIs instead</p></dd></dl><dl><dt class="spec value" id="val-definition_entry"><a href="#val-definition_entry" class="anchor"></a><code><span class="keyword">val</span> definition_entry : <span>?&#8288;opaque:bool</span> <span>&#45;&gt;</span> <span>?&#8288;using:<a href="../Names/Id/index.html#module-Set">Names.Id.Set</a>.t</span> <span>&#45;&gt;</span> <span>?&#8288;inline:bool</span> <span>&#45;&gt;</span> <span>?&#8288;types:<a href="../Constr/index.html#type-types">Constr.types</a></span> <span>&#45;&gt;</span> <span>?&#8288;univs:<a href="../Entries/index.html#type-universes_entry">Entries.universes_entry</a></span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><a href="../Evd/index.html#type-side_effects">Evd.side_effects</a> <a href="index.html#type-proof_entry">proof_entry</a></span></code></dt><dt class="spec value" id="val-declare_entry"><a href="#val-declare_entry" class="anchor"></a><code><span class="keyword">val</span> declare_entry : <span>name:<a href="../Names/Id/index.html#type-t">Names.Id.t</a></span> <span>&#45;&gt;</span> <span>scope:<a href="../Locality/index.html#type-locality">Locality.locality</a></span> <span>&#45;&gt;</span> <span>kind:<a href="../Decls/index.html#type-logical_kind">Decls.logical_kind</a></span> <span>&#45;&gt;</span> <span>?&#8288;hook:<a href="Hook/index.html#type-t">Hook.t</a></span> <span>&#45;&gt;</span> <span>impargs:<a href="../Impargs/index.html#type-manual_implicits">Impargs.manual_implicits</a></span> <span>&#45;&gt;</span> <span>uctx:<a href="../UState/index.html#type-t">UState.t</a></span> <span>&#45;&gt;</span> <span><a href="../Evd/index.html#type-side_effects">Evd.side_effects</a> <a href="index.html#type-proof_entry">proof_entry</a></span> <span>&#45;&gt;</span> <a href="../Names/GlobRef/index.html#type-t">Names.GlobRef.t</a></code></dt><dd><p>XXX: This is an internal, low-level API and could become scheduled for removal from the public API, use higher-level declare APIs instead</p></dd></dl><dl><dt class="spec value" id="val-declare_variable"><a href="#val-declare_variable" class="anchor"></a><code><span class="keyword">val</span> declare_variable : <span>name:<a href="../Names/index.html#type-variable">Names.variable</a></span> <span>&#45;&gt;</span> <span>kind:<a href="../Decls/index.html#type-logical_kind">Decls.logical_kind</a></span> <span>&#45;&gt;</span> <span>typ:<a href="../Constr/index.html#type-types">Constr.types</a></span> <span>&#45;&gt;</span> <span>impl:<a href="../Glob_term/index.html#type-binding_kind">Glob_term.binding_kind</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Declaration of local constructions (Variable/Hypothesis/Local)</p></dd></dl><dl><dt class="spec type" id="type-constant_entry"><a href="#type-constant_entry" class="anchor"></a><code><span class="keyword">type</span> <span>'a constant_entry</span></code><code> = </code><table class="variant"><tr id="type-constant_entry.DefinitionEntry" class="anchored"><td class="def constructor"><a href="#type-constant_entry.DefinitionEntry" class="anchor"></a><code>| </code><code><span class="constructor">DefinitionEntry</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-proof_entry">proof_entry</a></span></code></td></tr><tr id="type-constant_entry.ParameterEntry" class="anchored"><td class="def constructor"><a href="#type-constant_entry.ParameterEntry" class="anchor"></a><code>| </code><code><span class="constructor">ParameterEntry</span> <span class="keyword">of</span> <a href="../Entries/index.html#type-parameter_entry">Entries.parameter_entry</a></code></td></tr><tr id="type-constant_entry.PrimitiveEntry" class="anchored"><td class="def constructor"><a href="#type-constant_entry.PrimitiveEntry" class="anchor"></a><code>| </code><code><span class="constructor">PrimitiveEntry</span> <span class="keyword">of</span> <a href="../Entries/index.html#type-primitive_entry">Entries.primitive_entry</a></code></td></tr></table></dt><dd><p>Declaration of global constructions i.e. Definition/Theorem/Axiom/Parameter/...</p><p>XXX: This is an internal, low-level API and could become scheduled for removal from the public API, use higher-level declare APIs instead</p></dd></dl><dl><dt class="spec value" id="val-prepare_parameter"><a href="#val-prepare_parameter" class="anchor"></a><code><span class="keyword">val</span> prepare_parameter : <span>poly:bool</span> <span>&#45;&gt;</span> <span>udecl:<a href="../UState/index.html#type-universe_decl">UState.universe_decl</a></span> <span>&#45;&gt;</span> <span>types:<a href="../EConstr/index.html#type-types">EConstr.types</a></span> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../Entries/index.html#type-parameter_entry">Entries.parameter_entry</a></code></dt><dt class="spec value" id="val-declare_constant"><a href="#val-declare_constant" class="anchor"></a><code><span class="keyword">val</span> declare_constant : <span>?&#8288;local:<a href="../Locality/index.html#type-import_status">Locality.import_status</a></span> <span>&#45;&gt;</span> <span>name:<a href="../Names/Id/index.html#type-t">Names.Id.t</a></span> <span>&#45;&gt;</span> <span>kind:<a href="../Decls/index.html#type-logical_kind">Decls.logical_kind</a></span> <span>&#45;&gt;</span> <span>?&#8288;typing_flags:<a href="../Declarations/index.html#type-typing_flags">Declarations.typing_flags</a></span> <span>&#45;&gt;</span> <span><a href="../Evd/index.html#type-side_effects">Evd.side_effects</a> <a href="index.html#type-constant_entry">constant_entry</a></span> <span>&#45;&gt;</span> <a href="../Names/Constant/index.html#type-t">Names.Constant.t</a></code></dt><dd><p><code>declare_constant id cd</code> declares a global declaration (constant/parameter) with name <code>id</code> in the current section; it returns the full path of the declaration</p><p>XXX: This is an internal, low-level API and could become scheduled for removal from the public API, use higher-level declare APIs instead</p></dd></dl><aside><p>Declaration messages, for internal use</p></aside><dl><dt class="spec value" id="val-definition_message"><a href="#val-definition_message" class="anchor"></a><code><span class="keyword">val</span> definition_message : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>XXX: Scheduled for removal from public API, do not use</p></dd></dl><dl><dt class="spec value" id="val-assumption_message"><a href="#val-assumption_message" class="anchor"></a><code><span class="keyword">val</span> assumption_message : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-fixpoint_message"><a href="#val-fixpoint_message" class="anchor"></a><code><span class="keyword">val</span> fixpoint_message : <span><span>int array</span> option</span> <span>&#45;&gt;</span> <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-check_exists"><a href="#val-check_exists" class="anchor"></a><code><span class="keyword">val</span> check_exists : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-build_by_tactic"><a href="#val-build_by_tactic" class="anchor"></a><code><span class="keyword">val</span> build_by_tactic : <span>?&#8288;side_eff:bool</span> <span>&#45;&gt;</span> <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <span>uctx:<a href="../UState/index.html#type-t">UState.t</a></span> <span>&#45;&gt;</span> <span>poly:bool</span> <span>&#45;&gt;</span> <span>typ:<a href="../EConstr/index.html#type-types">EConstr.types</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Proofview/index.html#type-tactic">Proofview.tactic</a></span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> * <span><a href="../Constr/index.html#type-types">Constr.types</a> option</span> * <a href="../Entries/index.html#type-universes_entry">Entries.universes_entry</a> * bool * <a href="../UState/index.html#type-t">UState.t</a></code></dt><dd><p>Semantics of this function is a bit dubious, use with care</p></dd></dl></section><section><header><h3 id="program-mode-api"><a href="#program-mode-api" class="anchor"></a>Program mode API</h3></header><aside><p>Coq's Program mode support. This mode extends declarations of constants and fixpoints with <code>Program Definition</code> and <code>Program
   Fixpoint</code> to support incremental construction of terms using delayed proofs, called &quot;obligations&quot;</p><p>The mode also provides facilities for managing and auto-solving sets of obligations.</p><p>The basic code flow of programs/obligations is as follows:</p><ul><li><code>add_definition</code> / <code>add_mutual_definitions</code> are called from the respective <code>Program</code> vernacular command interpretation; at this point the only extra work we do is to prepare the new definition <code>d</code> using <code>RetrieveObl</code>, which consists in turning unsolved evars into obligations. <code>d</code> is not sent to the kernel yet, as it is not complete and cannot be typchecked, but saved in a special data-structure. Auto-solving of obligations is tried at this stage (see below)</li></ul><ul><li><code>next_obligation</code> will retrieve the next obligation (<code>RetrieveObl</code> sorts them by topological order) and will try to solve it. When all obligations are solved, the original constant <code>d</code> is grounded and sent to the kernel for addition to the global environment. Auto-solving of obligations is also triggered on obligation completion.</li></ul></aside></section><section><header><h3 id=""><a href="#" class="anchor"></a></h3><p>Solving of obligations: Solved obligations are stored as regular global declarations in the global environment, usually with name <code>constant_obligation_number</code> where <code>constant</code> is the original <code>constant</code> and <code>number</code> is the corresponding (internal) number.</p><p>Solving an obligation can trigger a bit of a complex cascaded callback path; closing an obligation can indeed allow all other obligations to be closed, which in turn may trigged the declaration of the original constant. Care must be taken, as this can modify <code>Global.env</code> in arbitrarily ways. Current code takes some care to refresh the <code>env</code> in the proper boundaries, but the invariants remain delicate.</p></header></section><section><header><h3 id=""><a href="#" class="anchor"></a></h3><p>Saving of obligations: as open obligations use the regular proof mode, a `Qed` will call `Lemmas.save_lemma` first. For this reason obligations code is split in two: this file, <code>Obligations</code>, taking care of the top-level vernac commands, and <code>Declare</code>, which is called by `Lemmas` to close an obligation proof and eventually to declare the top-level <code>Program</code>ed constant.</p></header><div class="spec module" id="module-Obls"><a href="#module-Obls" class="anchor"></a><code><span class="keyword">module</span> <a href="Obls/index.html">Obls</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-is_local_constant"><a href="#val-is_local_constant" class="anchor"></a><code><span class="keyword">val</span> is_local_constant : <a href="../Names/Constant/index.html#type-t">Names.Constant.t</a> <span>&#45;&gt;</span> bool</code></dt></dl><section><header><h6 id="for-internal-support,-do-not-use"><a href="#for-internal-support,-do-not-use" class="anchor"></a>For internal support, do not use</h6></header><div class="spec module" id="module-Internal"><a href="#module-Internal" class="anchor"></a><code><span class="keyword">module</span> <a href="Internal/index.html">Internal</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></section></div></body></html>