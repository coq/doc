<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Term (coq-core.Term)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">coq-core</a> &#x00BB; Term</nav><header class="odoc-preamble"><h1>Module <code><span>Term</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#derived-constructors">Derived constructors</a></li><li><a href="#other-term-constructors.">Other term constructors.</a></li><li><a href="#other-term-destructors.">Other term destructors.</a></li><li><a href="#...">...</a></li></ul></nav><div class="odoc-content"><h6 id="derived-constructors"><a href="#derived-constructors" class="anchor"></a>Derived constructors</h6><div class="odoc-spec"><div class="spec value" id="val-mkArrow" class="anchored"><a href="#val-mkArrow" class="anchor"></a><code><span><span class="keyword">val</span> mkArrow : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sorts/index.html#type-relevance">Sorts.relevance</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>non-dependent product <code>t1 -&gt; t2</code>, an alias for <code>forall (_:t1), t2</code>. Beware <code>t_2</code> is NOT lifted. Eg: in context <code>A:Prop</code>, <code>A-&gt;A</code> is built by <code>(mkArrow (mkRel 1) (mkRel 2))</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkArrowR" class="anchored"><a href="#val-mkArrowR" class="anchor"></a><code><span><span class="keyword">val</span> mkArrowR : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>For an always-relevant domain</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkNamedLambda" class="anchored"><a href="#val-mkNamedLambda" class="anchor"></a><code><span><span class="keyword">val</span> mkNamedLambda : <span><span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Named version of the functions from <code>Term</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkNamedLetIn" class="anchored"><a href="#val-mkNamedLetIn" class="anchor"></a><code><span><span class="keyword">val</span> mkNamedLetIn : <span><span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkNamedProd" class="anchored"><a href="#val-mkNamedProd" class="anchor"></a><code><span><span class="keyword">val</span> mkNamedProd : <span><span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkProd_or_LetIn" class="anchored"><a href="#val-mkProd_or_LetIn" class="anchor"></a><code><span><span class="keyword">val</span> mkProd_or_LetIn : <span><a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div><div class="spec-doc"><p>Constructs either <code>(x:t)c</code> or <code>[x=b:t]c</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkProd_wo_LetIn" class="anchored"><a href="#val-mkProd_wo_LetIn" class="anchor"></a><code><span><span class="keyword">val</span> mkProd_wo_LetIn : <span><a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkNamedProd_or_LetIn" class="anchored"><a href="#val-mkNamedProd_or_LetIn" class="anchor"></a><code><span><span class="keyword">val</span> mkNamedProd_or_LetIn : <span><a href="../Constr/index.html#type-named_declaration">Constr.named_declaration</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkNamedProd_wo_LetIn" class="anchored"><a href="#val-mkNamedProd_wo_LetIn" class="anchor"></a><code><span><span class="keyword">val</span> mkNamedProd_wo_LetIn : <span><a href="../Constr/index.html#type-named_declaration">Constr.named_declaration</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkLambda_or_LetIn" class="anchored"><a href="#val-mkLambda_or_LetIn" class="anchor"></a><code><span><span class="keyword">val</span> mkLambda_or_LetIn : <span><a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Constructs either <code>[x:t]c</code> or <code>[x=b:t]c</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkNamedLambda_or_LetIn" class="anchored"><a href="#val-mkNamedLambda_or_LetIn" class="anchor"></a><code><span><span class="keyword">val</span> mkNamedLambda_or_LetIn : <span><a href="../Constr/index.html#type-named_declaration">Constr.named_declaration</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><h6 id="other-term-constructors."><a href="#other-term-constructors." class="anchor"></a>Other term constructors.</h6><p><code>applist (f,args)</code> and its variants work as <code>mkApp</code></p><div class="odoc-spec"><div class="spec value" id="val-applist" class="anchored"><a href="#val-applist" class="anchor"></a><code><span><span class="keyword">val</span> applist : <span><span>(<a href="../Constr/index.html#type-constr">Constr.constr</a> * <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-applistc" class="anchored"><a href="#val-applistc" class="anchor"></a><code><span><span class="keyword">val</span> applistc : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-appvect" class="anchored"><a href="#val-appvect" class="anchor"></a><code><span><span class="keyword">val</span> appvect : <span><span>(<a href="../Constr/index.html#type-constr">Constr.constr</a> * <span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-appvectc" class="anchored"><a href="#val-appvectc" class="anchor"></a><code><span><span class="keyword">val</span> appvectc : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-prodn" class="anchored"><a href="#val-prodn" class="anchor"></a><code><span><span class="keyword">val</span> prodn : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>prodn n l b</code> = <code>forall (x_1:T_1)...(x_n:T_n), b</code> where <code>l</code> is <code>(x_n,T_n)...(x_1,T_1)...</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compose_prod" class="anchored"><a href="#val-compose_prod" class="anchor"></a><code><span><span class="keyword">val</span> compose_prod : <span><span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>compose_prod l b</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>forall (x_1:T_1)...(x_n:T_n), b</code> where <code>l</code> is <code>(x_n,T_n)...(x_1,T_1)</code>. Inverse of <code>decompose_prod</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-lamn" class="anchored"><a href="#val-lamn" class="anchor"></a><code><span><span class="keyword">val</span> lamn : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>lamn n l b</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>fun (x_1:T_1)...(x_n:T_n) =&gt; b</code> where <code>l</code> is <code>(x_n,T_n)...(x_1,T_1)...</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-compose_lam" class="anchored"><a href="#val-compose_lam" class="anchor"></a><code><span><span class="keyword">val</span> compose_lam : <span><span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>compose_lam l b</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>fun (x_1:T_1)...(x_n:T_n) =&gt; b</code> where <code>l</code> is <code>(x_n,T_n)...(x_1,T_1)</code>. Inverse of <code>it_destLam</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_lambda" class="anchored"><a href="#val-to_lambda" class="anchor"></a><code><span><span class="keyword">val</span> to_lambda : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>to_lambda n l</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>fun (x_1:T_1)...(x_n:T_n) =&gt; T</code> where <code>l</code> is <code>forall (x_1:T_1)...(x_n:T_n), T</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_prod" class="anchored"><a href="#val-to_prod" class="anchor"></a><code><span><span class="keyword">val</span> to_prod : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>to_prod n l</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>forall (x_1:T_1)...(x_n:T_n), T</code> where <code>l</code> is <code>fun (x_1:T_1)...(x_n:T_n) =&gt; T</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-it_mkLambda_or_LetIn" class="anchored"><a href="#val-it_mkLambda_or_LetIn" class="anchor"></a><code><span><span class="keyword">val</span> it_mkLambda_or_LetIn : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-it_mkProd_wo_LetIn" class="anchored"><a href="#val-it_mkProd_wo_LetIn" class="anchor"></a><code><span><span class="keyword">val</span> it_mkProd_wo_LetIn : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-it_mkProd_or_LetIn" class="anchored"><a href="#val-it_mkProd_or_LetIn" class="anchor"></a><code><span><span class="keyword">val</span> it_mkProd_or_LetIn : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lambda_applist" class="anchored"><a href="#val-lambda_applist" class="anchor"></a><code><span><span class="keyword">val</span> lambda_applist : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>In <code>lambda_applist c args</code>, <code>c</code> is supposed to have the form <code>λΓ.c</code> with <code>Γ</code> without let-in; it returns <code>c</code> with the variables of <code>Γ</code> instantiated by <code>args</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lambda_appvect" class="anchored"><a href="#val-lambda_appvect" class="anchor"></a><code><span><span class="keyword">val</span> lambda_appvect : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lambda_applist_assum" class="anchored"><a href="#val-lambda_applist_assum" class="anchor"></a><code><span><span class="keyword">val</span> lambda_applist_assum : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>In <code>lambda_applist_assum n c args</code>, <code>c</code> is supposed to have the form <code>λΓ.c</code> with <code>Γ</code> of length <code>n</code> and possibly with let-ins; it returns <code>c</code> with the assumptions of <code>Γ</code> instantiated by <code>args</code> and the local definitions of <code>Γ</code> expanded.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lambda_appvect_assum" class="anchored"><a href="#val-lambda_appvect_assum" class="anchor"></a><code><span><span class="keyword">val</span> lambda_appvect_assum : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><p>pseudo-reduction rule</p><div class="odoc-spec"><div class="spec value" id="val-prod_appvect" class="anchored"><a href="#val-prod_appvect" class="anchor"></a><code><span><span class="keyword">val</span> prod_appvect : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div><div class="spec-doc"><p><code>prod_appvect</code> <code>forall (x1:B1;...;xn:Bn), B</code> <code>a1...an</code></p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>B[a1...an]</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-prod_applist" class="anchored"><a href="#val-prod_applist" class="anchor"></a><code><span><span class="keyword">val</span> prod_applist : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-prod_appvect_assum" class="anchored"><a href="#val-prod_appvect_assum" class="anchor"></a><code><span><span class="keyword">val</span> prod_appvect_assum : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div><div class="spec-doc"><p>In <code>prod_appvect_assum n c args</code>, <code>c</code> is supposed to have the form <code>∀Γ.c</code> with <code>Γ</code> of length <code>n</code> and possibly with let-ins; it returns <code>c</code> with the assumptions of <code>Γ</code> instantiated by <code>args</code> and the local definitions of <code>Γ</code> expanded.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prod_applist_assum" class="anchored"><a href="#val-prod_applist_assum" class="anchor"></a><code><span><span class="keyword">val</span> prod_applist_assum : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div></div><h6 id="other-term-destructors."><a href="#other-term-destructors." class="anchor"></a>Other term destructors.</h6><div class="odoc-spec"><div class="spec value" id="val-decompose_prod" class="anchored"><a href="#val-decompose_prod" class="anchor"></a><code><span><span class="keyword">val</span> decompose_prod : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> * <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Transforms a product term <code> $ </code>(x_1:T_1)..(x_n:T_n)T<code> $ </code> into the pair <code> $ </code>(<code>(x_n,T_n);...;(x_1,T_1)</code>,T)<code> $ </code>, where <code> $ </code>T<code> $ </code> is not a product.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_lam" class="anchored"><a href="#val-decompose_lam" class="anchor"></a><code><span><span class="keyword">val</span> decompose_lam : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> * <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Transforms a lambda term <code> $ </code><code>x_1:T_1</code>..<code>x_n:T_n</code>T<code> $ </code> into the pair <code> $ </code>(<code>(x_n,T_n);...;(x_1,T_1)</code>,T)<code> $ </code>, where <code> $ </code>T<code> $ </code> is not a lambda.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_prod_n" class="anchored"><a href="#val-decompose_prod_n" class="anchor"></a><code><span><span class="keyword">val</span> decompose_prod_n : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> * <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Given a positive integer n, decompose a product term <code> $ </code>(x_1:T_1)..(x_n:T_n)T<code> $ </code> into the pair <code> $ </code>(<code>(xn,Tn);...;(x1,T1)</code>,T)<code> $ </code>. Raise a user error if not enough products.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_lam_n" class="anchored"><a href="#val-decompose_lam_n" class="anchor"></a><code><span><span class="keyword">val</span> decompose_lam_n : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Context/index.html#type-binder_annot">Context.binder_annot</a></span> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> * <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Given a positive integer <code> $ </code>n<code> $ </code>, decompose a lambda term <code> $ </code><code>x_1:T_1</code>..<code>x_n:T_n</code>T<code> $ </code> into the pair <code> $ </code>(<code>(x_n,T_n);...;(x_1,T_1)</code>,T)<code> $ </code>. Raise a user error if not enough lambdas.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_prod_assum" class="anchored"><a href="#val-decompose_prod_assum" class="anchor"></a><code><span><span class="keyword">val</span> decompose_prod_assum : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div><div class="spec-doc"><p>Extract the premisses and the conclusion of a term of the form &quot;(xi:Ti) ... (xj:=cj:Tj) ..., T&quot; where T is not a product nor a let</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_lam_assum" class="anchored"><a href="#val-decompose_lam_assum" class="anchor"></a><code><span><span class="keyword">val</span> decompose_lam_assum : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Idem with lambda's and let's</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_prod_n_assum" class="anchored"><a href="#val-decompose_prod_n_assum" class="anchor"></a><code><span><span class="keyword">val</span> decompose_prod_n_assum : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div><div class="spec-doc"><p>Idem but extract the first <code>n</code> premisses, counting let-ins.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_lam_n_assum" class="anchored"><a href="#val-decompose_lam_n_assum" class="anchor"></a><code><span><span class="keyword">val</span> decompose_lam_n_assum : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Idem for lambdas, _not_ counting let-ins</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decompose_lam_n_decls" class="anchored"><a href="#val-decompose_lam_n_decls" class="anchor"></a><code><span><span class="keyword">val</span> decompose_lam_n_decls : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Idem, counting let-ins</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prod_assum" class="anchored"><a href="#val-prod_assum" class="anchor"></a><code><span><span class="keyword">val</span> prod_assum : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p>Return the premisses/parameters of a type/term (let-in included)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lam_assum" class="anchored"><a href="#val-lam_assum" class="anchor"></a><code><span><span class="keyword">val</span> lam_assum : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-prod_n_assum" class="anchored"><a href="#val-prod_n_assum" class="anchor"></a><code><span><span class="keyword">val</span> prod_n_assum : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p>Return the first n-th premisses/parameters of a type (let included and counted)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lam_n_assum" class="anchored"><a href="#val-lam_n_assum" class="anchor"></a><code><span><span class="keyword">val</span> lam_n_assum : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p>Return the first n-th premisses/parameters of a term (let included but not counted)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-strip_prod" class="anchored"><a href="#val-strip_prod" class="anchor"></a><code><span><span class="keyword">val</span> strip_prod : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div><div class="spec-doc"><p>Remove the premisses/parameters of a type/term</p></div></div><div class="odoc-spec"><div class="spec value" id="val-strip_lam" class="anchored"><a href="#val-strip_lam" class="anchor"></a><code><span><span class="keyword">val</span> strip_lam : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-strip_prod_n" class="anchored"><a href="#val-strip_prod_n" class="anchor"></a><code><span><span class="keyword">val</span> strip_prod_n : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div><div class="spec-doc"><p>Remove the first n-th premisses/parameters of a type/term</p></div></div><div class="odoc-spec"><div class="spec value" id="val-strip_lam_n" class="anchored"><a href="#val-strip_lam_n" class="anchor"></a><code><span><span class="keyword">val</span> strip_lam_n : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-strip_prod_assum" class="anchored"><a href="#val-strip_prod_assum" class="anchor"></a><code><span><span class="keyword">val</span> strip_prod_assum : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div><div class="spec-doc"><p>Remove the premisses/parameters of a type/term (including let-in)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-strip_lam_assum" class="anchored"><a href="#val-strip_lam_assum" class="anchor"></a><code><span><span class="keyword">val</span> strip_lam_assum : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><h6 id="..."><a href="#..." class="anchor"></a>...</h6><p>An &quot;arity&quot; is a term of the form <code>[x1:T1]...[xn:Tn]s</code> with <code>s</code> a sort. Such a term can canonically be seen as the pair of a context of types and of a sort</p><div class="odoc-spec"><div class="spec type" id="type-arity" class="anchored"><a href="#type-arity" class="anchor"></a><code><span><span class="keyword">type</span> arity</span><span> = <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Sorts/index.html#type-t">Sorts.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mkArity" class="anchored"><a href="#val-mkArity" class="anchor"></a><code><span><span class="keyword">val</span> mkArity : <span><a href="#type-arity">arity</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div><div class="spec-doc"><p>Build an &quot;arity&quot; from its canonical form</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destArity" class="anchored"><a href="#val-destArity" class="anchor"></a><code><span><span class="keyword">val</span> destArity : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-arity">arity</a></span></code></div><div class="spec-doc"><p>Destruct an &quot;arity&quot; into its canonical form</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isArity" class="anchored"><a href="#val-isArity" class="anchor"></a><code><span><span class="keyword">val</span> isArity : <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Tell if a term has the form of an arity</p></div></div><div class="odoc-spec"><div class="spec type" id="type-sorts_family" class="anchored"><a href="#type-sorts_family" class="anchor"></a><code><span><span class="keyword">type</span> sorts_family</span><span> = <a href="../Sorts/index.html#type-family">Sorts.family</a></span><span> = </span></code><table><tr id="type-sorts_family.InSProp" class="anchored"><td class="def variant constructor"><a href="#type-sorts_family.InSProp" class="anchor"></a><code><span>| </span><span><span class="constructor">InSProp</span></span></code></td></tr><tr id="type-sorts_family.InProp" class="anchored"><td class="def variant constructor"><a href="#type-sorts_family.InProp" class="anchor"></a><code><span>| </span><span><span class="constructor">InProp</span></span></code></td></tr><tr id="type-sorts_family.InSet" class="anchored"><td class="def variant constructor"><a href="#type-sorts_family.InSet" class="anchor"></a><code><span>| </span><span><span class="constructor">InSet</span></span></code></td></tr><tr id="type-sorts_family.InType" class="anchored"><td class="def variant constructor"><a href="#type-sorts_family.InType" class="anchor"></a><code><span>| </span><span><span class="constructor">InType</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-sorts" class="anchored"><a href="#type-sorts" class="anchor"></a><code><span><span class="keyword">type</span> sorts</span><span> = <span class="keyword">private</span> <a href="../Sorts/index.html#type-t">Sorts.t</a></span><span> = </span></code><table><tr id="type-sorts.SProp" class="anchored"><td class="def variant constructor"><a href="#type-sorts.SProp" class="anchor"></a><code><span>| </span><span><span class="constructor">SProp</span></span></code></td></tr><tr id="type-sorts.Prop" class="anchored"><td class="def variant constructor"><a href="#type-sorts.Prop" class="anchor"></a><code><span>| </span><span><span class="constructor">Prop</span></span></code></td></tr><tr id="type-sorts.Set" class="anchored"><td class="def variant constructor"><a href="#type-sorts.Set" class="anchor"></a><code><span>| </span><span><span class="constructor">Set</span></span></code></td></tr><tr id="type-sorts.Type" class="anchored"><td class="def variant constructor"><a href="#type-sorts.Type" class="anchor"></a><code><span>| </span><span><span class="constructor">Type</span> <span class="keyword">of</span> <a href="../Univ/Universe/index.html#type-t">Univ.Universe.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Type</p><span class="comment-delim">*)</span></td></tr></table></div></div></div></body></html>