<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ltac_pretype (coq-core.Ltac_pretype)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq-core</a> &#x00BB; Ltac_pretype</nav><h1>Module <code>Ltac_pretype</code></h1><nav class="toc"><ul><li><a href="#maps-of-pattern-variables">Maps of pattern variables</a></li></ul></nav></header><section><header><h6 id="maps-of-pattern-variables"><a href="#maps-of-pattern-variables" class="anchor"></a>Maps of pattern variables</h6></header><aside><p>Type <code>constr_under_binders</code> is for representing the term resulting of a matching. Matching can return terms defined in a some context of named binders; in the context, variable names are ordered by (&lt;) and referred to by index in the term Thanks to the canonical ordering, a matching problem like</p><p><code>match ... with [(fun x y =&gt; ?p,fun y x =&gt; ?p)] =&gt; [forall x y =&gt; p]</code></p><p>will be accepted. Thanks to the reference by index, a matching problem like</p><p><code>match ... with [(fun x =&gt; ?p)] =&gt; [forall x =&gt; p]</code></p><p>will work even if <code>x</code> is also the name of an existing goal variable.</p><p>Note: we do not keep types in the signature. Besides simplicity, the main reason is that it would force to close the signature over binders that occur only in the types of effective binders but not in the term itself (e.g. for a term <code>f x</code> with <code>f:A -&gt; True</code> and <code>x:A</code>).</p><p>On the opposite side, by not keeping the types, we loose opportunity to propagate type informations which otherwise would not be inferable, as e.g. when matching <code>forall x, x = 0</code> with pattern <code>forall x, ?h = 0</code> and using the solution &quot;x|-h:=x&quot; in expression <code>forall x, h = x</code> where nothing tells how the type of x could be inferred. We also loose the ability of typing ltac variables before calling the right-hand-side of ltac matching clauses.</p></aside><dl><dt class="spec type" id="type-constr_under_binders"><a href="#type-constr_under_binders" class="anchor"></a><code><span class="keyword">type</span> constr_under_binders</code><code> = <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> * <a href="../EConstr/index.html#type-constr">EConstr.constr</a></code></dt></dl><aside><p>Types of substitutions with or w/o bound variables</p></aside><dl><dt class="spec type" id="type-patvar_map"><a href="#type-patvar_map" class="anchor"></a><code><span class="keyword">type</span> patvar_map</code><code> = <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <a href="../Names/Id/Map/index.html#type-t">Names.Id.Map.t</a></span></code></dt><dt class="spec type" id="type-extended_patvar_map"><a href="#type-extended_patvar_map" class="anchor"></a><code><span class="keyword">type</span> extended_patvar_map</code><code> = <span><a href="index.html#type-constr_under_binders">constr_under_binders</a> <a href="../Names/Id/Map/index.html#type-t">Names.Id.Map.t</a></span></code></dt><dt class="spec type" id="type-closure"><a href="#type-closure" class="anchor"></a><code><span class="keyword">type</span> closure</code><code> = </code><code>{</code><table class="record"><tr id="type-closure.idents" class="anchored"><td class="def field"><a href="#type-closure.idents" class="anchor"></a><code>idents : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <a href="../Names/Id/Map/index.html#type-t">Names.Id.Map.t</a></span>;</code></td></tr><tr id="type-closure.typed" class="anchored"><td class="def field"><a href="#type-closure.typed" class="anchor"></a><code>typed : <span><a href="index.html#type-constr_under_binders">constr_under_binders</a> <a href="../Names/Id/Map/index.html#type-t">Names.Id.Map.t</a></span>;</code></td></tr><tr id="type-closure.untyped" class="anchored"><td class="def field"><a href="#type-closure.untyped" class="anchor"></a><code>untyped : <span><a href="index.html#type-closed_glob_constr">closed_glob_constr</a> <a href="../Names/Id/Map/index.html#type-t">Names.Id.Map.t</a></span>;</code></td></tr></table><code>}</code></dt><dd><p>A globalised term together with a closure representing the value of its free variables. Intended for use when these variables are taken from the Ltac environment.</p></dd></dl><dl><dt class="spec type" id="type-closed_glob_constr"><a href="#type-closed_glob_constr" class="anchor"></a><code><span class="keyword">and</span> closed_glob_constr</code><code> = </code><code>{</code><table class="record"><tr id="type-closed_glob_constr.closure" class="anchored"><td class="def field"><a href="#type-closed_glob_constr.closure" class="anchor"></a><code>closure : <a href="index.html#type-closure">closure</a>;</code></td></tr><tr id="type-closed_glob_constr.term" class="anchored"><td class="def field"><a href="#type-closed_glob_constr.term" class="anchor"></a><code>term : <a href="../Glob_term/index.html#type-glob_constr">Glob_term.glob_constr</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-var_map"><a href="#type-var_map" class="anchor"></a><code><span class="keyword">type</span> var_map</code><code> = <span><a href="index.html#type-constr_under_binders">constr_under_binders</a> <a href="../Names/Id/Map/index.html#type-t">Names.Id.Map.t</a></span></code></dt><dd><p>Ltac variable maps</p></dd></dl><dl><dt class="spec type" id="type-uconstr_var_map"><a href="#type-uconstr_var_map" class="anchor"></a><code><span class="keyword">type</span> uconstr_var_map</code><code> = <span><a href="index.html#type-closed_glob_constr">closed_glob_constr</a> <a href="../Names/Id/Map/index.html#type-t">Names.Id.Map.t</a></span></code></dt><dt class="spec type" id="type-unbound_ltac_var_map"><a href="#type-unbound_ltac_var_map" class="anchor"></a><code><span class="keyword">type</span> unbound_ltac_var_map</code><code> = <span><a href="../Geninterp/Val/index.html#type-t">Geninterp.Val.t</a> <a href="../Names/Id/Map/index.html#type-t">Names.Id.Map.t</a></span></code></dt><dt class="spec type" id="type-ltac_var_map"><a href="#type-ltac_var_map" class="anchor"></a><code><span class="keyword">type</span> ltac_var_map</code><code> = </code><code>{</code><table class="record"><tr id="type-ltac_var_map.ltac_constrs" class="anchored"><td class="def field"><a href="#type-ltac_var_map.ltac_constrs" class="anchor"></a><code>ltac_constrs : <a href="index.html#type-var_map">var_map</a>;</code></td><td class="doc"><p>Ltac variables bound to constrs</p></td></tr><tr id="type-ltac_var_map.ltac_uconstrs" class="anchored"><td class="def field"><a href="#type-ltac_var_map.ltac_uconstrs" class="anchor"></a><code>ltac_uconstrs : <a href="index.html#type-uconstr_var_map">uconstr_var_map</a>;</code></td><td class="doc"><p>Ltac variables bound to untyped constrs</p></td></tr><tr id="type-ltac_var_map.ltac_idents" class="anchored"><td class="def field"><a href="#type-ltac_var_map.ltac_idents" class="anchor"></a><code>ltac_idents : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <a href="../Names/Id/Map/index.html#type-t">Names.Id.Map.t</a></span>;</code></td><td class="doc"><p>Ltac variables bound to identifiers</p></td></tr><tr id="type-ltac_var_map.ltac_genargs" class="anchored"><td class="def field"><a href="#type-ltac_var_map.ltac_genargs" class="anchor"></a><code>ltac_genargs : <a href="index.html#type-unbound_ltac_var_map">unbound_ltac_var_map</a>;</code></td><td class="doc"><p>All Ltac variables (to pass on ltac subterms, and for error reporting)</p></td></tr></table><code>}</code></dt></dl></section></div></body></html>