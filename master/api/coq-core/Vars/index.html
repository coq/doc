<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vars (coq-core.Vars)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">coq-core</a> &#x00BB; Vars</nav><h1>Module <code>Vars</code></h1><nav class="toc"><ul><li><a href="#occur-checks">Occur checks</a></li><li><a href="#relocation-and-substitution">Relocation and substitution</a></li><li><a href="#substitution-of-universes">Substitution of universes</a></li><li><a href="#low-level-cached-lift-type">Low-level cached lift type</a></li></ul></nav></header><section><header><h6 id="occur-checks"><a href="#occur-checks" class="anchor"></a>Occur checks</h6></header><dl><dt class="spec value" id="val-closedn"><a href="#val-closedn" class="anchor"></a><code><span class="keyword">val</span> closedn : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>closedn n M</code> is true iff <code>M</code> is a (de Bruijn) closed term under n binders</p></dd></dl><dl><dt class="spec value" id="val-closed0"><a href="#val-closed0" class="anchor"></a><code><span class="keyword">val</span> closed0 : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>closed0 M</code> is true iff <code>M</code> is a (de Bruijn) closed term</p></dd></dl><dl><dt class="spec value" id="val-noccurn"><a href="#val-noccurn" class="anchor"></a><code><span class="keyword">val</span> noccurn : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>noccurn n M</code> returns true iff <code>Rel n</code> does NOT occur in term <code>M</code></p></dd></dl><dl><dt class="spec value" id="val-noccur_between"><a href="#val-noccur_between" class="anchor"></a><code><span class="keyword">val</span> noccur_between : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>noccur_between n m M</code> returns true iff <code>Rel p</code> does NOT occur in term <code>M</code> for n &lt;= p &lt; n+m</p></dd></dl><dl><dt class="spec value" id="val-noccur_with_meta"><a href="#val-noccur_with_meta" class="anchor"></a><code><span class="keyword">val</span> noccur_with_meta : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Checking function for terms containing existential- or meta-variables. The function <code>noccur_with_meta</code> does not consider meta-variables applied to some terms (intended to be its local context) (for existential variables, it is necessarily the case)</p></dd></dl></section><section><header><h6 id="relocation-and-substitution"><a href="#relocation-and-substitution" class="anchor"></a>Relocation and substitution</h6></header><dl><dt class="spec value" id="val-exliftn"><a href="#val-exliftn" class="anchor"></a><code><span class="keyword">val</span> exliftn : <a href="../Esubst/index.html#type-lift">Esubst.lift</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>exliftn el c</code> lifts <code>c</code> with lifting <code>el</code></p></dd></dl><dl><dt class="spec value" id="val-liftn"><a href="#val-liftn" class="anchor"></a><code><span class="keyword">val</span> liftn : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>liftn n k c</code> lifts by <code>n</code> indexes above or equal to <code>k</code> in <code>c</code></p></dd></dl><dl><dt class="spec value" id="val-lift"><a href="#val-lift" class="anchor"></a><code><span class="keyword">val</span> lift : int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>lift n c</code> lifts by <code>n</code> the positive indexes in <code>c</code></p></dd></dl><aside><p>The type <code>substl</code> is the type of substitutions <code>u₁..un</code> of type some context Δ and defined in some environment Γ. Typing of substitutions is defined by:</p><ul><li>Γ ⊢ ∅ : ∅,</li><li>Γ ⊢ u₁..u<sub>n-1</sub> : Δ and Γ ⊢ u<sub>n</sub> : An[u₁..u<sub>n-1</sub>] implies Γ ⊢ u₁..u<sub>n</sub> : Δ,x<sub>n</sub>:A<sub>n</sub></li><li>Γ ⊢ u₁..u<sub>n-1</sub> : Δ and Γ ⊢ un : A<sub>n</sub>[u₁..u<sub>n-1</sub>] implies Γ ⊢ u₁..u<sub>n</sub> : Δ,x<sub>n</sub>:=c<sub>n</sub>:A<sub>n</sub> when Γ ⊢ u<sub>n</sub> ≡ c<sub>n</sub>[u₁..u<sub>n-1</sub>]</li></ul><p>Note that <code>u₁..un</code> is represented as a list with <code>un</code> at the head of the list, i.e. as <code>[un;...;u₁]</code>.</p></aside><dl><dt class="spec type" id="type-substl"><a href="#type-substl" class="anchor"></a><code><span class="keyword">type</span> substl</code><code> = <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span></code></dt></dl><dl><dt class="spec value" id="val-subst_of_rel_context_instance"><a href="#val-subst_of_rel_context_instance" class="anchor"></a><code><span class="keyword">val</span> subst_of_rel_context_instance : <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-substl">substl</a></code></dt><dd><p>Let <code>Γ</code> be a context interleaving declarations <code>x₁:T₁..xn:Tn</code> and definitions <code>y₁:=c₁..yp:=cp</code> in some context <code>Γ₀</code>. Let <code>u₁..un</code> be an <em>instance</em> of <code>Γ</code>, i.e. an instance in <code>Γ₀</code> of the <code>xi</code>. Then, <code>subst_of_rel_context_instance Γ u₁..un</code> returns the corresponding <em>substitution</em> of <code>Γ</code>, i.e. the appropriate interleaving <code>σ</code> of the <code>u₁..un</code> with the <code>c₁..cp</code>, all of them in <code>Γ₀</code>, so that a derivation <code>Γ₀, Γ, Γ₁|- t:T</code> can be instantiated into a derivation <code>Γ₀, Γ₁ |- t[σ]:T[σ]</code> using <code>substnl σ |Γ₁| t</code>. Note that the instance <code>u₁..un</code> is represented starting with <code>u₁</code>, as if usable in <code>applist</code> while the substitution is represented the other way round, i.e. ending with either <code>u₁</code> or <code>c₁</code>, as if usable for <code>substl</code>.</p></dd></dl><dl><dt class="spec value" id="val-adjust_rel_to_rel_context"><a href="#val-adjust_rel_to_rel_context" class="anchor"></a><code><span class="keyword">val</span> adjust_rel_to_rel_context : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Context/Rel/index.html#type-pt">Context.Rel.pt</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>Take an index in an instance of a context and returns its index wrt to the full context (e.g. 2 in <code>x:A;y:=b;z:C</code> is 3, i.e. a reference to z)</p></dd></dl><dl><dt class="spec value" id="val-substnl"><a href="#val-substnl" class="anchor"></a><code><span class="keyword">val</span> substnl : <a href="index.html#type-substl">substl</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>substnl [a₁;...;an] k c</code> substitutes in parallel <code>a₁</code>,...,<code>an</code> for respectively <code>Rel(k+1)</code>,...,<code>Rel(k+n)</code> in <code>c</code>; it relocates accordingly indexes in <code>an</code>,...,<code>a1</code> and <code>c</code>. In terms of typing, if Γ ⊢ a<sub>n</sub>..a₁ : Δ and Γ, Δ, Γ' ⊢ c : T with |Γ'|=k, then Γ, Γ' ⊢ <code>substnl [a₁;...;an] k c</code> : <code>substnl [a₁;...;an] k T</code>.</p></dd></dl><dl><dt class="spec value" id="val-substl"><a href="#val-substl" class="anchor"></a><code><span class="keyword">val</span> substl : <a href="index.html#type-substl">substl</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>substl σ c</code> is a short-hand for <code>substnl σ 0 c</code></p></dd></dl><dl><dt class="spec value" id="val-subst1"><a href="#val-subst1" class="anchor"></a><code><span class="keyword">val</span> subst1 : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>substl a c</code> is a short-hand for <code>substnl [a] 0 c</code></p></dd></dl><dl><dt class="spec value" id="val-substnl_decl"><a href="#val-substnl_decl" class="anchor"></a><code><span class="keyword">val</span> substnl_decl : <a href="index.html#type-substl">substl</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a></code></dt><dd><p><code>substnl_decl [a₁;...;an] k Ω</code> substitutes in parallel <code>a₁</code>, ..., <code>an</code> for respectively <code>Rel(k+1)</code>, ..., <code>Rel(k+n)</code> in <code>Ω</code>; it relocates accordingly indexes in <code>a₁</code>,...,<code>an</code> and <code>c</code>. In terms of typing, if Γ ⊢ a<sub>n</sub>..a₁ : Δ and Γ, Δ, Γ', Ω ⊢ with |Γ'|=<code>k</code>, then Γ, Γ', <code>substnl_decl [a₁;...;an]</code> k Ω ⊢.</p></dd></dl><dl><dt class="spec value" id="val-substl_decl"><a href="#val-substl_decl" class="anchor"></a><code><span class="keyword">val</span> substl_decl : <a href="index.html#type-substl">substl</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a></code></dt><dd><p><code>substl_decl σ Ω</code> is a short-hand for <code>substnl_decl σ 0 Ω</code></p></dd></dl><dl><dt class="spec value" id="val-subst1_decl"><a href="#val-subst1_decl" class="anchor"></a><code><span class="keyword">val</span> subst1_decl : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a></code></dt><dd><p><code>subst1_decl a Ω</code> is a short-hand for <code>substnl_decl [a] 0 Ω</code></p></dd></dl><dl><dt class="spec value" id="val-esubst"><a href="#val-esubst" class="anchor"></a><code><span class="keyword">val</span> esubst : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Esubst/index.html#type-subs">Esubst.subs</a></span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-replace_vars"><a href="#val-replace_vars" class="anchor"></a><code><span class="keyword">val</span> replace_vars : <span><span>(<a href="../Names/Id/index.html#type-t">Names.Id.t</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>replace_vars k [(id₁,c₁);...;(idn,cn)] t</code> substitutes <code>Var idj</code> by <code>cj</code> in <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-substn_vars"><a href="#val-substn_vars" class="anchor"></a><code><span class="keyword">val</span> substn_vars : int <span>&#45;&gt;</span> <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>substn_vars k [id₁;...;idn] t</code> substitutes <code>Var idj</code> by <code>Rel j+k-1</code> in <code>t</code>. If two names are identical, the one of least index is kept. In terms of typing, if Γ,x<sub>n</sub>:U<sub>n</sub>,...,x₁:U₁,Γ' ⊢ t:T, together with id<sub>j</sub>:T<sub>j</sub> and Γ,x<sub>n</sub>:U<sub>n</sub>,...,x₁:U₁,Γ' ⊢ T<sub>j</sub>[id<sub>j+1</sub>..id<sub>n</sub>:=x<sub>j+1</sub>..x<sub>n</sub>] ≡ Uj, then Γ\{id₁,...,id<sub>n</sub>},x<sub>n</sub>:U<sub>n</sub>,...,x₁:U₁,Γ' ⊢ <code>substn_vars
   (|Γ'|+1) [id₁;...;idn] t</code> : <code>substn_vars (|Γ'|+1) [id₁;...;idn]
   T</code>.</p></dd></dl><dl><dt class="spec value" id="val-subst_vars"><a href="#val-subst_vars" class="anchor"></a><code><span class="keyword">val</span> subst_vars : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>subst_vars [id1;...;idn] t</code> is a short-hand for <code>substn_vars
   [id1;...;idn] 1 t</code>: it substitutes <code>Var idj</code> by <code>Rel j</code> in <code>t</code>. If two names are identical, the one of least index is kept.</p></dd></dl><dl><dt class="spec value" id="val-subst_var"><a href="#val-subst_var" class="anchor"></a><code><span class="keyword">val</span> subst_var : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>subst_var id t</code> is a short-hand for <code>substn_vars [id] 1 t</code>: it substitutes <code>Var id</code> by <code>Rel 1</code> in <code>t</code>.</p></dd></dl></section><section><header><h4 id="substitution-of-universes"><a href="#substitution-of-universes" class="anchor"></a>Substitution of universes</h4></header><aside><p>Level substitutions for polymorphism.</p></aside><dl><dt class="spec value" id="val-subst_univs_level_constr"><a href="#val-subst_univs_level_constr" class="anchor"></a><code><span class="keyword">val</span> subst_univs_level_constr : <a href="../Univ/index.html#type-universe_level_subst">Univ.universe_level_subst</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dt class="spec value" id="val-subst_univs_level_context"><a href="#val-subst_univs_level_context" class="anchor"></a><code><span class="keyword">val</span> subst_univs_level_context : <a href="../Univ/index.html#type-universe_level_subst">Univ.universe_level_subst</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></code></dt><dt class="spec value" id="val-subst_instance_constr"><a href="#val-subst_instance_constr" class="anchor"></a><code><span class="keyword">val</span> subst_instance_constr : <a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Instance substitution for polymorphism.</p></dd></dl><dl><dt class="spec value" id="val-subst_instance_context"><a href="#val-subst_instance_context" class="anchor"></a><code><span class="keyword">val</span> subst_instance_context : <a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></code></dt><dt class="spec value" id="val-univ_instantiate_constr"><a href="#val-univ_instantiate_constr" class="anchor"></a><code><span class="keyword">val</span> univ_instantiate_constr : <a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> <span>&#45;&gt;</span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <a href="../Univ/index.html#type-univ_abstracted">Univ.univ_abstracted</a></span> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p>Ignores the constraints carried by <code>univ_abstracted</code>.</p></dd></dl><dl><dt class="spec value" id="val-universes_of_constr"><a href="#val-universes_of_constr" class="anchor"></a><code><span class="keyword">val</span> universes_of_constr : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../Univ/Level/Set/index.html#type-t">Univ.Level.Set.t</a></code></dt></dl></section><section><header><h4 id="low-level-cached-lift-type"><a href="#low-level-cached-lift-type" class="anchor"></a>Low-level cached lift type</h4></header><dl><dt class="spec type" id="type-substituend"><a href="#type-substituend" class="anchor"></a><code><span class="keyword">type</span> substituend</code></dt></dl><dl><dt class="spec value" id="val-make_substituend"><a href="#val-make_substituend" class="anchor"></a><code><span class="keyword">val</span> make_substituend : <a href="../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="index.html#type-substituend">substituend</a></code></dt><dt class="spec value" id="val-lift_substituend"><a href="#val-lift_substituend" class="anchor"></a><code><span class="keyword">val</span> lift_substituend : int <span>&#45;&gt;</span> <a href="index.html#type-substituend">substituend</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-constr">Constr.constr</a></code></dt></dl></section></div></body></html>