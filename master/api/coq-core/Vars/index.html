<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vars (coq-core.Vars)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">coq-core</a> &#x00BB; Vars</nav><header class="odoc-preamble"><h1>Module <code><span>Vars</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#occur-checks">Occur checks</a></li><li><a href="#relocation-and-substitution">Relocation and substitution</a></li><li><a href="#substitution-of-universes">Substitution of universes</a></li><li><a href="#low-level-cached-lift-type">Low-level cached lift type</a></li></ul></nav><div class="odoc-content"><h6 id="occur-checks"><a href="#occur-checks" class="anchor"></a>Occur checks</h6><div class="odoc-spec"><div class="spec value" id="val-closedn" class="anchored"><a href="#val-closedn" class="anchor"></a><code><span><span class="keyword">val</span> closedn : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>closedn n M</code> is true iff <code>M</code> is a (de Bruijn) closed term under n binders</p></div></div><div class="odoc-spec"><div class="spec value" id="val-closed0" class="anchored"><a href="#val-closed0" class="anchor"></a><code><span><span class="keyword">val</span> closed0 : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>closed0 M</code> is true iff <code>M</code> is a (de Bruijn) closed term</p></div></div><div class="odoc-spec"><div class="spec value" id="val-noccurn" class="anchored"><a href="#val-noccurn" class="anchor"></a><code><span><span class="keyword">val</span> noccurn : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>noccurn n M</code> returns true iff <code>Rel n</code> does NOT occur in term <code>M</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-noccur_between" class="anchored"><a href="#val-noccur_between" class="anchor"></a><code><span><span class="keyword">val</span> noccur_between : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>noccur_between n m M</code> returns true iff <code>Rel p</code> does NOT occur in term <code>M</code> for n &lt;= p &lt; n+m</p></div></div><div class="odoc-spec"><div class="spec value" id="val-noccur_with_meta" class="anchored"><a href="#val-noccur_with_meta" class="anchor"></a><code><span><span class="keyword">val</span> noccur_with_meta : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Checking function for terms containing existential- or meta-variables. The function <code>noccur_with_meta</code> does not consider meta-variables applied to some terms (intended to be its local context) (for existential variables, it is necessarily the case)</p></div></div><h6 id="relocation-and-substitution"><a href="#relocation-and-substitution" class="anchor"></a>Relocation and substitution</h6><div class="odoc-spec"><div class="spec value" id="val-exliftn" class="anchored"><a href="#val-exliftn" class="anchor"></a><code><span><span class="keyword">val</span> exliftn : <span><a href="../Esubst/index.html#type-lift">Esubst.lift</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>exliftn el c</code> lifts <code>c</code> with arbitrary complex lifting <code>el</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-liftn" class="anchored"><a href="#val-liftn" class="anchor"></a><code><span><span class="keyword">val</span> liftn : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>liftn n k c</code> lifts by <code>n</code> indices greater than or equal to <code>k</code> in <code>c</code> Note that with respect to substitution calculi's terminology, <code>n</code> is the _shift_ and <code>k</code> is the _lift_.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lift" class="anchored"><a href="#val-lift" class="anchor"></a><code><span><span class="keyword">val</span> lift : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>lift n c</code> lifts by <code>n</code> the positive indexes in <code>c</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-liftn_rel_context" class="anchored"><a href="#val-liftn_rel_context" class="anchor"></a><code><span><span class="keyword">val</span> liftn_rel_context : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p>Same as <code>liftn</code> for a context</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lift_rel_context" class="anchored"><a href="#val-lift_rel_context" class="anchor"></a><code><span><span class="keyword">val</span> lift_rel_context : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p>Same as <code>lift</code> for a context</p></div></div><p>The type <code>substl</code> is the type of substitutions <code>u₁..un</code> of type some well-typed context Δ and defined in some environment Γ. Typing of substitutions is defined by:</p><ul><li>Γ ⊢ ∅ : ∅,</li><li>Γ ⊢ u₁..u<sub>n-1</sub> : Δ and Γ ⊢ u<sub>n</sub> : An[u₁..u<sub>n-1</sub>] implies Γ ⊢ u₁..u<sub>n</sub> : Δ,x<sub>n</sub>:A<sub>n</sub></li><li>Γ ⊢ u₁..u<sub>n-1</sub> : Δ and Γ ⊢ un : A<sub>n</sub>[u₁..u<sub>n-1</sub>] implies Γ ⊢ u₁..u<sub>n</sub> : Δ,x<sub>n</sub>:=c<sub>n</sub>:A<sub>n</sub> when Γ ⊢ u<sub>n</sub> ≡ c<sub>n</sub>[u₁..u<sub>n-1</sub>]</li></ul><p>Note that <code>u₁..un</code> is represented as a list with <code>un</code> at the head of the list, i.e. as <code>[un;...;u₁]</code>.</p><p>A <code>substl</code> differs from an <code>instance</code> in that it includes the terms bound by lets while the latter does not. Also, their internal representations are in opposite order.</p><div class="odoc-spec"><div class="spec type" id="type-substl" class="anchored"><a href="#type-substl" class="anchor"></a><code><span><span class="keyword">type</span> substl</span><span> = <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span></span></code></div></div><p>The type <code>instance</code> is the type of instances <code>u₁..un</code> of a well-typed context Δ (relatively to some environment Γ). Typing of instances is defined by:</p><ul><li>Γ ⊢ ∅ : ∅,</li><li>Γ ⊢ u₁..u<sub>n</sub> : Δ and Γ ⊢ u<sub>n+1</sub> : A<sub>n+1</sub>[ϕ(Δ,u₁..u<sub>n</sub>)] implies Γ ⊢ u₁..u<sub>n+1</sub> : Δ,x<sub>n+1</sub>:A<sub>n+1</sub></li><li>Γ ⊢ u₁..u<sub>n</sub> : Δ implies Γ ⊢ u₁..u<sub>n</sub> : Δ,x<sub>n+1</sub>:=c<sub>n+1</sub>:A<sub>n+1</sub> where <code>ϕ(Δ,u₁..u{_n})</code> is the substitution obtained by adding lets of Δ to the instance so as to get a substitution (see <code>subst_of_rel_context_instance</code> below).</li></ul><p>Note that <code>u₁..un</code> is represented as an array with <code>u1</code> at the head of the array, i.e. as <code>[u₁;...;un]</code>. In particular, it can directly be used with <code>mkApp</code> to build an applicative term <code>f u₁..un</code> whenever <code>f</code> is of some type <code>forall Δ, T</code>.</p><p>An <code>instance</code> differs from a <code>substl</code> in that it does not include the terms bound by lets while the latter does. Also, their internal representations are in opposite order.</p><p>An <code>instance_list</code> is the same as an <code>instance</code> but using a list instead of an array.</p><div class="odoc-spec"><div class="spec type" id="type-instance" class="anchored"><a href="#type-instance" class="anchor"></a><code><span><span class="keyword">type</span> instance</span><span> = <span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-instance_list" class="anchored"><a href="#type-instance_list" class="anchor"></a><code><span><span class="keyword">type</span> instance_list</span><span> = <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-subst_of_rel_context_instance" class="anchored"><a href="#val-subst_of_rel_context_instance" class="anchor"></a><code><span><span class="keyword">val</span> subst_of_rel_context_instance : <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-instance">instance</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-substl">substl</a></span></code></div><div class="spec-doc"><p>Let <code>Γ</code> be a context interleaving declarations <code>x₁:T₁..xn:Tn</code> and definitions <code>y₁:=c₁..yp:=cp</code> in some context <code>Γ₀</code>. Let <code>u₁..un</code> be an <em>instance</em> of <code>Γ</code>, i.e. an instance in <code>Γ₀</code> of the <code>xi</code>. Then, <code>subst_of_rel_context_instance_list Γ u₁..un</code> returns the corresponding <em>substitution</em> of <code>Γ</code>, i.e. the appropriate interleaving <code>σ</code> of the <code>u₁..un</code> with the <code>c₁..cp</code>, all of them in <code>Γ₀</code>, so that a derivation <code>Γ₀, Γ, Γ₁|- t:T</code> can be instantiated into a derivation <code>Γ₀, Γ₁ |- t[σ]:T[σ]</code> using <code>substnl σ |Γ₁| t</code>. Note that the instance <code>u₁..un</code> is represented starting with <code>u₁</code>, as if usable in <code>applist</code> while the substitution is represented the other way round, i.e. ending with either <code>u₁</code> or <code>c₁</code>, as if usable for <code>substl</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subst_of_rel_context_instance_list" class="anchored"><a href="#val-subst_of_rel_context_instance_list" class="anchor"></a><code><span><span class="keyword">val</span> subst_of_rel_context_instance_list : <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-instance_list">instance_list</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-substl">substl</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-adjust_rel_to_rel_context" class="anchored"><a href="#val-adjust_rel_to_rel_context" class="anchor"></a><code><span><span class="keyword">val</span> adjust_rel_to_rel_context : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Context/Rel/index.html#type-pt">Context.Rel.pt</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Take an index in an instance of a context and returns its index wrt to the full context (e.g. 2 in <code>x:A;y:=b;z:C</code> is 3, i.e. a reference to z)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-substnl" class="anchored"><a href="#val-substnl" class="anchor"></a><code><span><span class="keyword">val</span> substnl : <span><a href="#type-substl">substl</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>substnl [a₁;...;an] k c</code> substitutes in parallel <code>a₁</code>,...,<code>an</code> for respectively <code>Rel(k+1)</code>,...,<code>Rel(k+n)</code> in <code>c</code>; it relocates accordingly indexes in <code>an</code>,...,<code>a1</code> and <code>c</code>. In terms of typing, if Γ ⊢ a<sub>n</sub>..a₁ : Δ and Γ, Δ, Γ' ⊢ c : T with |Γ'|=k, then Γ, Γ' ⊢ <code>substnl [a₁;...;an] k c</code> : <code>substnl [a₁;...;an] k T</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-substl" class="anchored"><a href="#val-substl" class="anchor"></a><code><span><span class="keyword">val</span> substl : <span><a href="#type-substl">substl</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>substl σ c</code> is a short-hand for <code>substnl σ 0 c</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-subst1" class="anchored"><a href="#val-subst1" class="anchor"></a><code><span><span class="keyword">val</span> subst1 : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>substl a c</code> is a short-hand for <code>substnl [a] 0 c</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-substnl_decl" class="anchored"><a href="#val-substnl_decl" class="anchor"></a><code><span><span class="keyword">val</span> substnl_decl : <span><a href="#type-substl">substl</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a></span></code></div><div class="spec-doc"><p><code>substnl_decl [a₁;...;an] k Ω</code> substitutes in parallel <code>a₁</code>, ..., <code>an</code> for respectively <code>Rel(k+1)</code>, ..., <code>Rel(k+n)</code> in a declaration <code>Ω</code>; it relocates accordingly indexes in <code>a₁</code>,...,<code>an</code> and <code>c</code>. In terms of typing, if Γ ⊢ a<sub>n</sub>..a₁ : Δ and Γ, Δ, Γ', Ω ⊢ with |Γ'|=<code>k</code>, then Γ, Γ', <code>substnl_decl [a₁;...;an]</code> k Ω ⊢.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-substl_decl" class="anchored"><a href="#val-substl_decl" class="anchor"></a><code><span><span class="keyword">val</span> substl_decl : <span><a href="#type-substl">substl</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a></span></code></div><div class="spec-doc"><p><code>substl_decl σ Ω</code> is a short-hand for <code>substnl_decl σ 0 Ω</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-subst1_decl" class="anchored"><a href="#val-subst1_decl" class="anchor"></a><code><span><span class="keyword">val</span> subst1_decl : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a></span></code></div><div class="spec-doc"><p><code>subst1_decl a Ω</code> is a short-hand for <code>substnl_decl [a] 0 Ω</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-substnl_rel_context" class="anchored"><a href="#val-substnl_rel_context" class="anchor"></a><code><span><span class="keyword">val</span> substnl_rel_context : <span><a href="#type-substl">substl</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p><code>substnl_rel_context [a₁;...;an] k Ω</code> substitutes in parallel <code>a₁</code>, ..., <code>an</code> for respectively <code>Rel(k+1)</code>, ..., <code>Rel(k+n)</code> in a context <code>Ω</code>; it relocates accordingly indexes in <code>a₁</code>,...,<code>an</code> and <code>c</code>. In terms of typing, if Γ ⊢ a<sub>n</sub>..a₁ : Δ and Γ, Δ, Γ', Ω ⊢ with |Γ'|=<code>k</code>, then Γ, Γ', <code>substnl_rel_context [a₁;...;an]</code> k Ω ⊢.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-substl_rel_context" class="anchored"><a href="#val-substl_rel_context" class="anchor"></a><code><span><span class="keyword">val</span> substl_rel_context : <span><a href="#type-substl">substl</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p><code>substl_rel_context σ Ω</code> is a short-hand for <code>substnl_rel_context σ 0 Ω</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-subst1_rel_context" class="anchored"><a href="#val-subst1_rel_context" class="anchor"></a><code><span><span class="keyword">val</span> subst1_rel_context : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p><code>subst1_rel_context a Ω</code> is a short-hand for <code>substnl_rel_context [a] 0 Ω</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-esubst" class="anchored"><a href="#val-esubst" class="anchor"></a><code><span><span class="keyword">val</span> esubst : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Esubst/index.html#type-subs">Esubst.subs</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>esubst lift σ c</code> substitutes <code>c</code> with arbitrary complex substitution <code>σ</code>, using <code>lift</code> to lift subterms where necessary.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-replace_vars" class="anchored"><a href="#val-replace_vars" class="anchor"></a><code><span><span class="keyword">val</span> replace_vars : <span><span><span>(<a href="../Names/Id/index.html#type-t">Names.Id.t</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>replace_vars k [(id₁,c₁);...;(idn,cn)] t</code> substitutes <code>Var idj</code> by <code>cj</code> in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-substn_vars" class="anchored"><a href="#val-substn_vars" class="anchor"></a><code><span><span class="keyword">val</span> substn_vars : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>substn_vars k [id₁;...;idn] t</code> substitutes <code>Var idj</code> by <code>Rel j+k-1</code> in <code>t</code>. If two names are identical, the one of least index is kept. In terms of typing, if Γ,x<sub>n</sub>:U<sub>n</sub>,...,x₁:U₁,Γ' ⊢ t:T, together with id<sub>j</sub>:T<sub>j</sub> and Γ,x<sub>n</sub>:U<sub>n</sub>,...,x₁:U₁,Γ' ⊢ T<sub>j</sub>[id<sub>j+1</sub>..id<sub>n</sub>:=x<sub>j+1</sub>..x<sub>n</sub>] ≡ Uj, then Γ\{id₁,...,id<sub>n</sub>},x<sub>n</sub>:U<sub>n</sub>,...,x₁:U₁,Γ' ⊢ <code>substn_vars
   (|Γ'|+1) [id₁;...;idn] t</code> : <code>substn_vars (|Γ'|+1) [id₁;...;idn]
   T</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subst_vars" class="anchored"><a href="#val-subst_vars" class="anchor"></a><code><span><span class="keyword">val</span> subst_vars : <span><span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>subst_vars [id1;...;idn] t</code> is a short-hand for <code>substn_vars
   [id1;...;idn] 1 t</code>: it substitutes <code>Var idj</code> by <code>Rel j</code> in <code>t</code>. If two names are identical, the one of least index is kept.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subst_var" class="anchored"><a href="#val-subst_var" class="anchor"></a><code><span><span class="keyword">val</span> subst_var : <span><a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p><code>subst_var id t</code> is a short-hand for <code>substn_vars [id] 1 t</code>: it substitutes <code>Var id</code> by <code>Rel 1</code> in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-smash_rel_context" class="anchored"><a href="#val-smash_rel_context" class="anchor"></a><code><span><span class="keyword">val</span> smash_rel_context : <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p>Expand lets in context</p></div></div><h4 id="substitution-of-universes"><a href="#substitution-of-universes" class="anchor"></a>Substitution of universes</h4><p>Level substitutions for polymorphism.</p><div class="odoc-spec"><div class="spec value" id="val-subst_univs_level_constr" class="anchored"><a href="#val-subst_univs_level_constr" class="anchor"></a><code><span><span class="keyword">val</span> subst_univs_level_constr : <span><a href="../Univ/index.html#type-universe_level_subst">Univ.universe_level_subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-subst_univs_level_context" class="anchored"><a href="#val-subst_univs_level_context" class="anchor"></a><code><span><span class="keyword">val</span> subst_univs_level_context : <span><a href="../Univ/index.html#type-universe_level_subst">Univ.universe_level_subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-subst_instance_constr" class="anchored"><a href="#val-subst_instance_constr" class="anchor"></a><code><span><span class="keyword">val</span> subst_instance_constr : <span><a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Instance substitution for polymorphism.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subst_instance_context" class="anchored"><a href="#val-subst_instance_context" class="anchor"></a><code><span><span class="keyword">val</span> subst_instance_context : <span><a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-univ_instantiate_constr" class="anchored"><a href="#val-univ_instantiate_constr" class="anchor"></a><code><span><span class="keyword">val</span> univ_instantiate_constr : <span><a href="../Univ/Instance/index.html#type-t">Univ.Instance.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> <a href="../Univ/index.html#type-univ_abstracted">Univ.univ_abstracted</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div><div class="spec-doc"><p>Ignores the constraints carried by <code>univ_abstracted</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-universes_of_constr" class="anchored"><a href="#val-universes_of_constr" class="anchor"></a><code><span><span class="keyword">val</span> universes_of_constr : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Univ/Level/Set/index.html#type-t">Univ.Level.Set.t</a></span></code></div></div><h4 id="low-level-cached-lift-type"><a href="#low-level-cached-lift-type" class="anchor"></a>Low-level cached lift type</h4><div class="odoc-spec"><div class="spec type" id="type-substituend" class="anchored"><a href="#type-substituend" class="anchor"></a><code><span><span class="keyword">type</span> substituend</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-make_substituend" class="anchored"><a href="#val-make_substituend" class="anchor"></a><code><span><span class="keyword">val</span> make_substituend : <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-substituend">substituend</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lift_substituend" class="anchored"><a href="#val-lift_substituend" class="anchor"></a><code><span><span class="keyword">val</span> lift_substituend : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-substituend">substituend</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-constr">Constr.constr</a></span></code></div></div></div></body></html>