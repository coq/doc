<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>List (coq-core.Util.List)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">coq-core</a> &#x00BB; <a href="../index.html">Util</a> &#x00BB; List</nav><h1>Module <code>Util.List</code></h1><nav class="toc"><ul><li><a href="#equality,-testing">Equality, testing</a></li><li><a href="#creating-lists">Creating lists</a></li><li><a href="#lists-as-arrays">Lists as arrays</a></li><li><a href="#filtering">Filtering</a></li><li><a href="#applying-functorially">Applying functorially</a></li><li><a href="#finding-position">Finding position</a></li><li><a href="#folding">Folding</a></li><li><a href="#splitting">Splitting</a></li><li><a href="#association-lists">Association lists</a></li><li><a href="#operations-on-lists-of-tuples">Operations on lists of tuples</a></li><li><a href="#operations-on-lists-seen-as-sets,-preserving-uniqueness-of-elements">Operations on lists seen as sets, preserving uniqueness of elements</a></li><li><a href="#uniqueness-and-duplication">Uniqueness and duplication</a></li><li><a href="#cartesian-product">Cartesian product</a></li></ul></nav></header><dl><dt class="spec type" id="type-cmp"><a href="#type-cmp" class="anchor"></a><code><span class="keyword">type</span> <span>'a cmp</span></code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec type" id="type-eq"><a href="#type-eq" class="anchor"></a><code><span class="keyword">type</span> <span>'a eq</span></code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> Stdlib.List</code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>!'a t</span></code><code> = <span><span class="type-var">'a</span> list</span></code><code> = </code><table class="variant"><tr id="type-t.([])" class="anchored"><td class="def constructor"><a href="#type-t.([])" class="anchor"></a><code>| </code><code><span class="constructor">([])</span></code></td></tr><tr id="type-t.(::)" class="anchored"><td class="def constructor"><a href="#type-t.(::)" class="anchor"></a><code>| </code><code><span class="constructor">(::)</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-compare_lengths"><a href="#val-compare_lengths" class="anchor"></a><code><span class="keyword">val</span> compare_lengths : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-compare_length_with"><a href="#val-compare_length_with" class="anchor"></a><code><span class="keyword">val</span> compare_length_with : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-hd"><a href="#val-hd" class="anchor"></a><code><span class="keyword">val</span> hd : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-tl"><a href="#val-tl" class="anchor"></a><code><span class="keyword">val</span> tl : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-nth_opt"><a href="#val-nth_opt" class="anchor"></a><code><span class="keyword">val</span> nth_opt : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-rev_append"><a href="#val-rev_append" class="anchor"></a><code><span class="keyword">val</span> rev_append : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><span><span class="type-var">'a</span> list</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span><span><span class="type-var">'a</span> list</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-rev_map"><a href="#val-rev_map" class="anchor"></a><code><span class="keyword">val</span> rev_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span class="keyword">val</span> iter2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span></code></dt><dt class="spec value" id="val-rev_map2"><a href="#val-rev_map2" class="anchor"></a><code><span class="keyword">val</span> rev_map2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span></code></dt><dt class="spec value" id="val-fold_left2"><a href="#val-fold_left2" class="anchor"></a><code><span class="keyword">val</span> fold_left2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_right2"><a href="#val-fold_right2" class="anchor"></a><code><span class="keyword">val</span> fold_right2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-for_all2"><a href="#val-for_all2" class="anchor"></a><code><span class="keyword">val</span> for_all2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-exists2"><a href="#val-exists2" class="anchor"></a><code><span class="keyword">val</span> exists2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-memq"><a href="#val-memq" class="anchor"></a><code><span class="keyword">val</span> memq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val</span> find_opt : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-find_all"><a href="#val-find_all" class="anchor"></a><code><span class="keyword">val</span> find_all : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span class="keyword">val</span> assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-assoc_opt"><a href="#val-assoc_opt" class="anchor"></a><code><span class="keyword">val</span> assoc_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dt class="spec value" id="val-assq"><a href="#val-assq" class="anchor"></a><code><span class="keyword">val</span> assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-assq_opt"><a href="#val-assq_opt" class="anchor"></a><code><span class="keyword">val</span> assq_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dt class="spec value" id="val-mem_assoc"><a href="#val-mem_assoc" class="anchor"></a><code><span class="keyword">val</span> mem_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-mem_assq"><a href="#val-mem_assq" class="anchor"></a><code><span class="keyword">val</span> mem_assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-remove_assoc"><a href="#val-remove_assoc" class="anchor"></a><code><span class="keyword">val</span> remove_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dt class="spec value" id="val-remove_assq"><a href="#val-remove_assq" class="anchor"></a><code><span class="keyword">val</span> remove_assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val</span> sort : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-stable_sort"><a href="#val-stable_sort" class="anchor"></a><code><span class="keyword">val</span> stable_sort : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-fast_sort"><a href="#val-fast_sort" class="anchor"></a><code><span class="keyword">val</span> fast_sort : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-sort_uniq"><a href="#val-sort_uniq" class="anchor"></a><code><span class="keyword">val</span> sort_uniq : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Stdlib.Seq.t</span></code></dt><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span><span class="type-var">'a</span> Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt></dl></details></div></div></div><section><header><h6 id="equality,-testing"><a href="#equality,-testing" class="anchor"></a>Equality, testing</h6></header><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span><span class="type-var">'a</span> <a href="index.html#type-cmp">cmp</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-cmp">cmp</a></span></code></dt><dd><p>Lexicographic order on lists.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-eq">eq</a></span></code></dt><dd><p>Lift equality to list type.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether a list is empty</p></dd></dl><dl><dt class="spec value" id="val-mem_f"><a href="#val-mem_f" class="anchor"></a><code><span class="keyword">val</span> mem_f : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <code>List.mem</code>, for some specific equality</p></dd></dl><dl><dt class="spec value" id="val-for_all_i"><a href="#val-for_all_i" class="anchor"></a><code><span class="keyword">val</span> for_all_i : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <code>List.for_all</code> but with an index</p></dd></dl><dl><dt class="spec value" id="val-for_all2eq"><a href="#val-for_all2eq" class="anchor"></a><code><span class="keyword">val</span> for_all2eq : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <code>List.for_all2</code> but returning <code>false</code> when of different length</p></dd></dl><dl><dt class="spec value" id="val-exists_i"><a href="#val-exists_i" class="anchor"></a><code><span class="keyword">val</span> exists_i : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <code>List.exists</code> but with an index</p></dd></dl><dl><dt class="spec value" id="val-prefix_of"><a href="#val-prefix_of" class="anchor"></a><code><span class="keyword">val</span> prefix_of : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-eq">eq</a></span></code></dt><dd><p><code>prefix_of eq l1 l2</code> returns <code>true</code> if <code>l1</code> is a prefix of <code>l2</code>, <code>false</code> otherwise. It uses <code>eq</code> to compare elements</p></dd></dl><dl><dt class="spec value" id="val-same_length"><a href="#val-same_length" class="anchor"></a><code><span class="keyword">val</span> same_length : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>A more efficient variant of <code>for_all2eq (fun _ _ -&gt; true)</code></p></dd></dl></section><section><header><h6 id="creating-lists"><a href="#creating-lists" class="anchor"></a>Creating lists</h6></header><dl><dt class="spec value" id="val-interval"><a href="#val-interval" class="anchor"></a><code><span class="keyword">val</span> interval : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int list</span></code></dt><dd><p><code>interval i j</code> creates the list <code>[i; i + 1; ...; j]</code>, or <code>[]</code> when <code>j &lt;= i</code>.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>make n x</code> returns a list made of <code>n</code> times <code>x</code>. Raise <code>Invalid_argument _</code> if <code>n</code> is negative.</p></dd></dl><dl><dt class="spec value" id="val-addn"><a href="#val-addn" class="anchor"></a><code><span class="keyword">val</span> addn : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>addn n x l</code> adds <code>n</code> times <code>x</code> on the left of <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>init n f</code> constructs the list <code>f 0; ... ; f (n - 1)</code>. Raise <code>Invalid_argument _</code> if <code>n</code> is negative</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Like OCaml's <code>List.append</code> but tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><span><span class="type-var">'a</span> list</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Like OCaml's <code>List.concat</code> but tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span><span><span class="type-var">'a</span> list</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Synonymous of <code>concat</code></p></dd></dl></section><section><header><h6 id="lists-as-arrays"><a href="#lists-as-arrays" class="anchor"></a>Lists as arrays</h6></header><dl><dt class="spec value" id="val-assign"><a href="#val-assign" class="anchor"></a><code><span class="keyword">val</span> assign : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>assign l i x</code> sets the <code>i</code>-th element of <code>l</code> to <code>x</code>, starting from <code>0</code>. Raise <code>Failure _</code> if <code>i</code> is out of range.</p></dd></dl></section><section><header><h6 id="filtering"><a href="#filtering" class="anchor"></a>Filtering</h6></header><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Like OCaml <code>List.filter</code> but tail-recursive and physically returns the original list if the predicate holds for all elements.</p></dd></dl><dl><dt class="spec value" id="val-filter2"><a href="#val-filter2" class="anchor"></a><code><span class="keyword">val</span> filter2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p>Like <code>List.filter</code> but with 2 arguments, raise <code>Invalid_argument _</code> if the lists are not of same length.</p></dd></dl><dl><dt class="spec value" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span class="keyword">val</span> filteri : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Like <code>List.filter</code> but with an index starting from <code>0</code></p></dd></dl><dl><dt class="spec value" id="val-filter_with"><a href="#val-filter_with" class="anchor"></a><code><span class="keyword">val</span> filter_with : <span>bool list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>filter_with bl l</code> selects elements of <code>l</code> whose corresponding element in <code>bl</code> is <code>true</code>. Raise <code>Invalid_argument _</code> if sizes differ.</p></dd></dl><dl><dt class="spec value" id="val-map_filter"><a href="#val-map_filter" class="anchor"></a><code><span class="keyword">val</span> map_filter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p>Like <code>map</code> but keeping only non-<code>None</code> elements</p></dd></dl><dl><dt class="spec value" id="val-map_filter_i"><a href="#val-map_filter_i" class="anchor"></a><code><span class="keyword">val</span> map_filter_i : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p>Like <code>map_filter</code> but with an index starting from <code>0</code></p></dd></dl><dl><dt class="spec value" id="val-partitioni"><a href="#val-partitioni" class="anchor"></a><code><span class="keyword">val</span> partitioni : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Like <code>List.partition</code> but with an index starting from <code>0</code></p></dd></dl></section><section><header><h6 id="applying-functorially"><a href="#applying-functorially" class="anchor"></a>Applying functorially</h6></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p>Like OCaml <code>List.map</code> but tail-recursive</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span></code></dt><dd><p>Like OCaml <code>List.map2</code> but tail-recursive</p></dd></dl><dl><dt class="spec value" id="val-map_left"><a href="#val-map_left" class="anchor"></a><code><span class="keyword">val</span> map_left : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p>As <code>map</code> but ensures the left-to-right order of evaluation.</p></dd></dl><dl><dt class="spec value" id="val-map_i"><a href="#val-map_i" class="anchor"></a><code><span class="keyword">val</span> map_i : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p>Like OCaml <code>List.mapi</code> but tail-recursive. Alternatively, like <code>map</code> but with an index</p></dd></dl><dl><dt class="spec value" id="val-map2_i"><a href="#val-map2_i" class="anchor"></a><code><span class="keyword">val</span> map2_i : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span></code></dt><dd><p>Like <code>map2</code> but with an index</p></dd></dl><dl><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">val</span> map3 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> list</span></code></dt><dd><p>Like <code>map</code> but for 3 lists.</p></dd></dl><dl><dt class="spec value" id="val-map4"><a href="#val-map4" class="anchor"></a><code><span class="keyword">val</span> map4 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'e</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'e</span> list</span></code></dt><dd><p>Like <code>map</code> but for 4 lists.</p></dd></dl><dl><dt class="spec value" id="val-map_of_array"><a href="#val-map_of_array" class="anchor"></a><code><span class="keyword">val</span> map_of_array : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> array</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>map_of_array f a</code> behaves as <code>List.map f (Array.to_list a)</code></p></dd></dl><dl><dt class="spec value" id="val-map_append"><a href="#val-map_append" class="anchor"></a><code><span class="keyword">val</span> map_append : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>map_append f [x1; ...; xn]</code> returns <code>f x1 @ ... @ f xn</code>.</p></dd></dl><dl><dt class="spec value" id="val-map_append2"><a href="#val-map_append2" class="anchor"></a><code><span class="keyword">val</span> map_append2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span></code></dt><dd><p>Like <code>map_append</code> but for two lists; raises <code>Invalid_argument _</code> if the two lists do not have the same length.</p></dd></dl><dl><dt class="spec value" id="val-extend"><a href="#val-extend" class="anchor"></a><code><span class="keyword">val</span> extend : <span>bool list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>extend l a [a1..an]</code> assumes that the number of <code>true</code> in <code>l</code> is <code>n</code>; it extends <code>a1..an</code> by inserting <code>a</code> at the position of <code>false</code> in <code>l</code></p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int</code></dt><dd><p>Count the number of elements satisfying a predicate</p></dd></dl></section><section><header><h6 id="finding-position"><a href="#finding-position" class="anchor"></a>Finding position</h6></header><dl><dt class="spec value" id="val-index"><a href="#val-index" class="anchor"></a><code><span class="keyword">val</span> index : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>index</code> returns the 1st index of an element in a list (counting from 1).</p></dd></dl><dl><dt class="spec value" id="val-safe_index"><a href="#val-safe_index" class="anchor"></a><code><span class="keyword">val</span> safe_index : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p><code>safe_index</code> returns the 1st index of an element in a list (counting from 1) and None otherwise.</p></dd></dl><dl><dt class="spec value" id="val-index0"><a href="#val-index0" class="anchor"></a><code><span class="keyword">val</span> index0 : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>index0</code> behaves as <code>index</code> except that it starts counting at 0.</p></dd></dl></section><section><header><h6 id="folding"><a href="#folding" class="anchor"></a>Folding</h6></header><dl><dt class="spec value" id="val-fold_left_until"><a href="#val-fold_left_until" class="anchor"></a><code><span class="keyword">val</span> fold_left_until : <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="../../CSig/index.html#type-until">CSig.until</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>acts like <code>fold_left f acc s</code> while <code>f</code> returns <code>Cont acc'</code>; it stops returning <code>c</code> as soon as <code>f</code> returns <code>Stop c</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right_i"><a href="#val-fold_right_i" class="anchor"></a><code><span class="keyword">val</span> fold_right_i : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Like <code>List.fold_right</code> but with an index</p></dd></dl><dl><dt class="spec value" id="val-fold_left_i"><a href="#val-fold_left_i" class="anchor"></a><code><span class="keyword">val</span> fold_left_i : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Like <code>List.fold_left</code> but with an index</p></dd></dl><dl><dt class="spec value" id="val-fold_right_and_left"><a href="#val-fold_right_and_left" class="anchor"></a><code><span class="keyword">val</span> fold_right_and_left : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold_right_and_left f [a1;...;an] hd</code> is <code>f (f (... (f (f hd an [an-1;...;a1]) an-1 [an-2;...;a1]) ...) a2 [a1]) a1 []</code></p></dd></dl><dl><dt class="spec value" id="val-fold_left3"><a href="#val-fold_left3" class="anchor"></a><code><span class="keyword">val</span> fold_left3 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Like <code>List.fold_left</code> but for 3 lists; raise <code>Invalid_argument _</code> if not all lists of the same size</p></dd></dl><dl><dt class="spec value" id="val-fold_left2_set"><a href="#val-fold_left2_set" class="anchor"></a><code><span class="keyword">val</span> fold_left2_set : exn <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Fold sets, i.e. lists up to order; the folding function tells when elements match by returning a value and raising the given exception otherwise; sets should have the same size; raise the given exception if no pairing of the two sets is found;; complexity in O(n^2)</p></dd></dl><dl><dt class="spec value" id="val-fold_left_map"><a href="#val-fold_left_map" class="anchor"></a><code><span class="keyword">val</span> fold_left_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'c</span> list</span></code></dt><dd><p><code>fold_left_map f e_0 [a1;...;an]</code> is <code>e_n,[k_1...k_n]</code> where <code>(e_i,k_i)</code> is <code>f e_{i-1} ai</code> for each i&lt;=n</p></dd></dl><dl><dt class="spec value" id="val-fold_right_map"><a href="#val-fold_right_map" class="anchor"></a><code><span class="keyword">val</span> fold_right_map : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> * <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> * <span class="type-var">'a</span></code></dt><dd><p>Same, folding on the right</p></dd></dl><dl><dt class="spec value" id="val-fold_left2_map"><a href="#val-fold_left2_map" class="anchor"></a><code><span class="keyword">val</span> fold_left2_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'d</span> list</span></code></dt><dd><p>Same with two lists, folding on the left</p></dd></dl><dl><dt class="spec value" id="val-fold_right2_map"><a href="#val-fold_right2_map" class="anchor"></a><code><span class="keyword">val</span> fold_right2_map : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> * <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> list</span> * <span class="type-var">'a</span></code></dt><dd><p>Same with two lists, folding on the right</p></dd></dl><dl><dt class="spec value" id="val-fold_left3_map"><a href="#val-fold_left3_map" class="anchor"></a><code><span class="keyword">val</span> fold_left3_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'e</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'e</span> list</span></code></dt><dd><p>Same with three lists, folding on the left</p></dd></dl><dl><dt class="spec value" id="val-fold_left4_map"><a href="#val-fold_left4_map" class="anchor"></a><code><span class="keyword">val</span> fold_left4_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'e</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'e</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'r</span> list</span></code></dt><dd><p>Same with four lists, folding on the left</p></dd></dl></section><section><header><h6 id="splitting"><a href="#splitting" class="anchor"></a>Splitting</h6></header><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>remove eq a l</code> Remove all occurrences of <code>a</code> in <code>l</code></p></dd></dl><dl><dt class="spec value" id="val-remove_first"><a href="#val-remove_first" class="anchor"></a><code><span class="keyword">val</span> remove_first : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Remove the first element satisfying a predicate, or raise <code>Not_found</code></p></dd></dl><dl><dt class="spec value" id="val-extract_first"><a href="#val-extract_first" class="anchor"></a><code><span class="keyword">val</span> extract_first : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span class="type-var">'a</span></code></dt><dd><p>Remove and return the first element satisfying a predicate, or raise <code>Not_found</code></p></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p><code>find_map f l</code> applies <code>f</code> to the elements of <code>l</code> in order, and returns the first result of the form <code>Some v</code>, or <code>None</code> if none exist.</p><p>In stdlib since OCaml 4.10.0</p></dd></dl><dl><dt class="spec value" id="val-find_map_exn"><a href="#val-find_map_exn" class="anchor"></a><code><span class="keyword">val</span> find_map_exn : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Like <code>find_map</code> but raises <code>Not_found</code> instead of returning <code>None</code>.</p></dd></dl><dl><dt class="spec exception" id="exception-IndexOutOfRange"><a href="#exception-IndexOutOfRange" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">IndexOutOfRange</span></code></dt></dl><dl><dt class="spec value" id="val-goto"><a href="#val-goto" class="anchor"></a><code><span class="keyword">val</span> goto : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>goto i l</code> splits <code>l</code> into two lists <code>(l1,l2)</code> such that <code>(List.rev l1)++l2=l</code> and <code>l1</code> has length <code>i</code>. It raises <code>IndexOutOfRange</code> when <code>i</code> is negative or greater than the length of <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-split_when"><a href="#val-split_when" class="anchor"></a><code><span class="keyword">val</span> split_when : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>split_when p l</code> splits <code>l</code> into two lists <code>(l1,a::l2)</code> such that <code>l1++(a::l2)=l</code>, <code>p a=true</code> and <code>p b = false</code> for every element <code>b</code> of <code>l1</code>. if there is no such <code>a</code>, then it returns <code>(l,[])</code> instead.</p></dd></dl><dl><dt class="spec value" id="val-sep_first"><a href="#val-sep_first" class="anchor"></a><code><span class="keyword">val</span> sep_first : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>sep_first l</code> returns <code>(a,l')</code> such that <code>l</code> is <code>a::l'</code>. It raises <code>Failure _</code> if the list is empty.</p></dd></dl><dl><dt class="spec value" id="val-sep_last"><a href="#val-sep_last" class="anchor"></a><code><span class="keyword">val</span> sep_last : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>sep_last l</code> returns <code>(a,l')</code> such that <code>l</code> is <code>l'@[a]</code>. It raises <code>Failure _</code> if the list is empty.</p></dd></dl><dl><dt class="spec value" id="val-drop_last"><a href="#val-drop_last" class="anchor"></a><code><span class="keyword">val</span> drop_last : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Remove the last element of the list. It raises <code>Failure _</code> if the list is empty. This is the second part of <code>sep_last</code>.</p></dd></dl><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val</span> last : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the last element of the list. It raises <code>Failure _</code> if the list is empty. This is the first part of <code>sep_last</code>.</p></dd></dl><dl><dt class="spec value" id="val-lastn"><a href="#val-lastn" class="anchor"></a><code><span class="keyword">val</span> lastn : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>lastn n l</code> returns the <code>n</code> last elements of <code>l</code>. It raises <code>Failure _</code> if <code>n</code> is less than 0 or larger than the length of <code>l</code></p></dd></dl><dl><dt class="spec value" id="val-chop"><a href="#val-chop" class="anchor"></a><code><span class="keyword">val</span> chop : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>chop i l</code> splits <code>l</code> into two lists <code>(l1,l2)</code> such that <code>l1++l2=l</code> and <code>l1</code> has length <code>i</code>. It raises <code>Failure _</code> when <code>i</code> is negative or greater than the length of <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-firstn"><a href="#val-firstn" class="anchor"></a><code><span class="keyword">val</span> firstn : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>firstn n l</code> Returns the <code>n</code> first elements of <code>l</code>. It raises <code>Failure _</code> if <code>n</code> negative or too large. This is the first part of <code>chop</code>.</p></dd></dl><dl><dt class="spec value" id="val-skipn"><a href="#val-skipn" class="anchor"></a><code><span class="keyword">val</span> skipn : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>skipn n l</code> drops the <code>n</code> first elements of <code>l</code>. It raises <code>Failure _</code> if <code>n</code> is less than 0 or larger than the length of <code>l</code>. This is the second part of <code>chop</code>.</p></dd></dl><dl><dt class="spec value" id="val-skipn_at_least"><a href="#val-skipn_at_least" class="anchor"></a><code><span class="keyword">val</span> skipn_at_least : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Same as <code>skipn</code> but returns <code></code> if <code>n</code> is larger than the length of the list.</p></dd></dl><dl><dt class="spec value" id="val-drop_prefix"><a href="#val-drop_prefix" class="anchor"></a><code><span class="keyword">val</span> drop_prefix : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>drop_prefix eq l1 l</code> returns <code>l2</code> if <code>l=l1++l2</code> else return <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-insert"><a href="#val-insert" class="anchor"></a><code><span class="keyword">val</span> insert : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Insert at the (first) position so that if the list is ordered wrt to the total order given as argument, the order is preserved</p></dd></dl><dl><dt class="spec value" id="val-share_tails"><a href="#val-share_tails" class="anchor"></a><code><span class="keyword">val</span> share_tails : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>share_tails l1 l2</code> returns <code>(l1',l2',l)</code> such that <code>l1</code> is <code>l1'\@l</code> and <code>l2</code> is <code>l2'\@l</code> and <code>l</code> is maximal amongst all such decompositions</p></dd></dl></section><section><header><h6 id="association-lists"><a href="#association-lists" class="anchor"></a>Association lists</h6></header><dl><dt class="spec value" id="val-map_assoc"><a href="#val-map_assoc" class="anchor"></a><code><span class="keyword">val</span> map_assoc : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span> * <span class="type-var">'a</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dd><p>Applies a function on the codomain of an association list</p></dd></dl><dl><dt class="spec value" id="val-assoc_f"><a href="#val-assoc_f" class="anchor"></a><code><span class="keyword">val</span> assoc_f : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Like <code>List.assoc</code> but using the equality given as argument</p></dd></dl><dl><dt class="spec value" id="val-assoc_f_opt"><a href="#val-assoc_f_opt" class="anchor"></a><code><span class="keyword">val</span> assoc_f_opt : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p>Like <code>List.assoc_opt</code> but using the equality given as argument</p></dd></dl><dl><dt class="spec value" id="val-remove_assoc_f"><a href="#val-remove_assoc_f" class="anchor"></a><code><span class="keyword">val</span> remove_assoc_f : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dd><p>Remove first matching element; unchanged if no such element</p></dd></dl><dl><dt class="spec value" id="val-mem_assoc_f"><a href="#val-mem_assoc_f" class="anchor"></a><code><span class="keyword">val</span> mem_assoc_f : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Like <code>List.mem_assoc</code> but using the equality given as argument</p></dd></dl><dl><dt class="spec value" id="val-factorize_left"><a href="#val-factorize_left" class="anchor"></a><code><span class="keyword">val</span> factorize_left : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span>)</span> list</span></code></dt><dd><p>Create a list of associations from a list of pairs</p></dd></dl></section><section><header><h6 id="operations-on-lists-of-tuples"><a href="#operations-on-lists-of-tuples" class="anchor"></a>Operations on lists of tuples</h6></header><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p>Like OCaml's <code>List.split</code> but tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dd><p>Like OCaml's <code>List.combine</code> but tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-split3"><a href="#val-split3" class="anchor"></a><code><span class="keyword">val</span> split3 : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span></code></dt><dd><p>Like <code>split</code> but for triples</p></dd></dl><dl><dt class="spec value" id="val-split4"><a href="#val-split4" class="anchor"></a><code><span class="keyword">val</span> split4 : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span> * <span class="type-var">'d</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span> * <span><span class="type-var">'d</span> list</span></code></dt><dd><p>Like <code>split</code> but for quads</p></dd></dl><dl><dt class="spec value" id="val-combine3"><a href="#val-combine3" class="anchor"></a><code><span class="keyword">val</span> combine3 : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> list</span></code></dt><dd><p>Like <code>combine</code> but for triples</p></dd></dl></section><section><header><h6 id="operations-on-lists-seen-as-sets,-preserving-uniqueness-of-elements"><a href="#operations-on-lists-seen-as-sets,-preserving-uniqueness-of-elements" class="anchor"></a>Operations on lists seen as sets, preserving uniqueness of elements</h6></header><dl><dt class="spec value" id="val-add_set"><a href="#val-add_set" class="anchor"></a><code><span class="keyword">val</span> add_set : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>add_set x l</code> adds <code>x</code> in <code>l</code> if it is not already there, or returns <code>l</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-eq_set"><a href="#val-eq_set" class="anchor"></a><code><span class="keyword">val</span> eq_set : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-eq">eq</a></span></code></dt><dd><p>Test equality up to permutation. It respects multiple occurrences and thus works also on multisets.</p></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val</span> subset : <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-eq">eq</a></span></code></dt><dd><p>Tell if a list is a subset of another up to permutation. It expects each element to occur only once.</p></dd></dl><dl><dt class="spec value" id="val-merge_set"><a href="#val-merge_set" class="anchor"></a><code><span class="keyword">val</span> merge_set : <span><span class="type-var">'a</span> <a href="index.html#type-cmp">cmp</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Merge two sorted lists and preserves the uniqueness property.</p></dd></dl><dl><dt class="spec value" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span class="keyword">val</span> intersect : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Return the intersection of two lists, assuming and preserving uniqueness of elements</p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Return the union of two lists, assuming and preserving uniqueness of elements</p></dd></dl><dl><dt class="spec value" id="val-unionq"><a href="#val-unionq" class="anchor"></a><code><span class="keyword">val</span> unionq : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>union</code> specialized to physical equality</p></dd></dl><dl><dt class="spec value" id="val-subtract"><a href="#val-subtract" class="anchor"></a><code><span class="keyword">val</span> subtract : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Remove from the first list all elements from the second list.</p></dd></dl><dl><dt class="spec value" id="val-subtractq"><a href="#val-subtractq" class="anchor"></a><code><span class="keyword">val</span> subtractq : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>subtract</code> specialized to physical equality</p></dd></dl></section><section><header><h6 id="uniqueness-and-duplication"><a href="#uniqueness-and-duplication" class="anchor"></a>Uniqueness and duplication</h6></header><dl><dt class="spec value" id="val-distinct"><a href="#val-distinct" class="anchor"></a><code><span class="keyword">val</span> distinct : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Return <code>true</code> if all elements of the list are distinct.</p></dd></dl><dl><dt class="spec value" id="val-distinct_f"><a href="#val-distinct_f" class="anchor"></a><code><span class="keyword">val</span> distinct_f : <span><span class="type-var">'a</span> <a href="index.html#type-cmp">cmp</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Like <code>distinct</code> but using the equality given as argument</p></dd></dl><dl><dt class="spec value" id="val-duplicates"><a href="#val-duplicates" class="anchor"></a><code><span class="keyword">val</span> duplicates : <span><span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Return the list of unique elements which appear at least twice. Elements are kept in the order of their first appearance.</p></dd></dl><dl><dt class="spec value" id="val-uniquize_key"><a href="#val-uniquize_key" class="anchor"></a><code><span class="keyword">val</span> uniquize_key : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Return the list of elements without duplicates using the function to associate a comparison key to each element. This is the list unchanged if there was none.</p></dd></dl><dl><dt class="spec value" id="val-uniquize"><a href="#val-uniquize" class="anchor"></a><code><span class="keyword">val</span> uniquize : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Return the list of elements without duplicates. This is the list unchanged if there was none.</p></dd></dl><dl><dt class="spec value" id="val-sort_uniquize"><a href="#val-sort_uniquize" class="anchor"></a><code><span class="keyword">val</span> sort_uniquize : <span><span class="type-var">'a</span> <a href="index.html#type-cmp">cmp</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Return a sorted version of a list without duplicates according to some comparison function.</p></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : <span><span class="type-var">'a</span> <a href="index.html#type-cmp">cmp</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return minimum element according to some comparison function.</p><dl><dt>raises Not_found</dt><dd><p>on an empty list.</p></dd></dl></dd></dl></section><section><header><h6 id="cartesian-product"><a href="#cartesian-product" class="anchor"></a>Cartesian product</h6></header><dl><dt class="spec value" id="val-cartesian"><a href="#val-cartesian" class="anchor"></a><code><span class="keyword">val</span> cartesian : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span></code></dt><dd><p>A generic binary cartesian product: for any operator (**), <code>cartesian (**) [x1;x2] [y1;y2] = [x1**y1; x1**y2; x2**y1; x2**y1]</code>, and so on if there are more elements in the lists.</p></dd></dl><dl><dt class="spec value" id="val-cartesians"><a href="#val-cartesians" class="anchor"></a><code><span class="keyword">val</span> cartesians : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>cartesians op init l</code> is an n-ary cartesian product: it builds the list of all <code>op a1 .. (op an init) ..</code> for <code>a1</code>, ..., <code>an</code> in the product of the elements of the lists</p></dd></dl><dl><dt class="spec value" id="val-combinations"><a href="#val-combinations" class="anchor"></a><code><span class="keyword">val</span> combinations : <span><span><span class="type-var">'a</span> list</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt><dd><p><code>combinations l</code> returns the list of <code>n_1</code> * ... * <code>n_p</code> tuples <code>[a11;...;ap1];...;[a1n_1;...;apn_pd]</code> whenever <code>l</code> is a list <code>[a11;..;a1n_1];...;[ap1;apn_p]</code>; otherwise said, it is <code>cartesians (::) [] l</code></p></dd></dl><dl><dt class="spec value" id="val-cartesians_filter"><a href="#val-cartesians_filter" class="anchor"></a><code><span class="keyword">val</span> cartesians_filter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p>Like <code>cartesians op init l</code> but keep only the tuples for which <code>op</code> returns <code>Some _</code> on all the elements of the tuple.</p></dd></dl><dl><dt class="spec module" id="module-Smart"><a href="#module-Smart" class="anchor"></a><code><span class="keyword">module</span> Smart = <a href="../../CList/index.html#module-Smart">CList.Smart</a></code></dt><dd><p>When returning a list of same type as the input, maximally shares the suffix of the output which is physically equal to the corresponding suffix of the input</p></dd></dl><div class="spec module-type" id="module-type-MonoS"><a href="#module-type-MonoS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MonoS/index.html">MonoS</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>