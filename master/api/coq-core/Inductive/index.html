<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Inductive (coq-core.Inductive)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">coq-core</a> &#x00BB; Inductive</nav><header class="odoc-preamble"><h1>Module <code><span>Inductive</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#extracting-an-inductive-type-from-a-construction">Extracting an inductive type from a construction</a></li><li><a href="#functions-to-build-standard-types-related-to-inductive">Functions to build standard types related to inductive</a></li><li><a href="#guard-conditions-for-fix-and-cofix-points.">Guard conditions for fix and cofix-points.</a></li><li><a href="#support-for-sort-polymorphic-inductive-types">Support for sort-polymorphic inductive types</a></li></ul></nav><div class="odoc-content"><h6 id="extracting-an-inductive-type-from-a-construction"><a href="#extracting-an-inductive-type-from-a-construction" class="anchor"></a>Extracting an inductive type from a construction</h6><p><code>find_m*type env sigma c</code> coerce <code>c</code> to an recursive type (I args). <code>find_rectype</code>, <code>find_inductive</code> and <code>find_coinductive</code> respectively accepts any recursive type, only an inductive type and only a coinductive type. They raise <code>Not_found</code> if not convertible to a recursive type.</p><div class="odoc-spec"><div class="spec value" id="val-find_rectype" class="anchored"><a href="#val-find_rectype" class="anchor"></a><code><span><span class="keyword">val</span> find_rectype : <span>?evars:<a href="../CClosure/index.html#type-evar_handler">CClosure.evar_handler</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> * <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-find_inductive" class="anchored"><a href="#val-find_inductive" class="anchor"></a><code><span><span class="keyword">val</span> find_inductive : <span>?evars:<a href="../CClosure/index.html#type-evar_handler">CClosure.evar_handler</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> * <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-find_coinductive" class="anchored"><a href="#val-find_coinductive" class="anchor"></a><code><span><span class="keyword">val</span> find_coinductive : <span>?evars:<a href="../CClosure/index.html#type-evar_handler">CClosure.evar_handler</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> * <span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lookup_mind_specif" class="anchored"><a href="#val-lookup_mind_specif" class="anchor"></a><code><span><span class="keyword">val</span> lookup_mind_specif : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/index.html#type-inductive">Names.inductive</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a></span></code></div><div class="spec-doc"><p>Fetching information in the environment about an inductive type. Raises an anomaly if the inductive type is not found.</p></div></div><h6 id="functions-to-build-standard-types-related-to-inductive"><a href="#functions-to-build-standard-types-related-to-inductive" class="anchor"></a>Functions to build standard types related to inductive</h6><div class="odoc-spec"><div class="spec value" id="val-inductive_paramdecls" class="anchored"><a href="#val-inductive_paramdecls" class="anchor"></a><code><span><span class="keyword">val</span> inductive_paramdecls : <span><span><a href="../Declarations/index.html#type-mutual_inductive_body">Declarations.mutual_inductive_body</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p>Returns the parameters of an inductive type with universes instantiated</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inductive_nonrec_rec_paramdecls" class="anchored"><a href="#val-inductive_nonrec_rec_paramdecls" class="anchor"></a><code><span><span class="keyword">val</span> inductive_nonrec_rec_paramdecls : <span><span><a href="../Declarations/index.html#type-mutual_inductive_body">Declarations.mutual_inductive_body</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p>Returns the parameters of an inductive type with universes instantiated, splitting it into the contexts of recursively uniform and recursively non-uniform parameters</p></div></div><div class="odoc-spec"><div class="spec value" id="val-instantiate_inductive_constraints" class="anchored"><a href="#val-instantiate_inductive_constraints" class="anchor"></a><code><span><span class="keyword">val</span> instantiate_inductive_constraints : <span><a href="../Declarations/index.html#type-mutual_inductive_body">Declarations.mutual_inductive_body</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Univ/Constraints/index.html#type-t">Univ.Constraints.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-template_univ" class="anchored"><a href="#type-template_univ" class="anchor"></a><code><span><span class="keyword">type</span> template_univ</span><span> = </span></code><table><tr id="type-template_univ.TemplateProp" class="anchored"><td class="def variant constructor"><a href="#type-template_univ.TemplateProp" class="anchor"></a><code><span>| </span><span><span class="constructor">TemplateProp</span></span></code></td></tr><tr id="type-template_univ.TemplateUniv" class="anchored"><td class="def variant constructor"><a href="#type-template_univ.TemplateUniv" class="anchor"></a><code><span>| </span><span><span class="constructor">TemplateUniv</span> <span class="keyword">of</span> <a href="../Univ/Universe/index.html#type-t">Univ.Universe.t</a></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-param_univs" class="anchored"><a href="#type-param_univs" class="anchor"></a><code><span><span class="keyword">type</span> param_univs</span><span> = <span><span>(<span>expected:<a href="../Univ/Level/index.html#type-t">Univ.Level.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-template_univ">template_univ</a>)</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-instantiate_template_constraints" class="anchored"><a href="#val-instantiate_template_constraints" class="anchor"></a><code><span><span class="keyword">val</span> instantiate_template_constraints : <span><span><a href="#type-template_univ">template_univ</a> <a href="../Univ/Level/Map/index.html#type-t">Univ.Level.Map.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Declarations/index.html#type-template_universes">Declarations.template_universes</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Univ/Constraints/index.html#type-t">Univ.Constraints.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-instantiate_template_universes" class="anchored"><a href="#val-instantiate_template_universes" class="anchor"></a><code><span><span class="keyword">val</span> instantiate_template_universes : <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-param_univs">param_univs</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Univ/Constraints/index.html#type-t">Univ.Constraints.t</a> * <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <span><a href="#type-template_univ">template_univ</a> <a href="../Univ/Level/Map/index.html#type-t">Univ.Level.Map.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-constrained_type_of_inductive" class="anchored"><a href="#val-constrained_type_of_inductive" class="anchor"></a><code><span><span class="keyword">val</span> constrained_type_of_inductive : <span><span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <a href="../Univ/index.html#type-constrained">Univ.constrained</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-relevance_of_ind_body" class="anchored"><a href="#val-relevance_of_ind_body" class="anchor"></a><code><span><span class="keyword">val</span> relevance_of_ind_body : <span><a href="../Declarations/index.html#type-one_inductive_body">Declarations.one_inductive_body</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-relevance_of_inductive" class="anchored"><a href="#val-relevance_of_inductive" class="anchor"></a><code><span><span class="keyword">val</span> relevance_of_inductive : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-type_of_inductive" class="anchored"><a href="#val-type_of_inductive" class="anchor"></a><code><span><span class="keyword">val</span> type_of_inductive : <span><span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-type_of_inductive_knowing_parameters" class="anchored"><a href="#val-type_of_inductive_knowing_parameters" class="anchor"></a><code><span><span class="keyword">val</span> type_of_inductive_knowing_parameters : <span>?polyprop:bool <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-param_univs">param_univs</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <a href="../Univ/index.html#type-constrained">Univ.constrained</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-quality_leq" class="anchored"><a href="#val-quality_leq" class="anchor"></a><code><span><span class="keyword">val</span> quality_leq : <span><a href="../Sorts/Quality/index.html#type-t">Sorts.Quality.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sorts/Quality/index.html#type-t">Sorts.Quality.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>For squashing.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-squash" class="anchored"><a href="#type-squash" class="anchor"></a><code><span><span class="keyword">type</span> squash</span><span> = </span></code><table><tr id="type-squash.SquashToSet" class="anchored"><td class="def variant constructor"><a href="#type-squash.SquashToSet" class="anchor"></a><code><span>| </span><span><span class="constructor">SquashToSet</span></span></code></td></tr><tr id="type-squash.SquashToQuality" class="anchored"><td class="def variant constructor"><a href="#type-squash.SquashToQuality" class="anchor"></a><code><span>| </span><span><span class="constructor">SquashToQuality</span> <span class="keyword">of</span> <a href="../Sorts/Quality/index.html#type-t">Sorts.Quality.t</a></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-is_squashed" class="anchored"><a href="#val-is_squashed" class="anchor"></a><code><span><span class="keyword">val</span> is_squashed : <span><span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-squash">squash</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_allowed_elimination" class="anchored"><a href="#val-is_allowed_elimination" class="anchor"></a><code><span><span class="keyword">val</span> is_allowed_elimination : <span><span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <a href="../UVars/index.html#type-puniverses">UVars.puniverses</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sorts/index.html#type-t">Sorts.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_private" class="anchored"><a href="#val-is_private" class="anchor"></a><code><span><span class="keyword">val</span> is_private : <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_primitive_record" class="anchored"><a href="#val-is_primitive_record" class="anchor"></a><code><span><span class="keyword">val</span> is_primitive_record : <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><p>Return type as quoted by the user</p><div class="odoc-spec"><div class="spec value" id="val-constrained_type_of_constructor" class="anchored"><a href="#val-constrained_type_of_constructor" class="anchor"></a><code><span><span class="keyword">val</span> constrained_type_of_constructor : <span><a href="../Constr/index.html#type-pconstructor">Constr.pconstructor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <a href="../Univ/index.html#type-constrained">Univ.constrained</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-type_of_constructor" class="anchored"><a href="#val-type_of_constructor" class="anchor"></a><code><span><span class="keyword">val</span> type_of_constructor : <span><a href="../Constr/index.html#type-pconstructor">Constr.pconstructor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-type_of_constructor_knowing_parameters" class="anchored"><a href="#val-type_of_constructor_knowing_parameters" class="anchor"></a><code><span><span class="keyword">val</span> type_of_constructor_knowing_parameters : <span><a href="../Constr/index.html#type-pconstructor">Constr.pconstructor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-param_univs">param_univs</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <a href="../Univ/index.html#type-constrained">Univ.constrained</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-arities_of_constructors" class="anchored"><a href="#val-arities_of_constructors" class="anchor"></a><code><span><span class="keyword">val</span> arities_of_constructors : <span><a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> array</span></span></code></div><div class="spec-doc"><p>Return constructor types in normal form</p></div></div><div class="odoc-spec"><div class="spec value" id="val-type_of_constructors" class="anchored"><a href="#val-type_of_constructors" class="anchor"></a><code><span><span class="keyword">val</span> type_of_constructors : <span><a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> array</span></span></code></div><div class="spec-doc"><p>Return constructor types in user form</p></div></div><div class="odoc-spec"><div class="spec value" id="val-abstract_constructor_type_relatively_to_inductive_types_context" class="anchored"><a href="#val-abstract_constructor_type_relatively_to_inductive_types_context" class="anchor"></a><code><span><span class="keyword">val</span> abstract_constructor_type_relatively_to_inductive_types_context : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/MutInd/index.html#type-t">Names.MutInd.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-types">Constr.types</a></span></code></div><div class="spec-doc"><p>Turns a constructor type recursively referring to inductive types into the same constructor type referring instead to a context made from the abstract declaration of the inductive types (e.g. turns <code>nat-&gt;nat</code> into <code>mkArrowR (Rel 1) (Rel 2)</code>); takes as arguments the number of inductive types in the block and the name of the block</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inductive_params" class="anchored"><a href="#val-inductive_params" class="anchor"></a><code><span><span class="keyword">val</span> inductive_params : <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-expand_arity" class="anchored"><a href="#val-expand_arity" class="anchor"></a><code><span><span class="keyword">val</span> expand_arity : <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Constr/index.html#type-binder_annot">Constr.binder_annot</a></span> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p>Given an inductive type and its parameters, builds the context of the return clause, including the inductive being eliminated. The additional binder array is only used to set the names of the context variables, we use the less general type to make it easy to use this function on Case nodes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-expand_branch_contexts" class="anchored"><a href="#val-expand_branch_contexts" class="anchor"></a><code><span><span class="keyword">val</span> expand_branch_contexts : <span><a href="../Declarations/index.html#type-mind_specif">Declarations.mind_specif</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Constr/index.html#type-binder_annot">Constr.binder_annot</a></span> array</span> * <span class="type-var">'a</span>)</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> array</span></span></code></div><div class="spec-doc"><p>Given an inductive type and its parameters, builds the context of the return clause, including the inductive being eliminated. The additional binder array is only used to set the names of the context variables, we use the less general type to make it easy to use this function on Case nodes.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-pexpanded_case" class="anchored"><a href="#type-pexpanded_case" class="anchor"></a><code><span><span class="keyword">type</span> <span>('constr, 'types, 'r) pexpanded_case</span></span><span> = <a href="../Constr/index.html#type-case_info">Constr.case_info</a> * <span>(<span class="type-var">'constr</span> * <span class="type-var">'r</span>)</span> * <span><span class="type-var">'constr</span> <a href="../Constr/index.html#type-pcase_invert">Constr.pcase_invert</a></span> * <span class="type-var">'constr</span> * <span><span class="type-var">'constr</span> array</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-expanded_case" class="anchored"><a href="#type-expanded_case" class="anchor"></a><code><span><span class="keyword">type</span> expanded_case</span><span> = <span><span>(<a href="../Constr/index.html#type-constr">Constr.constr</a>, <a href="../Constr/index.html#type-types">Constr.types</a>, <a href="../Sorts/index.html#type-relevance">Sorts.relevance</a>)</span> <a href="#type-pexpanded_case">pexpanded_case</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-expand_case" class="anchored"><a href="#val-expand_case" class="anchor"></a><code><span><span class="keyword">val</span> expand_case : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-case">Constr.case</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-expanded_case">expanded_case</a></span></code></div><div class="spec-doc"><p>Given a pattern-matching represented compactly, expands it so as to produce lambda and let abstractions in front of the return clause and the pattern branches.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-expand_case_specif" class="anchored"><a href="#val-expand_case_specif" class="anchor"></a><code><span><span class="keyword">val</span> expand_case_specif : <span><a href="../Declarations/index.html#type-mutual_inductive_body">Declarations.mutual_inductive_body</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-case">Constr.case</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-expanded_case">expanded_case</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-contract_case" class="anchored"><a href="#val-contract_case" class="anchor"></a><code><span><span class="keyword">val</span> contract_case : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expanded_case">expanded_case</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-case">Constr.case</a></span></code></div><div class="spec-doc"><p>Dual operation of the above. Fails if the return clause or branch has not the expected form.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-instantiate_context" class="anchored"><a href="#val-instantiate_context" class="anchor"></a><code><span><span class="keyword">val</span> instantiate_context : <span><a href="../UVars/Instance/index.html#type-t">UVars.Instance.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Vars/index.html#type-substl">Vars.substl</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="../Names/Name/index.html#type-t">Names.Name.t</a> <a href="../Constr/index.html#type-binder_annot">Constr.binder_annot</a></span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a></span></code></div><div class="spec-doc"><p><code>instantiate_context u subst nas ctx</code> applies both <code>u</code> and <code>subst</code> to <code>ctx</code> while replacing names using <code>nas</code> (order reversed). In particular, assumes that <code>ctx</code> and <code>nas</code> have the same length.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_branches_type" class="anchored"><a href="#val-build_branches_type" class="anchor"></a><code><span><span class="keyword">val</span> build_branches_type : <span><a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../Declarations/index.html#type-mutual_inductive_body">Declarations.mutual_inductive_body</a> * <a href="../Declarations/index.html#type-one_inductive_body">Declarations.one_inductive_body</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Constr/index.html#type-constr">Constr.constr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-types">Constr.types</a> array</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-check_case_info" class="anchored"><a href="#val-check_case_info" class="anchor"></a><code><span><span class="keyword">val</span> check_case_info : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-pinductive">Constr.pinductive</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-case_info">Constr.case_info</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Check a <code>case_info</code> actually correspond to a Case expression on the given inductive type.</p></div></div><h6 id="guard-conditions-for-fix-and-cofix-points."><a href="#guard-conditions-for-fix-and-cofix-points." class="anchor"></a>Guard conditions for fix and cofix-points.</h6><div class="odoc-spec"><div class="spec value" id="val-is_primitive_positive_container" class="anchored"><a href="#val-is_primitive_positive_container" class="anchor"></a><code><span><span class="keyword">val</span> is_primitive_positive_container : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/Constant/index.html#type-t">Names.Constant.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_primitive_positive_container env c</code> tells if the constant <code>c</code> is registered as a primitive type that can be seen as a container where the occurrences of its parameters are positive, in which case the positivity and guard conditions are extended to allow inductive types to nest their subterms in these containers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_fix" class="anchored"><a href="#val-check_fix" class="anchor"></a><code><span><span class="keyword">val</span> check_fix : <span>?evars:<a href="../CClosure/index.html#type-evar_handler">CClosure.evar_handler</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-fixpoint">Constr.fixpoint</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>When <code>chk</code> is false, the guard condition is not actually checked.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_cofix" class="anchored"><a href="#val-check_cofix" class="anchor"></a><code><span><span class="keyword">val</span> check_cofix : <span>?evars:<a href="../CClosure/index.html#type-evar_handler">CClosure.evar_handler</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-cofixpoint">Constr.cofixpoint</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><h6 id="support-for-sort-polymorphic-inductive-types"><a href="#support-for-sort-polymorphic-inductive-types" class="anchor"></a>Support for sort-polymorphic inductive types</h6><p>The &quot;polyprop&quot; optional argument below controls the &quot;Prop-polymorphism&quot;. By default, it is allowed. But when &quot;polyprop=false&quot;, the following exception is raised when a polymorphic singleton inductive type becomes Prop due to parameter instantiation. This is used by the Ocaml extraction, which cannot handle (yet?) Prop-polymorphism.</p><div class="odoc-spec"><div class="spec exception" id="exception-SingletonInductiveBecomesProp" class="anchored"><a href="#exception-SingletonInductiveBecomesProp" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">SingletonInductiveBecomesProp</span> <span class="keyword">of</span> <a href="../Names/Id/index.html#type-t">Names.Id.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-abstract_mind_lc" class="anchored"><a href="#val-abstract_mind_lc" class="anchor"></a><code><span><span class="keyword">val</span> abstract_mind_lc : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Names/MutInd/index.html#type-t">Names.MutInd.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> * <a href="../Constr/index.html#type-constr">Constr.constr</a>)</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Constr/index.html#type-constr">Constr.constr</a> array</span></span></code></div></div></div></body></html>