<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Combinators (coq-core.Combinators)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">coq-core</a> &#x00BB; Combinators</nav><header class="odoc-preamble"><h1>Module <code><span>Combinators</span></code></h1><p><code>telescope env sigma ctx</code> turns a context <code>x1:A1;...;xn:An</code> into a right-associated nested sigma-type of the right sort. It returns:</p><ul><li>the nested sigma-type <code>T := {x1:A1 &amp; ... {xn-1:An-1 &amp; ... An} ... }</code></li><li>the canonical tuple <code>(existsT _ x1 ... (existsT _ xn-1 xn) ...)</code> inhabiting the sigma-type in the given context</li><li>an instantiation of the assumptions of <code>ctx</code> with values they have in the context <code>x:T</code>, that is <code>x1:=projT1 x;...;xn-1:=projT1 ... (projT2 x);xn:=projT2 ... (projT2 x)</code>; note that let-ins in the original context are preserved Depending on the sorts of types, it uses either <code>ex</code>, <code>sig</code> or <code>sigT</code>, even if we always used <code>sigT</code> above as an example.</li></ul></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-telescope" class="anchored"><a href="#type-telescope" class="anchor"></a><code><span><span class="keyword">type</span> telescope</span><span> = </span><span>{</span></code><table><tr id="type-telescope.telescope_type" class="anchored"><td class="def record field"><a href="#type-telescope.telescope_type" class="anchor"></a><code><span>telescope_type : <a href="../EConstr/index.html#type-types">EConstr.types</a>;</span></code></td></tr><tr id="type-telescope.telescope_value" class="anchored"><td class="def record field"><a href="#type-telescope.telescope_value" class="anchor"></a><code><span>telescope_value : <a href="../EConstr/index.html#type-constr">EConstr.constr</a>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-telescope" class="anchored"><a href="#val-telescope" class="anchor"></a><code><span><span class="keyword">val</span> telescope : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../EConstr/index.html#type-rel_context">EConstr.rel_context</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../EConstr/index.html#type-rel_context">EConstr.rel_context</a> * <a href="#type-telescope">telescope</a></span></code></div></div><p><code>make_iterated_tuple env sigma ~default c</code> encapsulates <code>c</code> (of inferred type <code>C</code>) and its free variables <code>x1,...,xn</code> into a right-associated nested tuple in a <code>sigT</code>-type. It returns:</p><ul><li>the nested type <code>{x1:A1 &amp; ... {xn:An &amp; ... C} ... }</code></li><li>the tuple <code>(existsT _ x1 ... (existsT _ xn c) ...)</code></li><li>an alternative tuple <code>(existsT _ x1 ... (existsT _ xn default) ...)</code>; if <code>default</code> has not the right type, it fails.</li></ul><div class="odoc-spec"><div class="spec value" id="val-make_iterated_tuple" class="anchored"><a href="#val-make_iterated_tuple" class="anchor"></a><code><span><span class="keyword">val</span> make_iterated_tuple : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span>default:<a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../EConstr/index.html#type-types">EConstr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="#type-telescope">telescope</a> * <a href="../EConstr/index.html#type-constr">EConstr.constr</a></span></code></div></div><p><code>make_selector env sigma ~pos ~special ~default c</code> constructs a case-split on <code>c</code> (assumed of inductive type), with the <code>pos</code>-th branch returning <code>special</code>, and all the other branch returning <code>default</code>.</p><div class="odoc-spec"><div class="spec value" id="val-make_selector" class="anchored"><a href="#val-make_selector" class="anchor"></a><code><span><span class="keyword">val</span> make_selector : <span><a href="../Environ/index.html#type-env">Environ.env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span class="arrow">&#45;&gt;</span></span> <span>pos:int <span class="arrow">&#45;&gt;</span></span> <span>special:<a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span>default:<a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../EConstr/index.html#type-constr">EConstr.constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../EConstr/index.html#type-types">EConstr.types</a> <span class="arrow">&#45;&gt;</span></span> <a href="../EConstr/index.html#type-constr">EConstr.constr</a></span></code></div></div></div></body></html>