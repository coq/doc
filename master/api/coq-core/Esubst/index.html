<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Esubst (coq-core.Esubst)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">coq-core</a> &#x00BB; Esubst</nav><header class="odoc-preamble"><h1>Module <code><span>Esubst</span></code></h1><p>Explicit substitutions</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-subs" class="anchored"><a href="#type-subs" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a subs</span></span></code></div><div class="spec-doc"><p>Explicit substitutions for some type of terms <code>'a</code>.</p><p>Assuming terms enjoy a notion of typability Γ ⊢ t : A, where Γ is a telescope and A a type, substitutions can be typed as Γ ⊢ σ : Δ, where as a first approximation σ is a list of terms u₁; ...; uₙ s.t. Δ := (x₁ : A₁), ..., (xₙ : Aₙ) and Γ ⊢ uᵢ : Aᵢ<code>u₁...uᵢ₋₁</code> for all 1 ≤ i ≤ n.</p><p>Substitutions can be applied to terms as follows, and furthermore if Γ ⊢ σ : Δ and Δ ⊢ t : A, then Γ ⊢ t<code>σ</code> : A<code>σ</code>.</p><p>We make the typing rules explicit below, but we omit the explicit De Bruijn fidgetting and leave relocations implicit in terms and types.</p></div></div><p>Derived constructors granting basic invariants</p><div class="odoc-spec"><div class="spec value" id="val-subs_id" class="anchored"><a href="#val-subs_id" class="anchor"></a><code><span><span class="keyword">val</span> subs_id : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span></span></code></div><div class="spec-doc"><p>Assuming |Γ| = n, Γ ⊢ subs_id n : Γ</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subs_cons" class="anchored"><a href="#val-subs_cons" class="anchor"></a><code><span><span class="keyword">val</span> subs_cons : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span></span></code></div><div class="spec-doc"><p>Assuming Γ ⊢ σ : Δ and Γ ⊢ t : A<code>σ</code>, then Γ ⊢ subs_cons t σ : Δ, A</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subs_shft" class="anchored"><a href="#val-subs_shft" class="anchor"></a><code><span><span class="keyword">val</span> subs_shft : <span><span>(int * <span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span></span></code></div><div class="spec-doc"><p>Assuming Γ ⊢ σ : Δ and |Ξ| = n, then Γ, Ξ ⊢ subs_shft (n, σ) : Δ</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subs_lift" class="anchored"><a href="#val-subs_lift" class="anchor"></a><code><span><span class="keyword">val</span> subs_lift : <span><span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span></span></code></div><div class="spec-doc"><p>Unary variant of <code>subst_liftn</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subs_liftn" class="anchored"><a href="#val-subs_liftn" class="anchor"></a><code><span><span class="keyword">val</span> subs_liftn : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span></span></code></div><div class="spec-doc"><p>Assuming Γ ⊢ σ : Δ and |Ξ| = n, then Γ, Ξ ⊢ subs_liftn n σ : Δ, Ξ</p></div></div><div class="odoc-spec"><div class="spec value" id="val-expand_rel" class="anchored"><a href="#val-expand_rel" class="anchor"></a><code><span><span class="keyword">val</span> expand_rel : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( int * <span class="type-var">'a</span>, int * <span>int option</span> )</span> <a href="../Util/index.html#type-union">Util.union</a></span></span></code></div><div class="spec-doc"><p><code>expand_rel k subs</code> expands de Bruijn <code>k</code> in the explicit substitution <code>subs</code>. The result is either (Inl(lams,v)) when the variable is substituted by value <code>v</code> under <code>lams</code> binders (i.e. v *has* to be shifted by <code>lams</code>), or (Inr (k',p)) when the variable k is just relocated as k'; p is None if the variable points inside subs and Some(k) if the variable points k bindings beyond subs (cf argument of ESID).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_subs_id" class="anchored"><a href="#val-is_subs_id" class="anchor"></a><code><span><span class="keyword">val</span> is_subs_id : <span><span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Tests whether a substitution behaves like the identity</p></div></div><p>Composition of substitutions: <code>comp mk_clos s1 s2</code> computes a substitution equivalent to applying s2 then s1. Argument mk_clos is used when a closure has to be created, i.e. when s1 is applied on an element of s2.</p><div class="odoc-spec"><div class="spec type" id="type-lift" class="anchored"><a href="#type-lift" class="anchor"></a><code><span><span class="keyword">type</span> lift</span><span> = <span class="keyword">private</span> </span></code><table><tr id="type-lift.ELID" class="anchored"><td class="def variant constructor"><a href="#type-lift.ELID" class="anchor"></a><code><span>| </span><span><span class="constructor">ELID</span></span></code></td></tr><tr id="type-lift.ELSHFT" class="anchored"><td class="def variant constructor"><a href="#type-lift.ELSHFT" class="anchor"></a><code><span>| </span><span><span class="constructor">ELSHFT</span> <span class="keyword">of</span> <a href="#type-lift">lift</a> * int</span></code></td></tr><tr id="type-lift.ELLFT" class="anchored"><td class="def variant constructor"><a href="#type-lift.ELLFT" class="anchor"></a><code><span>| </span><span><span class="constructor">ELLFT</span> <span class="keyword">of</span> int * <a href="#type-lift">lift</a></span></code></td></tr></table></div><div class="spec-doc"><p>Compact representation of explicit relocations</p><ul><li><code>ELSHFT(l,n)</code> == lift of <code>n</code>, then apply <code>lift l</code>.</li><li><code>ELLFT(n,l)</code> == apply <code>l</code> to de Bruijn &gt; <code>n</code> i.e under n binders.</li></ul><p>Invariant ensured by the private flag: no lift contains two consecutive <code>ELSHFT</code> nor two consecutive <code>ELLFT</code>.</p><p>Relocations are a particular kind of substitutions that only contain variables. In particular, <code>el_*</code> enjoys the same typing rules as the equivalent substitution function <code>subs_*</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-el_id" class="anchored"><a href="#val-el_id" class="anchor"></a><code><span><span class="keyword">val</span> el_id : <a href="#type-lift">lift</a></span></code></div><div class="spec-doc"><p>For arbitrary Γ: Γ ⊢ el_id : Γ</p></div></div><div class="odoc-spec"><div class="spec value" id="val-el_shft" class="anchored"><a href="#val-el_shft" class="anchor"></a><code><span><span class="keyword">val</span> el_shft : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lift">lift</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lift">lift</a></span></code></div><div class="spec-doc"><p>Assuming Γ ⊢ σ : Δ and |Ξ| = n, then Γ, Ξ ⊢ el_shft (n, σ) : Δ</p></div></div><div class="odoc-spec"><div class="spec value" id="val-el_liftn" class="anchored"><a href="#val-el_liftn" class="anchor"></a><code><span><span class="keyword">val</span> el_liftn : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lift">lift</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lift">lift</a></span></code></div><div class="spec-doc"><p>Assuming Γ ⊢ σ : Δ and |Ξ| = n, then Γ, Ξ ⊢ el_liftn n σ : Δ, Ξ</p></div></div><div class="odoc-spec"><div class="spec value" id="val-el_lift" class="anchored"><a href="#val-el_lift" class="anchor"></a><code><span><span class="keyword">val</span> el_lift : <span><a href="#type-lift">lift</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lift">lift</a></span></code></div><div class="spec-doc"><p>Unary variant of <code>subst_liftn</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reloc_rel" class="anchored"><a href="#val-reloc_rel" class="anchor"></a><code><span><span class="keyword">val</span> reloc_rel : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lift">lift</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Assuming Γ₁, A, Γ₂ ⊢ σ : Δ₁, A, Δ₂ and Δ₁, A, Δ₂ ⊢ n : A, then Γ₁, A, Γ₂ ⊢ reloc_rel n σ : A</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_lift_id" class="anchored"><a href="#val-is_lift_id" class="anchor"></a><code><span><span class="keyword">val</span> is_lift_id : <span><a href="#type-lift">lift</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lift_subst" class="anchored"><a href="#val-lift_subst" class="anchor"></a><code><span><span class="keyword">val</span> lift_subst : <span><span>( <span><a href="#type-lift">lift</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lift">lift</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-subs">subs</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-subs">subs</a></span></span></code></div><div class="spec-doc"><p>Lift applied to substitution: <code>lift_subst mk_clos el s</code> computes a substitution equivalent to applying el then s. Argument mk_clos is used when a closure has to be created, i.e. when el is applied on an element of s.</p><p>That is, if Γ ⊢ e : Δ and Δ ⊢ σ : Ξ, then Γ ⊢ lift_subst mk e σ : Ξ.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Internal" class="anchored"><a href="#module-Internal" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Internal/index.html">Internal</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Debugging utilities</p></div></div></div></body></html>