<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/sites/all/themes/coq/coqdoc.css" />

<title>Standard Library | The Coq Proof Assistant</title>

</head>

<body>

<div id="container">
  <div id="headertop">
    <div id="nav">
      <ul class="links-menu">
        <li><a href="//coq.inria.fr/" class="active">Home</a></li>
        <li><a href="//coq.inria.fr/about-coq" title="More about coq">About Coq</a></li>
        <li><a href="//coq.inria.fr/download">Get Coq</a></li>
        <li><a href="//coq.inria.fr/documentation">Documentation</a></li>
        <li><a href="//coq.inria.fr/community">Community</a></li>
      </ul>
    </div>
  </div>

  <div id="header">
    <div id="logoWrapper">
      <div id="logo"><a href="//coq.inria.fr/" title="Home"><img src="//coq.inria.fr/files/barron_logo.png" alt="Home" /></a>
      </div>
      <div id="siteName"><a href="//coq.inria.fr/" title="Home">The Coq Proof Assistant</a>
      </div>
    </div>
  </div>

  <div id="content">

<h1 class="libtitle">Library Coq.ssr.ssrbool</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<style> .doc { font-family: monospace; white-space: pre; } </style> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="var">Bool</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">ssreflect</span> <span class="id" title="var">ssrfun</span>.<br/>

<br/>
</div>

<div class="doc">
 A theory of boolean predicates and operators. A large part of this file is
 concerned with boolean reflection.
 Definitions and notations:
               is_true b == the coercion of b : bool to Prop (:= b = true).
                            This is just input and displayed as `b''.
             reflect P b == the reflection inductive predicate, asserting
                            that the logical proposition P : prop with the
                            formula b : bool. Lemmas asserting reflect P b
                            are often referred to as "views".
  iffP, appP, sameP, rwP :: lemmas for direct manipulation of reflection
                            views: iffP is used to prove reflection from
                            logical equivalence, appP to compose views, and
                            sameP and rwP to perform boolean and setoid
                            rewriting.
                   elimT :: coercion reflect &gt;-&gt; Funclass, which allows the
                            direct application of `reflect' views to
                            boolean assertions.
             decidable P &lt;-&gt; P is effectively decidable (:= {P} + {~ P}.
    contra, contraL, ... :: contraposition lemmas.
           altP my_viewP :: natural alternative for reflection; given
                            lemma myviewP: reflect my_Prop my_formula,
                              have [myP | not_myP] := altP my_viewP.
                            generates two subgoals, in which my_formula has
                            been replaced by true and false, resp., with
                            new assumptions myP : my_Prop and
                            not_myP: ~~ my_formula.
                            Caveat: my_formula must be an APPLICATION, not
                            a variable, constant, let-in, etc. (due to the
                            poor behaviour of dependent index matching).
        boolP my_formula :: boolean disjunction, equivalent to
                            altP (idP my_formula) but circumventing the
                            dependent index capture issue; destructing
                            boolP my_formula generates two subgoals with
                            assumptions my_formula and ~~ myformula. As
                            with altP, my_formula must be an application.
            \unless C, P &lt;-&gt; we can assume property P when a something that
                            holds under condition C (such as C itself).
                         := forall G : Prop, (C -&gt; G) -&gt; (P -&gt; G) -&gt; G.
                            This is just C \/ P or rather its impredicative
                            encoding, whose usage better fits the above
                            description: given a lemma UCP whose conclusion
                            is \unless C, P we can assume P by writing:
                              wlog hP: / P by apply/UCP; (prove C -&gt; goal).
                           or even apply: UCP id _ =&gt; hP if the goal is C.
           classically P &lt;-&gt; we can assume P when proving is_true b.
                         := forall b : bool, (P -&gt; b) -&gt; b.
                            This is equivalent to ~ (~ P) when P : Prop.
             implies P Q == wrapper variant type that coerces to P -&gt; Q and
                            can be used as a P -&gt; Q view unambiguously.
                            Useful to avoid spurious insertion of &lt;-&gt; views
                            when Q is a conjunction of foralls, as in Lemma
                            all_and2 below; conversely, avoids confusion in
                            apply views for impredicative properties, such
                            as \unless C, P. Also supports contrapositives.
                  a &amp;&amp; b == the boolean conjunction of a and b.
                  a || b == the boolean disjunction of a and b.
                 a ==&gt; b == the boolean implication of b by a.
                    ~~ a == the boolean negation of a.
                 a (+) b == the boolean exclusive or (or sum) of a and b.
     [ /\ P1 , P2 &amp; P3 ] == multiway logical conjunction, up to 5 terms.
     [ \/ P1 , P2 | P3 ] == multiway logical disjunction, up to 4 terms.
        [&amp;&amp; a, b, c &amp; d] == iterated, right associative boolean conjunction
                            with arbitrary arity.
        [|| a, b, c | d] == iterated, right associative boolean disjunction
                            with arbitrary arity.
      [==&gt; a, b, c =&gt; d] == iterated, right associative boolean implication
                            with arbitrary arity.
              and3P, ... == specific reflection lemmas for iterated
                            connectives.
       andTb, orbAC, ... == systematic names for boolean connective
                            properties (see suffix conventions below).
              prop_congr == a tactic to move a boolean equality from
                            its coerced form in Prop to the equality
                            in bool.
              bool_congr == resolution tactic for blindly weeding out
                            like terms from boolean equalities (can fail).
 This file provides a theory of boolean predicates and relations:
                  pred T == the type of bool predicates (:= T -&gt; bool).
            simpl_pred T == the type of simplifying bool predicates, based on
                            the simpl_fun type from ssrfun.v.
              mem_pred T == a specialized form of simpl_pred for "collective"
                            predicates (see below).
                   rel T == the type of bool relations.
                         := T -&gt; pred T or T -&gt; T -&gt; bool.
             simpl_rel T == type of simplifying relations.
                         := T -&gt; simpl_pred T
                predType == the generic predicate interface, supported for
                            for lists and sets.
               pred_sort == the predType &gt;-&gt; Type projection; pred_sort is
                            itself a Coercion target class. Declaring a
                            coercion to pred_sort is an alternative way of
                            equiping a type with a predType structure, which
                            interoperates better with coercion subtyping.
                            This is used, e.g., for finite sets, so that finite
                            groups inherit the membership operation by
                            coercing to sets.
                {pred T} == a type convertible to pred T, but whose head
                            constant is pred_sort. This type should be used
                            for parameters that can be used as collective
                            predicates (see below), as this will allow passing
                            in directly collections that implement predType
                            by coercion as described above, e.g., finite sets.
                         := pred_sort (predPredType T)
 If P is a predicate the proposition "x satisfies P" can be written
 applicatively as (P x), or using an explicit connective as (x \in P); in
 the latter case we say that P is a "collective" predicate. We use A, B
 rather than P, Q for collective predicates:
                 x \in A == x satisfies the (collective) predicate A.
              x \notin A == x doesn't satisfy the (collective) predicate A.
 The pred T type can be used as a generic predicate type for either kind,
 but the two kinds of predicates should not be confused. When a "generic"
 pred T value of one type needs to be passed as the other the following
 conversions should be used explicitly:
             SimplPred P == a (simplifying) applicative equivalent of P.
                   mem A == an applicative equivalent of collective predicate A:
                            mem A x simplifies to x \in A, as mem A has in
                            fact type mem_pred T.
&gt; In user notation collective predicates <i>only</i> occur as arguments to mem:
     A only appears as (mem A). This is hidden by notation, e.g.,
     x \in A := in_mem x (mem A) here, enum A := enum_mem (mem A) in fintype.
     This makes it possible to unify the various ways in which A can be
     interpreted as a predicate, for both pattern matching and display.
 Alternatively one can use the syntax for explicit simplifying predicates
 and relations (in the following x is bound in E):
            [pred x | E] == simplifying (see ssrfun) predicate x =&gt; E.
        [pred x : T | E] == predicate x =&gt; E, with a cast on the argument.
          [pred : T | P] == constant predicate P on type T.
      [pred x | E1 &amp; E2] == [pred x | E1 &amp;&amp; E2]; an x : T cast is allowed.
           [pred x in A] == [pred x | x in A].
       [pred x in A | E] == [pred x | x in A &amp; E].
 [pred x in A | E1 &amp; E2] == [pred x in A | E1 &amp;&amp; E2].
           [predU A &amp; B] == union of two collective predicates A and B.
           [predI A &amp; B] == intersection of collective predicates A and B.
           [predD A &amp; B] == difference of collective predicates A and B.
               [predC A] == complement of the collective predicate A.
          [preim f of A] == preimage under f of the collective predicate A.
   predU P Q, ..., preim f P == union, etc of applicative predicates.
                       pred0 == the empty predicate.
                       predT == the total (always true) predicate.
                                if T : predArgType, then T coerces to predT.
                       {: T} == T cast to predArgType (e.g., {: bool * nat}).
 In the following, x and y are bound in E:
           [rel x y | E] == simplifying relation x, y =&gt; E.
       [rel x y : T | E] == simplifying relation with arguments cast.
  [rel x y in A &amp; B | E] == [rel x y | [&amp;&amp; x \in A, y \in B &amp; E] ].
      [rel x y in A &amp; B] == [rel x y | (x \in A) &amp;&amp; (y \in B) ].
      [rel x y in A | E] == [rel x y in A &amp; A | E].
          [rel x y in A] == [rel x y in A &amp; A].
                    relU R S == union of relations R and S.
                  relpre f R == preimage of relation R under f.
        xpredU, ..., xrelpre == lambda terms implementing predU, ..., etc.
 Explicit values of type pred T (i.e., lamdba terms) should always be used
 applicatively, while values of collection types implementing the predType
 interface, such as sequences or sets should always be used as collective
 predicates. Defined constants and functions of type pred T or simpl_pred T
 as well as the explicit simpl_pred T values described below, can generally
 be used either way. Note however that x \in A will not auto-simplify when
 A is an explicit simpl_pred T value; the generic simplification rule inE
 must be used (when A : pred T, the unfold_in rule can be used). Constants
 of type pred T with an explicit simpl_pred value do not auto-simplify when
 used applicatively, but can still be expanded with inE. This behavior can
 be controlled as follows:
   Let A : collective_pred T := [pred x | ... ].
     The collective_pred T type is just an alias for pred T, but this cast
     stops rewrite inE from expanding the definition of A, thus treating A
     into an abstract collection (unfold_in or in_collective can be used to
     expand manually).
   Let A : applicative_pred T := [pred x | ... ].
     This cast causes inE to turn x \in A into the applicative A x form;
     A will then have to unfolded explicitly with the /A rule. This will
     also apply to any definition that reduces to A (e.g., Let B := A).
   Canonical A_app_pred := ApplicativePred A.
     This declaration, given after definition of A, similarly causes inE to
     turn x \in A into A x, but in addition allows the app_predE rule to
     turn A x back into x \in A; it can be used for any definition of type
     pred T, which makes it especially useful for ambivalent predicates
     as the relational transitive closure connect, that are used in both
     applicative and collective styles.
 Purely for aesthetics, we provide a subtype of collective predicates:
   qualifier q T == a pred T pretty-printing wrapper. An A : qualifier q T
                    coerces to pred_sort and thus behaves as a collective
                    predicate, but x \in A and x \notin A are displayed as:
             x \is A and x \isn't A when q = 0,
         x \is a A and x \isn't a A when q = 1,
       x \is an A and x \isn't an A when q = 2, respectively.
   [qualify x | P] := Qualifier 0 (fun x =&gt; P), constructor for the above.
 [qualify x : T | P], [qualify a x | P], [qualify an X | P], etc.
                  variants of the above with type constraints and different
                  values of q.
 We provide an internal interface to support attaching properties (such as
 being multiplicative) to predicates:
    pred_key p == phantom type that will serve as a support for properties
                  to be attached to p : {pred _}; instances should be
                  created with Fact/Qed so as to be opaque.
 KeyedPred k_p == an instance of the interface structure that attaches
                  (k_p : pred_key P) to P; the structure projection is a
                  coercion to pred_sort.
 KeyedQualifier k_q == an instance of the interface structure that attaches
                  (k_q : pred_key q) to (q : qualifier n T).
 DefaultPredKey p == a default value for pred_key p; the vernacular command
                  Import DefaultKeying attaches this key to all predicates
                  that are not explicitly keyed.
 Keys can be used to attach properties to predicates, qualifiers and
 generic nouns in a way that allows them to be used transparently. The key
 projection of a predicate property structure such as unsignedPred should
 be a pred_key, not a pred, and corresponding lemmas will have the form
    Lemma rpredN R S (oppS : @opprPred R S) (kS : keyed_pred oppS) :
       {mono -%R: x / x \in kS}.
 Because x \in kS will be displayed as x \in S (or x \is S, etc), the
 canonical instance of opprPred will not normally be exposed (it will also
 be erased by /= simplification). In addition each predicate structure
 should have a DefaultPredKey Canonical instance that simply issues the
 property as a proof obligation (which can be caught by the Prop-irrelevant
 feature of the ssreflect plugin).
   Some properties of predicates and relations:
                  A =i B &lt;-&gt; A and B are extensionally equivalent.
         {subset A &lt;= B} &lt;-&gt; A is a (collective) subpredicate of B.
             subpred P Q &lt;-&gt; P is an (applicative) subpredicate or Q.
              subrel R S &lt;-&gt; R is a subrelation of S.
 In the following R is in rel T:
             reflexive R &lt;-&gt; R is reflexive.
           irreflexive R &lt;-&gt; R is irreflexive.
             symmetric R &lt;-&gt; R (in rel T) is symmetric (equation).
         pre_symmetric R &lt;-&gt; R is symmetric (implication).
         antisymmetric R &lt;-&gt; R is antisymmetric.
                 total R &lt;-&gt; R is total.
            transitive R &lt;-&gt; R is transitive.
       left_transitive R &lt;-&gt; R is a congruence on its left hand side.
      right_transitive R &lt;-&gt; R is a congruence on its right hand side.
       equivalence_rel R &lt;-&gt; R is an equivalence relation.
 Localization of (Prop) predicates; if P1 is convertible to forall x, Qx,
 P2 to forall x y, Qxy and P3 to forall x y z, Qxyz :
            {for y, P1} &lt;-&gt; Qx{y / x}.
             {in A, P1} &lt;-&gt; forall x, x \in A -&gt; Qx.
       {in A1 &amp; A2, P2} &lt;-&gt; forall x y, x \in A1 -&gt; y \in A2 -&gt; Qxy.
           {in A &amp;, P2} &lt;-&gt; forall x y, x \in A -&gt; y \in A -&gt; Qxy.
  {in A1 &amp; A2 &amp; A3, Q3} &lt;-&gt; forall x y z,
                            x \in A1 -&gt; y \in A2 -&gt; z \in A3 -&gt; Qxyz.
     {in A1 &amp; A2 &amp;, Q3} := {in A1 &amp; A2 &amp; A2, Q3}.
      {in A1 &amp;&amp; A3, Q3} := {in A1 &amp; A1 &amp; A3, Q3}.
          {in A &amp;&amp;, Q3} := {in A &amp; A &amp; A, Q3}.
    {in A, bijective f} &lt;-&gt; f has a right inverse in A.
             {on C, P1} &lt;-&gt; forall x, (f x) \in C -&gt; Qx
                           when P1 is also convertible to Pf f, e.g.,
                           {on C, involutive f}.
           {on C &amp;, P2} == forall x y, f x \in C -&gt; f y \in C -&gt; Qxy
                           when P2 is also convertible to Pf f, e.g.,
                           {on C &amp;, injective f}.
        {on C, P1' &amp; g} == forall x, (f x) \in cd -&gt; Qx
                           when P1' is convertible to Pf f
                           and P1' g is convertible to forall x, Qx, e.g.,
                           {on C, cancel f &amp; g}.
    {on C, bijective f} == f has a right inverse on C.
 This file extends the lemma name suffix conventions of ssrfun as follows:
   A -- associativity, as in andbA : associative andb.
  AC -- right commutativity.
 ACA -- self-interchange (inner commutativity), e.g.,
        orbACA : (a || b) || (c || d) = (a || c) || (b || d).
   b -- a boolean argument, as in andbb : idempotent andb.
   C -- commutativity, as in andbC : commutative andb,
        or predicate complement, as in predC.
  CA -- left commutativity.
   D -- predicate difference, as in predD.
   E -- elimination, as in negbFE : ~~ b = false -&gt; b.
   F or f -- boolean false, as in andbF : b &amp;&amp; false = false.
   I -- left/right injectivity, as in addbI : right_injective addb,
        or predicate intersection, as in predI.
   l -- a left-hand operation, as andb_orl : left_distributive andb orb.
   N or n -- boolean negation, as in andbN : a &amp;&amp; (~~ a) = false.
   P -- a characteristic property, often a reflection lemma, as in
        andP : reflect (a /\ b) (a &amp;&amp; b).
   r -- a right-hand operation, as orb_andr : rightt_distributive orb andb.
   T or t -- boolean truth, as in andbT: right_id true andb.
   U -- predicate union, as in predU.
   W -- weakening, as in in1W : (forall x, P) -&gt; {in D, forall x, P}.        
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">reflect</span> := <span class="id" title="var">Bool.reflect</span>.<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">ReflectT</span> := <span class="id" title="var">Bool.ReflectT</span>.<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">ReflectF</span> := <span class="id" title="var">Bool.ReflectF</span>.<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;~~ b" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 35, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;b ==&gt; c" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 55, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;b1 (+) b2" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x \in A" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' x '/ '  \in  A ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x \notin A" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' x '/ '  \notin  A ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x \is A" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' x '/ '  \is  A ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x \isn't A" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' x '/ '  \isn't  A ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x \is 'a' A" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' x '/ '  \is  'a'  A ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x \isn't 'a' A" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' x '/ '  \isn't  'a'  A ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x \is 'an' A" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' x '/ '  \is  'an'  A ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x \isn't 'an' A" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' x '/ '  \isn't  'an'  A ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;p1 =i p2" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' p1 '/ '  =i  p2 ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'subset' A &lt;= B }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">A</span>, <span class="id" title="var">B</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 69,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'subset'  A '/    '  &lt;=  B } ']'").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ : T }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "{ :  T }").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'pred' T }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "{ 'pred'  T }").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'predType' 'of' T ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'predType'  'of'  T ]").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'pred' : T | E ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'pred' :  T  | '/ '  E ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'pred' x | E ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'pred'  x  | '/ '  E ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'pred' x : T | E ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'pred'  x  :  T  | '/ '  E ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'pred' x | E1 &amp; E2 ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'pred'  x  | '/ '  E1  &amp; '/ '  E2 ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'pred' x : T | E1 &amp; E2 ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'pred'  x  :  T  | '/ '  E1  &amp;  E2 ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'pred' x 'in' A ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'pred'  x  'in'  A ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'pred' x 'in' A | E ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'pred'  x  'in'  A  | '/ '  E ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'pred' x 'in' A | E1 &amp; E2 ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'pred'  x  'in'  A  | '/ '  E1  &amp; '/ '  E2 ] ']'").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'qualify' x | P ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [  'qualify'  x  | '/ '  P ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'qualify' x : T | P ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [  'qualify'  x  :  T  | '/ '  P ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'qualify' 'a' x | P ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'qualify'  'a'  x  | '/ '  P ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'qualify' 'a' x : T | P ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'qualify'  'a'  x  :  T  | '/ '  P ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'qualify' 'an' x | P ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'qualify'  'an'  x  | '/ '  P ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'qualify' 'an' x : T | P ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'qualify'  'an'  x  :  T  | '/ '  P ] ']'").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rel' x y | E ]"  (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'rel'  x  y  | '/ '  E ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rel' x y : T | E ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'rel'  x  y  :  T  | '/ '  E ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rel' x y 'in' A &amp; B | E ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'rel'  x  y  'in'  A  &amp;  B  | '/ '  E ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rel' x y 'in' A &amp; B ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'rel'  x  y  'in'  A  &amp;  B ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rel' x y 'in' A | E ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'rel'  x  y  'in'  A  | '/ '  E ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rel' x y 'in' A ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'rel'  x  y  'in'  A ] ']'").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'mem' A ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "[ 'mem'  A ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'predI' A &amp; B ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'predI'  A  &amp;  B ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'predU' A &amp; B ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'predU'  A  &amp;  B ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'predD' A &amp; B ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'predD'  A  &amp;  B ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'predC' A ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'predC'  A ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'preim' f 'of' A ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'preim'  f  'of'  A ]").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;\unless C , P" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200, <span class="id" title="var">C</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 100,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' \unless  C , '/ '  P ']'").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'for' x , P }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'for'  x , '/ '  P } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'in' d , P }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'in'  d , '/ '  P } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'in' d1 &amp; d2 , P }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'in'  d1  &amp;  d2 , '/ '  P } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'in' d &amp; , P }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'in'  d  &amp; , '/ '  P } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'in' d1 &amp; d2 &amp; d3 , P }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'in'  d1  &amp;  d2  &amp;  d3 , '/ '  P } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'in' d1 &amp; &amp; d3 , P }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'in'  d1  &amp;  &amp;  d3 , '/ '  P } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'in' d1 &amp; d2 &amp; , P }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'in'  d1  &amp;  d2  &amp; , '/ '  P } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'in' d &amp; &amp; , P }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'in'  d  &amp;  &amp; , '/ '  P } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'on' cd , P }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'on'  cd , '/ '  P } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'on' cd &amp; , P }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'on'  cd  &amp; , '/ '  P } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'on' cd , P &amp; g }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">g</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'on'  cd , '/ '  P  &amp;  g } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'in' d , 'bijective' f }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'in'  d , '/ '  'bijective'  f } ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'on' cd , 'bijective' f }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' { 'on'  cd , '/ '  'bijective'  f } ']'").<br/>

<br/>
</div>

<div class="doc">
 We introduce a number of n-ary "list-style" notations that share a common
 format, namely
    [op arg1, arg2, ... last_separator last_arg]
 This usually denotes a right-associative applications of op, e.g.,
  [&amp;&amp; a, b, c &amp; d] denotes a &amp;&amp; (b &amp;&amp; (c &amp;&amp; d))
 The last_separator must be a non-operator token. Here we use &amp;, | or =&gt;;
 our default is &amp;, but we try to match the intended meaning of op. The
 separator is a workaround for limitations of the parsing engine; the same
 limitations mean the separator cannot be omitted even when last_arg can.
   The Notation declarations are complicated by the separate treatment for
 some fixed arities (binary for bool operators, and all arities for Prop
 operators).
   We also use the square brackets in comprehension-style notations
    [type var separator expr]
 where "type" is the type of the comprehension (e.g., pred) and "separator"
 is | or =&gt; . It is important that in other notations a leading square
 bracket [ is always followed by an operator symbol or a fixed identifier.   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ /\ P1 &amp; P2 ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ /\ P1 , P2 &amp; P3 ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span><br/>
&nbsp;&nbsp;"'[hv' [ /\ '['  P1 , '/'  P2 ']' '/ '  &amp;  P3 ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ /\ P1 , P2 , P3 &amp; P4 ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span><br/>
&nbsp;&nbsp;"'[hv' [ /\ '['  P1 , '/'  P2 , '/'  P3 ']' '/ '  &amp;  P4 ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ /\ P1 , P2 , P3 , P4 &amp; P5 ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span><br/>
&nbsp;&nbsp;"'[hv' [ /\ '['  P1 , '/'  P2 , '/'  P3 , '/'  P4 ']' '/ '  &amp;  P5 ] ']'").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ \/ P1 | P2 ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ \/ P1 , P2 | P3 ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span><br/>
&nbsp;&nbsp;"'[hv' [ \/ '['  P1 , '/'  P2 ']' '/ '  |  P3 ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ \/ P1 , P2 , P3 | P4 ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span><br/>
&nbsp;&nbsp;"'[hv' [ \/ '['  P1 , '/'  P2 , '/'  P3 ']' '/ '  |  P4 ] ']'").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ &amp;&amp; b1 &amp; c ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ &amp;&amp; b1 , b2 , .. , bn &amp; c ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span><br/>
&nbsp;&nbsp;"'[hv' [ &amp;&amp; '['  b1 , '/'  b2 , '/'  .. , '/'  bn ']' '/ '  &amp;  c ] ']'").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ || b1 | c ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ || b1 , b2 , .. , bn | c ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span><br/>
&nbsp;&nbsp;"'[hv' [ || '['  b1 , '/'  b2 , '/'  .. , '/'  bn ']' '/ '  |  c ] ']'").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ ==&gt; b1 =&gt; c ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ ==&gt; b1 , b2 , .. , bn =&gt; c ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span><br/>
&nbsp;&nbsp;"'[hv' [ ==&gt; '['  b1 , '/'  b2 , '/'  .. , '/'  bn ']' '/'  =&gt;  c ] ']'").<br/>

<br/>
</div>

<div class="doc">
 Shorter delimiter  
</div>
<div class="code">
<span class="id" title="keyword">Delimit</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">bool_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">bool_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 An alternative to xorb that behaves somewhat better wrt simplification. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">addb</span> <span class="id" title="var">b</span> := <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">negb</span> <span class="id" title="keyword">else</span> <span class="id" title="var">id</span>.<br/>

<br/>
</div>

<div class="doc">
 Notation for &amp;&amp; and || is declared in Init.Datatypes.  
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> &quot;~~ b" := (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;b ==&gt; c" := (<span class="id" title="var">implb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;b1 (+) b2" := (<span class="id" title="var">addb</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span>) : <span class="id" title="var">bool_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Constant is_true b := b = true is defined in Init.Datatypes.  
</div>
<div class="code">
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">is_true</span> : <span class="id" title="var">bool</span> &gt;-&gt; <span class="id" title="var">Sortclass</span>. 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">prop_congr</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> <span class="id" title="var">b'</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">b</span> = <span class="id" title="var">b'</span> -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">b'</span> :&gt; <span class="id" title="keyword">Prop</span>.<br/>
 
<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">prop_congr</span> := <span class="id" title="tactic">apply</span>: <span class="id" title="var">prop_congr</span>.<br/>

<br/>
</div>

<div class="doc">
 Lemmas for trivial.  
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">is_true_true</span> : <span class="id" title="var">true</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">not_false_is_true</span> : ~ <span class="id" title="var">false</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">is_true_locked_true</span> : <span class="id" title="var">locked</span> <span class="id" title="var">true</span>.  <br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">is_true_true</span> <span class="id" title="var">not_false_is_true</span> <span class="id" title="var">is_true_locked_true</span> : <span class="id" title="var">core</span>.<br/>

<br/>
</div>

<div class="doc">
 Shorter names.  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isT</span> := <span class="id" title="var">is_true_true</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">notF</span> := <span class="id" title="var">not_false_is_true</span>.<br/>

<br/>
</div>

<div class="doc">
 Negation lemmas.  
<div class="paragraph"> </div>


<div class="paragraph"> </div>

 We generally take NEGATION as the standard form of a false condition:
 negative boolean hypotheses should be of the form ~~ b, rather than ~ b or
 b = false, as much as possible.                                             
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negbT</span> <span class="id" title="var">b</span> : <span class="id" title="var">b</span> = <span class="id" title="var">false</span> -&gt; ~~ <span class="id" title="var">b</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negbTE</span> <span class="id" title="var">b</span> : ~~ <span class="id" title="var">b</span> -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">false</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negbF</span> <span class="id" title="var">b</span> : (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) -&gt; ~~ <span class="id" title="var">b</span> = <span class="id" title="var">false</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negbFE</span> <span class="id" title="var">b</span> : ~~ <span class="id" title="var">b</span> = <span class="id" title="var">false</span> -&gt; <span class="id" title="var">b</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negbK</span> : <span class="id" title="var">involutive</span> <span class="id" title="var">negb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negbNE</span> <span class="id" title="var">b</span> : ~~ ~~ <span class="id" title="var">b</span> -&gt; <span class="id" title="var">b</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negb_inj</span> : <span class="id" title="var">injective</span> <span class="id" title="var">negb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negbLR</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">b</span> = ~~ <span class="id" title="var">c</span> -&gt; ~~ <span class="id" title="var">b</span> = <span class="id" title="var">c</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negbRL</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : ~~ <span class="id" title="var">b</span> = <span class="id" title="var">c</span> -&gt; <span class="id" title="var">b</span> = ~~ <span class="id" title="var">c</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">contra</span> (<span class="id" title="var">c</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">c</span> -&gt; <span class="id" title="var">b</span>) -&gt; ~~ <span class="id" title="var">b</span> -&gt; ~~ <span class="id" title="var">c</span>.<br/>
 <span class="id" title="keyword">Definition</span> <span class="id" title="var">contraNN</span> := <span class="id" title="var">contra</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">contraL</span> (<span class="id" title="var">c</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">c</span> -&gt; ~~ <span class="id" title="var">b</span>) -&gt; <span class="id" title="var">b</span> -&gt; ~~ <span class="id" title="var">c</span>.<br/>
 <span class="id" title="keyword">Definition</span> <span class="id" title="var">contraTN</span> := <span class="id" title="var">contraL</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">contraR</span> (<span class="id" title="var">c</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (~~ <span class="id" title="var">c</span> -&gt; <span class="id" title="var">b</span>) -&gt; ~~ <span class="id" title="var">b</span> -&gt; <span class="id" title="var">c</span>.<br/>
 <span class="id" title="keyword">Definition</span> <span class="id" title="var">contraNT</span> := <span class="id" title="var">contraR</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">contraLR</span> (<span class="id" title="var">c</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (~~ <span class="id" title="var">c</span> -&gt; ~~ <span class="id" title="var">b</span>) -&gt; <span class="id" title="var">b</span> -&gt; <span class="id" title="var">c</span>.<br/>
 <span class="id" title="keyword">Definition</span> <span class="id" title="var">contraTT</span> := <span class="id" title="var">contraLR</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">contraT</span> <span class="id" title="var">b</span> : (~~ <span class="id" title="var">b</span> -&gt; <span class="id" title="var">false</span>) -&gt; <span class="id" title="var">b</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">wlog_neg</span> <span class="id" title="var">b</span> : (~~ <span class="id" title="var">b</span> -&gt; <span class="id" title="var">b</span>) -&gt; <span class="id" title="var">b</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">contraFT</span> (<span class="id" title="var">c</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (~~ <span class="id" title="var">c</span> -&gt; <span class="id" title="var">b</span>) -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">false</span> -&gt; <span class="id" title="var">c</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">contraFN</span> (<span class="id" title="var">c</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">c</span> -&gt; <span class="id" title="var">b</span>) -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">false</span> -&gt; ~~ <span class="id" title="var">c</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">contraTF</span> (<span class="id" title="var">c</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">c</span> -&gt; ~~ <span class="id" title="var">b</span>) -&gt; <span class="id" title="var">b</span> -&gt; <span class="id" title="var">c</span> = <span class="id" title="var">false</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">contraNF</span> (<span class="id" title="var">c</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">c</span> -&gt; <span class="id" title="var">b</span>) -&gt; ~~ <span class="id" title="var">b</span> -&gt; <span class="id" title="var">c</span> = <span class="id" title="var">false</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">contraFF</span> (<span class="id" title="var">c</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">c</span> -&gt; <span class="id" title="var">b</span>) -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">false</span> -&gt; <span class="id" title="var">c</span> = <span class="id" title="var">false</span>.<br/>
 
<br/>
</div>

<div class="doc">
 Coercion of sum-style datatypes into bool, which makes it possible
 to use ssr's boolean if rather than Coq's "generic" if.             
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">isSome</span> <span class="id" title="var">T</span> (<span class="id" title="var">u</span> : <span class="id" title="var">option</span> <span class="id" title="var">T</span>) := <span class="id" title="keyword">if</span> <span class="id" title="var">u</span> <span class="id" title="keyword">is</span> <span class="id" title="var">Some</span> <span class="id" title="var">_</span> <span class="id" title="keyword">then</span> <span class="id" title="var">true</span> <span class="id" title="keyword">else</span> <span class="id" title="var">false</span>.<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">is_inl</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">u</span> : <span class="id" title="var">A</span> + <span class="id" title="var">B</span>) := <span class="id" title="keyword">if</span> <span class="id" title="var">u</span> <span class="id" title="keyword">is</span> <span class="id" title="var">inl</span> <span class="id" title="var">_</span> <span class="id" title="keyword">then</span> <span class="id" title="var">true</span> <span class="id" title="keyword">else</span> <span class="id" title="var">false</span>.<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">is_left</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">u</span> : {<span class="id" title="var">A</span>} + {<span class="id" title="var">B</span>}) := <span class="id" title="keyword">if</span> <span class="id" title="var">u</span> <span class="id" title="keyword">is</span> <span class="id" title="tactic">left</span> <span class="id" title="var">_</span> <span class="id" title="keyword">then</span> <span class="id" title="var">true</span> <span class="id" title="keyword">else</span> <span class="id" title="var">false</span>.<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">is_inleft</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">u</span> : <span class="id" title="var">A</span> + {<span class="id" title="var">B</span>}) := <span class="id" title="keyword">if</span> <span class="id" title="var">u</span> <span class="id" title="keyword">is</span> <span class="id" title="var">inleft</span> <span class="id" title="var">_</span> <span class="id" title="keyword">then</span> <span class="id" title="var">true</span> <span class="id" title="keyword">else</span> <span class="id" title="var">false</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">decidable</span> <span class="id" title="var">P</span> := {<span class="id" title="var">P</span>} + {~ <span class="id" title="var">P</span>}.<br/>

<br/>
</div>

<div class="doc">
 Lemmas for ifs with large conditions, which allow reasoning about the
 condition without repeating it inside the proof (the latter IS
 preferable when the condition is short).
 Usage :
   if the goal contains (if cond then ...) = ...
     case: ifP =&gt; Hcond.
   generates two subgoal, with the assumption Hcond : cond = true/false
     Rewrite if_same  eliminates redundant ifs
     Rewrite (fun_if f) moves a function f inside an if
     Rewrite if_arg moves an argument inside a function-valued if        
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">BoolIf</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) (<span class="id" title="var">vT</span> <span class="id" title="var">vF</span> : <span class="id" title="var">A</span>).<br/>

<br/>
<span class="id" title="keyword">Variant</span> <span class="id" title="var">if_spec</span> (<span class="id" title="var">not_b</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">IfSpecTrue</span>  <span class="id" title="keyword">of</span>      <span class="id" title="var">b</span> : <span class="id" title="var">if_spec</span> <span class="id" title="var">not_b</span> <span class="id" title="var">true</span> <span class="id" title="var">vT</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">IfSpecFalse</span> <span class="id" title="keyword">of</span>  <span class="id" title="var">not_b</span> : <span class="id" title="var">if_spec</span> <span class="id" title="var">not_b</span> <span class="id" title="var">false</span> <span class="id" title="var">vF</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ifP</span> : <span class="id" title="var">if_spec</span> (<span class="id" title="var">b</span> = <span class="id" title="var">false</span>) <span class="id" title="var">b</span> (<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ifPn</span> : <span class="id" title="var">if_spec</span> (~~ <span class="id" title="var">b</span>) <span class="id" title="var">b</span> (<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ifT</span> : <span class="id" title="var">b</span> -&gt; (<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>) = <span class="id" title="var">vT</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ifF</span> : <span class="id" title="var">b</span> = <span class="id" title="var">false</span> -&gt; (<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>) = <span class="id" title="var">vF</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ifN</span> : ~~ <span class="id" title="var">b</span> -&gt; (<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>) = <span class="id" title="var">vF</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">if_same</span> : (<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vT</span>) = <span class="id" title="var">vT</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">if_neg</span> : (<span class="id" title="keyword">if</span> ~~ <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>) = <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vF</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vT</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">fun_if</span> : <span class="id" title="var">f</span> (<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>) = <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">f</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">f</span> <span class="id" title="var">vF</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">if_arg</span> (<span class="id" title="var">fT</span> <span class="id" title="var">fF</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">fT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">fF</span>) <span class="id" title="var">x</span> = <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">fT</span> <span class="id" title="var">x</span> <span class="id" title="keyword">else</span> <span class="id" title="var">fF</span> <span class="id" title="var">x</span>.<br/>
 
<br/>
</div>

<div class="doc">
 Turning a boolean "if" form into an application.  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">if_expr</span> := <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>.<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ifE</span> : (<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>) = <span class="id" title="var">if_expr</span>.  <br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">BoolIf</span>.<br/>

<br/>
</div>

<div class="doc">
 Core (internal) reflection lemmas, used for the three kinds of views.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">ReflectCore</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>).<br/>

<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">Hb</span> : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">b</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">introNTF</span> : (<span class="id" title="keyword">if</span> <span class="id" title="var">c</span> <span class="id" title="keyword">then</span> ~ <span class="id" title="var">P</span> <span class="id" title="keyword">else</span> <span class="id" title="var">P</span>) -&gt; ~~ <span class="id" title="var">b</span> = <span class="id" title="var">c</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">introTF</span> : (<span class="id" title="keyword">if</span> <span class="id" title="var">c</span> <span class="id" title="keyword">then</span> <span class="id" title="var">P</span> <span class="id" title="keyword">else</span> ~ <span class="id" title="var">P</span>) -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">c</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">elimNTF</span> : ~~ <span class="id" title="var">b</span> = <span class="id" title="var">c</span> -&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">c</span> <span class="id" title="keyword">then</span> ~ <span class="id" title="var">P</span> <span class="id" title="keyword">else</span> <span class="id" title="var">P</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">elimTF</span> : <span class="id" title="var">b</span> = <span class="id" title="var">c</span> -&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">c</span> <span class="id" title="keyword">then</span> <span class="id" title="var">P</span> <span class="id" title="keyword">else</span> ~ <span class="id" title="var">P</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">equivPif</span> : (<span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span>) -&gt; (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>) -&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Q</span> <span class="id" title="keyword">else</span> ~ <span class="id" title="var">Q</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">xorPif</span> : <span class="id" title="var">Q</span> \/ <span class="id" title="var">P</span> -&gt; ~ (<span class="id" title="var">Q</span> /\ <span class="id" title="var">P</span>) -&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> ~ <span class="id" title="var">Q</span> <span class="id" title="keyword">else</span> <span class="id" title="var">Q</span>.<br/>
 
<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ReflectCore</span>.<br/>

<br/>
</div>

<div class="doc">
 Internal negated reflection lemmas  
</div>
<div class="code">
<span class="id" title="keyword">Section</span> <span class="id" title="var">ReflectNegCore</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>).<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">Hb</span> : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> (~~ <span class="id" title="var">b</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">introTFn</span> : (<span class="id" title="keyword">if</span> <span class="id" title="var">c</span> <span class="id" title="keyword">then</span> ~ <span class="id" title="var">P</span> <span class="id" title="keyword">else</span> <span class="id" title="var">P</span>) -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">c</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">elimTFn</span> : <span class="id" title="var">b</span> = <span class="id" title="var">c</span> -&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">c</span> <span class="id" title="keyword">then</span> ~ <span class="id" title="var">P</span> <span class="id" title="keyword">else</span> <span class="id" title="var">P</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">equivPifn</span> : (<span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span>) -&gt; (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>) -&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> ~ <span class="id" title="var">Q</span> <span class="id" title="keyword">else</span> <span class="id" title="var">Q</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">xorPifn</span> : <span class="id" title="var">Q</span> \/ <span class="id" title="var">P</span> -&gt; ~ (<span class="id" title="var">Q</span> /\ <span class="id" title="var">P</span>) -&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Q</span> <span class="id" title="keyword">else</span> ~ <span class="id" title="var">Q</span>.<br/>
 
<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ReflectNegCore</span>.<br/>

<br/>
</div>

<div class="doc">
 User-oriented reflection lemmas  
</div>
<div class="code">
<span class="id" title="keyword">Section</span> <span class="id" title="var">Reflect</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">b</span> <span class="id" title="var">b'</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>).<br/>
<span class="id" title="keyword">Hypotheses</span> (<span class="id" title="var">Pb</span> : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">b</span>) (<span class="id" title="var">Pb'</span> : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> (~~ <span class="id" title="var">b'</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">introT</span>  : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">b</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">introF</span>  : ~ <span class="id" title="var">P</span> -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">false</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">introN</span>  : ~ <span class="id" title="var">P</span> -&gt; ~~ <span class="id" title="var">b</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">introNf</span> : <span class="id" title="var">P</span> -&gt; ~~ <span class="id" title="var">b</span> = <span class="id" title="var">false</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">introTn</span> : ~ <span class="id" title="var">P</span> -&gt; <span class="id" title="var">b'</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">introFn</span> : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">b'</span> = <span class="id" title="var">false</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">elimT</span>  : <span class="id" title="var">b</span> -&gt; <span class="id" title="var">P</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">elimF</span>  : <span class="id" title="var">b</span> = <span class="id" title="var">false</span> -&gt; ~ <span class="id" title="var">P</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">elimN</span>  : ~~ <span class="id" title="var">b</span> -&gt; ~<span class="id" title="var">P</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">elimNf</span> : ~~ <span class="id" title="var">b</span> = <span class="id" title="var">false</span> -&gt; <span class="id" title="var">P</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">elimTn</span> : <span class="id" title="var">b'</span> -&gt; ~ <span class="id" title="var">P</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">elimFn</span> : <span class="id" title="var">b'</span> = <span class="id" title="var">false</span> -&gt; <span class="id" title="var">P</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">introP</span> : (<span class="id" title="var">b</span> -&gt; <span class="id" title="var">Q</span>) -&gt; (~~ <span class="id" title="var">b</span> -&gt; ~ <span class="id" title="var">Q</span>) -&gt; <span class="id" title="var">reflect</span> <span class="id" title="var">Q</span> <span class="id" title="var">b</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">iffP</span> : (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>) -&gt; (<span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span>) -&gt; <span class="id" title="var">reflect</span> <span class="id" title="var">Q</span> <span class="id" title="var">b</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">equivP</span> : (<span class="id" title="var">P</span> &lt;-&gt; <span class="id" title="var">Q</span>) -&gt; <span class="id" title="var">reflect</span> <span class="id" title="var">Q</span> <span class="id" title="var">b</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sumboolP</span> (<span class="id" title="var">decQ</span> : <span class="id" title="var">decidable</span> <span class="id" title="var">Q</span>) : <span class="id" title="var">reflect</span> <span class="id" title="var">Q</span> <span class="id" title="var">decQ</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">appP</span> : <span class="id" title="var">reflect</span> <span class="id" title="var">Q</span> <span class="id" title="var">b</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sameP</span> : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">c</span> -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">c</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">decPcases</span> : <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">P</span> <span class="id" title="keyword">else</span> ~ <span class="id" title="var">P</span>.  <br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">decP</span> : <span class="id" title="var">decidable</span> <span class="id" title="var">P</span>. <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">rwP</span> : <span class="id" title="var">P</span> &lt;-&gt; <span class="id" title="var">b</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">rwP2</span> : <span class="id" title="var">reflect</span> <span class="id" title="var">Q</span> <span class="id" title="var">b</span> -&gt; (<span class="id" title="var">P</span> &lt;-&gt; <span class="id" title="var">Q</span>).<br/>
 
<br/>
</div>

<div class="doc">
  Predicate family to reflect excluded middle in bool.  
</div>
<div class="code">
<span class="id" title="keyword">Variant</span> <span class="id" title="var">alt_spec</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">AltTrue</span> <span class="id" title="keyword">of</span>     <span class="id" title="var">P</span> : <span class="id" title="var">alt_spec</span> <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">AltFalse</span> <span class="id" title="keyword">of</span> ~~ <span class="id" title="var">b</span> : <span class="id" title="var">alt_spec</span> <span class="id" title="var">false</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">altP</span> : <span class="id" title="var">alt_spec</span> <span class="id" title="var">b</span>.<br/>
 
<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Reflect</span>.<br/>

<br/>

<br/>

<br/>

<br/>
</div>

<div class="doc">
 Allow the direct application of a reflection lemma to a boolean assertion.  
</div>
<div class="code">
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">elimT</span> : <span class="id" title="var">reflect</span> &gt;-&gt; <span class="id" title="var">Funclass</span>.<br/>

<br/>
#[<span class="id" title="var">universes</span>(<span class="id" title="var">template</span>)]<br/>
<span class="id" title="keyword">Variant</span> <span class="id" title="var">implies</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> := <span class="id" title="var">Implies</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>.<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">impliesP</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="var">implies</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">impliesPn</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">implies</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> -&gt; ~ <span class="id" title="var">Q</span> -&gt; ~ <span class="id" title="var">P</span>.<br/>
 <span class="id" title="keyword">Coercion</span> <span class="id" title="var">impliesP</span> : <span class="id" title="var">implies</span> &gt;-&gt; <span class="id" title="var">Funclass</span>.<br/>

<br/>
</div>

<div class="doc">
 Impredicative or, which can emulate a classical not-implies.  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">unless</span> <span class="id" title="var">condition</span> <span class="id" title="var">property</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="keyword">goal</span> : <span class="id" title="keyword">Prop</span>, (<span class="id" title="var">condition</span> -&gt; <span class="id" title="keyword">goal</span>) -&gt; (<span class="id" title="var">property</span> -&gt; <span class="id" title="keyword">goal</span>) -&gt; <span class="id" title="keyword">goal</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;\unless C , P" := (<span class="id" title="var">unless</span> <span class="id" title="var">C</span> <span class="id" title="var">P</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">unlessL</span> <span class="id" title="var">C</span> <span class="id" title="var">P</span> : <span class="id" title="var">implies</span> <span class="id" title="var">C</span> (\<span class="id" title="var">unless</span> <span class="id" title="var">C</span>, <span class="id" title="var">P</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">unlessR</span> <span class="id" title="var">C</span> <span class="id" title="var">P</span> : <span class="id" title="var">implies</span> <span class="id" title="var">P</span> (\<span class="id" title="var">unless</span> <span class="id" title="var">C</span>, <span class="id" title="var">P</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">unless_sym</span> <span class="id" title="var">C</span> <span class="id" title="var">P</span> : <span class="id" title="var">implies</span> (\<span class="id" title="var">unless</span> <span class="id" title="var">C</span>, <span class="id" title="var">P</span>) (\<span class="id" title="var">unless</span> <span class="id" title="var">P</span>, <span class="id" title="var">C</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">unlessP</span> (<span class="id" title="var">C</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) : (\<span class="id" title="var">unless</span> <span class="id" title="var">C</span>, <span class="id" title="var">P</span>) &lt;-&gt; <span class="id" title="var">C</span> \/ <span class="id" title="var">P</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bind_unless</span> <span class="id" title="var">C</span> <span class="id" title="var">P</span> {<span class="id" title="var">Q</span>} : <span class="id" title="var">implies</span> (\<span class="id" title="var">unless</span> <span class="id" title="var">C</span>, <span class="id" title="var">P</span>) (\<span class="id" title="var">unless</span> (\<span class="id" title="var">unless</span> <span class="id" title="var">C</span>, <span class="id" title="var">Q</span>), <span class="id" title="var">P</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">unless_contra</span> <span class="id" title="var">b</span> <span class="id" title="var">C</span> : <span class="id" title="var">implies</span> (~~ <span class="id" title="var">b</span> -&gt; <span class="id" title="var">C</span>) (\<span class="id" title="var">unless</span> <span class="id" title="var">C</span>, <span class="id" title="var">b</span>).<br/>
 
<br/>
</div>

<div class="doc">
 Classical reasoning becomes directly accessible for any bool subgoal.
 Note that we cannot use "unless" here for lack of universe polymorphism.    
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">classically</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">b</span>) -&gt; <span class="id" title="var">b</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">classicP</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">classically</span> <span class="id" title="var">P</span> &lt;-&gt; ~ ~ <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">classicW</span> <span class="id" title="var">P</span> : <span class="id" title="var">P</span> -&gt; <span class="id" title="var">classically</span> <span class="id" title="var">P</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">classic_bind</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">classically</span> <span class="id" title="var">Q</span>) -&gt; <span class="id" title="var">classically</span> <span class="id" title="var">P</span> -&gt; <span class="id" title="var">classically</span> <span class="id" title="var">Q</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">classic_EM</span> <span class="id" title="var">P</span> : <span class="id" title="var">classically</span> (<span class="id" title="var">decidable</span> <span class="id" title="var">P</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">classic_pick</span> <span class="id" title="var">T</span> <span class="id" title="var">P</span> : <span class="id" title="var">classically</span> ({<span class="id" title="var">x</span> : <span class="id" title="var">T</span> | <span class="id" title="var">P</span> <span class="id" title="var">x</span>} + (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, ~ <span class="id" title="var">P</span> <span class="id" title="var">x</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">classic_imply</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">classically</span> <span class="id" title="var">Q</span>) -&gt; <span class="id" title="var">classically</span> (<span class="id" title="var">P</span> -&gt; <span class="id" title="var">Q</span>).<br/>

<br/>
</div>

<div class="doc">
 List notations for wider connectives; the Prop connectives have a fixed
 width so as to avoid iterated destruction (we go up to width 5 for /\, and
 width 4 for or). The bool connectives have arbitrary widths, but denote
 expressions that associate to the RIGHT. This is consistent with the right
 associativity of list expressions and thus more convenient in most proofs.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">and3</span> (<span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> := <span class="id" title="var">And3</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P1</span> &amp; <span class="id" title="var">P2</span> &amp; <span class="id" title="var">P3</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">and4</span> (<span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span> <span class="id" title="var">P4</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> := <span class="id" title="var">And4</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P1</span> &amp; <span class="id" title="var">P2</span> &amp; <span class="id" title="var">P3</span> &amp; <span class="id" title="var">P4</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">and5</span> (<span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span> <span class="id" title="var">P4</span> <span class="id" title="var">P5</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">And5</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P1</span> &amp; <span class="id" title="var">P2</span> &amp; <span class="id" title="var">P3</span> &amp; <span class="id" title="var">P4</span> &amp; <span class="id" title="var">P5</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">or3</span> (<span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> := <span class="id" title="var">Or31</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P1</span> | <span class="id" title="var">Or32</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P2</span> | <span class="id" title="var">Or33</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P3</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">or4</span> (<span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span> <span class="id" title="var">P4</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">Or41</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P1</span> | <span class="id" title="var">Or42</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P2</span> | <span class="id" title="var">Or43</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P3</span> | <span class="id" title="var">Or44</span> <span class="id" title="keyword">of</span> <span class="id" title="var">P4</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ /\ P1 &amp; P2 ]" := (<span class="id" title="var">and</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ /\ P1 , P2 &amp; P3 ]" := (<span class="id" title="var">and3</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span>) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ /\ P1 , P2 , P3 &amp; P4 ]" := (<span class="id" title="var">and4</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span> <span class="id" title="var">P4</span>) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ /\ P1 , P2 , P3 , P4 &amp; P5 ]" := (<span class="id" title="var">and5</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span> <span class="id" title="var">P4</span> <span class="id" title="var">P5</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ \/ P1 | P2 ]" := (<span class="id" title="var">or</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ \/ P1 , P2 | P3 ]" := (<span class="id" title="var">or3</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span>) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ \/ P1 , P2 , P3 | P4 ]" := (<span class="id" title="var">or4</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span> <span class="id" title="var">P4</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ &amp;&amp; b1 &amp; c ]" := (<span class="id" title="var">b1</span> &amp;&amp; <span class="id" title="var">c</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ &amp;&amp; b1 , b2 , .. , bn &amp; c ]" := (<span class="id" title="var">b1</span> &amp;&amp; (<span class="id" title="var">b2</span> &amp;&amp; .. (<span class="id" title="var">bn</span> &amp;&amp; <span class="id" title="var">c</span>) .. ))<br/>
&nbsp;&nbsp;: <span class="id" title="var">bool_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ || b1 | c ]" := (<span class="id" title="var">b1</span> || <span class="id" title="var">c</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ || b1 , b2 , .. , bn | c ]" := (<span class="id" title="var">b1</span> || (<span class="id" title="var">b2</span> || .. (<span class="id" title="var">bn</span> || <span class="id" title="var">c</span>) .. ))<br/>
&nbsp;&nbsp;: <span class="id" title="var">bool_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ ==&gt; b1 , b2 , .. , bn =&gt; c ]" :=<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">b1</span> ==&gt; (<span class="id" title="var">b2</span> ==&gt; .. (<span class="id" title="var">bn</span> ==&gt; <span class="id" title="var">c</span>) .. )) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ ==&gt; b1 =&gt; c ]" := (<span class="id" title="var">b1</span> ==&gt; <span class="id" title="var">c</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">bool_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">AllAnd</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P1</span> <span class="id" title="var">P2</span> <span class="id" title="var">P3</span> <span class="id" title="var">P4</span> <span class="id" title="var">P5</span> : <span class="id" title="var">T</span> -&gt; <span class="id" title="keyword">Prop</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">all_and2</span> : <span class="id" title="var">implies</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, [/\ <span class="id" title="var">P1</span> <span class="id" title="var">x</span> &amp; <span class="id" title="var">P2</span> <span class="id" title="var">x</span>]) [/\ <span class="id" title="var">a</span> <span class="id" title="var">P1</span> &amp; <span class="id" title="var">a</span> <span class="id" title="var">P2</span>].<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">all_and3</span> : <span class="id" title="var">implies</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, [/\ <span class="id" title="var">P1</span> <span class="id" title="var">x</span>, <span class="id" title="var">P2</span> <span class="id" title="var">x</span> &amp; <span class="id" title="var">P3</span> <span class="id" title="var">x</span>])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[/\ <span class="id" title="var">a</span> <span class="id" title="var">P1</span>, <span class="id" title="var">a</span> <span class="id" title="var">P2</span> &amp; <span class="id" title="var">a</span> <span class="id" title="var">P3</span>].<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">all_and4</span> : <span class="id" title="var">implies</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, [/\ <span class="id" title="var">P1</span> <span class="id" title="var">x</span>, <span class="id" title="var">P2</span> <span class="id" title="var">x</span>, <span class="id" title="var">P3</span> <span class="id" title="var">x</span> &amp; <span class="id" title="var">P4</span> <span class="id" title="var">x</span>])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[/\ <span class="id" title="var">a</span> <span class="id" title="var">P1</span>, <span class="id" title="var">a</span> <span class="id" title="var">P2</span>, <span class="id" title="var">a</span> <span class="id" title="var">P3</span> &amp; <span class="id" title="var">a</span> <span class="id" title="var">P4</span>].<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">all_and5</span> : <span class="id" title="var">implies</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, [/\ <span class="id" title="var">P1</span> <span class="id" title="var">x</span>, <span class="id" title="var">P2</span> <span class="id" title="var">x</span>, <span class="id" title="var">P3</span> <span class="id" title="var">x</span>, <span class="id" title="var">P4</span> <span class="id" title="var">x</span> &amp; <span class="id" title="var">P5</span> <span class="id" title="var">x</span>])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[/\ <span class="id" title="var">a</span> <span class="id" title="var">P1</span>, <span class="id" title="var">a</span> <span class="id" title="var">P2</span>, <span class="id" title="var">a</span> <span class="id" title="var">P3</span>, <span class="id" title="var">a</span> <span class="id" title="var">P4</span> &amp; <span class="id" title="var">a</span> <span class="id" title="var">P5</span>].<br/>
 
<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">AllAnd</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">pair_andP</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="var">P</span> /\ <span class="id" title="var">Q</span> &lt;-&gt; <span class="id" title="var">P</span> * <span class="id" title="var">Q</span>.  <br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">ReflectConnectives</span>.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> <span class="id" title="var">b4</span> <span class="id" title="var">b5</span> : <span class="id" title="var">bool</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">idP</span> : <span class="id" title="var">reflect</span> <span class="id" title="var">b1</span> <span class="id" title="var">b1</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">boolP</span> : <span class="id" title="var">alt_spec</span> <span class="id" title="var">b1</span> <span class="id" title="var">b1</span> <span class="id" title="var">b1</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">idPn</span> : <span class="id" title="var">reflect</span> (~~ <span class="id" title="var">b1</span>) (~~ <span class="id" title="var">b1</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negP</span> : <span class="id" title="var">reflect</span> (~ <span class="id" title="var">b1</span>) (~~ <span class="id" title="var">b1</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negPn</span> : <span class="id" title="var">reflect</span> <span class="id" title="var">b1</span> (~~ ~~ <span class="id" title="var">b1</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negPf</span> : <span class="id" title="var">reflect</span> (<span class="id" title="var">b1</span> = <span class="id" title="var">false</span>) (~~ <span class="id" title="var">b1</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andP</span> : <span class="id" title="var">reflect</span> (<span class="id" title="var">b1</span> /\ <span class="id" title="var">b2</span>) (<span class="id" title="var">b1</span> &amp;&amp; <span class="id" title="var">b2</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">and3P</span> : <span class="id" title="var">reflect</span> [/\ <span class="id" title="var">b1</span>, <span class="id" title="var">b2</span> &amp; <span class="id" title="var">b3</span>] [&amp;&amp; <span class="id" title="var">b1</span>, <span class="id" title="var">b2</span> &amp; <span class="id" title="var">b3</span>].<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">and4P</span> : <span class="id" title="var">reflect</span> [/\ <span class="id" title="var">b1</span>, <span class="id" title="var">b2</span>, <span class="id" title="var">b3</span> &amp; <span class="id" title="var">b4</span>] [&amp;&amp; <span class="id" title="var">b1</span>, <span class="id" title="var">b2</span>, <span class="id" title="var">b3</span> &amp; <span class="id" title="var">b4</span>].<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">and5P</span> : <span class="id" title="var">reflect</span> [/\ <span class="id" title="var">b1</span>, <span class="id" title="var">b2</span>, <span class="id" title="var">b3</span>, <span class="id" title="var">b4</span> &amp; <span class="id" title="var">b5</span>] [&amp;&amp; <span class="id" title="var">b1</span>, <span class="id" title="var">b2</span>, <span class="id" title="var">b3</span>, <span class="id" title="var">b4</span> &amp; <span class="id" title="var">b5</span>].<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orP</span> : <span class="id" title="var">reflect</span> (<span class="id" title="var">b1</span> \/ <span class="id" title="var">b2</span>) (<span class="id" title="var">b1</span> || <span class="id" title="var">b2</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">or3P</span> : <span class="id" title="var">reflect</span> [\/ <span class="id" title="var">b1</span>, <span class="id" title="var">b2</span> | <span class="id" title="var">b3</span>] [|| <span class="id" title="var">b1</span>, <span class="id" title="var">b2</span> | <span class="id" title="var">b3</span>].<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">or4P</span> : <span class="id" title="var">reflect</span> [\/ <span class="id" title="var">b1</span>, <span class="id" title="var">b2</span>, <span class="id" title="var">b3</span> | <span class="id" title="var">b4</span>] [|| <span class="id" title="var">b1</span>, <span class="id" title="var">b2</span>, <span class="id" title="var">b3</span> | <span class="id" title="var">b4</span>].<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nandP</span> : <span class="id" title="var">reflect</span> (~~ <span class="id" title="var">b1</span> \/ ~~ <span class="id" title="var">b2</span>) (~~ (<span class="id" title="var">b1</span> &amp;&amp; <span class="id" title="var">b2</span>)).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">norP</span> : <span class="id" title="var">reflect</span> (~~ <span class="id" title="var">b1</span> /\ ~~ <span class="id" title="var">b2</span>) (~~ (<span class="id" title="var">b1</span> || <span class="id" title="var">b2</span>)).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implyP</span> : <span class="id" title="var">reflect</span> (<span class="id" title="var">b1</span> -&gt; <span class="id" title="var">b2</span>) (<span class="id" title="var">b1</span> ==&gt; <span class="id" title="var">b2</span>).<br/>
 
<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ReflectConnectives</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
 Shorter, more systematic names for the boolean connectives laws.        
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andTb</span> : <span class="id" title="var">left_id</span> <span class="id" title="var">true</span> <span class="id" title="var">andb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andFb</span> : <span class="id" title="var">left_zero</span> <span class="id" title="var">false</span> <span class="id" title="var">andb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andbT</span> : <span class="id" title="var">right_id</span> <span class="id" title="var">true</span> <span class="id" title="var">andb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andbF</span> : <span class="id" title="var">right_zero</span> <span class="id" title="var">false</span> <span class="id" title="var">andb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andbb</span> : <span class="id" title="var">idempotent</span> <span class="id" title="var">andb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andbC</span> : <span class="id" title="var">commutative</span> <span class="id" title="var">andb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andbA</span> : <span class="id" title="var">associative</span> <span class="id" title="var">andb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andbCA</span> : <span class="id" title="var">left_commutative</span> <span class="id" title="var">andb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andbAC</span> : <span class="id" title="var">right_commutative</span> <span class="id" title="var">andb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andbACA</span> : <span class="id" title="var">interchange</span> <span class="id" title="var">andb</span> <span class="id" title="var">andb</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orTb</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>, <span class="id" title="var">true</span> || <span class="id" title="var">b</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orFb</span> : <span class="id" title="var">left_id</span> <span class="id" title="var">false</span> <span class="id" title="var">orb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orbT</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>, <span class="id" title="var">b</span> || <span class="id" title="var">true</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orbF</span> : <span class="id" title="var">right_id</span> <span class="id" title="var">false</span> <span class="id" title="var">orb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orbb</span> : <span class="id" title="var">idempotent</span> <span class="id" title="var">orb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orbC</span> : <span class="id" title="var">commutative</span> <span class="id" title="var">orb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orbA</span> : <span class="id" title="var">associative</span> <span class="id" title="var">orb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orbCA</span> : <span class="id" title="var">left_commutative</span> <span class="id" title="var">orb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orbAC</span> : <span class="id" title="var">right_commutative</span> <span class="id" title="var">orb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orbACA</span> : <span class="id" title="var">interchange</span> <span class="id" title="var">orb</span> <span class="id" title="var">orb</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andbN</span> <span class="id" title="var">b</span> : <span class="id" title="var">b</span> &amp;&amp; ~~ <span class="id" title="var">b</span> = <span class="id" title="var">false</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andNb</span> <span class="id" title="var">b</span> : ~~ <span class="id" title="var">b</span> &amp;&amp; <span class="id" title="var">b</span> = <span class="id" title="var">false</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orbN</span> <span class="id" title="var">b</span> : <span class="id" title="var">b</span> || ~~ <span class="id" title="var">b</span> = <span class="id" title="var">true</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orNb</span> <span class="id" title="var">b</span> : ~~ <span class="id" title="var">b</span> || <span class="id" title="var">b</span> = <span class="id" title="var">true</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_orl</span> : <span class="id" title="var">left_distributive</span> <span class="id" title="var">andb</span> <span class="id" title="var">orb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_orr</span> : <span class="id" title="var">right_distributive</span> <span class="id" title="var">andb</span> <span class="id" title="var">orb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_andl</span> : <span class="id" title="var">left_distributive</span> <span class="id" title="var">orb</span> <span class="id" title="var">andb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_andr</span> : <span class="id" title="var">right_distributive</span> <span class="id" title="var">orb</span> <span class="id" title="var">andb</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_idl</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">b</span> -&gt; <span class="id" title="var">a</span>) -&gt; <span class="id" title="var">a</span> &amp;&amp; <span class="id" title="var">b</span> = <span class="id" title="var">b</span>.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_idr</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">a</span> -&gt; <span class="id" title="var">b</span>) -&gt; <span class="id" title="var">a</span> &amp;&amp; <span class="id" title="var">b</span> = <span class="id" title="var">a</span>.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_id2l</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">a</span> -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">c</span>) -&gt; <span class="id" title="var">a</span> &amp;&amp; <span class="id" title="var">b</span> = <span class="id" title="var">a</span> &amp;&amp; <span class="id" title="var">c</span>.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_id2r</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">b</span> -&gt; <span class="id" title="var">a</span> = <span class="id" title="var">c</span>) -&gt; <span class="id" title="var">a</span> &amp;&amp; <span class="id" title="var">b</span> = <span class="id" title="var">c</span> &amp;&amp; <span class="id" title="var">b</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_idl</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">a</span> -&gt; <span class="id" title="var">b</span>) -&gt; <span class="id" title="var">a</span> || <span class="id" title="var">b</span> = <span class="id" title="var">b</span>.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_idr</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">b</span> -&gt; <span class="id" title="var">a</span>) -&gt; <span class="id" title="var">a</span> || <span class="id" title="var">b</span> = <span class="id" title="var">a</span>.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_id2l</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>) : (~~ <span class="id" title="var">a</span> -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">c</span>) -&gt; <span class="id" title="var">a</span> || <span class="id" title="var">b</span> = <span class="id" title="var">a</span> || <span class="id" title="var">c</span>.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">orb_id2r</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>) : (~~ <span class="id" title="var">b</span> -&gt; <span class="id" title="var">a</span> = <span class="id" title="var">c</span>) -&gt; <span class="id" title="var">a</span> || <span class="id" title="var">b</span> = <span class="id" title="var">c</span> || <span class="id" title="var">b</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negb_and</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : ~~ (<span class="id" title="var">a</span> &amp;&amp; <span class="id" title="var">b</span>) = ~~ <span class="id" title="var">a</span> || ~~ <span class="id" title="var">b</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negb_or</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : ~~ (<span class="id" title="var">a</span> || <span class="id" title="var">b</span>) = ~~ <span class="id" title="var">a</span> &amp;&amp; ~~ <span class="id" title="var">b</span>.<br/>
 
<br/>
</div>

<div class="doc">
 Pseudo-cancellation -- i.e, absorption  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andbK</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">a</span> &amp;&amp; <span class="id" title="var">b</span> || <span class="id" title="var">a</span> = <span class="id" title="var">a</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andKb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">a</span> || <span class="id" title="var">b</span> &amp;&amp; <span class="id" title="var">a</span> = <span class="id" title="var">a</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orbK</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : (<span class="id" title="var">a</span> || <span class="id" title="var">b</span>) &amp;&amp; <span class="id" title="var">a</span> = <span class="id" title="var">a</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">orKb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">a</span> &amp;&amp; (<span class="id" title="var">b</span> || <span class="id" title="var">a</span>) = <span class="id" title="var">a</span>.  <br/>

<br/>
</div>

<div class="doc">
 Imply  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implybT</span> <span class="id" title="var">b</span> : <span class="id" title="var">b</span> ==&gt; <span class="id" title="var">true</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implybF</span> <span class="id" title="var">b</span> : (<span class="id" title="var">b</span> ==&gt; <span class="id" title="var">false</span>) = ~~ <span class="id" title="var">b</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implyFb</span> <span class="id" title="var">b</span> : <span class="id" title="var">false</span> ==&gt; <span class="id" title="var">b</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implyTb</span> <span class="id" title="var">b</span> : (<span class="id" title="var">true</span> ==&gt; <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implybb</span> <span class="id" title="var">b</span> : <span class="id" title="var">b</span> ==&gt; <span class="id" title="var">b</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">negb_imply</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : ~~ (<span class="id" title="var">a</span> ==&gt; <span class="id" title="var">b</span>) = <span class="id" title="var">a</span> &amp;&amp; ~~ <span class="id" title="var">b</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implybE</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : (<span class="id" title="var">a</span> ==&gt; <span class="id" title="var">b</span>) = ~~ <span class="id" title="var">a</span> || <span class="id" title="var">b</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implyNb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : (~~ <span class="id" title="var">a</span> ==&gt; <span class="id" title="var">b</span>) = <span class="id" title="var">a</span> || <span class="id" title="var">b</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implybN</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : (<span class="id" title="var">a</span> ==&gt; ~~ <span class="id" title="var">b</span>) = (<span class="id" title="var">b</span> ==&gt; ~~ <span class="id" title="var">a</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implybNN</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : (~~ <span class="id" title="var">a</span> ==&gt; ~~ <span class="id" title="var">b</span>) = <span class="id" title="var">b</span> ==&gt; <span class="id" title="var">a</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">implyb_idl</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (~~ <span class="id" title="var">a</span> -&gt; <span class="id" title="var">b</span>) -&gt; (<span class="id" title="var">a</span> ==&gt; <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">implyb_idr</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">b</span> -&gt; ~~ <span class="id" title="var">a</span>) -&gt; (<span class="id" title="var">a</span> ==&gt; <span class="id" title="var">b</span>) = ~~ <span class="id" title="var">a</span>.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">implyb_id2l</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>) : (<span class="id" title="var">a</span> -&gt; <span class="id" title="var">b</span> = <span class="id" title="var">c</span>) -&gt; (<span class="id" title="var">a</span> ==&gt; <span class="id" title="var">b</span>) = (<span class="id" title="var">a</span> ==&gt; <span class="id" title="var">c</span>).<br/>
 
<br/>
</div>

<div class="doc">
 Addition (xor)  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addFb</span> : <span class="id" title="var">left_id</span> <span class="id" title="var">false</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbF</span> : <span class="id" title="var">right_id</span> <span class="id" title="var">false</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbb</span> : <span class="id" title="var">self_inverse</span> <span class="id" title="var">false</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbC</span> : <span class="id" title="var">commutative</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbA</span> : <span class="id" title="var">associative</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbCA</span> : <span class="id" title="var">left_commutative</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbAC</span> : <span class="id" title="var">right_commutative</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbACA</span> : <span class="id" title="var">interchange</span> <span class="id" title="var">addb</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_addl</span> : <span class="id" title="var">left_distributive</span> <span class="id" title="var">andb</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">andb_addr</span> : <span class="id" title="var">right_distributive</span> <span class="id" title="var">andb</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addKb</span> : <span class="id" title="var">left_loop</span> <span class="id" title="var">id</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbK</span> : <span class="id" title="var">right_loop</span> <span class="id" title="var">id</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addIb</span> : <span class="id" title="var">left_injective</span> <span class="id" title="var">addb</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbI</span> : <span class="id" title="var">right_injective</span> <span class="id" title="var">addb</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addTb</span> <span class="id" title="var">b</span> : <span class="id" title="var">true</span> (+) <span class="id" title="var">b</span> = ~~ <span class="id" title="var">b</span>.  <br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbT</span> <span class="id" title="var">b</span> : <span class="id" title="var">b</span> (+) <span class="id" title="var">true</span> = ~~ <span class="id" title="var">b</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbN</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">a</span> (+) ~~ <span class="id" title="var">b</span> = ~~ (<span class="id" title="var">a</span> (+) <span class="id" title="var">b</span>).<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">addNb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : ~~ <span class="id" title="var">a</span> (+) <span class="id" title="var">b</span> = ~~ (<span class="id" title="var">a</span> (+) <span class="id" title="var">b</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">addbP</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">reflect</span> (~~ <span class="id" title="var">a</span> = <span class="id" title="var">b</span>) (<span class="id" title="var">a</span> (+) <span class="id" title="var">b</span>).<br/>
 
<br/>
</div>

<div class="doc">
 Resolution tactic for blindly weeding out common terms from boolean
 equalities. When faced with a goal of the form (andb/orb/addb b1 b2) = b3
 they will try to locate b1 in b3 and remove it. This can fail!             
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">bool_congr</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| |- (?<span class="id" title="var">X1</span> &amp;&amp; ?<span class="id" title="var">X2</span> = ?<span class="id" title="var">X3</span>) =&gt; <span class="id" title="tactic">first</span><br/>
&nbsp;&nbsp;[ <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">rewrite</span> -1?(<span class="id" title="var">andbC</span> <span class="id" title="var">X1</span>) -?(<span class="id" title="var">andbCA</span> <span class="id" title="var">X1</span>); <span class="id" title="var">congr</span> 1 (<span class="id" title="var">andb</span> <span class="id" title="var">X1</span>); <span class="id" title="tactic">symmetry</span><br/>
&nbsp;&nbsp;| <span class="id" title="tactic">case</span>: (<span class="id" title="var">X1</span>); [ <span class="id" title="tactic">rewrite</span> ?<span class="id" title="var">andTb</span> ?<span class="id" title="var">andbT</span> // | <span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> ?<span class="id" title="var">andbF</span> /= ] ]<br/>
&nbsp;&nbsp;| |- (?<span class="id" title="var">X1</span> || ?<span class="id" title="var">X2</span> = ?<span class="id" title="var">X3</span>) =&gt; <span class="id" title="tactic">first</span><br/>
&nbsp;&nbsp;[ <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">rewrite</span> -1?(<span class="id" title="var">orbC</span> <span class="id" title="var">X1</span>) -?(<span class="id" title="var">orbCA</span> <span class="id" title="var">X1</span>); <span class="id" title="var">congr</span> 1 (<span class="id" title="var">orb</span> <span class="id" title="var">X1</span>); <span class="id" title="tactic">symmetry</span><br/>
&nbsp;&nbsp;| <span class="id" title="tactic">case</span>: (<span class="id" title="var">X1</span>); [ <span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> ?<span class="id" title="var">orbT</span> //= | <span class="id" title="tactic">rewrite</span> ?<span class="id" title="var">orFb</span> ?<span class="id" title="var">orbF</span> ] ]<br/>
&nbsp;&nbsp;| |- (?<span class="id" title="var">X1</span> (+) ?<span class="id" title="var">X2</span> = ?<span class="id" title="var">X3</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">rewrite</span> -1?(<span class="id" title="var">addbC</span> <span class="id" title="var">X1</span>) -?(<span class="id" title="var">addbCA</span> <span class="id" title="var">X1</span>); <span class="id" title="var">congr</span> 1 (<span class="id" title="var">addb</span> <span class="id" title="var">X1</span>); <span class="id" title="tactic">symmetry</span><br/>
&nbsp;&nbsp;| |- (~~ ?<span class="id" title="var">X1</span> = ?<span class="id" title="var">X2</span>) =&gt; <span class="id" title="var">congr</span> 1 <span class="id" title="var">negb</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
 Predicates, i.e., packaged functions to bool.
<ul class="doclist">
<li> pred T, the basic type for predicates over a type T, is simply an alias

</li>
</ul>
 for T -&gt; bool.
 We actually distinguish two kinds of predicates, which we call applicative
 and collective, based on the syntax used to test them at some x in T:
<ul class="doclist">
<li> For an applicative predicate P, one uses prefix syntax:
     P x
   Also, most operations on applicative predicates use prefix syntax as
   well (e.g., predI P Q).

</li>
<li> For a collective predicate A, one uses infix syntax:
     x \in A
   and all operations on collective predicates use infix syntax as well
   (e.g., [predI A &amp; B]).

</li>
</ul>
 There are only two kinds of applicative predicates:
<ul class="doclist">
<li> pred T, the alias for T -&gt; bool mentioned above

</li>
<li> simpl_pred T, an alias for simpl_fun T bool with a coercion to pred T
   that auto-simplifies on application (see ssrfun).

</li>
</ul>
 On the other hand, the set of collective predicate types is open-ended via
<ul class="doclist">
<li> predType T, a Structure that can be used to put Canonical collective
   predicate interpretation on other types, such as lists, tuples,
   finite sets, etc.

</li>
</ul>
 Indeed, we define such interpretations for applicative predicate types,
 which can therefore also be used with the infix syntax, e.g.,
     x \in predI P Q
 Moreover these infix forms are convertible to their prefix counterpart
 (e.g., predI P Q x which in turn simplifies to P x &amp;&amp; Q x). The converse
 is not true, however; collective predicate types cannot, in general, be
 used applicatively, because of restrictions on implicit coercions.
   However, we do define an explicit generic coercion
<ul class="doclist">
<li> mem : forall (pT : predType), pT -&gt; mem_pred T
   where mem_pred T is a variant of simpl_pred T that preserves the infix
   syntax, i.e., mem A x auto-simplifies to x \in A.

</li>
</ul>
 Indeed, the infix "collective" operators are notation for a prefix
 operator with arguments of type mem_pred T or pred T, applied to coerced
 collective predicates, e.g.,
      Notation "x \in A" := (in_mem x (mem A)).
 This prevents the variability in the predicate type from interfering with
 the application of generic lemmas. Moreover this also makes it much easier
 to define generic lemmas, because the simplest type -- pred T -- can be
 used as the type of generic collective predicates, provided one takes care
 not to use it applicatively; this avoids the burden of having to declare a
 different predicate type for each predicate parameter of each section or
 lemma.
   In detail, we ensure that the head normal form of mem A is always of the
 eta-long MemPred (fun x =&gt; pA x) form, where pA is the pred interpretation of
 A following its predType pT, i.e., the <i>expansion</i> of topred A. For a pred T
 evar ?P, (mem ?P) converts MemPred (fun x =&gt; ?P x), whose argument is a Miller
 pattern and therefore always unify: unifying (mem A) with (mem ?P) always
 yields ?P = pA, because the rigid constant MemPred aligns the unification.
 Furthermore, we ensure pA is always either A or toP .... A where toP ... is
 the expansion of @topred T pT, and toP is declared as a Coercion, so pA will
 <i>display</i> as A in either case, and the instances of @mem T (predPredType T) pA
 appearing in the premises or right-hand side of a generic lemma parametrized
 by ?P will be indistinguishable from @mem T pT A.
   Users should take care not to inadvertently "strip" (mem A) down to the
 coerced A, since this will expose the internal toP coercion: Coq could then
 display terms A x that cannot be typed as such. The topredE lemma can be used
 to restore the x \in A syntax in this case. While -topredE can conversely be
 used to change x \in P into P x for an applicative P, it is safer to use the
 inE, unfold_in or and memE lemmas instead, as they do not run the risk of
 exposing internal coercions. As a consequence it is better to explicitly
 cast a generic applicative predicate to simpl_pred using the SimplPred
 constructor when it is used as a collective predicate (see, e.g.,
 Lemma eq_big in bigop).
   We also sometimes "instantiate" the predType structure by defining a
 coercion to the sort of the predPredType structure, conveniently denoted
 {pred T}. This works better for types such as {set T} that have subtypes that
 coerce to them, since the same coercion will be inserted by the application
 of mem, or of any lemma that expects a generic collective predicates with
 type {pred T} := pred_sort (predPredType T) = pred T; thus {pred T} should be
 the preferred type for generic collective predicate parameters.
   This device also lets us turn any Type aT : predArgType into the total
 predicate over that type, i.e., fun _: aT =&gt; true. This allows us to write,
 e.g., #|'I_n| for the cardinal of the (finite) type of integers less than n.
 
<div class="paragraph"> </div>

 Boolean predicates. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred</span> <span class="id" title="var">T</span> := <span class="id" title="var">T</span> -&gt; <span class="id" title="var">bool</span>.<br/>
<span class="id" title="keyword">Identity</span> <span class="id" title="keyword">Coercion</span> <span class="id" title="var">fun_of_pred</span> : <span class="id" title="var">pred</span> &gt;-&gt; <span class="id" title="var">Funclass</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">subpred</span> <span class="id" title="var">T</span> (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T</span>) := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span>, <span class="id" title="var">p1</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">p2</span> <span class="id" title="var">x</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">xpred0</span> := (<span class="id" title="keyword">fun</span>=&gt; <span class="id" title="var">false</span>).<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">xpredT</span> := (<span class="id" title="keyword">fun</span>=&gt; <span class="id" title="var">true</span>).<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">xpredI</span> := (<span class="id" title="keyword">fun</span> (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <span class="id" title="var">pred</span> <span class="id" title="var">_</span>) <span class="id" title="var">x</span> =&gt; <span class="id" title="var">p1</span> <span class="id" title="var">x</span> &amp;&amp; <span class="id" title="var">p2</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">xpredU</span> := (<span class="id" title="keyword">fun</span> (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <span class="id" title="var">pred</span> <span class="id" title="var">_</span>) <span class="id" title="var">x</span> =&gt; <span class="id" title="var">p1</span> <span class="id" title="var">x</span> || <span class="id" title="var">p2</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">xpredC</span> := (<span class="id" title="keyword">fun</span> (<span class="id" title="var">p</span> : <span class="id" title="var">pred</span> <span class="id" title="var">_</span>) <span class="id" title="var">x</span> =&gt; ~~ <span class="id" title="var">p</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">xpredD</span> := (<span class="id" title="keyword">fun</span> (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <span class="id" title="var">pred</span> <span class="id" title="var">_</span>) <span class="id" title="var">x</span> =&gt; ~~ <span class="id" title="var">p2</span> <span class="id" title="var">x</span> &amp;&amp; <span class="id" title="var">p1</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">xpreim</span> := (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> (<span class="id" title="var">p</span> : <span class="id" title="var">pred</span> <span class="id" title="var">_</span>) <span class="id" title="var">x</span> =&gt; <span class="id" title="var">p</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>)).<br/>

<br/>
</div>

<div class="doc">
The packed class interface for pred-like types. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Structure</span> <span class="id" title="var">predType</span> <span class="id" title="var">T</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">PredType</span> {<span class="id" title="var">pred_sort</span> :&gt; <span class="id" title="keyword">Type</span>; <span class="id" title="var">topred</span> : <span class="id" title="var">pred_sort</span> -&gt; <span class="id" title="var">pred</span> <span class="id" title="var">T</span>}.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">clone_pred</span> <span class="id" title="var">T</span> <span class="id" title="var">U</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">pT</span> &amp; @<span class="id" title="var">pred_sort</span> <span class="id" title="var">T</span> <span class="id" title="var">pT</span> -&gt; <span class="id" title="var">U</span> =&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">toP</span> (<span class="id" title="var">pT'</span> := @<span class="id" title="var">PredType</span> <span class="id" title="var">T</span> <span class="id" title="var">U</span> <span class="id" title="var">toP</span>) &amp; <span class="id" title="var">phant_id</span> <span class="id" title="var">pT'</span> <span class="id" title="var">pT</span> =&gt; <span class="id" title="var">pT'</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'predType' 'of' T ]" := (@<span class="id" title="var">clone_pred</span> <span class="id" title="var">_</span> <span class="id" title="var">T</span> <span class="id" title="var">_</span> <span class="id" title="var">id</span> <span class="id" title="var">_</span> <span class="id" title="var">id</span>) : <span class="id" title="var">form_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">predPredType</span> <span class="id" title="var">T</span> := <span class="id" title="var">PredType</span> (@<span class="id" title="var">id</span> (<span class="id" title="var">pred</span> <span class="id" title="var">T</span>)).<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">boolfunPredType</span> <span class="id" title="var">T</span> := <span class="id" title="var">PredType</span> (@<span class="id" title="var">id</span> (<span class="id" title="var">T</span> -&gt; <span class="id" title="var">bool</span>)).<br/>

<br/>
</div>

<div class="doc">
The type of abstract collective predicates.
 While {pred T} is contertible to pred T, it presents the pred_sort coercion
 class, which crucially does <i>not</i> coerce to Funclass. Term whose type P coerces
 to {pred T} cannot be applied to arguments, but they <i>can</i> be used as if P
 had a canonical predType instance, as the coercion will be inserted if the
 unification P =~= pred_sort ?pT fails, changing the problem into the trivial
 {pred T} =~= pred_sort ?pT (solution ?pT := predPredType P).
   Additional benefits of this approach are that any type coercing to P will
 also inherit this behaviour, and that the coercion will be apparent in the
 elaborated expression. The latter may be important if the coercion is also
 a canonical structure projector - see mathcomp/fingroup/fingroup.v. The
 main drawback of implementing predType by coercion in this way is that the
 type of the value must be known when the unification constraint is imposed:
 if we only register the constraint and then later discover later that the
 expression had type P it will be too late of insert a coercion, whereas a
 canonical instance of predType fo P would have solved the deferred constraint.
   Finally, definitions, lemmas and sections should use type {pred T} for
 their generic collective type parameters, as this will make it possible to
 apply such definitions and lemmas directly to values of types that implement
 predType by coercion to {pred T} (values of types that implement predType
 without coercing to {pred T} will have to be coerced explicitly using topred).

</div>
<div class="code">
<span class="id" title="keyword">Notation</span> &quot;{ 'pred' T }" := (<span class="id" title="var">pred_sort</span> (<span class="id" title="var">predPredType</span> <span class="id" title="var">T</span>)) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
The type of self-simplifying collective predicates. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span> := <span class="id" title="var">simpl_fun</span> <span class="id" title="var">T</span> <span class="id" title="var">bool</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">SimplPred</span> {<span class="id" title="var">T</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T</span>) : <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span> := <span class="id" title="var">SimplFun</span> <span class="id" title="var">p</span>.<br/>

<br/>
</div>

<div class="doc">
Some simpl_pred constructors. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred0</span> {<span class="id" title="var">T</span>} := @<span class="id" title="var">SimplPred</span> <span class="id" title="var">T</span> <span class="id" title="var">xpred0</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">predT</span> {<span class="id" title="var">T</span>} := @<span class="id" title="var">SimplPred</span> <span class="id" title="var">T</span> <span class="id" title="var">xpredT</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">predI</span> {<span class="id" title="var">T</span>} (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T</span>) := <span class="id" title="var">SimplPred</span> (<span class="id" title="var">xpredI</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">predU</span> {<span class="id" title="var">T</span>} (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T</span>) := <span class="id" title="var">SimplPred</span> (<span class="id" title="var">xpredU</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">predC</span> {<span class="id" title="var">T</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T</span>) := <span class="id" title="var">SimplPred</span> (<span class="id" title="var">xpredC</span> <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">predD</span> {<span class="id" title="var">T</span>} (<span class="id" title="var">p1</span> <span class="id" title="var">p2</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T</span>) := <span class="id" title="var">SimplPred</span> (<span class="id" title="var">xpredD</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">preim</span> {<span class="id" title="var">aT</span> <span class="id" title="var">rT</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">aT</span> -&gt; <span class="id" title="var">rT</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">pred</span> <span class="id" title="var">rT</span>) := <span class="id" title="var">SimplPred</span> (<span class="id" title="var">xpreim</span> <span class="id" title="var">f</span> <span class="id" title="var">d</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'pred' : T | E ]" := (<span class="id" title="var">SimplPred</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">T</span> =&gt; <span class="id" title="var">E</span>%<span class="id" title="var">B</span>)) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'pred' x | E ]" := (<span class="id" title="var">SimplPred</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">E</span>%<span class="id" title="var">B</span>)) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'pred' x | E1 &amp; E2 ]" := [<span class="id" title="var">pred</span> <span class="id" title="var">x</span> | <span class="id" title="var">E1</span> &amp;&amp; <span class="id" title="var">E2</span> ] : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'pred' x : T | E ]" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">SimplPred</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> =&gt; <span class="id" title="var">E</span>%<span class="id" title="var">B</span>)) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'pred' x : T | E1 &amp; E2 ]" :=<br/>
&nbsp;&nbsp;[<span class="id" title="var">pred</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> | <span class="id" title="var">E1</span> &amp;&amp; <span class="id" title="var">E2</span> ] (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Coercions for simpl_pred.
   As simpl_pred T values are used both applicatively and collectively we
 need simpl_pred to coerce to both pred T <i>and</i> {pred T}. However it is
 undesirable to have two distinct constants for what are essentially identical
 coercion functions, as this confuses the SSReflect keyed matching algorithm.
 While the Coq Coercion declarations appear to disallow such Coercion aliasing,
 it is possible to work around this limitation with a combination of modules
 and functors, which we do below.
   In addition we also give a predType instance for simpl_pred, which will
 be preferred to the {pred T} coercion to solve simpl_pred T =~= pred_sort ?pT
 constraints; not however that the pred_of_simpl coercion <i>will</i> be used
 when a simpl_pred T is passed as a {pred T}, since the simplPredType T
 structure for simpl_pred T is <i>not</i> convertible to predPredType T.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">PredOfSimpl</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">coerce</span> <span class="id" title="var">T</span> (<span class="id" title="var">sp</span> : <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span>) : <span class="id" title="var">pred</span> <span class="id" title="var">T</span> := <span class="id" title="var">fun_of_simpl</span> <span class="id" title="var">sp</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">PredOfSimpl</span>.<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">pred_of_simpl</span> := <span class="id" title="var">PredOfSimpl.coerce</span>.<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">pred_of_simpl</span> : <span class="id" title="var">simpl_pred</span> &gt;-&gt; <span class="id" title="var">pred</span>.<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">simplPredType</span> <span class="id" title="var">T</span> := <span class="id" title="var">PredType</span> (@<span class="id" title="var">pred_of_simpl</span> <span class="id" title="var">T</span>).<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">PredSortOfSimplSignature</span>.<br/>
<span class="id" title="keyword">Parameter</span> <span class="id" title="var">coerce</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">T</span>, <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span> -&gt; {<span class="id" title="var">pred</span> <span class="id" title="var">T</span>}.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">PredSortOfSimplSignature</span>.<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">DeclarePredSortOfSimpl</span> (<span class="id" title="var">PredSortOfSimpl</span> : <span class="id" title="var">PredSortOfSimplSignature</span>).<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">PredSortOfSimpl.coerce</span> : <span class="id" title="var">simpl_pred</span> &gt;-&gt; <span class="id" title="var">pred_sort</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">DeclarePredSortOfSimpl</span>.<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">PredSortOfSimplCoercion</span> := <span class="id" title="var">DeclarePredSortOfSimpl</span> <span class="id" title="var">PredOfSimpl</span>.<br/>

<br/>
</div>

<div class="doc">
Type to pred coercion.
   This lets us use types of sort predArgType as a synonym for their universal
 predicate. We define this predicate as a simpl_pred T rather than a pred T or
 a {pred T} so that /= and inE reduce (T x) and x \in T to true, respectively.
   Unfortunately, this can't be used for existing types like bool whose sort
 is already fixed (at least, not without redefining bool, true, false and
 all bool operations and lemmas); we provide syntax to recast a given type
 in predArgType as a workaround. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">predArgType</span> := <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Identity</span> <span class="id" title="keyword">Coercion</span> <span class="id" title="var">sort_of_predArgType</span> : <span class="id" title="var">predArgType</span> &gt;-&gt; <span class="id" title="var">Sortclass</span>.<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">pred_of_argType</span> (<span class="id" title="var">T</span> : <span class="id" title="var">predArgType</span>) : <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span> := <span class="id" title="var">predT</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ : T }" := (<span class="id" title="var">T</span>%<span class="id" title="keyword">type</span> : <span class="id" title="var">predArgType</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Boolean relations.
 Simplifying relations follow the coding pattern of 2-argument simplifying
 functions: the simplifying type constructor is applied to the <i>last</i>
 argument. This design choice will let the in_simpl componenent of inE expand
 membership in simpl_rel as well. We provide an explicit coercion to rel T
 to avoid eta-expansion during coercion; this coercion self-simplifies so it
 should be invisible.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">rel</span> <span class="id" title="var">T</span> := <span class="id" title="var">T</span> -&gt; <span class="id" title="var">pred</span> <span class="id" title="var">T</span>.<br/>
<span class="id" title="keyword">Identity</span> <span class="id" title="keyword">Coercion</span> <span class="id" title="var">fun_of_rel</span> : <span class="id" title="var">rel</span> &gt;-&gt; <span class="id" title="var">Funclass</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">subrel</span> <span class="id" title="var">T</span> (<span class="id" title="var">r1</span> <span class="id" title="var">r2</span> : <span class="id" title="var">rel</span> <span class="id" title="var">T</span>) := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">T</span>, <span class="id" title="var">r1</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">r2</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">simpl_rel</span> <span class="id" title="var">T</span> := <span class="id" title="var">T</span> -&gt; <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span>.<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">rel_of_simpl</span> <span class="id" title="var">T</span> (<span class="id" title="var">sr</span> : <span class="id" title="var">simpl_rel</span> <span class="id" title="var">T</span>) : <span class="id" title="var">rel</span> <span class="id" title="var">T</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> =&gt; <span class="id" title="var">sr</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">xrelU</span> := (<span class="id" title="keyword">fun</span> (<span class="id" title="var">r1</span> <span class="id" title="var">r2</span> : <span class="id" title="var">rel</span> <span class="id" title="var">_</span>) <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">r1</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> || <span class="id" title="var">r2</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">xrelpre</span> := (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> (<span class="id" title="var">r</span> : <span class="id" title="var">rel</span> <span class="id" title="var">_</span>) <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">r</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="var">f</span> <span class="id" title="var">y</span>)).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">SimplRel</span> {<span class="id" title="var">T</span>} (<span class="id" title="var">r</span> : <span class="id" title="var">rel</span> <span class="id" title="var">T</span>) : <span class="id" title="var">simpl_rel</span> <span class="id" title="var">T</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">SimplPred</span> (<span class="id" title="var">r</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">relU</span> {<span class="id" title="var">T</span>} (<span class="id" title="var">r1</span> <span class="id" title="var">r2</span> : <span class="id" title="var">rel</span> <span class="id" title="var">T</span>) := <span class="id" title="var">SimplRel</span> (<span class="id" title="var">xrelU</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span>).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">relpre</span> {<span class="id" title="var">aT</span> <span class="id" title="var">rT</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">aT</span> -&gt; <span class="id" title="var">rT</span>) (<span class="id" title="var">r</span> : <span class="id" title="var">rel</span> <span class="id" title="var">rT</span>) := <span class="id" title="var">SimplRel</span> (<span class="id" title="var">xrelpre</span> <span class="id" title="var">f</span> <span class="id" title="var">r</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'rel' x y | E ]" := (<span class="id" title="var">SimplRel</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">E</span>%<span class="id" title="var">B</span>)) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'rel' x y : T | E ]" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">SimplRel</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">T</span> =&gt; <span class="id" title="var">E</span>%<span class="id" title="var">B</span>)) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subrelUl</span> <span class="id" title="var">T</span> (<span class="id" title="var">r1</span> <span class="id" title="var">r2</span> : <span class="id" title="var">rel</span> <span class="id" title="var">T</span>) : <span class="id" title="var">subrel</span> <span class="id" title="var">r1</span> (<span class="id" title="var">relU</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subrelUr</span> <span class="id" title="var">T</span> (<span class="id" title="var">r1</span> <span class="id" title="var">r2</span> : <span class="id" title="var">rel</span> <span class="id" title="var">T</span>) : <span class="id" title="var">subrel</span> <span class="id" title="var">r2</span> (<span class="id" title="var">relU</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span>).<br/>
 
<br/>
</div>

<div class="doc">
Variant of simpl_pred specialised to the membership operator. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Variant</span> <span class="id" title="var">mem_pred</span> <span class="id" title="var">T</span> := <span class="id" title="var">Mem</span> <span class="id" title="keyword">of</span> <span class="id" title="var">pred</span> <span class="id" title="var">T</span>.<br/>

<br/>
</div>

<div class="doc">
  We mainly declare pred_of_mem as a coercion so that it is not displayed.
  Similarly to pred_of_simpl, it will usually not be inserted by type
  inference, as all mem_pred mp =~= pred_sort ?pT unification problems will
  be solve by the memPredType instance below; pred_of_mem will however
  be used if a mem_pred T is used as a {pred T}, which is desirable as it
  will avoid a redundant mem in a collective, e.g., passing (mem A) to a lemma
  exception a generic collective predicate p : {pred T} and premise x \in P
  will display a subgoal x \in A rathere than x \in mem A.
    Conversely, pred_of_mem will <i>not</i> if it is used id (mem A) is used
  applicatively or as a pred T; there the simpl_of_mem coercion defined below
  will be used, resulting in a subgoal that displays as mem A x by simplifies
  to x \in A.
 
</div>
<div class="code">
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">pred_of_mem</span> {<span class="id" title="var">T</span>} <span class="id" title="var">mp</span> : {<span class="id" title="var">pred</span> <span class="id" title="var">T</span>} := <span class="id" title="keyword">let</span>: <span class="id" title="var">Mem</span> <span class="id" title="var">p</span> := <span class="id" title="var">mp</span> <span class="id" title="tactic">in</span> [<span class="id" title="var">eta</span> <span class="id" title="var">p</span>].<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">memPredType</span> <span class="id" title="var">T</span> := <span class="id" title="var">PredType</span> (@<span class="id" title="var">pred_of_mem</span> <span class="id" title="var">T</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">in_mem</span> {<span class="id" title="var">T</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">T</span>) <span class="id" title="var">mp</span> := <span class="id" title="var">pred_of_mem</span> <span class="id" title="var">mp</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">eq_mem</span> {<span class="id" title="var">T</span>} <span class="id" title="var">mp1</span> <span class="id" title="var">mp2</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span>, <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">mp1</span> = <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">mp2</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">sub_mem</span> {<span class="id" title="var">T</span>} <span class="id" title="var">mp1</span> <span class="id" title="var">mp2</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span>, <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">mp1</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">mp2</span>.<br/>

<br/>
<span class="id" title="keyword">Type</span><span class="id" title="var">classes</span> <span class="id" title="keyword">Opaque</span> <span class="id" title="var">eq_mem</span>.<br/>
<span class="id" title="keyword">Type</span><span class="id" title="var">classes</span> <span class="id" title="keyword">Opaque</span> <span class="id" title="var">sub_mem</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" title="var">simpl_of_mem</span>;</span> <span class="inlinecode"><span class="id" title="var">pred_of_simpl</span></span> path provides a new mem_pred &gt;-&gt; pred
  coercion, but does <i>not</i> override the pred_of_mem : mem_pred &gt;-&gt; pred_sort
  explicit coercion declaration above.
 
</div>
<div class="code">
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">simpl_of_mem</span> {<span class="id" title="var">T</span>} <span class="id" title="var">mp</span> := <span class="id" title="var">SimplPred</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> =&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">mp</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sub_refl</span> <span class="id" title="var">T</span> (<span class="id" title="var">mp</span> : <span class="id" title="var">mem_pred</span> <span class="id" title="var">T</span>) : <span class="id" title="var">sub_mem</span> <span class="id" title="var">mp</span> <span class="id" title="var">mp</span>.  <br/>

<br/>
</div>

<div class="doc">
 It is essential to interlock the production of the Mem constructor inside
 the branch of the predType match, to ensure that unifying mem A with
 Mem <span class="inlinecode"><span class="id" title="var">eta</span></span> <span class="inlinecode">?<span class="id" title="var">p</span></span> sets ?p := toP A (or ?p := P if toP = id and A = <span class="inlinecode"><span class="id" title="var">eta</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>),
 rather than topred pT A, had we put mem A := Mem (topred A).

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mem</span> <span class="id" title="var">T</span> (<span class="id" title="var">pT</span> : <span class="id" title="var">predType</span> <span class="id" title="var">T</span>) : <span class="id" title="var">pT</span> -&gt; <span class="id" title="var">mem_pred</span> <span class="id" title="var">T</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span>: <span class="id" title="var">PredType</span> <span class="id" title="var">toP</span> := <span class="id" title="var">pT</span> <span class="id" title="tactic">in</span> <span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> =&gt; <span class="id" title="var">Mem</span> [<span class="id" title="var">eta</span> <span class="id" title="var">toP</span> <span class="id" title="var">A</span>].<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;x \in A" := (<span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> (<span class="id" title="var">mem</span> <span class="id" title="var">A</span>)) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x \in A" := (<span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> (<span class="id" title="var">mem</span> <span class="id" title="var">A</span>)) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x \notin A" := (~~ (<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">A</span>)) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;A =i B" := (<span class="id" title="var">eq_mem</span> (<span class="id" title="var">mem</span> <span class="id" title="var">A</span>) (<span class="id" title="var">mem</span> <span class="id" title="var">B</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'subset' A &lt;= B }" := (<span class="id" title="var">sub_mem</span> (<span class="id" title="var">mem</span> <span class="id" title="var">A</span>) (<span class="id" title="var">mem</span> <span class="id" title="var">B</span>)) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'mem' A ]" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">pred_of_simpl</span> (<span class="id" title="var">simpl_of_mem</span> (<span class="id" title="var">mem</span> <span class="id" title="var">A</span>))) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'predI' A &amp; B ]" := (<span class="id" title="var">predI</span> [<span class="id" title="var">mem</span> <span class="id" title="var">A</span>] [<span class="id" title="var">mem</span> <span class="id" title="var">B</span>]) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'predU' A &amp; B ]" := (<span class="id" title="var">predU</span> [<span class="id" title="var">mem</span> <span class="id" title="var">A</span>] [<span class="id" title="var">mem</span> <span class="id" title="var">B</span>]) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'predD' A &amp; B ]" := (<span class="id" title="var">predD</span> [<span class="id" title="var">mem</span> <span class="id" title="var">A</span>] [<span class="id" title="var">mem</span> <span class="id" title="var">B</span>]) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'predC' A ]" := (<span class="id" title="var">predC</span> [<span class="id" title="var">mem</span> <span class="id" title="var">A</span>]) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'preim' f 'of' A ]" := (<span class="id" title="var">preim</span> <span class="id" title="var">f</span> [<span class="id" title="var">mem</span> <span class="id" title="var">A</span>]) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'pred' x 'in' A ]" := [<span class="id" title="var">pred</span> <span class="id" title="var">x</span> | <span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">A</span>] : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'pred' x 'in' A | E ]" := [<span class="id" title="var">pred</span> <span class="id" title="var">x</span> | <span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">A</span> &amp; <span class="id" title="var">E</span>] : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'pred' x 'in' A | E1 &amp; E2 ]" :=<br/>
&nbsp;&nbsp;[<span class="id" title="var">pred</span> <span class="id" title="var">x</span> | <span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">A</span> &amp; <span class="id" title="var">E1</span> &amp;&amp; <span class="id" title="var">E2</span> ] : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'rel' x y 'in' A &amp; B | E ]" :=<br/>
&nbsp;&nbsp;[<span class="id" title="var">rel</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> | (<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">A</span>) &amp;&amp; (<span class="id" title="var">y</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">B</span>) &amp;&amp; <span class="id" title="var">E</span>] : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'rel' x y 'in' A &amp; B ]" :=<br/>
&nbsp;&nbsp;[<span class="id" title="var">rel</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> | (<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">A</span>) &amp;&amp; (<span class="id" title="var">y</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">B</span>)] : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'rel' x y 'in' A | E ]" := [<span class="id" title="var">rel</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="tactic">in</span> <span class="id" title="var">A</span> &amp; <span class="id" title="var">A</span> | <span class="id" title="var">E</span>] : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'rel' x y 'in' A ]" := [<span class="id" title="var">rel</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="tactic">in</span> <span class="id" title="var">A</span> &amp; <span class="id" title="var">A</span>] : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Aliases of pred T that let us tag instances of simpl_pred as applicative
  or collective, via bespoke coercions. This tagging will give control over
  the simplification behaviour of inE and othe rewriting lemmas below.
    For this control to work it is crucial that collective_of_simpl <i>not</i>
  be convertible to either applicative_of_simpl or pred_of_simpl. Indeed
  they differ here by a commutattive conversion (of the match and lambda).
 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">applicative_pred</span> <span class="id" title="var">T</span> := <span class="id" title="var">pred</span> <span class="id" title="var">T</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">collective_pred</span> <span class="id" title="var">T</span> := <span class="id" title="var">pred</span> <span class="id" title="var">T</span>.<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">applicative_pred_of_simpl</span> <span class="id" title="var">T</span> (<span class="id" title="var">sp</span> : <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span>) : <span class="id" title="var">applicative_pred</span> <span class="id" title="var">T</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">fun_of_simpl</span> <span class="id" title="var">sp</span>.<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">collective_pred_of_simpl</span> <span class="id" title="var">T</span> (<span class="id" title="var">sp</span> : <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span>) : <span class="id" title="var">collective_pred</span> <span class="id" title="var">T</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span>: <span class="id" title="var">SimplFun</span> <span class="id" title="var">p</span> := <span class="id" title="var">sp</span> <span class="id" title="tactic">in</span> <span class="id" title="var">p</span>.<br/>

<br/>
</div>

<div class="doc">
Explicit simplification rules for predicate application and membership. 
</div>
<div class="code">
<span class="id" title="keyword">Section</span> <span class="id" title="var">PredicateSimplification</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> <span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> (<span class="id" title="var">p</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T</span>) (<span class="id" title="var">pT</span> : <span class="id" title="var">predType</span> <span class="id" title="var">T</span>) (<span class="id" title="var">sp</span> : <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span>).<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> (<span class="id" title="var">mp</span> : <span class="id" title="var">mem_pred</span> <span class="id" title="var">T</span>).<br/>

<br/>
</div>

<div class="doc">
 The following four bespoke structures provide fine-grained control over
 matching the various predicate forms. While all four follow a common pattern
 of using a canonical projection to match a particular form of predicate
 (in pred T, simpl_pred, mem_pred and mem_pred, respectively), and display
 the matched predicate in the structure type, each is in fact used for a
 different, specific purpose:
<ul class="doclist">
<li> registered_applicative_pred: this user-facing structure is used to
    declare values of type pred T meant to be used applicatively. The
    structure parameter merely displays this same value, and is used to avoid
    undesirable, visible occurrence of the structure in the right hand side
    of rewrite rules such as app_predE.
      There is a canonical instance of registered_applicative_pred for values
    of the applicative_of_simpl coercion, which handles the
       Definition Apred : applicative_pred T := <span class="inlinecode"><span class="id" title="var">pred</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span> idiom.
    This instance is mainly intended for the in_applicative component of inE,
    in conjunction with manifest_mem_pred and applicative_mem_pred.

</li>
<li> manifest_simpl_pred: the only instance of this structure matches manifest
    simpl_pred values of the form SimplPred p, displaying p in the structure
    type. This structure is used in in_simpl to detect and selectively expand
    collective predicates of this form. An explicit SimplPred p pattern would
    <i>NOT</i> work for this purpose, as then the left-hand side of in_simpl would
    reduce to in_mem ?x (Mem <span class="inlinecode"><span class="id" title="var">eta</span></span> <span class="inlinecode">?<span class="id" title="var">p</span></span>) and would thus match <i>any</i> instance
    of \in, not just those arising from a manifest simpl_pred.

</li>
<li> manifest_mem_pred: similar to manifest_simpl_pred, the one instance of this
    structure matches manifest mem_pred values of the form Mem <span class="inlinecode"><span class="id" title="var">eta</span></span> <span class="inlinecode">?<span class="id" title="var">p</span></span>. The
    purpose is different however: to match and display in ?p the actual
    predicate appearing in an ... \in ... expression matched by the left hand
    side of the in_applicative component of inE; then

</li>
<li> applicative_mem_pred is a telescope refinement of manifest_mem_pred p with
    a default constructor that checks that the predicate p is the value of a
    registered_applicative_pred; any unfolding occurring during this check
    does <i>not</i> affect the value of p passed to in_applicative, since that
    has been fixed earlier by the manifest_mem_pred match. In particular the
    definition of a predicate using the applicative_pred_of_simpl idiom above
    will not be expanded - this very case is the reason in_applicative uses
    a mem_pred telescope in its left hand side. The more straightforward
    ?x \in applicative_pred_value ?ap (equivalent to in_mem ?x (Mem ?ap))
    with ?ap : registered_applicative_pred ?p would set ?p := <span class="inlinecode"><span class="id" title="var">pred</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span>
    rather than ?p := Apred in the example above.

</li>
</ul>
 Also note that the in_applicative component of inE must be come before the
 in_simpl one, as the latter also matches terms of the form x \in Apred.
 Finally, no component of inE matches x \in Acoll, when
   Definition Acoll : collective_pred T := <span class="inlinecode"><span class="id" title="var">pred</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span>.
 as the collective_pred_of_simpl is <i>not</i> convertible to pred_of_simpl.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Structure</span> <span class="id" title="var">registered_applicative_pred</span> <span class="id" title="var">p</span> := <span class="id" title="var">RegisteredApplicativePred</span> {<br/>
&nbsp;&nbsp;<span class="id" title="var">applicative_pred_value</span> :&gt; <span class="id" title="var">pred</span> <span class="id" title="var">T</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">_</span> : <span class="id" title="var">applicative_pred_value</span> = <span class="id" title="var">p</span><br/>
}.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ApplicativePred</span> <span class="id" title="var">p</span> := <span class="id" title="var">RegisteredApplicativePred</span> (<span class="id" title="var">erefl</span> <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">applicative_pred_applicative</span> <span class="id" title="var">sp</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">ApplicativePred</span> (<span class="id" title="var">applicative_pred_of_simpl</span> <span class="id" title="var">sp</span>).<br/>

<br/>
<span class="id" title="keyword">Structure</span> <span class="id" title="var">manifest_simpl_pred</span> <span class="id" title="var">p</span> := <span class="id" title="var">ManifestSimplPred</span> {<br/>
&nbsp;&nbsp;<span class="id" title="var">simpl_pred_value</span> :&gt; <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">_</span> : <span class="id" title="var">simpl_pred_value</span> = <span class="id" title="var">SimplPred</span> <span class="id" title="var">p</span><br/>
}.<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">expose_simpl_pred</span> <span class="id" title="var">p</span> := <span class="id" title="var">ManifestSimplPred</span> (<span class="id" title="var">erefl</span> (<span class="id" title="var">SimplPred</span> <span class="id" title="var">p</span>)).<br/>

<br/>
<span class="id" title="keyword">Structure</span> <span class="id" title="var">manifest_mem_pred</span> <span class="id" title="var">p</span> := <span class="id" title="var">ManifestMemPred</span> {<br/>
&nbsp;&nbsp;<span class="id" title="var">mem_pred_value</span> :&gt; <span class="id" title="var">mem_pred</span> <span class="id" title="var">T</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">_</span> : <span class="id" title="var">mem_pred_value</span> = <span class="id" title="var">Mem</span> [<span class="id" title="var">eta</span> <span class="id" title="var">p</span>]<br/>
}.<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">expose_mem_pred</span> <span class="id" title="var">p</span> := <span class="id" title="var">ManifestMemPred</span> (<span class="id" title="var">erefl</span> (<span class="id" title="var">Mem</span> [<span class="id" title="var">eta</span> <span class="id" title="var">p</span>])).<br/>

<br/>
<span class="id" title="keyword">Structure</span> <span class="id" title="var">applicative_mem_pred</span> <span class="id" title="var">p</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">ApplicativeMemPred</span> {<span class="id" title="var">applicative_mem_pred_value</span> :&gt; <span class="id" title="var">manifest_mem_pred</span> <span class="id" title="var">p</span>}.<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">check_applicative_mem_pred</span> <span class="id" title="var">p</span> (<span class="id" title="var">ap</span> : <span class="id" title="var">registered_applicative_pred</span> <span class="id" title="var">p</span>) :=<br/>
&nbsp;&nbsp;[<span class="id" title="var">eta</span> @<span class="id" title="var">ApplicativeMemPred</span> <span class="id" title="var">ap</span>].<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mem_topred</span> <span class="id" title="var">pT</span> (<span class="id" title="var">pp</span> : <span class="id" title="var">pT</span>) : <span class="id" title="var">mem</span> (<span class="id" title="var">topred</span> <span class="id" title="var">pp</span>) = <span class="id" title="var">mem</span> <span class="id" title="var">pp</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">topredE</span> <span class="id" title="var">pT</span> <span class="id" title="var">x</span> (<span class="id" title="var">pp</span> : <span class="id" title="var">pT</span>) : <span class="id" title="var">topred</span> <span class="id" title="var">pp</span> <span class="id" title="var">x</span> = (<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">pp</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">app_predE</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span> (<span class="id" title="var">ap</span> : <span class="id" title="var">registered_applicative_pred</span> <span class="id" title="var">p</span>) : <span class="id" title="var">ap</span> <span class="id" title="var">x</span> = (<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">p</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_applicative</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span> (<span class="id" title="var">amp</span> : <span class="id" title="var">applicative_mem_pred</span> <span class="id" title="var">p</span>) : <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">amp</span> = <span class="id" title="var">p</span> <span class="id" title="var">x</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_collective</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span> (<span class="id" title="var">msp</span> : <span class="id" title="var">manifest_simpl_pred</span> <span class="id" title="var">p</span>) :<br/>
&nbsp;&nbsp;(<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">collective_pred_of_simpl</span> <span class="id" title="var">msp</span>) = <span class="id" title="var">p</span> <span class="id" title="var">x</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_simpl</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span> (<span class="id" title="var">msp</span> : <span class="id" title="var">manifest_simpl_pred</span> <span class="id" title="var">p</span>) :<br/>
&nbsp;&nbsp;<span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> (<span class="id" title="var">Mem</span> [<span class="id" title="var">eta</span> <span class="id" title="var">pred_of_simpl</span> <span class="id" title="var">msp</span>]) = <span class="id" title="var">p</span> <span class="id" title="var">x</span>.<br/>
 
<br/>
</div>

<div class="doc">
 Because of the explicit eta expansion in the left-hand side, this lemma
 should only be used in the left-to-right direction.
 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">unfold_in</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span> : (<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> ([<span class="id" title="var">eta</span> <span class="id" title="var">p</span>] : <span class="id" title="var">pred</span> <span class="id" title="var">T</span>)) = <span class="id" title="var">p</span> <span class="id" title="var">x</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">simpl_predE</span> <span class="id" title="var">p</span> : <span class="id" title="var">SimplPred</span> <span class="id" title="var">p</span> =1 <span class="id" title="var">p</span>.<br/>
 
<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">inE</span> := (<span class="id" title="var">in_applicative</span>, <span class="id" title="var">in_simpl</span>, <span class="id" title="var">simpl_predE</span>). 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mem_simpl</span> <span class="id" title="var">sp</span> : <span class="id" title="var">mem</span> <span class="id" title="var">sp</span> = <span class="id" title="var">sp</span> :&gt; <span class="id" title="var">pred</span> <span class="id" title="var">T</span>.<br/>
 
<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">memE</span> := <span class="id" title="var">mem_simpl</span>. 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mem_mem</span> <span class="id" title="var">mp</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="var">mem</span> <span class="id" title="var">mp</span> = <span class="id" title="var">mp</span>) * (<span class="id" title="var">mem</span> (<span class="id" title="var">mp</span> : <span class="id" title="var">simpl_pred</span> <span class="id" title="var">T</span>) = <span class="id" title="var">mp</span>) * (<span class="id" title="var">mem</span> (<span class="id" title="var">mp</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T</span>) = <span class="id" title="var">mp</span>).<br/>
 
<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">PredicateSimplification</span>.<br/>

<br/>
</div>

<div class="doc">
 Qualifiers and keyed predicates.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Variant</span> <span class="id" title="var">qualifier</span> (<span class="id" title="var">q</span> : <span class="id" title="var">nat</span>) <span class="id" title="var">T</span> := <span class="id" title="var">Qualifier</span> <span class="id" title="keyword">of</span> {<span class="id" title="var">pred</span> <span class="id" title="var">T</span>}.<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">has_quality</span> <span class="id" title="var">n</span> <span class="id" title="var">T</span> (<span class="id" title="var">q</span> : <span class="id" title="var">qualifier</span> <span class="id" title="var">n</span> <span class="id" title="var">T</span>) : {<span class="id" title="var">pred</span> <span class="id" title="var">T</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="keyword">let</span>: <span class="id" title="var">Qualifier</span> <span class="id" title="var">_</span> <span class="id" title="var">p</span> := <span class="id" title="var">q</span> <span class="id" title="tactic">in</span> <span class="id" title="var">p</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">qualifE</span> <span class="id" title="var">n</span> <span class="id" title="var">T</span> <span class="id" title="var">p</span> <span class="id" title="var">x</span> : (<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> @<span class="id" title="var">Qualifier</span> <span class="id" title="var">n</span> <span class="id" title="var">T</span> <span class="id" title="var">p</span>) = <span class="id" title="var">p</span> <span class="id" title="var">x</span>.  <br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;x \is A" := (<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">has_quality</span> 0 <span class="id" title="var">A</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x \is 'a' A" := (<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">has_quality</span> 1 <span class="id" title="var">A</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x \is 'an' A" := (<span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">has_quality</span> 2 <span class="id" title="var">A</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x \isn't A" := (<span class="id" title="var">x</span> \<span class="id" title="var">notin</span> <span class="id" title="var">has_quality</span> 0 <span class="id" title="var">A</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x \isn't 'a' A" := (<span class="id" title="var">x</span> \<span class="id" title="var">notin</span> <span class="id" title="var">has_quality</span> 1 <span class="id" title="var">A</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x \isn't 'an' A" := (<span class="id" title="var">x</span> \<span class="id" title="var">notin</span> <span class="id" title="var">has_quality</span> 2 <span class="id" title="var">A</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'qualify' x | P ]" := (<span class="id" title="var">Qualifier</span> 0 (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">P</span>%<span class="id" title="var">B</span>)) : <span class="id" title="var">form_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'qualify' x : T | P ]" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">Qualifier</span> 0 (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> =&gt; <span class="id" title="var">P</span>%<span class="id" title="var">B</span>)) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">form_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'qualify' 'a' x | P ]" := (<span class="id" title="var">Qualifier</span> 1 (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">P</span>%<span class="id" title="var">B</span>)) : <span class="id" title="var">form_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'qualify' 'a' x : T | P ]" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">Qualifier</span> 1 (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> =&gt; <span class="id" title="var">P</span>%<span class="id" title="var">B</span>)) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">form_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'qualify' 'an' x | P ]" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">Qualifier</span> 2 (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">P</span>%<span class="id" title="var">B</span>)) : <span class="id" title="var">form_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ 'qualify' 'an' x : T | P ]" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">Qualifier</span> 2 (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> =&gt; <span class="id" title="var">P</span>%<span class="id" title="var">B</span>)) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">form_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Keyed predicates: support for property-bearing predicate interfaces.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">KeyPred</span>.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>.<br/>
#[<span class="id" title="var">universes</span>(<span class="id" title="var">template</span>)]<br/>
<span class="id" title="keyword">Variant</span> <span class="id" title="var">pred_key</span> (<span class="id" title="var">p</span> : {<span class="id" title="var">pred</span> <span class="id" title="var">T</span>}) := <span class="id" title="var">DefaultPredKey</span>.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">p</span> : {<span class="id" title="var">pred</span> <span class="id" title="var">T</span>}.<br/>
<span class="id" title="keyword">Structure</span> <span class="id" title="var">keyed_pred</span> (<span class="id" title="var">k</span> : <span class="id" title="var">pred_key</span> <span class="id" title="var">p</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">PackKeyedPred</span> {<span class="id" title="var">unkey_pred</span> :&gt; {<span class="id" title="var">pred</span> <span class="id" title="var">T</span>}; <span class="id" title="var">_</span> : <span class="id" title="var">unkey_pred</span> =<span class="id" title="var">i</span> <span class="id" title="var">p</span>}.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">k</span> : <span class="id" title="var">pred_key</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">KeyedPred</span> := @<span class="id" title="var">PackKeyedPred</span> <span class="id" title="var">k</span> <span class="id" title="var">p</span> (<span class="id" title="var">frefl</span> <span class="id" title="var">_</span>).<br/>

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">k_p</span> : <span class="id" title="var">keyed_pred</span> <span class="id" title="var">k</span>.<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">keyed_predE</span> : <span class="id" title="var">k_p</span> =<span class="id" title="var">i</span> <span class="id" title="var">p</span>.  <br/>

<br/>
</div>

<div class="doc">
 Instances that strip the mem cast; the first one has "pred_of_mem" as its
 projection head value, while the second has "pred_of_simpl". The latter
 has the side benefit of preempting accidental misdeclarations.
 Note: pred_of_mem is the registered mem &gt;-&gt; pred_sort coercion, while
 <span class="inlinecode"><span class="id" title="var">simpl_of_mem</span>;</span> <span class="inlinecode"><span class="id" title="var">pred_of_simpl</span></span> is the mem &gt;-&gt; pred &gt;=&gt; Funclass coercion. We
 must write down the coercions explicitly as the Canonical head constant
 computation does not strip casts.                                        
</div>
<div class="code">
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">keyed_mem</span> :=<br/>
&nbsp;&nbsp;@<span class="id" title="var">PackKeyedPred</span> <span class="id" title="var">k</span> (<span class="id" title="var">pred_of_mem</span> (<span class="id" title="var">mem</span> <span class="id" title="var">k_p</span>)) <span class="id" title="var">keyed_predE</span>.<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">keyed_mem_simpl</span> :=<br/>
&nbsp;&nbsp;@<span class="id" title="var">PackKeyedPred</span> <span class="id" title="var">k</span> (<span class="id" title="var">pred_of_simpl</span> (<span class="id" title="var">mem</span> <span class="id" title="var">k_p</span>)) <span class="id" title="var">keyed_predE</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">KeyPred</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;x \in S" := (<span class="id" title="var">in_unkey</span> <span class="id" title="var">x</span> <span class="id" title="var">S</span>) (<span class="id" title="var">only</span> <span class="id" title="var">printing</span>) : <span class="id" title="var">bool_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">KeyedQualifier</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">q</span> : <span class="id" title="var">qualifier</span> <span class="id" title="var">n</span> <span class="id" title="var">T</span>).<br/>

<br/>
<span class="id" title="keyword">Structure</span> <span class="id" title="var">keyed_qualifier</span> (<span class="id" title="var">k</span> : <span class="id" title="var">pred_key</span> <span class="id" title="var">q</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">PackKeyedQualifier</span> {<span class="id" title="var">unkey_qualifier</span>; <span class="id" title="var">_</span> : <span class="id" title="var">unkey_qualifier</span> = <span class="id" title="var">q</span>}.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">KeyedQualifier</span> <span class="id" title="var">k</span> := <span class="id" title="var">PackKeyedQualifier</span> <span class="id" title="var">k</span> (<span class="id" title="var">erefl</span> <span class="id" title="var">q</span>).<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">k</span> : <span class="id" title="var">pred_key</span> <span class="id" title="var">q</span>) (<span class="id" title="var">k_q</span> : <span class="id" title="var">keyed_qualifier</span> <span class="id" title="var">k</span>).<br/>
<span class="id" title="keyword">Fact</span> <span class="id" title="var">keyed_qualifier_suproof</span> : <span class="id" title="var">unkey_qualifier</span> <span class="id" title="var">k_q</span> =<span class="id" title="var">i</span> <span class="id" title="var">q</span>.<br/>
 <span class="id" title="keyword">Canonical</span> <span class="id" title="var">keyed_qualifier_keyed</span> := <span class="id" title="var">PackKeyedPred</span> <span class="id" title="var">k</span> <span class="id" title="var">keyed_qualifier_suproof</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">KeyedQualifier</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;x \is A" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">in_unkey</span> <span class="id" title="var">x</span> (<span class="id" title="var">has_quality</span> 0 <span class="id" title="var">A</span>)) (<span class="id" title="var">only</span> <span class="id" title="var">printing</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x \is 'a' A" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">in_unkey</span> <span class="id" title="var">x</span> (<span class="id" title="var">has_quality</span> 1 <span class="id" title="var">A</span>)) (<span class="id" title="var">only</span> <span class="id" title="var">printing</span>) : <span class="id" title="var">bool_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x \is 'an' A" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">in_unkey</span> <span class="id" title="var">x</span> (<span class="id" title="var">has_quality</span> 2 <span class="id" title="var">A</span>)) (<span class="id" title="var">only</span> <span class="id" title="var">printing</span>) : <span class="id" title="var">bool_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">DefaultKeying</span>.<br/>

<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">default_keyed_pred</span> <span class="id" title="var">T</span> <span class="id" title="var">p</span> := <span class="id" title="var">KeyedPred</span> (@<span class="id" title="var">DefaultPredKey</span> <span class="id" title="var">T</span> <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">default_keyed_qualifier</span> <span class="id" title="var">T</span> <span class="id" title="var">n</span> (<span class="id" title="var">q</span> : <span class="id" title="var">qualifier</span> <span class="id" title="var">n</span> <span class="id" title="var">T</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">KeyedQualifier</span> (<span class="id" title="var">DefaultPredKey</span> <span class="id" title="var">q</span>).<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">DefaultKeying</span>.<br/>

<br/>
</div>

<div class="doc">
 Skolemizing with conditions.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">all_tag_cond_dep</span> <span class="id" title="var">I</span> <span class="id" title="var">T</span> (<span class="id" title="var">C</span> : <span class="id" title="var">pred</span> <span class="id" title="var">I</span>) <span class="id" title="var">U</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">T</span> <span class="id" title="var">x</span>) -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">C</span> <span class="id" title="var">x</span> -&gt; {<span class="id" title="var">y</span> : <span class="id" title="var">T</span> <span class="id" title="var">x</span> &amp; <span class="id" title="var">U</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}) -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">T</span> <span class="id" title="var">x</span> &amp; <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">C</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">U</span> <span class="id" title="var">x</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>)}.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">all_tag_cond</span> <span class="id" title="var">I</span> <span class="id" title="var">T</span> (<span class="id" title="var">C</span> : <span class="id" title="var">pred</span> <span class="id" title="var">I</span>) <span class="id" title="var">U</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">T</span> -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">C</span> <span class="id" title="var">x</span> -&gt; {<span class="id" title="var">y</span> : <span class="id" title="var">T</span> &amp; <span class="id" title="var">U</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}) -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="var">T</span> &amp; <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">C</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">U</span> <span class="id" title="var">x</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>)}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">all_sig_cond_dep</span> <span class="id" title="var">I</span> <span class="id" title="var">T</span> (<span class="id" title="var">C</span> : <span class="id" title="var">pred</span> <span class="id" title="var">I</span>) <span class="id" title="var">P</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">T</span> <span class="id" title="var">x</span>) -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">C</span> <span class="id" title="var">x</span> -&gt; {<span class="id" title="var">y</span> : <span class="id" title="var">T</span> <span class="id" title="var">x</span> | <span class="id" title="var">P</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}) -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">T</span> <span class="id" title="var">x</span> | <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">C</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>)}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">all_sig_cond</span> <span class="id" title="var">I</span> <span class="id" title="var">T</span> (<span class="id" title="var">C</span> : <span class="id" title="var">pred</span> <span class="id" title="var">I</span>) <span class="id" title="var">P</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">T</span> -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">C</span> <span class="id" title="var">x</span> -&gt; {<span class="id" title="var">y</span> : <span class="id" title="var">T</span> | <span class="id" title="var">P</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}) -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">I</span> -&gt; <span class="id" title="var">T</span> | <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">C</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>)}.<br/>
 
<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">RelationProperties</span>.<br/>

<br/>
</div>

<div class="doc">
 Caveat: reflexive should not be used to state lemmas, as auto and trivial
 will not expand the constant.                                               
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">R</span> : <span class="id" title="var">rel</span> <span class="id" title="var">T</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">total</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> || <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">transitive</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> <span class="id" title="var">z</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> -&gt; <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">z</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">symmetric</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> = <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">antisymmetric</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &amp;&amp; <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pre_symmetric</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">symmetric_from_pre</span> : <span class="id" title="var">pre_symmetric</span> -&gt; <span class="id" title="var">symmetric</span>.<br/>
 
<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">reflexive</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">irreflexive</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span> = <span class="id" title="var">false</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">left_transitive</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">R</span> <span class="id" title="var">x</span> =1 <span class="id" title="var">R</span> <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">right_transitive</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">R</span>^~ <span class="id" title="var">x</span> =1 <span class="id" title="var">R</span>^~ <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">PER</span>.<br/>

<br/>
<span class="id" title="keyword">Hypotheses</span> (<span class="id" title="var">symR</span> : <span class="id" title="var">symmetric</span>) (<span class="id" title="var">trR</span> : <span class="id" title="var">transitive</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sym_left_transitive</span> : <span class="id" title="var">left_transitive</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sym_right_transitive</span> : <span class="id" title="var">right_transitive</span>.<br/>
 
<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">PER</span>.<br/>

<br/>
</div>

<div class="doc">
 We define the equivalence property with prenex quantification so that it
 can be localized using the {in ..., ..} form defined below.                 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">equivalence_rel</span> := <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">R</span> <span class="id" title="var">z</span> <span class="id" title="var">z</span> * (<span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">z</span> = <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">equivalence_relP</span> : <span class="id" title="var">equivalence_rel</span> &lt;-&gt; <span class="id" title="var">reflexive</span> /\ <span class="id" title="var">left_transitive</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">RelationProperties</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">rev_trans</span> <span class="id" title="var">T</span> (<span class="id" title="var">R</span> : <span class="id" title="var">rel</span> <span class="id" title="var">T</span>) : <span class="id" title="var">transitive</span> <span class="id" title="var">R</span> -&gt; <span class="id" title="var">transitive</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span>).<br/>
 
<br/>
</div>

<div class="doc">
 Property localization  
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">LocalProperties</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> <span class="id" title="var">T1</span> <span class="id" title="var">T2</span> <span class="id" title="var">T3</span> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">d1</span> : <span class="id" title="var">mem_pred</span> <span class="id" title="var">T1</span>) (<span class="id" title="var">d2</span> : <span class="id" title="var">mem_pred</span> <span class="id" title="var">T2</span>) (<span class="id" title="var">d3</span> : <span class="id" title="var">mem_pred</span> <span class="id" title="var">T3</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">prop_for</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T1</span>) <span class="id" title="var">P</span> &amp; <span class="id" title="var">ph</span> {<span class="id" title="var">all1</span> <span class="id" title="var">P</span>} := <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">forE</span> <span class="id" title="var">x</span> <span class="id" title="var">P</span> <span class="id" title="var">phP</span> : @<span class="id" title="var">prop_for</span> <span class="id" title="var">x</span> <span class="id" title="var">P</span> <span class="id" title="var">phP</span> = <span class="id" title="var">P</span> <span class="id" title="var">x</span>.  <br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">prop_in1</span> <span class="id" title="var">P</span> &amp; <span class="id" title="var">ph</span> {<span class="id" title="var">all1</span> <span class="id" title="var">P</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">prop_in11</span> <span class="id" title="var">P</span> &amp; <span class="id" title="var">ph</span> {<span class="id" title="var">all2</span> <span class="id" title="var">P</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">y</span> <span class="id" title="var">d2</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">prop_in2</span> <span class="id" title="var">P</span> &amp; <span class="id" title="var">ph</span> {<span class="id" title="var">all2</span> <span class="id" title="var">P</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">y</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">prop_in111</span> <span class="id" title="var">P</span> &amp; <span class="id" title="var">ph</span> {<span class="id" title="var">all3</span> <span class="id" title="var">P</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">y</span> <span class="id" title="var">d2</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">z</span> <span class="id" title="var">d3</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">prop_in12</span> <span class="id" title="var">P</span> &amp; <span class="id" title="var">ph</span> {<span class="id" title="var">all3</span> <span class="id" title="var">P</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">y</span> <span class="id" title="var">d2</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">z</span> <span class="id" title="var">d2</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">prop_in21</span> <span class="id" title="var">P</span> &amp; <span class="id" title="var">ph</span> {<span class="id" title="var">all3</span> <span class="id" title="var">P</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">y</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">z</span> <span class="id" title="var">d2</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">prop_in3</span> <span class="id" title="var">P</span> &amp; <span class="id" title="var">ph</span> {<span class="id" title="var">all3</span> <span class="id" title="var">P</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">in_mem</span> <span class="id" title="var">x</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">y</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">in_mem</span> <span class="id" title="var">z</span> <span class="id" title="var">d1</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">f</span> : <span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T2</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">prop_on1</span> <span class="id" title="var">Pf</span> <span class="id" title="var">P</span> &amp; <span class="id" title="var">phantom</span> <span class="id" title="var">T3</span> (<span class="id" title="var">Pf</span> <span class="id" title="var">f</span>) &amp; <span class="id" title="var">ph</span> {<span class="id" title="var">all1</span> <span class="id" title="var">P</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">in_mem</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) <span class="id" title="var">d2</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">prop_on2</span> <span class="id" title="var">Pf</span> <span class="id" title="var">P</span> &amp; <span class="id" title="var">phantom</span> <span class="id" title="var">T3</span> (<span class="id" title="var">Pf</span> <span class="id" title="var">f</span>) &amp; <span class="id" title="var">ph</span> {<span class="id" title="var">all2</span> <span class="id" title="var">P</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">in_mem</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) <span class="id" title="var">d2</span> -&gt; <span class="id" title="var">in_mem</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>) <span class="id" title="var">d2</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">LocalProperties</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">inPhantom</span> := <span class="id" title="var">Phantom</span> <span class="id" title="keyword">Prop</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">onPhantom</span> {<span class="id" title="var">T</span>} <span class="id" title="var">P</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T</span>) := <span class="id" title="var">Phantom</span> <span class="id" title="keyword">Prop</span> (<span class="id" title="var">P</span> <span class="id" title="var">x</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bijective_in</span> <span class="id" title="var">aT</span> <span class="id" title="var">rT</span> (<span class="id" title="var">d</span> : <span class="id" title="var">mem_pred</span> <span class="id" title="var">aT</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">aT</span> -&gt; <span class="id" title="var">rT</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">exists2</span> <span class="id" title="var">g</span>, <span class="id" title="var">prop_in1</span> <span class="id" title="var">d</span> (<span class="id" title="var">inPhantom</span> (<span class="id" title="var">cancel</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp; <span class="id" title="var">prop_on1</span> <span class="id" title="var">d</span> (<span class="id" title="var">Phantom</span> <span class="id" title="var">_</span> (<span class="id" title="var">cancel</span> <span class="id" title="var">g</span>)) (<span class="id" title="var">onPhantom</span> (<span class="id" title="var">cancel</span> <span class="id" title="var">g</span>) <span class="id" title="var">f</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bijective_on</span> <span class="id" title="var">aT</span> <span class="id" title="var">rT</span> (<span class="id" title="var">cd</span> : <span class="id" title="var">mem_pred</span> <span class="id" title="var">rT</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">aT</span> -&gt; <span class="id" title="var">rT</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">exists2</span> <span class="id" title="var">g</span>, <span class="id" title="var">prop_on1</span> <span class="id" title="var">cd</span> (<span class="id" title="var">Phantom</span> <span class="id" title="var">_</span> (<span class="id" title="var">cancel</span> <span class="id" title="var">f</span>)) (<span class="id" title="var">onPhantom</span> (<span class="id" title="var">cancel</span> <span class="id" title="var">f</span>) <span class="id" title="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp; <span class="id" title="var">prop_in1</span> <span class="id" title="var">cd</span> (<span class="id" title="var">inPhantom</span> (<span class="id" title="var">cancel</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span>)).<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'for' x , P }" := (<span class="id" title="var">prop_for</span> <span class="id" title="var">x</span> (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'in' d , P }" := (<span class="id" title="var">prop_in1</span> (<span class="id" title="var">mem</span> <span class="id" title="var">d</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'in' d1 &amp; d2 , P }" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">prop_in11</span> (<span class="id" title="var">mem</span> <span class="id" title="var">d1</span>) (<span class="id" title="var">mem</span> <span class="id" title="var">d2</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'in' d &amp; , P }" := (<span class="id" title="var">prop_in2</span> (<span class="id" title="var">mem</span> <span class="id" title="var">d</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'in' d1 &amp; d2 &amp; d3 , P }" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">prop_in111</span> (<span class="id" title="var">mem</span> <span class="id" title="var">d1</span>) (<span class="id" title="var">mem</span> <span class="id" title="var">d2</span>) (<span class="id" title="var">mem</span> <span class="id" title="var">d3</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'in' d1 &amp; &amp; d3 , P }" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">prop_in21</span> (<span class="id" title="var">mem</span> <span class="id" title="var">d1</span>) (<span class="id" title="var">mem</span> <span class="id" title="var">d3</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'in' d1 &amp; d2 &amp; , P }" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">prop_in12</span> (<span class="id" title="var">mem</span> <span class="id" title="var">d1</span>) (<span class="id" title="var">mem</span> <span class="id" title="var">d2</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'in' d &amp; &amp; , P }" := (<span class="id" title="var">prop_in3</span> (<span class="id" title="var">mem</span> <span class="id" title="var">d</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'on' cd , P }" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">prop_on1</span> (<span class="id" title="var">mem</span> <span class="id" title="var">cd</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'on' cd &amp; , P }" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">prop_on2</span> (<span class="id" title="var">mem</span> <span class="id" title="var">cd</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>) (<span class="id" title="var">inPhantom</span> <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'on' cd , P &amp; g }" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">prop_on1</span> (<span class="id" title="var">mem</span> <span class="id" title="var">cd</span>) (<span class="id" title="var">Phantom</span> (<span class="id" title="var">_</span> -&gt; <span class="id" title="keyword">Prop</span>) <span class="id" title="var">P</span>) (<span class="id" title="var">onPhantom</span> <span class="id" title="var">P</span> <span class="id" title="var">g</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'in' d , 'bijective' f }" := (<span class="id" title="var">bijective_in</span> (<span class="id" title="var">mem</span> <span class="id" title="var">d</span>) <span class="id" title="var">f</span>) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ 'on' cd , 'bijective' f }" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">bijective_on</span> (<span class="id" title="var">mem</span> <span class="id" title="var">cd</span>) <span class="id" title="var">f</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Weakening and monotonicity lemmas for localized predicates.
 Note that using these lemmas in backward reasoning will force expansion of
 the predicate definition, as Coq needs to expose the quantifier to apply
 these lemmas. We define a few specialized variants to avoid this for some
 of the ssrfun predicates.                                                   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">LocalGlobal</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> <span class="id" title="var">T1</span> <span class="id" title="var">T2</span> <span class="id" title="var">T3</span> : <span class="id" title="var">predArgType</span>.<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">D1</span> : {<span class="id" title="var">pred</span> <span class="id" title="var">T1</span>}) (<span class="id" title="var">D2</span> : {<span class="id" title="var">pred</span> <span class="id" title="var">T2</span>}) (<span class="id" title="var">D3</span> : {<span class="id" title="var">pred</span> <span class="id" title="var">T3</span>}).<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">d1</span> <span class="id" title="var">d1'</span> : <span class="id" title="var">mem_pred</span> <span class="id" title="var">T1</span>) (<span class="id" title="var">d2</span> <span class="id" title="var">d2'</span> : <span class="id" title="var">mem_pred</span> <span class="id" title="var">T2</span>) (<span class="id" title="var">d3</span> <span class="id" title="var">d3'</span> : <span class="id" title="var">mem_pred</span> <span class="id" title="var">T3</span>).<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">f</span> <span class="id" title="var">f'</span> : <span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T2</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">T2</span> -&gt; <span class="id" title="var">T1</span>) (<span class="id" title="var">h</span> : <span class="id" title="var">T3</span>).<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">P1</span> : <span class="id" title="var">T1</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">P2</span> : <span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T2</span> -&gt; <span class="id" title="keyword">Prop</span>).<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">P3</span> : <span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T2</span> -&gt; <span class="id" title="var">T3</span> -&gt; <span class="id" title="keyword">Prop</span>.<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">Q1</span> : (<span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T2</span>) -&gt; <span class="id" title="var">T1</span> -&gt; <span class="id" title="keyword">Prop</span>.<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">Q1l</span> : (<span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T2</span>) -&gt; <span class="id" title="var">T3</span> -&gt; <span class="id" title="var">T1</span> -&gt; <span class="id" title="keyword">Prop</span>.<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">Q2</span> : (<span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T2</span>) -&gt; <span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T1</span> -&gt; <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">sub1</span> : <span class="id" title="var">sub_mem</span> <span class="id" title="var">d1</span> <span class="id" title="var">d1'</span>.<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">sub2</span> : <span class="id" title="var">sub_mem</span> <span class="id" title="var">d2</span> <span class="id" title="var">d2'</span>.<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">sub3</span> : <span class="id" title="var">sub_mem</span> <span class="id" title="var">d3</span> <span class="id" title="var">d3'</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in1W</span> : {<span class="id" title="var">all1</span> <span class="id" title="var">P1</span>} -&gt; {<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span>, {<span class="id" title="var">all1</span> <span class="id" title="var">P1</span>}}.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">in2W</span> : {<span class="id" title="var">all2</span> <span class="id" title="var">P2</span>} -&gt; {<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span> &amp; <span class="id" title="var">D2</span>, {<span class="id" title="var">all2</span> <span class="id" title="var">P2</span>}}.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">in3W</span> : {<span class="id" title="var">all3</span> <span class="id" title="var">P3</span>} -&gt; {<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span> &amp; <span class="id" title="var">D2</span> &amp; <span class="id" title="var">D3</span>, {<span class="id" title="var">all3</span> <span class="id" title="var">P3</span>}}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in1T</span> : {<span class="id" title="tactic">in</span> <span class="id" title="var">T1</span>, {<span class="id" title="var">all1</span> <span class="id" title="var">P1</span>}} -&gt; {<span class="id" title="var">all1</span> <span class="id" title="var">P1</span>}.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">in2T</span> : {<span class="id" title="tactic">in</span> <span class="id" title="var">T1</span> &amp; <span class="id" title="var">T2</span>, {<span class="id" title="var">all2</span> <span class="id" title="var">P2</span>}} -&gt; {<span class="id" title="var">all2</span> <span class="id" title="var">P2</span>}.<br/>
 <span class="id" title="keyword">Lemma</span> <span class="id" title="var">in3T</span> : {<span class="id" title="tactic">in</span> <span class="id" title="var">T1</span> &amp; <span class="id" title="var">T2</span> &amp; <span class="id" title="var">T3</span>, {<span class="id" title="var">all3</span> <span class="id" title="var">P3</span>}} -&gt; {<span class="id" title="var">all3</span> <span class="id" title="var">P3</span>}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sub_in1</span> (<span class="id" title="var">Ph</span> : <span class="id" title="var">ph</span> {<span class="id" title="var">all1</span> <span class="id" title="var">P1</span>}) : <span class="id" title="var">prop_in1</span> <span class="id" title="var">d1'</span> <span class="id" title="var">Ph</span> -&gt; <span class="id" title="var">prop_in1</span> <span class="id" title="var">d1</span> <span class="id" title="var">Ph</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sub_in11</span> (<span class="id" title="var">Ph</span> : <span class="id" title="var">ph</span> {<span class="id" title="var">all2</span> <span class="id" title="var">P2</span>}) : <span class="id" title="var">prop_in11</span> <span class="id" title="var">d1'</span> <span class="id" title="var">d2'</span> <span class="id" title="var">Ph</span> -&gt; <span class="id" title="var">prop_in11</span> <span class="id" title="var">d1</span> <span class="id" title="var">d2</span> <span class="id" title="var">Ph</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sub_in111</span> (<span class="id" title="var">Ph</span> : <span class="id" title="var">ph</span> {<span class="id" title="var">all3</span> <span class="id" title="var">P3</span>}) :<br/>
&nbsp;&nbsp;<span class="id" title="var">prop_in111</span> <span class="id" title="var">d1'</span> <span class="id" title="var">d2'</span> <span class="id" title="var">d3'</span> <span class="id" title="var">Ph</span> -&gt; <span class="id" title="var">prop_in111</span> <span class="id" title="var">d1</span> <span class="id" title="var">d2</span> <span class="id" title="var">d3</span> <span class="id" title="var">Ph</span>.<br/>
 
<br/>
<span class="id" title="keyword">Let</span> <span class="id" title="var">allQ1</span> <span class="id" title="var">f''</span> := {<span class="id" title="var">all1</span> <span class="id" title="var">Q1</span> <span class="id" title="var">f''</span>}.<br/>
<span class="id" title="keyword">Let</span> <span class="id" title="var">allQ1l</span> <span class="id" title="var">f''</span> <span class="id" title="var">h'</span> := {<span class="id" title="var">all1</span> <span class="id" title="var">Q1l</span> <span class="id" title="var">f''</span> <span class="id" title="var">h'</span>}.<br/>
<span class="id" title="keyword">Let</span> <span class="id" title="var">allQ2</span> <span class="id" title="var">f''</span> := {<span class="id" title="var">all2</span> <span class="id" title="var">Q2</span> <span class="id" title="var">f''</span>}.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">on1W</span> : <span class="id" title="var">allQ1</span> <span class="id" title="var">f</span> -&gt; {<span class="id" title="var">on</span> <span class="id" title="var">D2</span>, <span class="id" title="var">allQ1</span> <span class="id" title="var">f</span>}.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">on1lW</span> : <span class="id" title="var">allQ1l</span> <span class="id" title="var">f</span> <span class="id" title="var">h</span> -&gt; {<span class="id" title="var">on</span> <span class="id" title="var">D2</span>, <span class="id" title="var">allQ1l</span> <span class="id" title="var">f</span> &amp; <span class="id" title="var">h</span>}.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">on2W</span> : <span class="id" title="var">allQ2</span> <span class="id" title="var">f</span> -&gt; {<span class="id" title="var">on</span> <span class="id" title="var">D2</span> &amp;, <span class="id" title="var">allQ2</span> <span class="id" title="var">f</span>}.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">on1T</span> : {<span class="id" title="var">on</span> <span class="id" title="var">T2</span>, <span class="id" title="var">allQ1</span> <span class="id" title="var">f</span>} -&gt; <span class="id" title="var">allQ1</span> <span class="id" title="var">f</span>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">on1lT</span> : {<span class="id" title="var">on</span> <span class="id" title="var">T2</span>, <span class="id" title="var">allQ1l</span> <span class="id" title="var">f</span> &amp; <span class="id" title="var">h</span>} -&gt; <span class="id" title="var">allQ1l</span> <span class="id" title="var">f</span> <span class="id" title="var">h</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">on2T</span> : {<span class="id" title="var">on</span> <span class="id" title="var">T2</span> &amp;, <span class="id" title="var">allQ2</span> <span class="id" title="var">f</span>} -&gt; <span class="id" title="var">allQ2</span> <span class="id" title="var">f</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subon1</span> (<span class="id" title="var">Phf</span> : <span class="id" title="var">ph</span> (<span class="id" title="var">allQ1</span> <span class="id" title="var">f</span>)) (<span class="id" title="var">Ph</span> : <span class="id" title="var">ph</span> (<span class="id" title="var">allQ1</span> <span class="id" title="var">f</span>)) :<br/>
&nbsp;&nbsp;<span class="id" title="var">prop_on1</span> <span class="id" title="var">d2'</span> <span class="id" title="var">Phf</span> <span class="id" title="var">Ph</span> -&gt; <span class="id" title="var">prop_on1</span> <span class="id" title="var">d2</span> <span class="id" title="var">Phf</span> <span class="id" title="var">Ph</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subon1l</span> (<span class="id" title="var">Phf</span> : <span class="id" title="var">ph</span> (<span class="id" title="var">allQ1l</span> <span class="id" title="var">f</span>)) (<span class="id" title="var">Ph</span> : <span class="id" title="var">ph</span> (<span class="id" title="var">allQ1l</span> <span class="id" title="var">f</span> <span class="id" title="var">h</span>)) :<br/>
&nbsp;&nbsp;<span class="id" title="var">prop_on1</span> <span class="id" title="var">d2'</span> <span class="id" title="var">Phf</span> <span class="id" title="var">Ph</span> -&gt; <span class="id" title="var">prop_on1</span> <span class="id" title="var">d2</span> <span class="id" title="var">Phf</span> <span class="id" title="var">Ph</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subon2</span> (<span class="id" title="var">Phf</span> : <span class="id" title="var">ph</span> (<span class="id" title="var">allQ2</span> <span class="id" title="var">f</span>)) (<span class="id" title="var">Ph</span> : <span class="id" title="var">ph</span> (<span class="id" title="var">allQ2</span> <span class="id" title="var">f</span>)) :<br/>
&nbsp;&nbsp;<span class="id" title="var">prop_on2</span> <span class="id" title="var">d2'</span> <span class="id" title="var">Phf</span> <span class="id" title="var">Ph</span> -&gt; <span class="id" title="var">prop_on2</span> <span class="id" title="var">d2</span> <span class="id" title="var">Phf</span> <span class="id" title="var">Ph</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">can_in_inj</span> : {<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span>, <span class="id" title="var">cancel</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>} -&gt; {<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span> &amp;, <span class="id" title="var">injective</span> <span class="id" title="var">f</span>}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">canLR_in</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : {<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span>, <span class="id" title="var">cancel</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>} -&gt; <span class="id" title="var">y</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">g</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">canRL_in</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : {<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span>, <span class="id" title="var">cancel</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>} -&gt; <span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span> -&gt; <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">y</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">on_can_inj</span> : {<span class="id" title="var">on</span> <span class="id" title="var">D2</span>, <span class="id" title="var">cancel</span> <span class="id" title="var">f</span> &amp; <span class="id" title="var">g</span>} -&gt; {<span class="id" title="var">on</span> <span class="id" title="var">D2</span> &amp;, <span class="id" title="var">injective</span> <span class="id" title="var">f</span>}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">canLR_on</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : {<span class="id" title="var">on</span> <span class="id" title="var">D2</span>, <span class="id" title="var">cancel</span> <span class="id" title="var">f</span> &amp; <span class="id" title="var">g</span>} -&gt; <span class="id" title="var">f</span> <span class="id" title="var">y</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">D2</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">g</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">canRL_on</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : {<span class="id" title="var">on</span> <span class="id" title="var">D2</span>, <span class="id" title="var">cancel</span> <span class="id" title="var">f</span> &amp; <span class="id" title="var">g</span>} -&gt; <span class="id" title="var">f</span> <span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">D2</span> -&gt; <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">y</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">inW_bij</span> : <span class="id" title="var">bijective</span> <span class="id" title="var">f</span> -&gt; {<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span>, <span class="id" title="var">bijective</span> <span class="id" title="var">f</span>}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">onW_bij</span> : <span class="id" title="var">bijective</span> <span class="id" title="var">f</span> -&gt; {<span class="id" title="var">on</span> <span class="id" title="var">D2</span>, <span class="id" title="var">bijective</span> <span class="id" title="var">f</span>}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">inT_bij</span> : {<span class="id" title="tactic">in</span> <span class="id" title="var">T1</span>, <span class="id" title="var">bijective</span> <span class="id" title="var">f</span>} -&gt; <span class="id" title="var">bijective</span> <span class="id" title="var">f</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">onT_bij</span> : {<span class="id" title="var">on</span> <span class="id" title="var">T2</span>, <span class="id" title="var">bijective</span> <span class="id" title="var">f</span>} -&gt; <span class="id" title="var">bijective</span> <span class="id" title="var">f</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sub_in_bij</span> (<span class="id" title="var">D1'</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T1</span>) :<br/>
&nbsp;&nbsp;{<span class="id" title="var">subset</span> <span class="id" title="var">D1</span> &lt;= <span class="id" title="var">D1'</span>} -&gt; {<span class="id" title="tactic">in</span> <span class="id" title="var">D1'</span>, <span class="id" title="var">bijective</span> <span class="id" title="var">f</span>} -&gt; {<span class="id" title="tactic">in</span> <span class="id" title="var">D1</span>, <span class="id" title="var">bijective</span> <span class="id" title="var">f</span>}.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subon_bij</span> (<span class="id" title="var">D2'</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T2</span>) :<br/>
&nbsp;&nbsp;{<span class="id" title="var">subset</span> <span class="id" title="var">D2</span> &lt;= <span class="id" title="var">D2'</span>} -&gt; {<span class="id" title="var">on</span> <span class="id" title="var">D2'</span>, <span class="id" title="var">bijective</span> <span class="id" title="var">f</span>} -&gt; {<span class="id" title="var">on</span> <span class="id" title="var">D2</span>, <span class="id" title="var">bijective</span> <span class="id" title="var">f</span>}.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">LocalGlobal</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sub_in2</span> <span class="id" title="var">T</span> <span class="id" title="var">d</span> <span class="id" title="var">d'</span> (<span class="id" title="var">P</span> : <span class="id" title="var">T</span> -&gt; <span class="id" title="var">T</span> -&gt; <span class="id" title="keyword">Prop</span>) :<br/>
&nbsp;&nbsp;<span class="id" title="var">sub_mem</span> <span class="id" title="var">d</span> <span class="id" title="var">d'</span> -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">Ph</span> : <span class="id" title="var">ph</span> {<span class="id" title="var">all2</span> <span class="id" title="var">P</span>}, <span class="id" title="var">prop_in2</span> <span class="id" title="var">d'</span> <span class="id" title="var">Ph</span> -&gt; <span class="id" title="var">prop_in2</span> <span class="id" title="var">d</span> <span class="id" title="var">Ph</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sub_in3</span> <span class="id" title="var">T</span> <span class="id" title="var">d</span> <span class="id" title="var">d'</span> (<span class="id" title="var">P</span> : <span class="id" title="var">T</span> -&gt; <span class="id" title="var">T</span> -&gt; <span class="id" title="var">T</span> -&gt; <span class="id" title="keyword">Prop</span>) :<br/>
&nbsp;&nbsp;<span class="id" title="var">sub_mem</span> <span class="id" title="var">d</span> <span class="id" title="var">d'</span> -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">Ph</span> : <span class="id" title="var">ph</span> {<span class="id" title="var">all3</span> <span class="id" title="var">P</span>}, <span class="id" title="var">prop_in3</span> <span class="id" title="var">d'</span> <span class="id" title="var">Ph</span> -&gt; <span class="id" title="var">prop_in3</span> <span class="id" title="var">d</span> <span class="id" title="var">Ph</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sub_in12</span> <span class="id" title="var">T1</span> <span class="id" title="var">T</span> <span class="id" title="var">d1</span> <span class="id" title="var">d1'</span> <span class="id" title="var">d</span> <span class="id" title="var">d'</span> (<span class="id" title="var">P</span> : <span class="id" title="var">T1</span> -&gt; <span class="id" title="var">T</span> -&gt; <span class="id" title="var">T</span> -&gt; <span class="id" title="keyword">Prop</span>) :<br/>
&nbsp;&nbsp;<span class="id" title="var">sub_mem</span> <span class="id" title="var">d1</span> <span class="id" title="var">d1'</span> -&gt; <span class="id" title="var">sub_mem</span> <span class="id" title="var">d</span> <span class="id" title="var">d'</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">Ph</span> : <span class="id" title="var">ph</span> {<span class="id" title="var">all3</span> <span class="id" title="var">P</span>}, <span class="id" title="var">prop_in12</span> <span class="id" title="var">d1'</span> <span class="id" title="var">d'</span> <span class="id" title="var">Ph</span> -&gt; <span class="id" title="var">prop_in12</span> <span class="id" title="var">d1</span> <span class="id" title="var">d</span> <span class="id" title="var">Ph</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sub_in21</span> <span class="id" title="var">T</span> <span class="id" title="var">T3</span> <span class="id" title="var">d</span> <span class="id" title="var">d'</span> <span class="id" title="var">d3</span> <span class="id" title="var">d3'</span> (<span class="id" title="var">P</span> : <span class="id" title="var">T</span> -&gt; <span class="id" title="var">T</span> -&gt; <span class="id" title="var">T3</span> -&gt; <span class="id" title="keyword">Prop</span>) :<br/>
&nbsp;&nbsp;<span class="id" title="var">sub_mem</span> <span class="id" title="var">d</span> <span class="id" title="var">d'</span> -&gt; <span class="id" title="var">sub_mem</span> <span class="id" title="var">d3</span> <span class="id" title="var">d3'</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">Ph</span> : <span class="id" title="var">ph</span> {<span class="id" title="var">all3</span> <span class="id" title="var">P</span>}, <span class="id" title="var">prop_in21</span> <span class="id" title="var">d'</span> <span class="id" title="var">d3'</span> <span class="id" title="var">Ph</span> -&gt; <span class="id" title="var">prop_in21</span> <span class="id" title="var">d</span> <span class="id" title="var">d3</span> <span class="id" title="var">Ph</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">equivalence_relP_in</span> <span class="id" title="var">T</span> (<span class="id" title="var">R</span> : <span class="id" title="var">rel</span> <span class="id" title="var">T</span>) (<span class="id" title="var">A</span> : <span class="id" title="var">pred</span> <span class="id" title="var">T</span>) :<br/>
&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">A</span> &amp; &amp;, <span class="id" title="var">equivalence_rel</span> <span class="id" title="var">R</span>}<br/>
&nbsp;&nbsp;&nbsp;&lt;-&gt; {<span class="id" title="tactic">in</span> <span class="id" title="var">A</span>, <span class="id" title="var">reflexive</span> <span class="id" title="var">R</span>} /\ {<span class="id" title="tactic">in</span> <span class="id" title="var">A</span> &amp;, <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> -&gt; {<span class="id" title="tactic">in</span> <span class="id" title="var">A</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> =1 <span class="id" title="var">R</span> <span class="id" title="var">y</span>}}.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">MonoHomoMorphismTheory</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">aT</span> <span class="id" title="var">rT</span> <span class="id" title="var">sT</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">aT</span> -&gt; <span class="id" title="var">rT</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">rT</span> -&gt; <span class="id" title="var">aT</span>).<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">aP</span> : <span class="id" title="var">pred</span> <span class="id" title="var">aT</span>) (<span class="id" title="var">rP</span> : <span class="id" title="var">pred</span> <span class="id" title="var">rT</span>) (<span class="id" title="var">aR</span> : <span class="id" title="var">rel</span> <span class="id" title="var">aT</span>) (<span class="id" title="var">rR</span> : <span class="id" title="var">rel</span> <span class="id" title="var">rT</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">monoW</span> : {<span class="id" title="var">mono</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> / <span class="id" title="var">aP</span> <span class="id" title="var">x</span> &gt;-&gt; <span class="id" title="var">rP</span> <span class="id" title="var">x</span>} -&gt; {<span class="id" title="var">homo</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> / <span class="id" title="var">aP</span> <span class="id" title="var">x</span> &gt;-&gt; <span class="id" title="var">rP</span> <span class="id" title="var">x</span>}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mono2W</span> :<br/>
&nbsp;&nbsp;{<span class="id" title="var">mono</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>} -&gt; {<span class="id" title="var">homo</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}.<br/>
 
<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">fgK</span> : <span class="id" title="var">cancel</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">homoRL</span> :<br/>
&nbsp;&nbsp;{<span class="id" title="var">homo</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>} -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">aR</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span> -&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">homoLR</span> :<br/>
&nbsp;&nbsp;{<span class="id" title="var">homo</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>} -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">aR</span> <span class="id" title="var">x</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>) -&gt; <span class="id" title="var">rR</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">homo_mono</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">homo</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>} -&gt; {<span class="id" title="var">homo</span> <span class="id" title="var">g</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>} -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="var">mono</span> <span class="id" title="var">g</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">monoLR</span> :<br/>
&nbsp;&nbsp;{<span class="id" title="var">mono</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>} -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">rR</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span> = <span class="id" title="var">aR</span> <span class="id" title="var">x</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">monoRL</span> :<br/>
&nbsp;&nbsp;{<span class="id" title="var">mono</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>} -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">rR</span> <span class="id" title="var">x</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>) = <span class="id" title="var">aR</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">can_mono</span> :<br/>
&nbsp;&nbsp;{<span class="id" title="var">mono</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>} -&gt; {<span class="id" title="var">mono</span> <span class="id" title="var">g</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}.<br/>
 
<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MonoHomoMorphismTheory</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">MonoHomoMorphismTheory_in</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">aT</span> <span class="id" title="var">rT</span> <span class="id" title="var">sT</span> : <span class="id" title="var">predArgType</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">aT</span> -&gt; <span class="id" title="var">rT</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">rT</span> -&gt; <span class="id" title="var">aT</span>).<br/>
<span class="id" title="keyword">Variable</span> (<span class="id" title="var">aD</span> : {<span class="id" title="var">pred</span> <span class="id" title="var">aT</span>}).<br/>
<span class="id" title="keyword">Variable</span> (<span class="id" title="var">aP</span> : <span class="id" title="var">pred</span> <span class="id" title="var">aT</span>) (<span class="id" title="var">rP</span> : <span class="id" title="var">pred</span> <span class="id" title="var">rT</span>) (<span class="id" title="var">aR</span> : <span class="id" title="var">rel</span> <span class="id" title="var">aT</span>) (<span class="id" title="var">rR</span> : <span class="id" title="var">rel</span> <span class="id" title="var">rT</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">rD</span> := [<span class="id" title="var">pred</span> <span class="id" title="var">x</span> | <span class="id" title="var">g</span> <span class="id" title="var">x</span> \<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span>].<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">monoW_in</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span> &amp;, {<span class="id" title="var">mono</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span> &amp;, {<span class="id" title="var">homo</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mono2W_in</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span>, {<span class="id" title="var">mono</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> / <span class="id" title="var">aP</span> <span class="id" title="var">x</span> &gt;-&gt; <span class="id" title="var">rP</span> <span class="id" title="var">x</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span>, {<span class="id" title="var">homo</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> / <span class="id" title="var">aP</span> <span class="id" title="var">x</span> &gt;-&gt; <span class="id" title="var">rP</span> <span class="id" title="var">x</span>}}.<br/>
 
<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">fgK_on</span> : {<span class="id" title="var">on</span> <span class="id" title="var">aD</span>, <span class="id" title="var">cancel</span> <span class="id" title="var">g</span> &amp; <span class="id" title="var">f</span>}.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">homoRL_in</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span> &amp;, {<span class="id" title="var">homo</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">rD</span> &amp; <span class="id" title="var">aD</span>, <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">aR</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span> -&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>)}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">homoLR_in</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span> &amp;, {<span class="id" title="var">homo</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span> &amp; <span class="id" title="var">rD</span>, <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">aR</span> <span class="id" title="var">x</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>) -&gt; <span class="id" title="var">rR</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span>}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">homo_mono_in</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span> &amp;, {<span class="id" title="var">homo</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}} -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">rD</span> &amp;, {<span class="id" title="var">homo</span> <span class="id" title="var">g</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">rD</span> &amp;, {<span class="id" title="var">mono</span> <span class="id" title="var">g</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}}.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">monoLR_in</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span> &amp;, {<span class="id" title="var">mono</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span> &amp; <span class="id" title="var">rD</span>, <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">rR</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span> = <span class="id" title="var">aR</span> <span class="id" title="var">x</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>)}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">monoRL_in</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span> &amp;, {<span class="id" title="var">mono</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">rD</span> &amp; <span class="id" title="var">aD</span>, <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">rR</span> <span class="id" title="var">x</span> (<span class="id" title="var">f</span> <span class="id" title="var">y</span>) = <span class="id" title="var">aR</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span>}.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">can_mono_in</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">aD</span> &amp;, {<span class="id" title="var">mono</span> <span class="id" title="var">f</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}} -&gt;<br/>
&nbsp;&nbsp;{<span class="id" title="tactic">in</span> <span class="id" title="var">rD</span> &amp;, {<span class="id" title="var">mono</span> <span class="id" title="var">g</span> : <span class="id" title="var">x</span> <span class="id" title="var">y</span> / <span class="id" title="var">rR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> &gt;-&gt; <span class="id" title="var">aR</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>}}.<br/>
 
<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">MonoHomoMorphismTheory_in</span>.<br/>
</div>
    <div id="sidebarWrapper">
      <div id="sidebar">
        <div class="block">
          <h2 class="title">Navigation</h2>
          <div class="content">
            <ul class="menu">
              <li class="leaf">Standard Library
                <ul class="menu">
                  <li><a href="index.html">Table of contents</a></li>
                  <li><a href="genindex.html">Index</a></li>
                </ul>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>

  </div>

  <div id="footer">
    <div id="nav-footer">
      <ul class="links-menu-footer">
        <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
        <li><a href="http://validator.w3.org/">xhtml valid</a></li>
        <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
      </ul>
    </div>
  </div>

</div>

</body>
</html>
