<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/sites/all/themes/coq/coqdoc.css" />

<title>Standard Library | The Coq Proof Assistant</title>

</head>

<body>

<div id="container">
  <div id="headertop">
    <div id="nav">
      <ul class="links-menu">
        <li><a href="//coq.inria.fr/" class="active">Home</a></li>
        <li><a href="//coq.inria.fr/about-coq" title="More about coq">About Coq</a></li>
        <li><a href="//coq.inria.fr/download">Get Coq</a></li>
        <li><a href="//coq.inria.fr/documentation">Documentation</a></li>
        <li><a href="//coq.inria.fr/community">Community</a></li>
      </ul>
    </div>
  </div>

  <div id="header">
    <div id="logoWrapper">
      <div id="logo"><a href="//coq.inria.fr/" title="Home"><img src="//coq.inria.fr/files/barron_logo.png" alt="Home" /></a>
      </div>
      <div id="siteName"><a href="//coq.inria.fr/" title="Home">The Coq Proof Assistant</a>
      </div>
    </div>
  </div>

  <div id="content">

<h1 class="libtitle">Library Stdlib.Logic.ConstructiveEpsilon</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
This provides with a proof of the constructive form of definite
and indefinite descriptions for Sigma^0_1-formulas (hereafter called
"small" formulas), which infers the sigma-existence (i.e.,
<span class="inlinecode"><span class="id" title="keyword">Type</span></span>-existence) of a witness to a decidable predicate over a
countable domain from the regular existence (i.e.,
<span class="inlinecode"><span class="id" title="keyword">Prop</span></span>-existence). 
<div class="paragraph"> </div>

 Coq does not allow case analysis on sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> when the goal is in
not in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Therefore, one cannot eliminate <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> in order to
show <span class="inlinecode">{<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>. However, one can perform a recursion on an
inductive predicate in sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> so that the returning type of the
recursion is in <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. This trick is described in Coq'Art book, Sect.
14.2.3 and 15.4. In particular, this trick is used in the proof of
<span class="inlinecode"><span class="id" title="var">Fix_F</span></span> in the module Coq.Init.Wf. There, recursion is done on an
inductive predicate <span class="inlinecode"><span class="id" title="var">Acc</span></span> and the resulting type is in <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.

<div class="paragraph"> </div>

To find a witness of <span class="inlinecode"><span class="id" title="var">P</span></span> constructively, we program the well-known
linear search algorithm that tries P on all natural numbers starting
from 0 and going up.  Such an algorithm needs a suitable termination
certificate.  We offer two ways for providing this termination
certificate: a direct one, based on an ad-hoc predicate called
<span class="inlinecode"><span class="id" title="var">before_witness</span></span>, and another one based on the predicate <span class="inlinecode"><span class="id" title="var">Acc</span></span>.
For the first one we provide explicit and short proof terms. 
<div class="paragraph"> </div>

 The method based on <span class="inlinecode"><span class="id" title="var">before_witness</span></span> (2009) can be seen as an ancestor
of the first ingredient of the Braga method, by Dominique Larchey-Wendling
and Jean-François Monin (Types'18, then in more details in <span class="inlinecode">[1]</span>).
In this approach, the termination certificate is usually combined
with an inductive relational presentation of the recursive function
of interest. This became especially useful here since the introduction
of <span class="inlinecode"><span class="id" title="var">epsilon_smallest</span></span>, stating that the output of the linear search
algorithm is minimal, whereas in the 2009 version, the only
postcondition considered stated that the output satisfies <span class="inlinecode"><span class="id" title="var">P</span></span>.
In this file, the linear search program is named <span class="inlinecode"><span class="id" title="var">prog_linear_search</span></span>
because <span class="inlinecode"><span class="id" title="var">linear_search</span></span> happens to be the name of a similar but
different program in the 2009 version: both programs take as input a
natural number <span class="inlinecode"><span class="id" title="var">start</span></span> and a termination certificate, and
the output of <span class="inlinecode"><span class="id" title="var">prog_linear_search</span></span> is a natural number <span class="inlinecode"><span class="id" title="var">n</span></span>
whereas the output of <span class="inlinecode"><span class="id" title="var">linear_search</span></span> is <span class="inlinecode"><span class="id" title="var">n</span></span> packed with a proof
of <span class="inlinecode">(<span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>. The inductive relation for linear search is named <span class="inlinecode"><span class="id" title="var">rel_ls</span></span>.

<div class="paragraph"> </div>

The Braga method usually consists in defining a function <span class="inlinecode"><span class="id" title="var">f_conform</span></span>
intended to be extracted as (the OCaml translation of) an n-ary
function <span class="inlinecode"><span class="id" title="var">f</span></span>, with inputs <span class="inlinecode"><span class="id" title="var">x</span>...</span> and output type <span class="inlinecode">{<span class="id" title="var">y</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span>...</span> <span class="inlinecode"><span class="id" title="var">y</span>}</span>
where <span class="inlinecode"><span class="id" title="var">R</span></span> is an inductive n+1-ary relational presentation of <span class="inlinecode"><span class="id" title="var">f</span></span>.
An additional input of <span class="inlinecode"><span class="id" title="var">f_conform</span></span> is a termination certificate
whose type can be derived from <span class="inlinecode"><span class="id" title="var">R</span></span>. Partial correctness properties
are proved on <span class="inlinecode"><span class="id" title="var">R</span></span>, then transported on <span class="inlinecode"><span class="id" title="var">f_conform</span></span> (an alternative,
not considered for linear search, is to simulate an inductive-recursive
scheme for <span class="inlinecode"><span class="id" title="var">f_conform</span></span>).
In the present case, the Coq name of <span class="inlinecode"><span class="id" title="var">f</span></span> is then <span class="inlinecode"><span class="id" title="var">prog_linear_search</span></span>,
<span class="inlinecode"><span class="id" title="var">R</span></span> is <span class="inlinecode"><span class="id" title="var">rel_ls</span></span> and the type of the termination certificate is named
<span class="inlinecode"><span class="id" title="var">before_witness</span></span>.
In simple situations such as linear search, one can as well
directly define the type of the termination certificate and
the n+1-ary Coq version of <span class="inlinecode"><span class="id" title="var">f</span></span>.
Several variants of the proofs are offered for the record:
<ul class="doclist">
<li> a version that follows the steps in <span class="inlinecode">[1]</span>, named <span class="inlinecode"><span class="id" title="var">linear_search_conform</span></span>;

</li>
<li> a variant of the latter, named <span class="inlinecode"><span class="id" title="var">linear_search_conform_alt</span></span>,
  where the recursive call is no longer encapsulated in a
  pattern-matching (avoiding packing-unpacking steps which
  are for instance removed at extraction at the price of
  an additional optimization step).

</li>
<li> a version where <span class="inlinecode"><span class="id" title="var">prog_linear_search</span></span> is directly programmed
  and its conformity to <span class="inlinecode"><span class="id" title="var">rel_ls</span></span> (by dependent induction on
  the termination certificate), and then the properties of
  its output are separately proven.

</li>
</ul>
It is interesting to see that in the last version, the conformity
proof slightly deviates from the definition of <span class="inlinecode"><span class="id" title="var">prog_linear_search</span></span>,
resulting in an unpleasant duplication of proof obligations, because
the first pattern-matching is performed on <span class="inlinecode"><span class="id" title="var">P_dec</span></span> <span class="inlinecode"><span class="id" title="var">start</span></span> in the
function and on the termination certificate in the conformity proof.
This deviation seems to be unavoidable because crucial proof steps
require the guard argument of the fixpoint to start with a constructor.

<div class="paragraph"> </div>

The three programs <span class="inlinecode"><span class="id" title="var">prog_linear_search</span></span>, <span class="inlinecode"><span class="id" title="var">linear_search_conform</span></span>
and <span class="inlinecode"><span class="id" title="var">linear_search_conform_alt</span></span> are purposely presented in a
very similar manner, using <span class="inlinecode"><span class="id" title="tactic">refine</span></span> and postponing proof obligations
related to conformity to <span class="inlinecode"><span class="id" title="var">rel_ls</span></span>.

<div class="paragraph"> </div>

 <span class="inlinecode">[1]</span> Dominique Larchey-Wendling and Jean-François Monin.
     The Braga Method: Extracting Certified Algorithms from
     Complex Recursive Schemes in Coq, chapter 8, pages 305--386.
     In K. Mainzer, P. Schuster, and H. Schwichtenberg, editors.
     Proof and Computation II: From Proof Theory and Univalent
     Mathematics to Program Extraction and Verification.
     World Scientific, September 2021.

<div class="paragraph"> </div>

 Based on ideas from Benjamin Werner and Jean-François Monin 
<div class="paragraph"> </div>

 Contributed by Yevgeniy Makarov and Jean-François Monin 
</div>
<div class="code">

<br/>

<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stdlib.Arith.Arith.html#"><span class="id" title="library">Arith</span></a>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a id="ConstructiveIndefiniteGroundDescription_Direct" class="idref" href="#ConstructiveIndefiniteGroundDescription_Direct"><span class="id" title="section">ConstructiveIndefiniteGroundDescription_Direct</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <a id="ConstructiveIndefiniteGroundDescription_Direct.P" class="idref" href="#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Hypothesis</span> <a id="ConstructiveIndefiniteGroundDescription_Direct.P_dec" class="idref" href="#ConstructiveIndefiniteGroundDescription_Direct.P_dec"><span class="id" title="variable">P_dec</span></a> : <span class="id" title="keyword">forall</span> <a id="n:3" class="idref" href="#n:3"><span class="id" title="binder">n</span></a>, <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">{</span></a><a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:3"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">}+{</span></a><a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~(</span></a><a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:3"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a><a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">}</span></a>.<br/>

<br/>
</div>

<div class="doc">
The termination argument is <span class="inlinecode"><span class="id" title="var">before_witness</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, which says that
any number before any witness (not necessarily the <span class="inlinecode"><span class="id" title="var">x</span></span> of <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:<span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>)
makes the search eventually stops. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a id="before_witness" class="idref" href="#before_witness"><span class="id" title="definition, inductive"><span id="before_witness_ind" class="id"><span id="before_witness_sind" class="id">before_witness</span></span></span></a> (<a id="n:6" class="idref" href="#n:6"><span class="id" title="binder">n</span></a>:<a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a id="stop" class="idref" href="#stop"><span class="id" title="constructor">stop</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:6"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness:7"><span class="id" title="inductive">before_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:6"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;| <a id="next" class="idref" href="#next"><span class="id" title="constructor">next</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness:7"><span class="id" title="inductive">before_witness</span></a> (<a class="idref" href="Stdlib.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:6"><span class="id" title="variable">n</span></a>) <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness:7"><span class="id" title="inductive">before_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:6"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="O_witness" class="idref" href="#O_witness"><span class="id" title="definition">O_witness</span></a> (<a id="n:9" class="idref" href="#n:9"><span class="id" title="binder">n</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:9"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> 0 :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:9"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">return</span> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:11"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> 0) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="keyword">fun</span> <a id="b:12" class="idref" href="#b:12"><span class="id" title="binder">b</span></a> =&gt; <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#b:12"><span class="id" title="variable">b</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Stdlib.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span> =&gt; <span class="id" title="keyword">fun</span> <a id="b:13" class="idref" href="#b:13"><span class="id" title="binder">b</span></a> =&gt; <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#O_witness:10"><span class="id" title="definition">O_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:9"><span class="id" title="variable">n</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#next"><span class="id" title="constructor">next</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:9"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#b:13"><span class="id" title="variable">b</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="inv_before_witness" class="idref" href="#inv_before_witness"><span class="id" title="definition">inv_before_witness</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="n:14" class="idref" href="#n:14"><span class="id" title="binder">n</span></a>, <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:14"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~(</span></a><a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:14"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> (<a class="idref" href="Stdlib.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:14"><span class="id" title="variable">n</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="n:15" class="idref" href="#n:15"><span class="id" title="binder">n</span></a> <a id="b:16" class="idref" href="#b:16"><span class="id" title="binder">b</span></a> <a id="not_p:17" class="idref" href="#not_p:17"><span class="id" title="binder">not_p</span></a> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#b:16"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#stop"><span class="id" title="constructor">stop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">p</span> =&gt; <span class="id" title="keyword">match</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#not_p:17"><span class="id" title="variable">not_p</span></a> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#next"><span class="id" title="constructor">next</span></a> <span class="id" title="var">_</span> <span class="id" title="var">b</span> =&gt; <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#b:16"><span class="id" title="variable">b</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Basic program 
</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <a id="prog_linear_search" class="idref" href="#prog_linear_search"><span class="id" title="definition">prog_linear_search</span></a> <a id="start:19" class="idref" href="#start:19"><span class="id" title="binder">start</span></a> (<a id="b:20" class="idref" href="#b:20"><span class="id" title="binder">b</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:19"><span class="id" title="variable">start</span></a>) : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P_dec"><span class="id" title="variable">P_dec</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:19"><span class="id" title="variable">start</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Stdlib.Init.Specif.html#left"><span class="id" title="constructor">left</span></a> <span class="id" title="var">yes</span> =&gt; <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:19"><span class="id" title="variable">start</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Stdlib.Init.Specif.html#right"><span class="id" title="constructor">right</span></a> <span class="id" title="keyword">no</span> =&gt; <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#prog_linear_search:21"><span class="id" title="definition">prog_linear_search</span></a> (<a class="idref" href="Stdlib.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:19"><span class="id" title="variable">start</span></a>) (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#inv_before_witness"><span class="id" title="definition">inv_before_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:19"><span class="id" title="variable">start</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#b:20"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">no</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
rel_ls = relational version of linear search 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <a id="rel_ls" class="idref" href="#rel_ls"><span class="id" title="definition, inductive"><span id="rel_ls_ind" class="id"><span id="rel_ls_sind" class="id">rel_ls</span></span></span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
| <a id="Rstop" class="idref" href="#Rstop"><span class="id" title="constructor">Rstop</span></a> : <span class="id" title="keyword">forall</span> {<a id="found:24" class="idref" href="#found:24"><span class="id" title="binder">found</span></a>}, <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#found:24"><span class="id" title="variable">found</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls:22"><span class="id" title="inductive">rel_ls</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#found:24"><span class="id" title="variable">found</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#found:24"><span class="id" title="variable">found</span></a><br/>
| <a id="Rnext" class="idref" href="#Rnext"><span class="id" title="constructor">Rnext</span></a> : <span class="id" title="keyword">forall</span> {<a id="start:25" class="idref" href="#start:25"><span class="id" title="binder">start</span></a> <a id="found:26" class="idref" href="#found:26"><span class="id" title="binder">found</span></a>}, <a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~(</span></a><a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:25"><span class="id" title="variable">start</span></a><a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls:22"><span class="id" title="inductive">rel_ls</span></a> (<a class="idref" href="Stdlib.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:25"><span class="id" title="variable">start</span></a>) <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#found:26"><span class="id" title="variable">found</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls:22"><span class="id" title="inductive">rel_ls</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:25"><span class="id" title="variable">start</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#found:26"><span class="id" title="variable">found</span></a>.<br/>

<br/>
</div>

<div class="doc">
Following the Braga method, the output is packed with a proof of its conformity wrt rel_ls 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="linear_search_conform" class="idref" href="#linear_search_conform"><span class="id" title="definition">linear_search_conform</span></a> <a id="start:27" class="idref" href="#start:27"><span class="id" title="binder">start</span></a> (<a id="b:28" class="idref" href="#b:28"><span class="id" title="binder">b</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:27"><span class="id" title="variable">start</span></a>) : <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a><a id="n:29" class="idref" href="#n:29"><span class="id" title="binder">n</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls"><span class="id" title="inductive">rel_ls</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:27"><span class="id" title="variable">start</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:29"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
A variant where the computational contents is closer to <span class="inlinecode"><span class="id" title="var">prog_linear_search</span></span>
    (no deconstruction/reconstruction of the result), using a suitable
    abstraction of the postcondition.
    The predicate <span class="inlinecode"><span class="id" title="var">rel_ls</span></span> <span class="inlinecode"><span class="id" title="var">start</span></span> is abstracted into <span class="inlinecode"><span class="id" title="var">Q</span></span>, with an additional
    implication <span class="inlinecode"><span class="id" title="var">rq</span></span> they are equivalent (but only one direction is needed);
    and as linear search is tail recursive, <span class="inlinecode"><span class="id" title="var">Q</span></span> can be fixed (but <span class="inlinecode"><span class="id" title="var">rq</span></span> varies,
    behaving like a logical continuation). 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="linear_search_conform_alt" class="idref" href="#linear_search_conform_alt"><span class="id" title="definition">linear_search_conform_alt</span></a> <a id="start:40" class="idref" href="#start:40"><span class="id" title="binder">start</span></a> (<a id="b:41" class="idref" href="#b:41"><span class="id" title="binder">b</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:40"><span class="id" title="variable">start</span></a>) : <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a><a id="n:42" class="idref" href="#n:42"><span class="id" title="binder">n</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls"><span class="id" title="inductive">rel_ls</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:40"><span class="id" title="variable">start</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:42"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Start at 0 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="linear_search_from_0_conform" class="idref" href="#linear_search_from_0_conform"><span class="id" title="definition">linear_search_from_0_conform</span></a> (<a id="e:62" class="idref" href="#e:62"><span class="id" title="binder">e</span></a> : <a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:61" class="idref" href="#n:61"><span class="id" title="binder">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:61"><span class="id" title="variable">n</span></a>) : <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a><a id="n:63" class="idref" href="#n:63"><span class="id" title="binder">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a><a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls"><span class="id" title="inductive">rel_ls</span></a> 0 <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:63"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="b:66" class="idref" href="#b:66"><span class="id" title="binder">b</span></a> := <span class="id" title="keyword">let</span> (<a id="n:64" class="idref" href="#n:64"><span class="id" title="binder">n</span></a>, <a id="p:65" class="idref" href="#p:65"><span class="id" title="binder">p</span></a>) := <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#e:62"><span class="id" title="variable">e</span></a> <span class="id" title="tactic">in</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#O_witness"><span class="id" title="definition">O_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:64"><span class="id" title="variable">n</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#stop"><span class="id" title="constructor">stop</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:64"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#p:65"><span class="id" title="variable">p</span></a>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#linear_search_conform"><span class="id" title="definition">linear_search_conform</span></a> 0 <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#b:66"><span class="id" title="variable">b</span></a>.<br/>

<br/>
</div>

<div class="doc">
Partial correctness properties 
<div class="paragraph"> </div>

 rel_ls entails P on the output 
</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a id="rel_ls_post" class="idref" href="#rel_ls_post"><span class="id" title="lemma">rel_ls_post</span></a> : <span class="id" title="keyword">forall</span> {<a id="start:67" class="idref" href="#start:67"><span class="id" title="binder">start</span></a> <a id="found:68" class="idref" href="#found:68"><span class="id" title="binder">found</span></a>}, <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls"><span class="id" title="inductive">rel_ls</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:67"><span class="id" title="variable">start</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#found:68"><span class="id" title="variable">found</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#found:68"><span class="id" title="variable">found</span></a>.<br/>

<br/>
</div>

<div class="doc">
rel_ls entails minimality of the output 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="rel_ls_lower_bound" class="idref" href="#rel_ls_lower_bound"><span class="id" title="lemma">rel_ls_lower_bound</span></a> {<a id="found:69" class="idref" href="#found:69"><span class="id" title="binder">found</span></a> <a id="start:70" class="idref" href="#start:70"><span class="id" title="binder">start</span></a>} :<br/>
&nbsp;&nbsp;<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls"><span class="id" title="inductive">rel_ls</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:70"><span class="id" title="variable">start</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#found:69"><span class="id" title="variable">found</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">forall</span> {<a id="k:71" class="idref" href="#k:71"><span class="id" title="binder">k</span></a>}, <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#k:71"><span class="id" title="variable">k</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:70"><span class="id" title="variable">start</span></a> <a class="idref" href="Stdlib.Init.Peano.html#cb53cf0ee22c036a03b4a9281c68b5a3"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#k:71"><span class="id" title="variable">k</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#found:69"><span class="id" title="variable">found</span></a> <a class="idref" href="Stdlib.Init.Peano.html#cb53cf0ee22c036a03b4a9281c68b5a3"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#k:71"><span class="id" title="variable">k</span></a>.<br/>

<br/>
</div>

<div class="doc">
For compatibility with previous version 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="linear_search" class="idref" href="#linear_search"><span class="id" title="definition">linear_search</span></a> <a id="start:72" class="idref" href="#start:72"><span class="id" title="binder">start</span></a> (<a id="b:73" class="idref" href="#b:73"><span class="id" title="binder">b</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:72"><span class="id" title="variable">start</span></a>) : <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a><a id="n:74" class="idref" href="#n:74"><span class="id" title="binder">n</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:74"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> (<a id="n:75" class="idref" href="#n:75"><span class="id" title="binder">n</span></a>, <a id="p:76" class="idref" href="#p:76"><span class="id" title="binder">p</span></a>) := <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#linear_search_conform"><span class="id" title="definition">linear_search_conform</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:72"><span class="id" title="variable">start</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#b:73"><span class="id" title="variable">b</span></a> <span class="id" title="tactic">in</span> <a class="idref" href="Stdlib.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <span class="id" title="var">_</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:75"><span class="id" title="variable">n</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls_post"><span class="id" title="lemma">rel_ls_post</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#p:76"><span class="id" title="variable">p</span></a>).<br/>

<br/>
</div>

<div class="doc">
Main definitions 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="constructive_indefinite_ground_description_nat" class="idref" href="#constructive_indefinite_ground_description_nat"><span class="id" title="definition">constructive_indefinite_ground_description_nat</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:77" class="idref" href="#n:77"><span class="id" title="binder">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:77"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a><a id="n:78" class="idref" href="#n:78"><span class="id" title="binder">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a><a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:78"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="epsilon_smallest" class="idref" href="#epsilon_smallest"><span class="id" title="definition">epsilon_smallest</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:79" class="idref" href="#n:79"><span class="id" title="binder">n</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:79"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a> <a id="n:80" class="idref" href="#n:80"><span class="id" title="binder">n</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:80"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <span class="id" title="keyword">forall</span> <a id="k:81" class="idref" href="#k:81"><span class="id" title="binder">k</span></a>, <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#k:81"><span class="id" title="variable">k</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:80"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Init.Peano.html#cb53cf0ee22c036a03b4a9281c68b5a3"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#k:81"><span class="id" title="variable">k</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
</div>

<div class="doc">
NB. The previous version used a negative formulation:
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">k</span>,</span> <span class="inlinecode"><span class="id" title="var">k</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">~<span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>
    Lemmas <span class="inlinecode"><span class="id" title="var">le_not_lt</span></span> and <span class="inlinecode"><span class="id" title="var">lt_not_le</span></span> can help if needed. 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

 In simple situations like here, a direct proof that <span class="inlinecode"><span class="id" title="var">prog_linear_search</span></span>
    satisfies <span class="inlinecode"><span class="id" title="var">rel_ls</span></span> can be provided.
    On the computational side of the proof, the fixpoint (coming from
    <span class="inlinecode"><span class="id" title="var">before_witness_dep_ind</span></span>) has to come first, before the pattern matching
    on <span class="inlinecode"><span class="id" title="var">P_dec</span></span>, so we get a slight mismatch between the program
    <span class="inlinecode"><span class="id" title="var">prog_linear_search</span></span> and the proof; in particular, there is a duplication
    for <span class="inlinecode"><span class="id" title="var">Rstop</span></span>.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Scheme</span> <a id="before_witness_dep_ind" class="idref" href="#before_witness_dep_ind"><span class="id" title="definition">before_witness_dep_ind</span></a> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#before_witness"><span class="id" title="inductive">before_witness</span></a> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="linear_search_rel" class="idref" href="#linear_search_rel"><span class="id" title="lemma">linear_search_rel</span></a> : <span class="id" title="keyword">forall</span> <a id="start:82" class="idref" href="#start:82"><span class="id" title="binder">start</span></a> <a id="b:83" class="idref" href="#b:83"><span class="id" title="binder">b</span></a>, <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls"><span class="id" title="inductive">rel_ls</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:82"><span class="id" title="variable">start</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#prog_linear_search"><span class="id" title="definition">prog_linear_search</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#start:82"><span class="id" title="variable">start</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#b:83"><span class="id" title="variable">b</span></a>).<br/>

<br/>
</div>

<div class="doc">
Start at 0 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="linear_search_from_0" class="idref" href="#linear_search_from_0"><span class="id" title="definition">linear_search_from_0</span></a> (<a id="e:85" class="idref" href="#e:85"><span class="id" title="binder">e</span></a> : <a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:84" class="idref" href="#n:84"><span class="id" title="binder">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:84"><span class="id" title="variable">n</span></a>) : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="b:88" class="idref" href="#b:88"><span class="id" title="binder">b</span></a> := <span class="id" title="keyword">let</span> (<a id="n:86" class="idref" href="#n:86"><span class="id" title="binder">n</span></a>, <a id="p:87" class="idref" href="#p:87"><span class="id" title="binder">p</span></a>) := <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#e:85"><span class="id" title="variable">e</span></a> <span class="id" title="tactic">in</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#O_witness"><span class="id" title="definition">O_witness</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:86"><span class="id" title="variable">n</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#stop"><span class="id" title="constructor">stop</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:86"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#p:87"><span class="id" title="variable">p</span></a>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#prog_linear_search"><span class="id" title="definition">prog_linear_search</span></a> 0 <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#b:88"><span class="id" title="variable">b</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="linear_search_from_0_rel" class="idref" href="#linear_search_from_0_rel"><span class="id" title="lemma">linear_search_from_0_rel</span></a> (<a id="e:90" class="idref" href="#e:90"><span class="id" title="binder">e</span></a> : <a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:89" class="idref" href="#n:89"><span class="id" title="binder">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:89"><span class="id" title="variable">n</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#rel_ls"><span class="id" title="inductive">rel_ls</span></a> 0 (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#linear_search_from_0"><span class="id" title="definition">linear_search_from_0</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#e:90"><span class="id" title="variable">e</span></a>).<br/>
 
<br/>
</div>

<div class="doc">
Main definitions 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="constructive_indefinite_ground_description_nat_direct" class="idref" href="#constructive_indefinite_ground_description_nat_direct"><span class="id" title="definition">constructive_indefinite_ground_description_nat_direct</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:91" class="idref" href="#n:91"><span class="id" title="binder">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:91"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a><a id="n:92" class="idref" href="#n:92"><span class="id" title="binder">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a><a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:92"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="epsilon_smallest_direct" class="idref" href="#epsilon_smallest_direct"><span class="id" title="definition">epsilon_smallest_direct</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:93" class="idref" href="#n:93"><span class="id" title="binder">n</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:93"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a> <a id="n:94" class="idref" href="#n:94"><span class="id" title="binder">n</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:94"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <span class="id" title="keyword">forall</span> <a id="k:95" class="idref" href="#k:95"><span class="id" title="binder">k</span></a>, <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#k:95"><span class="id" title="variable">k</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:94"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Init.Peano.html#cb53cf0ee22c036a03b4a9281c68b5a3"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#k:95"><span class="id" title="variable">k</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Direct"><span class="id" title="section">ConstructiveIndefiniteGroundDescription_Direct</span></a>.<br/>

<br/>

<br/>

<br/>
<span class="id" title="keyword">Section</span> <a id="ConstructiveIndefiniteGroundDescription_Acc" class="idref" href="#ConstructiveIndefiniteGroundDescription_Acc"><span class="id" title="section">ConstructiveIndefiniteGroundDescription_Acc</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <a id="ConstructiveIndefiniteGroundDescription_Acc.P" class="idref" href="#ConstructiveIndefiniteGroundDescription_Acc.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Hypothesis</span> <a id="ConstructiveIndefiniteGroundDescription_Acc.P_decidable" class="idref" href="#ConstructiveIndefiniteGroundDescription_Acc.P_decidable"><span class="id" title="variable">P_decidable</span></a> : <span class="id" title="keyword">forall</span> <a id="n:98" class="idref" href="#n:98"><span class="id" title="binder">n</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">{</span></a><a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:98"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">}</span></a> <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">+</span></a> <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">{</span></a><a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:98"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">}</span></a>.<br/>

<br/>
</div>

<div class="doc">
The predicate <span class="inlinecode"><span class="id" title="var">Acc</span></span> delineates elements that are accessible via a
given relation <span class="inlinecode"><span class="id" title="var">R</span></span>. An element is accessible if there are no infinite
<span class="inlinecode"><span class="id" title="var">R</span></span>-descending chains starting from it.

<div class="paragraph"> </div>

To use <span class="inlinecode"><span class="id" title="var">Fix_F</span></span>, we define a relation R and prove that if <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
then 0 is accessible with respect to R. Then, by induction on the
definition of <span class="inlinecode"><span class="id" title="var">Acc</span></span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">0</span>, we show <span class="inlinecode">{<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>.

<div class="paragraph"> </div>

The relation <span class="inlinecode"><span class="id" title="var">R</span></span> describes the connection between the two successive
numbers we try. Namely, <span class="inlinecode"><span class="id" title="var">y</span></span> is <span class="inlinecode"><span class="id" title="var">R</span></span>-less then <span class="inlinecode"><span class="id" title="var">x</span></span> if we try <span class="inlinecode"><span class="id" title="var">y</span></span> after
<span class="inlinecode"><span class="id" title="var">x</span></span>, i.e., <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> and <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> is false. Then the absence of an
infinite <span class="inlinecode"><span class="id" title="var">R</span></span>-descending chain from 0 is equivalent to the termination
of our searching algorithm. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Let</span> <a id="ConstructiveIndefiniteGroundDescription_Acc.R" class="idref" href="#ConstructiveIndefiniteGroundDescription_Acc.R"><span class="id" title="variable">R</span></a> (<a id="x:101" class="idref" href="#x:101"><span class="id" title="binder">x</span></a> <a id="y:102" class="idref" href="#y:102"><span class="id" title="binder">y</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <span class="id" title="keyword">Prop</span> := <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:101"><span class="id" title="variable">x</span></a> <a class="idref" href="Stdlib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Stdlib.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#y:102"><span class="id" title="variable">y</span></a> <a class="idref" href="Stdlib.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#y:102"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">Local Notation</span> <a id="acc" class="idref" href="#acc"><span class="id" title="abbreviation">acc</span></a> <span class="id" title="var">x</span> := (<a class="idref" href="Stdlib.Init.Wf.html#Acc"><span class="id" title="inductive">Acc</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc.R"><span class="id" title="variable">R</span></a> <span class="id" title="var">x</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="P_implies_acc" class="idref" href="#P_implies_acc"><span class="id" title="lemma">P_implies_acc</span></a> : <span class="id" title="keyword">forall</span> <a id="x:103" class="idref" href="#x:103"><span class="id" title="binder">x</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:103"><span class="id" title="variable">x</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#acc"><span class="id" title="abbreviation">acc</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:103"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="P_eventually_implies_acc" class="idref" href="#P_eventually_implies_acc"><span class="id" title="lemma">P_eventually_implies_acc</span></a> : <span class="id" title="keyword">forall</span> (<a id="x:104" class="idref" href="#x:104"><span class="id" title="binder">x</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<a id="n:105" class="idref" href="#n:105"><span class="id" title="binder">n</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>), <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:105"><span class="id" title="variable">n</span></a> <a class="idref" href="Stdlib.Init.Peano.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:104"><span class="id" title="variable">x</span></a>) <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#acc"><span class="id" title="abbreviation">acc</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:104"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Corollary</span> <a id="P_eventually_implies_acc_ex" class="idref" href="#P_eventually_implies_acc_ex"><span class="id" title="lemma">P_eventually_implies_acc_ex</span></a> : <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:106" class="idref" href="#n:106"><span class="id" title="binder">n</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:106"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#acc"><span class="id" title="abbreviation">acc</span></a> 0.<br/>

<br/>
</div>

<div class="doc">
In the following statement, we use the trick with recursion on
<span class="inlinecode"><span class="id" title="var">Acc</span></span>. This is also where decidability of <span class="inlinecode"><span class="id" title="var">P</span></span> is used. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="acc_implies_P_eventually" class="idref" href="#acc_implies_P_eventually"><span class="id" title="lemma">acc_implies_P_eventually</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#acc"><span class="id" title="abbreviation">acc</span></a> 0 <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a><a id="n:107" class="idref" href="#n:107"><span class="id" title="binder">n</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:107"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="constructive_indefinite_ground_description_nat_Acc" class="idref" href="#constructive_indefinite_ground_description_nat_Acc"><span class="id" title="lemma">constructive_indefinite_ground_description_nat_Acc</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:108" class="idref" href="#n:108"><span class="id" title="binder">n</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:108"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a><a id="n:109" class="idref" href="#n:109"><span class="id" title="binder">n</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:109"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveIndefiniteGroundDescription_Acc"><span class="id" title="section">ConstructiveIndefiniteGroundDescription_Acc</span></a>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Section</span> <a id="ConstructiveGroundEpsilon_nat" class="idref" href="#ConstructiveGroundEpsilon_nat"><span class="id" title="section">ConstructiveGroundEpsilon_nat</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <a id="ConstructiveGroundEpsilon_nat.P" class="idref" href="#ConstructiveGroundEpsilon_nat.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Hypothesis</span> <a id="ConstructiveGroundEpsilon_nat.P_decidable" class="idref" href="#ConstructiveGroundEpsilon_nat.P_decidable"><span class="id" title="variable">P_decidable</span></a> : <span class="id" title="keyword">forall</span> <a id="x:112" class="idref" href="#x:112"><span class="id" title="binder">x</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">{</span></a><a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon_nat.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:112"><span class="id" title="variable">x</span></a><a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">}</span></a> <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">+</span></a> <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">{</span></a><a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon_nat.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:112"><span class="id" title="variable">x</span></a><a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">}</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="constructive_ground_epsilon_nat" class="idref" href="#constructive_ground_epsilon_nat"><span class="id" title="definition">constructive_ground_epsilon_nat</span></a> (<a id="E:116" class="idref" href="#E:116"><span class="id" title="binder">E</span></a> : <a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:115" class="idref" href="#n:115"><span class="id" title="binder">n</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon_nat.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:115"><span class="id" title="variable">n</span></a>) : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="Stdlib.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#constructive_indefinite_ground_description_nat"><span class="id" title="definition">constructive_indefinite_ground_description_nat</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon_nat.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon_nat.P_decidable"><span class="id" title="variable">P_decidable</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#E:116"><span class="id" title="variable">E</span></a>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="constructive_ground_epsilon_spec_nat" class="idref" href="#constructive_ground_epsilon_spec_nat"><span class="id" title="definition">constructive_ground_epsilon_spec_nat</span></a> (<a id="E:118" class="idref" href="#E:118"><span class="id" title="binder">E</span></a> : (<a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="n:117" class="idref" href="#n:117"><span class="id" title="binder">n</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon_nat.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:117"><span class="id" title="variable">n</span></a>)) : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon_nat.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#constructive_ground_epsilon_nat"><span class="id" title="definition">constructive_ground_epsilon_nat</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#E:118"><span class="id" title="variable">E</span></a>)<br/>
&nbsp;&nbsp;:= <a class="idref" href="Stdlib.Init.Specif.html#proj2_sig"><span class="id" title="definition">proj2_sig</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#constructive_indefinite_ground_description_nat"><span class="id" title="definition">constructive_indefinite_ground_description_nat</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon_nat.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon_nat.P_decidable"><span class="id" title="variable">P_decidable</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#E:118"><span class="id" title="variable">E</span></a>).<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon_nat"><span class="id" title="section">ConstructiveGroundEpsilon_nat</span></a>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Section</span> <a id="ConstructiveGroundEpsilon" class="idref" href="#ConstructiveGroundEpsilon"><span class="id" title="section">ConstructiveGroundEpsilon</span></a>.<br/>

<br/>
</div>

<div class="doc">
For the current purpose, we say that a set <span class="inlinecode"><span class="id" title="var">A</span></span> is countable if
there are functions <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> and <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> such that <span class="inlinecode"><span class="id" title="var">g</span></span> is
a left inverse of <span class="inlinecode"><span class="id" title="var">f</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Variable</span> <a id="ConstructiveGroundEpsilon.A" class="idref" href="#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Variable</span> <a id="ConstructiveGroundEpsilon.f" class="idref" href="#ConstructiveGroundEpsilon.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>
<span class="id" title="keyword">Variable</span> <a id="ConstructiveGroundEpsilon.g" class="idref" href="#ConstructiveGroundEpsilon.g"><span class="id" title="variable">g</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a>.<br/>

<br/>
<span class="id" title="keyword">Hypothesis</span> <a id="ConstructiveGroundEpsilon.gof_eq_id" class="idref" href="#ConstructiveGroundEpsilon.gof_eq_id"><span class="id" title="variable">gof_eq_id</span></a> : <span class="id" title="keyword">forall</span> <a id="x:125" class="idref" href="#x:125"><span class="id" title="binder">x</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a>, <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.g"><span class="id" title="variable">g</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:125"><span class="id" title="variable">x</span></a>) <a class="idref" href="Stdlib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:125"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variable</span> <a id="ConstructiveGroundEpsilon.P" class="idref" href="#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Hypothesis</span> <a id="ConstructiveGroundEpsilon.P_decidable" class="idref" href="#ConstructiveGroundEpsilon.P_decidable"><span class="id" title="variable">P_decidable</span></a> : <span class="id" title="keyword">forall</span> <a id="x:130" class="idref" href="#x:130"><span class="id" title="binder">x</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a>, <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">{</span></a><a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:130"><span class="id" title="variable">x</span></a><a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">}</span></a> <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">+</span></a> <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">{</span></a><a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:130"><span class="id" title="variable">x</span></a><a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">}</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="P'" class="idref" href="#P'"><span class="id" title="definition">P'</span></a> (<a id="x:133" class="idref" href="#x:133"><span class="id" title="binder">x</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <span class="id" title="keyword">Prop</span> := <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:133"><span class="id" title="variable">x</span></a>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="P'_decidable" class="idref" href="#P'_decidable"><span class="id" title="lemma">P'_decidable</span></a> : <span class="id" title="keyword">forall</span> <a id="n:134" class="idref" href="#n:134"><span class="id" title="binder">n</span></a> : <a class="idref" href="Stdlib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">{</span></a><a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#P'"><span class="id" title="definition">P'</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:134"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">}</span></a> <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">+</span></a> <a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">{</span></a><a class="idref" href="Stdlib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#P'"><span class="id" title="definition">P'</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#n:134"><span class="id" title="variable">n</span></a><a class="idref" href="Stdlib.Init.Specif.html#87727981cdc1579fef00b9d9c1d3b9da"><span class="id" title="notation">}</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="constructive_indefinite_ground_description" class="idref" href="#constructive_indefinite_ground_description"><span class="id" title="lemma">constructive_indefinite_ground_description</span></a> : <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="x:135" class="idref" href="#x:135"><span class="id" title="binder">x</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:135"><span class="id" title="variable">x</span></a><a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a><a id="x:136" class="idref" href="#x:136"><span class="id" title="binder">x</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:136"><span class="id" title="variable">x</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="constructive_definite_ground_description" class="idref" href="#constructive_definite_ground_description"><span class="id" title="lemma">constructive_definite_ground_description</span></a> : <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Stdlib.Init.Logic.html#a3726bd940c3c0e96cb8e13291e9ded4"><span class="id" title="notation">exists</span></a><a class="idref" href="Stdlib.Init.Logic.html#a3726bd940c3c0e96cb8e13291e9ded4"><span class="id" title="notation">!</span></a> <a id="x:139" class="idref" href="#x:139"><span class="id" title="binder">x</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a><a class="idref" href="Stdlib.Init.Logic.html#a3726bd940c3c0e96cb8e13291e9ded4"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:139"><span class="id" title="variable">x</span></a><a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Stdlib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a><a id="x:140" class="idref" href="#x:140"><span class="id" title="binder">x</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:140"><span class="id" title="variable">x</span></a><a class="idref" href="Stdlib.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="constructive_ground_epsilon" class="idref" href="#constructive_ground_epsilon"><span class="id" title="definition">constructive_ground_epsilon</span></a> (<a id="E:142" class="idref" href="#E:142"><span class="id" title="binder">E</span></a> : <a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="x:141" class="idref" href="#x:141"><span class="id" title="binder">x</span></a> : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:141"><span class="id" title="variable">x</span></a>) : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;:= <a class="idref" href="Stdlib.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#constructive_indefinite_ground_description"><span class="id" title="lemma">constructive_indefinite_ground_description</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#E:142"><span class="id" title="variable">E</span></a>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="constructive_ground_epsilon_spec" class="idref" href="#constructive_ground_epsilon_spec"><span class="id" title="definition">constructive_ground_epsilon_spec</span></a> (<a id="E:144" class="idref" href="#E:144"><span class="id" title="binder">E</span></a> : (<a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a id="x:143" class="idref" href="#x:143"><span class="id" title="binder">x</span></a><a class="idref" href="Stdlib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#x:143"><span class="id" title="variable">x</span></a>)) : <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#constructive_ground_epsilon"><span class="id" title="definition">constructive_ground_epsilon</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#E:144"><span class="id" title="variable">E</span></a>)<br/>
&nbsp;&nbsp;:= <a class="idref" href="Stdlib.Init.Specif.html#proj2_sig"><span class="id" title="definition">proj2_sig</span></a> (<a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#constructive_indefinite_ground_description"><span class="id" title="lemma">constructive_indefinite_ground_description</span></a> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#E:144"><span class="id" title="variable">E</span></a>).<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Stdlib.Logic.ConstructiveEpsilon.html#ConstructiveGroundEpsilon"><span class="id" title="section">ConstructiveGroundEpsilon</span></a>.<br/>

<br/>
</div>
    <div id="sidebarWrapper">
      <div id="sidebar">
        <div class="block">
          <h2 class="title">Navigation</h2>
          <div class="content">
            <ul class="menu">
              <li class="leaf">Standard Library
                <ul class="menu">
                  <li><a href="index.html">Table of contents</a></li>
                  <li><a href="genindex.html">Index</a></li>
                </ul>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>

  </div>

  <div id="footer">
    <div id="nav-footer">
      <ul class="links-menu-footer">
        <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
        <li><a href="http://validator.w3.org/">xhtml valid</a></li>
        <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
      </ul>
    </div>
  </div>

</div>

</body>
</html>
