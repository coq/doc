<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/sites/all/themes/coq/style.css" />
<link type="text/css" rel="stylesheet" media="all" href="//coq.inria.fr/sites/all/themes/coq/coqdoc.css" />

<title>Standard Library | The Coq Proof Assistant</title>

</head>

<body>

<div id="container">
  <div id="headertop">
    <div id="nav">
      <ul class="links-menu">
        <li><a href="//coq.inria.fr/" class="active">Home</a></li>
        <li><a href="//coq.inria.fr/about-coq" title="More about coq">About Coq</a></li>
        <li><a href="//coq.inria.fr/download">Get Coq</a></li>
        <li><a href="//coq.inria.fr/documentation">Documentation</a></li>
        <li><a href="//coq.inria.fr/community">Community</a></li>
      </ul>
    </div>
  </div>

  <div id="header">
    <div id="logoWrapper">
      <div id="logo"><a href="//coq.inria.fr/" title="Home"><img src="//coq.inria.fr/files/barron_logo.png" alt="Home" /></a>
      </div>
      <div id="siteName"><a href="//coq.inria.fr/" title="Home">The Coq Proof Assistant</a>
      </div>
    </div>
  </div>

  <div id="content">

<h1 class="libtitle">Library Coq.ssr.ssreflect</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<style> .doc { font-family: monospace; white-space: pre; } </style> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Coq.Bool.Bool.html#"><span class="id" title="library">Bool</span></a>. <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Coq.ssrmatching.ssrmatching.html#"><span class="id" title="library">ssrmatching</span></a>.<br/>

<br/>
</div>

<div class="doc">
 This file is the Gallina part of the ssreflect plugin implementation.
 Files that use the ssreflect plugin should always Require ssreflect and
 either Import ssreflect or Import ssreflect.SsrSyntax.
   Part of the contents of this file is technical and will only interest
 advanced developers; in addition the following are defined:
   [the str of v by f] == the Canonical s : str such that f s = v.
        [the str of v] == the Canonical s : str that coerces to v.
        argumentType c == the T such that c : forall x : T, P x.
          returnType c == the R such that c : T -&gt; R.
     {type of c for s} == P s where c : forall x : T, P x.
           nonPropType == an interface for non-Prop Types: a nonPropType coerces
                          to a Type, and only types that do <i>not</i> have sort
                          Prop are canonical nonPropType instances. This is
                          useful for applied views (see mid-file comment).
             notProp T == the nonPropType instance for type T.
           phantom T v == singleton type with inhabitant Phantom T v.
               phant T == singleton type with inhabitant Phant v.
                 =^~ r == the converse of rewriting rule r (e.g., in a
                          rewrite multirule).
             unkeyed t == t, but treated as an unkeyed matching pattern by
                          the ssreflect matching algorithm.
             nosimpl t == t, but on the right-hand side of Definition C :=
                          nosimpl disables expansion of C by /=.
              locked t == t, but locked t is not convertible to t.
       locked_with k t == t, but not convertible to t or locked_with k' t
                          unless k = k' (with k : unit). Coq type-checking
                          will be much more efficient if locked_with with a
                          bespoke k is used for sealed definitions.
          unlockable v == interface for sealed constant definitions of v.
        Unlockable def == the unlockable that registers def : C = v.
     [unlockable of C] == a clone for C of the canonical unlockable for the
                          definition of C (e.g., if it uses locked_with).
    [unlockable fun C] == [unlockable of C] with the expansion forced to be
                          an explicit lambda expression.
<ul class="doclist">
<li>&gt; The usage pattern for ADT operations is:
       Definition foo_def x1 .. xn := big_foo_expression.
       Fact foo_key : unit. Proof. by [ ]. Qed.
       Definition foo := locked_with foo_key foo_def.
       Canonical foo_unlockable := [unlockable fun foo].
     This minimizes the comparison overhead for foo, while still allowing
     rewrite unlock to expose big_foo_expression.

</li>
</ul>

<div class="paragraph"> </div>

  Additionally we provide default intro pattern ltac views:
<ul class="doclist">
<li> top of the stack actions:
    =&gt; /<span class="inlinecode"><span class="id" title="tactic">apply</span></span>     := =&gt; hyp {}/hyp
    =&gt; /<span class="inlinecode"><span class="id" title="var">swap</span></span>      := =&gt; x y; move: y x
                      (also swap and preserves let bindings)
    =&gt; /<span class="inlinecode"><span class="id" title="var">dup</span></span>       := =&gt; x; have copy := x; move: copy x
                      (also copies and preserves let bindings)

</li>
</ul>

<div class="paragraph"> </div>

 More information about these definitions and their use can be found in the
 ssreflect manual, and in specific comments below.                           
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a id="SsrSyntax" class="idref" href="#SsrSyntax"><span class="id" title="module">SsrSyntax</span></a>.<br/>

<br/>
</div>

<div class="doc">
 Declare Ssr keywords: 'is' 'of' '//' '/=' and '//='. We also declare the
 parsing level 8, as a workaround for a notation grammar factoring problem.
 Arguments of application-style notations (at level 10) should be declared
 at level 8 rather than 9 or the camlp5 grammar will not factor properly.    
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;(* x 'is' y 'of' z 'isn't' // /= //= *)" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;(* 69 *)" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 69).<br/>

<br/>
</div>

<div class="doc">
 Non ambiguous keyword to check if the SsrSyntax module is imported  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;(* Use to test if 'SsrSyntax_is_Imported' *)" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8).<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;&lt;hidden n &gt;" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">n</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "&lt;hidden  n &gt;").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;T (* n *)" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200, <span class="id" title="var">format</span> "T  (* n *)").<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Coq.ssr.ssreflect.html#SsrSyntax"><span class="id" title="module">SsrSyntax</span></a>.<br/>

<br/>
<span class="id" title="keyword">Export</span> <span class="id" title="var">SsrMatchingSyntax</span>.<br/>
<span class="id" title="keyword">Export</span> <span class="id" title="var">SsrSyntax</span>.<br/>

<br/>
</div>

<div class="doc">
Save primitive notation that will be overloaded. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
Reserve notation that introduced in this file. 
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;'if' c 'then' vT 'else' vF" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200,<br/>
&nbsp;&nbsp;<span class="id" title="var">c</span>, <span class="id" title="var">vT</span>, <span class="id" title="var">vF</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;'if' c 'return' R 'then' vT 'else' vF" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200,<br/>
&nbsp;&nbsp;<span class="id" title="var">c</span>, <span class="id" title="var">R</span>, <span class="id" title="var">vT</span>, <span class="id" title="var">vF</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;'if' c 'as' x 'return' R 'then' vT 'else' vF" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200,<br/>
&nbsp;&nbsp;<span class="id" title="var">c</span>, <span class="id" title="var">R</span>, <span class="id" title="var">vT</span>, <span class="id" title="var">vF</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200, <span class="id" title="var">x</span> <span class="id" title="var">name</span>).<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x : T" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 100, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' x '/ '  :  T ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;T : 'Type'" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 100, <span class="id" title="var">format</span> "T  :  'Type'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;P : 'Prop'" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 100, <span class="id" title="var">format</span> "P  :  'Prop'").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'the' sT 'of' v 'by' f ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'the'  sT  'of'  v  'by'  f ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'the' sT 'of' v ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'the'  sT  'of'  v ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;{ 'type' 'of' c 'for' s }" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'type'  'of'  c  'for'  s }").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;=^~ r" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 100, <span class="id" title="var">format</span> "=^~  r").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'unlockable' 'of' C ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'unlockable'  'of'  C ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'unlockable' 'fun' C ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'unlockable'  'fun'  C ]").<br/>

<br/>
</div>

<div class="doc">
 To define notations for tactic in intro patterns.
 When "=&gt; /t" is parsed, "t:
</div>
<div class="code">
<span class="id" title="keyword">Delimit</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">ssripat_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">ssripat</span>.<br/>

<br/>
</div>

<div class="doc">
 Make the general "if" into a notation, so that we can override it below.
 The notations are "only parsing" because the Coq decompiler will not
 recognize the expansion of the boolean if; using the default printer
 avoids a spurious trailing %GEN_IF. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Delimit</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">general_if_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">GEN_IF</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="::general_if_scope:'if'_x_'then'_x_'else'_x" class="idref" href="#::general_if_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">&quot;</span></a>'if' c 'then' vT 'else' vF" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Coq.ssr.ssreflect.html#CoqGenericIf"><span class="id" title="abbreviation">CoqGenericIf</span></a> <span class="id" title="var">c</span> <span class="id" title="var">vT</span> <span class="id" title="var">vF</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">general_if_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="::general_if_scope:'if'_x_'return'_x_'then'_x_'else'_x" class="idref" href="#::general_if_scope:'if'_x_'return'_x_'then'_x_'else'_x"><span class="id" title="notation">&quot;</span></a>'if' c 'return' R 'then' vT 'else' vF" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Coq.ssr.ssreflect.html#CoqGenericDependentIf"><span class="id" title="abbreviation">CoqGenericDependentIf</span></a> <span class="id" title="var">c</span> <a id="c:3" class="idref" href="#c:3"><span class="id" title="binder">c</span></a> <span class="id" title="var">R</span> <span class="id" title="var">vT</span> <span class="id" title="var">vF</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">general_if_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="::general_if_scope:'if'_x_'as'_x_'return'_x_'then'_x_'else'_x" class="idref" href="#::general_if_scope:'if'_x_'as'_x_'return'_x_'then'_x_'else'_x"><span class="id" title="notation">&quot;</span></a>'if' c 'as' x 'return' R 'then' vT 'else' vF" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Coq.ssr.ssreflect.html#CoqGenericDependentIf"><span class="id" title="abbreviation">CoqGenericDependentIf</span></a> <span class="id" title="var">c</span> <a id="x:5" class="idref" href="#x:5"><span class="id" title="binder">x</span></a> <span class="id" title="var">R</span> <span class="id" title="var">vT</span> <span class="id" title="var">vF</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">general_if_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Force boolean interpretation of simple if expressions.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Delimit</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">boolean_if_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">BOOL_IF</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="::boolean_if_scope:'if'_x_'return'_x_'then'_x_'else'_x" class="idref" href="#::boolean_if_scope:'if'_x_'return'_x_'then'_x_'else'_x"><span class="id" title="notation">&quot;</span></a>'if' c 'return' R 'then' vT 'else' vF" :=<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">if</span> <span class="id" title="var">c</span> <span class="id" title="keyword">is</span> <a class="idref" href="Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <span class="id" title="keyword">as</span> <span class="id" title="var">c</span> <span class="id" title="tactic">in</span> <a class="idref" href="Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <span class="id" title="keyword">return</span> <span class="id" title="var">R</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>) : <span class="id" title="var">boolean_if_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="::boolean_if_scope:'if'_x_'then'_x_'else'_x" class="idref" href="#::boolean_if_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">&quot;</span></a>'if' c 'then' vT 'else' vF" :=<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">if</span> <span class="id" title="var">c</span>%<span class="id" title="var">bool</span> <span class="id" title="keyword">is</span> <a class="idref" href="Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <span class="id" title="keyword">as</span> <span class="id" title="var">_</span> <span class="id" title="tactic">in</span> <a class="idref" href="Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <span class="id" title="keyword">return</span> <span class="id" title="var">_</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>) : <span class="id" title="var">boolean_if_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="::boolean_if_scope:'if'_x_'as'_x_'return'_x_'then'_x_'else'_x" class="idref" href="#::boolean_if_scope:'if'_x_'as'_x_'return'_x_'then'_x_'else'_x"><span class="id" title="notation">&quot;</span></a>'if' c 'as' x 'return' R 'then' vT 'else' vF" :=<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">if</span> <span class="id" title="var">c</span>%<span class="id" title="var">bool</span> <span class="id" title="keyword">is</span> <a class="idref" href="Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <span class="id" title="keyword">as</span> <span class="id" title="var">x</span> <span class="id" title="tactic">in</span> <a class="idref" href="Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <span class="id" title="keyword">return</span> <span class="id" title="var">R</span> <span class="id" title="keyword">then</span> <span class="id" title="var">vT</span> <span class="id" title="keyword">else</span> <span class="id" title="var">vF</span>) : <span class="id" title="var">boolean_if_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">boolean_if_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 To allow a wider variety of notations without reserving a large number of
 of identifiers, the ssreflect library systematically uses "forms" to
 enclose complex mixfix syntax. A "form" is simply a mixfix expression
 enclosed in square brackets and introduced by a keyword:
      [keyword ... ]
 Because the keyword follows a bracket it does not need to be reserved.
 Non-ssreflect libraries that do not respect the form syntax (e.g., the Coq
 Lists library) should be loaded before ssreflect so that their notations
 do not mask all ssreflect forms.                                            
</div>
<div class="code">
<span class="id" title="keyword">Delimit</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">form_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">FORM</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">form_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Allow overloading of the cast (x : T) syntax, put whitespace around the
 ":" symbol to avoid lexical clashes (and for consistency with the parsing
 precedence of the notation, which binds less tightly than application),
 and put printing boxes that print the type of a long definition on a
 separate line rather than force-fit it at the right margin.                 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <a id="::core_scope:x_':'_x" class="idref" href="#::core_scope:x_':'_x"><span class="id" title="notation">&quot;</span></a>x : T" := (<a class="idref" href="Coq.ssr.ssreflect.html#CoqCast"><span class="id" title="abbreviation">CoqCast</span></a> <span class="id" title="var">x</span> <span class="id" title="var">T</span>) : <span class="id" title="var">core_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Allow the casual use of notations like nat * nat for explicit Type
 declarations. Note that (nat * nat : Type) is NOT equivalent to
 (nat * nat)%type, whose inferred type is legacy type "Set".                
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <a id="::core_scope:x_':'_'Type'" class="idref" href="#::core_scope:x_':'_'Type'"><span class="id" title="notation">&quot;</span></a>T : 'Type'" := (<a class="idref" href="Coq.ssr.ssreflect.html#CoqCast"><span class="id" title="abbreviation">CoqCast</span></a> <span class="id" title="var">T</span>%<span class="id" title="keyword">type</span> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">core_scope</span>.<br/>
</div>

<div class="doc">
 Allow similarly Prop annotation for, e.g., rewrite multirules. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <a id="::core_scope:x_':'_'Prop'" class="idref" href="#::core_scope:x_':'_'Prop'"><span class="id" title="notation">&quot;</span></a>P : 'Prop'" := (<a class="idref" href="Coq.ssr.ssreflect.html#CoqCast"><span class="id" title="abbreviation">CoqCast</span></a> <span class="id" title="var">P</span>%<span class="id" title="keyword">type</span> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">core_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Constants for abstract: and [: name ] intro pattern  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="abstract_lock" class="idref" href="#abstract_lock"><span class="id" title="definition">abstract_lock</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a id="abstract_key" class="idref" href="#abstract_key"><span class="id" title="definition">abstract_key</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="abstract" class="idref" href="#abstract"><span class="id" title="definition">abstract</span></a> (<a id="statement:8" class="idref" href="#statement:8"><span class="id" title="binder">statement</span></a> : <span class="id" title="keyword">Type</span>) (<a id="id:9" class="idref" href="#id:9"><span class="id" title="binder">id</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<a id="lock:10" class="idref" href="#lock:10"><span class="id" title="binder">lock</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#abstract_lock"><span class="id" title="definition">abstract_lock</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span>: <a class="idref" href="Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#lock:10"><span class="id" title="variable">lock</span></a> <span class="id" title="tactic">in</span> <a class="idref" href="Coq.ssr.ssreflect.html#statement:8"><span class="id" title="variable">statement</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="::ssr_scope:'&lt;hidden'_x_'&gt;'" class="idref" href="#::ssr_scope:'&lt;hidden'_x_'&gt;'"><span class="id" title="notation">&quot;</span></a>&lt;hidden n &gt;" := (<a class="idref" href="Coq.ssr.ssreflect.html#abstract"><span class="id" title="definition">abstract</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> <span class="id" title="var">_</span>) : <span class="id" title="var">ssr_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id="b5d88b94bca3ca2a78564b6d8ed3faa7" class="idref" href="#b5d88b94bca3ca2a78564b6d8ed3faa7"><span class="id" title="notation">&quot;</span></a>T (* n *)" := (<a class="idref" href="Coq.ssr.ssreflect.html#abstract"><span class="id" title="definition">abstract</span></a> <span class="id" title="var">T</span> <span class="id" title="var">n</span> <a class="idref" href="Coq.ssr.ssreflect.html#abstract_key"><span class="id" title="definition">abstract_key</span></a>) : <span class="id" title="var">ssr_scope</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">ssr_scope</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
 Constants for tactic-views  
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <a id="external_view" class="idref" href="#external_view"><span class="id" title="inductive">external_view</span></a> : <span class="id" title="keyword">Type</span> := <a id="tactic_view" class="idref" href="#tactic_view"><span class="id" title="constructor">tactic_view</span></a> <span class="id" title="keyword">of</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
</div>

<div class="doc">
 Syntax for referring to canonical structures:
      [the struct_type of proj_val by proj_fun]
 This form denotes the Canonical instance s of the Structure type
 struct_type whose proj_fun projection is proj_val, i.e., such that
      proj_fun s = proj_val.
 Typically proj_fun will be A record field accessors of struct_type, but
 this need not be the case; it can be, for instance, a field of a record
 type to which struct_type coerces; proj_val will likewise be coerced to
 the return type of proj_fun. In all but the simplest cases, proj_fun
 should be eta-expanded to allow for the insertion of implicit arguments.
   In the common case where proj_fun itself is a coercion, the "by" part
 can be omitted entirely; in this case it is inferred by casting s to the
 inferred type of proj_val. Obviously the latter can be fixed by using an
 explicit cast on proj_val, and it is highly recommended to do so when the
 return type intended for proj_fun is "Type", as the type inferred for
 proj_val may vary because of sort polymorphism (it could be Set or Prop).
   Note when using the [the _ of _ ] form to generate a substructure from a
 telescopes-style canonical hierarchy (implementing inheritance with
 coercions), one should always project or coerce the value to the BASE
 structure, because Coq will only find a Canonical derived structure for
 the Canonical base structure -- not for a base structure that is specific
 to proj_value.                                                              
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a id="TheCanonical" class="idref" href="#TheCanonical"><span class="id" title="module">TheCanonical</span></a>.<br/>

<br/>
#[<span class="id" title="var">universes</span>(<span class="id" title="var">template</span>)]<br/>
<span class="id" title="keyword">Variant</span> <a id="TheCanonical.put" class="idref" href="#TheCanonical.put"><span class="id" title="inductive">put</span></a> <a id="vT:14" class="idref" href="#vT:14"><span class="id" title="binder">vT</span></a> <a id="sT:15" class="idref" href="#sT:15"><span class="id" title="binder">sT</span></a> (<a id="v1:16" class="idref" href="#v1:16"><span class="id" title="binder">v1</span></a> <a id="v2:17" class="idref" href="#v2:17"><span class="id" title="binder">v2</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#vT:14"><span class="id" title="variable">vT</span></a>) (<a id="s:18" class="idref" href="#s:18"><span class="id" title="binder">s</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#sT:15"><span class="id" title="variable">sT</span></a>) := <a id="TheCanonical.Put" class="idref" href="#TheCanonical.Put"><span class="id" title="constructor">Put</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="TheCanonical.get" class="idref" href="#TheCanonical.get"><span class="id" title="definition">get</span></a> <a id="vT:21" class="idref" href="#vT:21"><span class="id" title="binder">vT</span></a> <a id="sT:22" class="idref" href="#sT:22"><span class="id" title="binder">sT</span></a> <a id="v:23" class="idref" href="#v:23"><span class="id" title="binder">v</span></a> <a id="s:24" class="idref" href="#s:24"><span class="id" title="binder">s</span></a> (<a id="p:25" class="idref" href="#p:25"><span class="id" title="binder">p</span></a> : @<a class="idref" href="Coq.ssr.ssreflect.html#TheCanonical.put"><span class="id" title="inductive">put</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#vT:21"><span class="id" title="variable">vT</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#sT:22"><span class="id" title="variable">sT</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#v:23"><span class="id" title="variable">v</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#v:23"><span class="id" title="variable">v</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#s:24"><span class="id" title="variable">s</span></a>) := <span class="id" title="keyword">let</span>: <a class="idref" href="Coq.ssr.ssreflect.html#TheCanonical.Put"><span class="id" title="constructor">Put</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> := <a class="idref" href="Coq.ssr.ssreflect.html#p:25"><span class="id" title="variable">p</span></a> <span class="id" title="tactic">in</span> <a class="idref" href="Coq.ssr.ssreflect.html#s:24"><span class="id" title="variable">s</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="TheCanonical.get_by" class="idref" href="#TheCanonical.get_by"><span class="id" title="definition">get_by</span></a> <a id="vT:27" class="idref" href="#vT:27"><span class="id" title="binder">vT</span></a> <a id="sT:28" class="idref" href="#sT:28"><span class="id" title="binder">sT</span></a> <span class="id" title="keyword">of</span> <a class="idref" href="Coq.ssr.ssreflect.html#sT:28"><span class="id" title="variable">sT</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#vT:27"><span class="id" title="variable">vT</span></a> := @<a class="idref" href="Coq.ssr.ssreflect.html#TheCanonical.get"><span class="id" title="definition">get</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#vT:27"><span class="id" title="variable">vT</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#sT:28"><span class="id" title="variable">sT</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Coq.ssr.ssreflect.html#TheCanonical"><span class="id" title="module">TheCanonical</span></a>.<br/>

<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">TheCanonical</span>. 
<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="5686d18699d1d98d5f8016a5eda2aa8f" class="idref" href="#5686d18699d1d98d5f8016a5eda2aa8f"><span class="id" title="notation">&quot;</span></a>[ 'the' sT 'of' v 'by' f ]" :=<br/>
&nbsp;&nbsp;(@<a class="idref" href="Coq.ssr.ssreflect.html#get_by"><span class="id" title="definition">get_by</span></a> <span class="id" title="var">_</span> <span class="id" title="var">sT</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ((<span class="id" title="keyword">fun</span> <a id="v':29" class="idref" href="#v':29"><span class="id" title="binder">v'</span></a> (<a id="s:30" class="idref" href="#s:30"><span class="id" title="binder">s</span></a> : <span class="id" title="var">sT</span>) =&gt; <a class="idref" href="Coq.ssr.ssreflect.html#Put"><span class="id" title="constructor">Put</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#v':29"><span class="id" title="variable">v'</span></a> (<span class="id" title="var">f</span> <a class="idref" href="Coq.ssr.ssreflect.html#s:30"><span class="id" title="variable">s</span></a>) <a class="idref" href="Coq.ssr.ssreflect.html#s:30"><span class="id" title="variable">s</span></a>) <span class="id" title="var">v</span> <span class="id" title="var">_</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">form_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="dd4e793ea9d0dbe0a320346aa74c809d" class="idref" href="#dd4e793ea9d0dbe0a320346aa74c809d"><span class="id" title="notation">&quot;</span></a>[ 'the' sT 'of' v ]" := (<a class="idref" href="Coq.ssr.ssreflect.html#get"><span class="id" title="definition">get</span></a> ((<span class="id" title="keyword">fun</span> <a id="s:31" class="idref" href="#s:31"><span class="id" title="binder">s</span></a> : <span class="id" title="var">sT</span> =&gt; <a class="idref" href="Coq.ssr.ssreflect.html#Put"><span class="id" title="constructor">Put</span></a> <span class="id" title="var">v</span>  <a class="idref" href="Coq.ssr.ssreflect.html#s:31"><span class="id" title="variable">s</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#s:31"><span class="id" title="variable">s</span></a>) <span class="id" title="var">_</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">form_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 The following are "format only" versions of the above notations.
 We need to do this to prevent the formatter from being be thrown off by
 application collapsing, coercion insertion and beta reduction in the right
 hand side of the notations above.                                           
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a id="5686d18699d1d98d5f8016a5eda2aa8f" class="idref" href="#5686d18699d1d98d5f8016a5eda2aa8f"><span class="id" title="notation">&quot;</span></a>[ 'the' sT 'of' v 'by' f ]" := (@<a class="idref" href="Coq.ssr.ssreflect.html#get_by"><span class="id" title="definition">get_by</span></a> <span class="id" title="var">_</span> <span class="id" title="var">sT</span> <span class="id" title="var">f</span> <span class="id" title="var">v</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">only</span> <span class="id" title="var">printing</span>) : <span class="id" title="var">form_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="dd4e793ea9d0dbe0a320346aa74c809d" class="idref" href="#dd4e793ea9d0dbe0a320346aa74c809d"><span class="id" title="notation">&quot;</span></a>[ 'the' sT 'of' v ]" := (@<a class="idref" href="Coq.ssr.ssreflect.html#get"><span class="id" title="definition">get</span></a> <span class="id" title="var">_</span> <span class="id" title="var">sT</span> <span class="id" title="var">v</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">only</span> <span class="id" title="var">printing</span>) : <span class="id" title="var">form_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 We would like to recognize
Notation " [ 'the' sT 'of' v : 'Type' ]" := (@get Type sT v _ )
  (at level 0, format " [ 'the'  sT   'of'  v  :  'Type' ]") : form_scope.
 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

 Helper notation for canonical structure inheritance support.
 This is a workaround for the poor interaction between delta reduction and
 canonical projections in Coq's unification algorithm, by which transparent
 definitions hide canonical instances, i.e., in
   Canonical a_type_struct := @Struct a_type ...
   Definition my_type := a_type.
 my_type doesn't effectively inherit the struct structure from a_type. Our
 solution is to redeclare the instance as follows
   Canonical my_type_struct := Eval hnf in [struct of my_type].
 The special notation [str of _ ] must be defined for each Structure "str"
 with constructor "Str", typically as follows
   Definition clone_str s :=
      let: Str _ x y ... z := s return {type of Str for s} -&gt; str in
      fun k =&gt; k _ x y ... z.
    Notation " [ 'str' 'of' T 'for' s ]" := (@clone_str s (@Str T))
      (at level 0, format " [ 'str'  'of'  T  'for'  s ]") : form_scope.
    Notation " [ 'str' 'of' T ]" := (repack_str (fun x =&gt; @Str T x))
      (at level 0, format " [ 'str'  'of'  T ]") : form_scope.
 The notation for the match return predicate is defined below; the eta
 expansion in the second form serves both to distinguish it from the first
 and to avoid the delta reduction problem.
   There are several variations on the notation and the definition of the
 the "clone" function, for telescopes, mixin classes, and join (multiple
 inheritance) classes. We describe a different idiom for clones in ssrfun;
 it uses phantom types (see below) and static unification; see fintype and
 ssralg for examples.                                                        
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="argumentType" class="idref" href="#argumentType"><span class="id" title="definition">argumentType</span></a> <a id="T:32" class="idref" href="#T:32"><span class="id" title="binder">T</span></a> <a id="P:33" class="idref" href="#P:33"><span class="id" title="binder">P</span></a> &amp; <span class="id" title="keyword">forall</span> <a id="x:34" class="idref" href="#x:34"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#T:32"><span class="id" title="variable">T</span></a>, <a class="idref" href="Coq.ssr.ssreflect.html#P:33"><span class="id" title="variable">P</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:34"><span class="id" title="variable">x</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#T:32"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a id="dependentReturnType" class="idref" href="#dependentReturnType"><span class="id" title="definition">dependentReturnType</span></a> <a id="T:35" class="idref" href="#T:35"><span class="id" title="binder">T</span></a> <a id="P:36" class="idref" href="#P:36"><span class="id" title="binder">P</span></a> &amp; <span class="id" title="keyword">forall</span> <a id="x:37" class="idref" href="#x:37"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#T:35"><span class="id" title="variable">T</span></a>, <a class="idref" href="Coq.ssr.ssreflect.html#P:36"><span class="id" title="variable">P</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:37"><span class="id" title="variable">x</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#P:36"><span class="id" title="variable">P</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a id="returnType" class="idref" href="#returnType"><span class="id" title="definition">returnType</span></a> <a id="aT:38" class="idref" href="#aT:38"><span class="id" title="binder">aT</span></a> <a id="rT:39" class="idref" href="#rT:39"><span class="id" title="binder">rT</span></a> &amp; <a class="idref" href="Coq.ssr.ssreflect.html#aT:38"><span class="id" title="variable">aT</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#rT:39"><span class="id" title="variable">rT</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#rT:39"><span class="id" title="variable">rT</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="daf095f6f58ec61a0b83a3c10c4f8017" class="idref" href="#daf095f6f58ec61a0b83a3c10c4f8017"><span class="id" title="notation">&quot;</span></a>{ 'type' 'of' c 'for' s }" := (<a class="idref" href="Coq.ssr.ssreflect.html#dependentReturnType"><span class="id" title="definition">dependentReturnType</span></a> <span class="id" title="var">c</span> <span class="id" title="var">s</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 A generic "phantom" type (actually, a unit type with a phantom parameter).
 This type can be used for type definitions that require some Structure
 on one of their parameters, to allow Coq to infer said structure so it
 does not have to be supplied explicitly or via the " [the _ of _ ]" notation
 (the latter interacts poorly with other Notation).
   The definition of a (co)inductive type with a parameter p : p_type, that
 needs to use the operations of a structure
  Structure p_str : Type := p_Str {p_repr :&gt; p_type; p_op : p_repr -&gt; ...}
 should be given as
  Inductive indt_type (p : p_str) := Indt ... .
  Definition indt_of (p : p_str) &amp; phantom p_type p := indt_type p.
  Notation "{ 'indt' p }" := (indt_of (Phantom p)).
  Definition indt p x y ... z : {indt p} := @Indt p x y ... z.
  Notation " [ 'indt' x y ... z ]" := (indt x y ... z).
 That is, the concrete type and its constructor should be shadowed by
 definitions that use a phantom argument to infer and display the true
 value of p (in practice, the "indt" constructor often performs additional
 functions, like "locking" the representation -- see below).
   We also define a simpler version ("phant" / "Phant") of phantom for the
 common case where p_type is Type.                                           
</div>
<div class="code">

<br/>
#[<span class="id" title="var">universes</span>(<span class="id" title="var">template</span>)]<br/>
<span class="id" title="keyword">Variant</span> <a id="phantom" class="idref" href="#phantom"><span class="id" title="inductive">phantom</span></a> <a id="T:40" class="idref" href="#T:40"><span class="id" title="binder">T</span></a> (<a id="p:41" class="idref" href="#p:41"><span class="id" title="binder">p</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#T:40"><span class="id" title="variable">T</span></a>) := <a id="Phantom" class="idref" href="#Phantom"><span class="id" title="constructor">Phantom</span></a>.<br/>
#[<span class="id" title="var">universes</span>(<span class="id" title="var">template</span>)]<br/>
<span class="id" title="keyword">Variant</span> <a id="phant" class="idref" href="#phant"><span class="id" title="inductive">phant</span></a> (<a id="p:44" class="idref" href="#p:44"><span class="id" title="binder">p</span></a> : <span class="id" title="keyword">Type</span>) := <a id="Phant" class="idref" href="#Phant"><span class="id" title="constructor">Phant</span></a>.<br/>

<br/>
</div>

<div class="doc">
 Internal tagging used by the implementation of the ssreflect elim.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="protect_term" class="idref" href="#protect_term"><span class="id" title="definition">protect_term</span></a> (<a id="A:47" class="idref" href="#A:47"><span class="id" title="binder">A</span></a> : <span class="id" title="keyword">Type</span>) (<a id="x:48" class="idref" href="#x:48"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#A:47"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Coq.ssr.ssreflect.html#A:47"><span class="id" title="variable">A</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#x:48"><span class="id" title="variable">x</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
 The ssreflect idiom for a non-keyed pattern:
<ul class="doclist">
<li> unkeyed t will match any subterm that unifies with t, regardless of
    whether it displays the same head symbol as t.

</li>
<li> unkeyed t a b will match any application of a term f unifying with t,
    to two arguments unifying with with a and b, respectively, regardless of
    apparent head symbols.

</li>
<li> unkeyed x where x is a variable will match any subterm with the same
    type as x (when x would raise the 'indeterminate pattern' error).        

</li>
</ul>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a id="unkeyed" class="idref" href="#unkeyed"><span class="id" title="abbreviation">unkeyed</span></a> <span class="id" title="var">x</span> := (<span class="id" title="keyword">let</span> <a id="flex:49" class="idref" href="#flex:49"><span class="id" title="binder">flex</span></a> := <span class="id" title="var">x</span> <span class="id" title="tactic">in</span> <a class="idref" href="Coq.ssr.ssreflect.html#flex:49"><span class="id" title="variable">flex</span></a>).<br/>

<br/>
</div>

<div class="doc">
 Ssreflect converse rewrite rule rule idiom.  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="ssr_converse" class="idref" href="#ssr_converse"><span class="id" title="definition">ssr_converse</span></a> <a id="R:50" class="idref" href="#R:50"><span class="id" title="binder">R</span></a> (<a id="r:51" class="idref" href="#r:51"><span class="id" title="binder">r</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#R:50"><span class="id" title="variable">R</span></a>) := <a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Coq.Init.Logic.html#I"><span class="id" title="constructor">Logic.I</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#r:51"><span class="id" title="variable">r</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a id="cf4622b495e328f0df000006fee34402" class="idref" href="#cf4622b495e328f0df000006fee34402"><span class="id" title="notation">&quot;</span></a>=^~ r" := (<a class="idref" href="Coq.ssr.ssreflect.html#ssr_converse"><span class="id" title="definition">ssr_converse</span></a> <span class="id" title="var">r</span>) : <span class="id" title="var">form_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Term tagging (user-level).
 The ssreflect library uses four strengths of term tagging to restrict
 convertibility during type checking:
  nosimpl t simplifies to t EXCEPT in a definition; more precisely, given
    Definition foo := nosimpl bar, foo (or foo t') will NOT be expanded by
    the /= and //= switches unless it is in a forcing context (e.g., in
    match foo t' with ... end, foo t' will be reduced if this allows the
    match to be reduced). Note that nosimpl bar is simply notation for a
    a term that beta-iota reduces to bar; hence rewrite /foo will replace
    foo by bar, and rewrite -/foo will replace bar by foo.
    CAVEAT: nosimpl should not be used inside a Section, because the end of
    section "cooking" removes the iota redex.
  locked t is provably equal to t, but is not convertible to t; 'locked'
    provides support for selective rewriting, via the lock t : t = locked t
    Lemma, and the ssreflect unlock tactic.
  locked_with k t is equal but not convertible to t, much like locked t,
    but supports explicit tagging with a value k : unit. This is used to
    mitigate a flaw in the term comparison heuristic of the Coq kernel,
    which treats all terms of the form locked t as equal and compares their
    arguments recursively, leading to an exponential blowup of comparison.
    For this reason locked_with should be used rather than locked when
    defining ADT operations. The unlock tactic does not support locked_with
    but the unlock rewrite rule does, via the unlockable interface.
  we also use Module Type ascription to create truly opaque constants,
    because simple expansion of constants to reveal an unreducible term
    doubles the time complexity of a negative comparison. Such opaque
    constants can be expanded generically with the unlock rewrite rule.
    See the definition of card and subset in fintype for examples of this.   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a id="nosimpl" class="idref" href="#nosimpl"><span class="id" title="abbreviation">nosimpl</span></a> <span class="id" title="var">t</span> := (<span class="id" title="keyword">let</span>: <a class="idref" href="Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">t</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="master_key" class="idref" href="#master_key"><span class="id" title="lemma">master_key</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>.  <br/>
<span class="id" title="keyword">Definition</span> <a id="locked" class="idref" href="#locked"><span class="id" title="definition">locked</span></a> <a id="A:52" class="idref" href="#A:52"><span class="id" title="binder">A</span></a> := <span class="id" title="keyword">let</span>: <a class="idref" href="Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#master_key"><span class="id" title="lemma">master_key</span></a> <span class="id" title="tactic">in</span> <span class="id" title="keyword">fun</span> <a id="x:53" class="idref" href="#x:53"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#A:52"><span class="id" title="variable">A</span></a> =&gt; <a class="idref" href="Coq.ssr.ssreflect.html#x:53"><span class="id" title="variable">x</span></a>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="lock" class="idref" href="#lock"><span class="id" title="lemma">lock</span></a> <a id="A:54" class="idref" href="#A:54"><span class="id" title="binder">A</span></a> <a id="x:55" class="idref" href="#x:55"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#x:55"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#b8b2ebc8e1a8b9aa935c0702efb5dccf"><span class="id" title="notation">=</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#locked"><span class="id" title="definition">locked</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:55"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#b8b2ebc8e1a8b9aa935c0702efb5dccf"><span class="id" title="notation">:&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#A:54"><span class="id" title="variable">A</span></a>.  <br/>

<br/>
</div>

<div class="doc">
 Needed for locked predicates, in particular for eqType's.  
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="not_locked_false_eq_true" class="idref" href="#not_locked_false_eq_true"><span class="id" title="lemma">not_locked_false_eq_true</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#locked"><span class="id" title="definition">locked</span></a> <a class="idref" href="Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>.<br/>
 
<br/>
</div>

<div class="doc">
 The basic closing tactic "done".  
</div>
<div class="code">
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">done</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>; <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">solve</span><br/>
&nbsp;&nbsp;&nbsp;[ <span class="id" title="tactic">do</span> ![<span class="id" title="tactic">solve</span> [<span class="id" title="tactic">trivial</span> | <span class="id" title="tactic">apply</span>: <a class="idref" href="Coq.Init.Logic.html#sym_equal"><span class="id" title="abbreviation">sym_equal</span></a>; <span class="id" title="tactic">trivial</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">discriminate</span> | <span class="id" title="var">contradiction</span> | <span class="id" title="tactic">split</span>]<br/>
&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">case</span> <a class="idref" href="Coq.ssr.ssreflect.html#not_locked_false_eq_true"><span class="id" title="lemma">not_locked_false_eq_true</span></a>; <span class="id" title="tactic">assumption</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> <span class="id" title="var">H</span> : <a class="idref" href="Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">solve</span> [<span class="id" title="tactic">case</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">trivial</span>] <span class="id" title="keyword">end</span> ].<br/>

<br/>
</div>

<div class="doc">
 Quicker done tactic not including split, syntax: /0/  
</div>
<div class="code">
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">ssrdone0</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>; <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">solve</span><br/>
&nbsp;&nbsp;&nbsp;[ <span class="id" title="tactic">do</span> ![<span class="id" title="tactic">solve</span> [<span class="id" title="tactic">trivial</span> | <span class="id" title="tactic">apply</span>: <a class="idref" href="Coq.Init.Logic.html#sym_equal"><span class="id" title="abbreviation">sym_equal</span></a>; <span class="id" title="tactic">trivial</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">discriminate</span> | <span class="id" title="var">contradiction</span> ]<br/>
&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">case</span> <a class="idref" href="Coq.ssr.ssreflect.html#not_locked_false_eq_true"><span class="id" title="lemma">not_locked_false_eq_true</span></a>; <span class="id" title="tactic">assumption</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> <span class="id" title="var">H</span> : <a class="idref" href="Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">solve</span> [<span class="id" title="tactic">case</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">trivial</span>] <span class="id" title="keyword">end</span> ].<br/>

<br/>
</div>

<div class="doc">
 To unlock opaque constants.  
</div>
<div class="code">
#[<span class="id" title="var">universes</span>(<span class="id" title="var">template</span>)]<br/>
<span class="id" title="keyword">Structure</span> <a id="unlockable" class="idref" href="#unlockable"><span class="id" title="record">unlockable</span></a> <a id="T:56" class="idref" href="#T:56"><span class="id" title="binder">T</span></a> <a id="v:57" class="idref" href="#v:57"><span class="id" title="binder">v</span></a> := <a id="Unlockable" class="idref" href="#Unlockable"><span class="id" title="constructor">Unlockable</span></a> {<a id="unlocked" class="idref" href="#unlocked"><span class="id" title="projection">unlocked</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#T:56"><span class="id" title="variable">T</span></a>; <span class="id" title="var">_</span> : <a class="idref" href="Coq.ssr.ssreflect.html#unlocked:59"><span class="id" title="method">unlocked</span></a> <a class="idref" href="Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#v:57"><span class="id" title="variable">v</span></a>}.<br/>
<span class="id" title="keyword">Lemma</span> <a id="unlock" class="idref" href="#unlock"><span class="id" title="lemma">unlock</span></a> <a id="T:60" class="idref" href="#T:60"><span class="id" title="binder">T</span></a> <a id="x:61" class="idref" href="#x:61"><span class="id" title="binder">x</span></a> <a id="C:62" class="idref" href="#C:62"><span class="id" title="binder">C</span></a> : @<a class="idref" href="Coq.ssr.ssreflect.html#unlocked"><span class="id" title="projection">unlocked</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#T:60"><span class="id" title="variable">T</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:61"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#C:62"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:61"><span class="id" title="variable">x</span></a>.  <br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="5ad020f08aa5d2a22e22f3b18f63fcd0" class="idref" href="#5ad020f08aa5d2a22e22f3b18f63fcd0"><span class="id" title="notation">&quot;</span></a>[ 'unlockable' 'of' C ]" :=<br/>
&nbsp;&nbsp;(@<a class="idref" href="Coq.ssr.ssreflect.html#Unlockable"><span class="id" title="constructor">Unlockable</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">C</span> (<a class="idref" href="Coq.ssr.ssreflect.html#unlock"><span class="id" title="lemma">unlock</span></a> <span class="id" title="var">_</span>)) : <span class="id" title="var">form_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="84464b412faf5a30a7c5c6423d9b3956" class="idref" href="#84464b412faf5a30a7c5c6423d9b3956"><span class="id" title="notation">&quot;</span></a>[ 'unlockable' 'fun' C ]" :=<br/>
&nbsp;&nbsp;(@<a class="idref" href="Coq.ssr.ssreflect.html#Unlockable"><span class="id" title="constructor">Unlockable</span></a> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">_</span>) <span class="id" title="var">C</span> (<a class="idref" href="Coq.ssr.ssreflect.html#unlock"><span class="id" title="lemma">unlock</span></a> <span class="id" title="var">_</span>)) : <span class="id" title="var">form_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Generic keyed constant locking.  
<div class="paragraph"> </div>

  The argument order ensures that k is always compared before T.  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="locked_with" class="idref" href="#locked_with"><span class="id" title="definition">locked_with</span></a> <a id="k:63" class="idref" href="#k:63"><span class="id" title="binder">k</span></a> := <span class="id" title="keyword">let</span>: <a class="idref" href="Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#k:63"><span class="id" title="variable">k</span></a> <span class="id" title="tactic">in</span> <span class="id" title="keyword">fun</span> <a id="T:65" class="idref" href="#T:65"><span class="id" title="binder">T</span></a> <a id="x:66" class="idref" href="#x:66"><span class="id" title="binder">x</span></a> =&gt; <a class="idref" href="Coq.ssr.ssreflect.html#x:66"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#::core_scope:x_':'_x"><span class="id" title="notation">:</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#T:65"><span class="id" title="variable">T</span></a>.<br/>

<br/>
</div>

<div class="doc">
 This can be used as a cheap alternative to cloning the unlockable instance
 below, but with caution as unkeyed matching can be expensive.               
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="locked_withE" class="idref" href="#locked_withE"><span class="id" title="lemma">locked_withE</span></a> <a id="T:67" class="idref" href="#T:67"><span class="id" title="binder">T</span></a> <a id="k:68" class="idref" href="#k:68"><span class="id" title="binder">k</span></a> <a id="x:69" class="idref" href="#x:69"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#unkeyed"><span class="id" title="abbreviation">unkeyed</span></a> (<a class="idref" href="Coq.ssr.ssreflect.html#locked_with"><span class="id" title="definition">locked_with</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#k:68"><span class="id" title="variable">k</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:69"><span class="id" title="variable">x</span></a>) <a class="idref" href="Coq.Init.Logic.html#b8b2ebc8e1a8b9aa935c0702efb5dccf"><span class="id" title="notation">=</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:69"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#b8b2ebc8e1a8b9aa935c0702efb5dccf"><span class="id" title="notation">:&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#T:67"><span class="id" title="variable">T</span></a>.<br/>
 
<br/>
</div>

<div class="doc">
 Intensionaly, this instance will not apply to locked u.  
</div>
<div class="code">
<span class="id" title="keyword">Canonical</span> <a id="locked_with_unlockable" class="idref" href="#locked_with_unlockable"><span class="id" title="definition">locked_with_unlockable</span></a> <a id="T:70" class="idref" href="#T:70"><span class="id" title="binder">T</span></a> <a id="k:71" class="idref" href="#k:71"><span class="id" title="binder">k</span></a> <a id="x:72" class="idref" href="#x:72"><span class="id" title="binder">x</span></a> :=<br/>
&nbsp;&nbsp;@<a class="idref" href="Coq.ssr.ssreflect.html#Unlockable"><span class="id" title="constructor">Unlockable</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#T:70"><span class="id" title="variable">T</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:72"><span class="id" title="variable">x</span></a> (<a class="idref" href="Coq.ssr.ssreflect.html#locked_with"><span class="id" title="definition">locked_with</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#k:71"><span class="id" title="variable">k</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:72"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Coq.ssr.ssreflect.html#locked_withE"><span class="id" title="lemma">locked_withE</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#k:71"><span class="id" title="variable">k</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:72"><span class="id" title="variable">x</span></a>).<br/>

<br/>
</div>

<div class="doc">
 More accurate variant of unlock, and safer alternative to locked_withE. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="unlock_with" class="idref" href="#unlock_with"><span class="id" title="lemma">unlock_with</span></a> <a id="T:73" class="idref" href="#T:73"><span class="id" title="binder">T</span></a> <a id="k:74" class="idref" href="#k:74"><span class="id" title="binder">k</span></a> <a id="x:75" class="idref" href="#x:75"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#unlocked"><span class="id" title="projection">unlocked</span></a> (<a class="idref" href="Coq.ssr.ssreflect.html#locked_with_unlockable"><span class="id" title="definition">locked_with_unlockable</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#k:74"><span class="id" title="variable">k</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:75"><span class="id" title="variable">x</span></a>) <a class="idref" href="Coq.Init.Logic.html#b8b2ebc8e1a8b9aa935c0702efb5dccf"><span class="id" title="notation">=</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:75"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#b8b2ebc8e1a8b9aa935c0702efb5dccf"><span class="id" title="notation">:&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#T:73"><span class="id" title="variable">T</span></a>.<br/>
 
<br/>
</div>

<div class="doc">
 The internal lemmas for the have tactics.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="ssr_have" class="idref" href="#ssr_have"><span class="id" title="definition">ssr_have</span></a> <a id="Plemma:76" class="idref" href="#Plemma:76"><span class="id" title="binder">Plemma</span></a> <a id="Pgoal:77" class="idref" href="#Pgoal:77"><span class="id" title="binder">Pgoal</span></a> (<a id="step:78" class="idref" href="#step:78"><span class="id" title="binder">step</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#Plemma:76"><span class="id" title="variable">Plemma</span></a>) <a id="rest:79" class="idref" href="#rest:79"><span class="id" title="binder">rest</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#Pgoal:77"><span class="id" title="variable">Pgoal</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#rest:79"><span class="id" title="variable">rest</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#step:78"><span class="id" title="variable">step</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="ssr_have_let" class="idref" href="#ssr_have_let"><span class="id" title="definition">ssr_have_let</span></a> <a id="Pgoal:80" class="idref" href="#Pgoal:80"><span class="id" title="binder">Pgoal</span></a> <a id="Plemma:81" class="idref" href="#Plemma:81"><span class="id" title="binder">Plemma</span></a> <a id="step:82" class="idref" href="#step:82"><span class="id" title="binder">step</span></a><br/>
&nbsp;&nbsp;(<a id="rest:84" class="idref" href="#rest:84"><span class="id" title="binder">rest</span></a> : <span class="id" title="keyword">let</span> <a id="x:83" class="idref" href="#x:83"><span class="id" title="binder">x</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#Plemma:81"><span class="id" title="variable">Plemma</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#step:82"><span class="id" title="variable">step</span></a> <span class="id" title="tactic">in</span> <a class="idref" href="Coq.ssr.ssreflect.html#Pgoal:80"><span class="id" title="variable">Pgoal</span></a>) : <a class="idref" href="Coq.ssr.ssreflect.html#Pgoal:80"><span class="id" title="variable">Pgoal</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#rest:84"><span class="id" title="variable">rest</span></a>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="ssr_suff" class="idref" href="#ssr_suff"><span class="id" title="definition">ssr_suff</span></a> <a id="Plemma:85" class="idref" href="#Plemma:85"><span class="id" title="binder">Plemma</span></a> <a id="Pgoal:86" class="idref" href="#Pgoal:86"><span class="id" title="binder">Pgoal</span></a> <a id="step:87" class="idref" href="#step:87"><span class="id" title="binder">step</span></a> (<a id="rest:88" class="idref" href="#rest:88"><span class="id" title="binder">rest</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#Plemma:85"><span class="id" title="variable">Plemma</span></a>) : <a class="idref" href="Coq.ssr.ssreflect.html#Pgoal:86"><span class="id" title="variable">Pgoal</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#step:87"><span class="id" title="variable">step</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#rest:88"><span class="id" title="variable">rest</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="ssr_wlog" class="idref" href="#ssr_wlog"><span class="id" title="definition">ssr_wlog</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#ssr_suff"><span class="id" title="definition">ssr_suff</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
 Internal N-ary congruence lemmas for the congr tactic.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="nary_congruence_statement" class="idref" href="#nary_congruence_statement"><span class="id" title="definition">nary_congruence_statement</span></a> (<a id="n:89" class="idref" href="#n:89"><span class="id" title="binder">n</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">forall</span> <a id="B:90" class="idref" href="#B:90"><span class="id" title="binder">B</span></a>, <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Coq.ssr.ssreflect.html#B:90"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#B:90"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span><a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span><a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Coq.ssr.ssreflect.html#n:89"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> =&gt; <span class="id" title="keyword">fun</span> <a id="k:93" class="idref" href="#k:93"><span class="id" title="binder">k</span></a> =&gt; <span class="id" title="keyword">forall</span> <a id="B:94" class="idref" href="#B:94"><span class="id" title="binder">B</span></a>, <a class="idref" href="Coq.ssr.ssreflect.html#k:93"><span class="id" title="variable">k</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#B:94"><span class="id" title="variable">B</span></a> (<span class="id" title="keyword">fun</span> <a id="x1:95" class="idref" href="#x1:95"><span class="id" title="binder">x1</span></a> <a id="x2:96" class="idref" href="#x2:96"><span class="id" title="binder">x2</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#B:94"><span class="id" title="variable">B</span></a> =&gt; <a class="idref" href="Coq.ssr.ssreflect.html#x1:95"><span class="id" title="variable">x1</span></a> <a class="idref" href="Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x2:96"><span class="id" title="variable">x2</span></a>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="k':104" class="idref" href="#k':104"><span class="id" title="binder">k'</span></a> <a id="A:97" class="idref" href="#A:97"><span class="id" title="binder">A</span></a> <a id="B:98" class="idref" href="#B:98"><span class="id" title="binder">B</span></a> <a id="e:99" class="idref" href="#e:99"><span class="id" title="binder">e</span></a> (<a id="f1:100" class="idref" href="#f1:100"><span class="id" title="binder">f1</span></a> <a id="f2:101" class="idref" href="#f2:101"><span class="id" title="binder">f2</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#A:97"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#B:98"><span class="id" title="variable">B</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <a id="x1:102" class="idref" href="#x1:102"><span class="id" title="binder">x1</span></a> <a id="x2:103" class="idref" href="#x2:103"><span class="id" title="binder">x2</span></a>, <a class="idref" href="Coq.ssr.ssreflect.html#x1:102"><span class="id" title="variable">x1</span></a> <a class="idref" href="Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x2:103"><span class="id" title="variable">x2</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Coq.ssr.ssreflect.html#e:99"><span class="id" title="variable">e</span></a> (<a class="idref" href="Coq.ssr.ssreflect.html#f1:100"><span class="id" title="variable">f1</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x1:102"><span class="id" title="variable">x1</span></a>) (<a class="idref" href="Coq.ssr.ssreflect.html#f2:101"><span class="id" title="variable">f2</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x2:103"><span class="id" title="variable">x2</span></a>) <a class="idref" href="Coq.ssr.ssreflect.html#::core_scope:x_':'_'Prop'"><span class="id" title="notation">:</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#::core_scope:x_':'_'Prop'"><span class="id" title="notation">Prop</span></a><a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="k:105" class="idref" href="#k:105"><span class="id" title="binder">k</span></a> =&gt; <span class="id" title="keyword">forall</span> <a id="A:106" class="idref" href="#A:106"><span class="id" title="binder">A</span></a>, <a class="idref" href="Coq.ssr.ssreflect.html#nary_congruence_statement:91"><span class="id" title="definition">nary_congruence_statement</span></a> <span class="id" title="var">n'</span> (<span class="id" title="keyword">fun</span> <a id="B:107" class="idref" href="#B:107"><span class="id" title="binder">B</span></a> <a id="e:108" class="idref" href="#e:108"><span class="id" title="binder">e</span></a> =&gt; <a class="idref" href="Coq.ssr.ssreflect.html#k:105"><span class="id" title="variable">k</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.ssr.ssreflect.html#k':104"><span class="id" title="variable">k'</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#A:106"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#B:107"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#e:108"><span class="id" title="variable">e</span></a>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="nary_congruence" class="idref" href="#nary_congruence"><span class="id" title="lemma">nary_congruence</span></a> <a id="n:109" class="idref" href="#n:109"><span class="id" title="binder">n</span></a> (<a id="k:113" class="idref" href="#k:113"><span class="id" title="binder">k</span></a> := <span class="id" title="keyword">fun</span> <a id="B:110" class="idref" href="#B:110"><span class="id" title="binder">B</span></a> <a id="e:111" class="idref" href="#e:111"><span class="id" title="binder">e</span></a> =&gt; <span class="id" title="keyword">forall</span> <a id="y:112" class="idref" href="#y:112"><span class="id" title="binder">y</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#B:110"><span class="id" title="variable">B</span></a>, (<a class="idref" href="Coq.ssr.ssreflect.html#e:111"><span class="id" title="variable">e</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#y:112"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#y:112"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#::core_scope:x_':'_'Prop'"><span class="id" title="notation">:</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#::core_scope:x_':'_'Prop'"><span class="id" title="notation">Prop</span></a>)) :<br/>
&nbsp;&nbsp;<a class="idref" href="Coq.ssr.ssreflect.html#nary_congruence_statement"><span class="id" title="definition">nary_congruence_statement</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#n:109"><span class="id" title="variable">n</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#k:113"><span class="id" title="variable">k</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="ssr_congr_arrow" class="idref" href="#ssr_congr_arrow"><span class="id" title="lemma">ssr_congr_arrow</span></a> <a id="Plemma:114" class="idref" href="#Plemma:114"><span class="id" title="binder">Plemma</span></a> <a id="Pgoal:115" class="idref" href="#Pgoal:115"><span class="id" title="binder">Pgoal</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#Plemma:114"><span class="id" title="variable">Plemma</span></a> <a class="idref" href="Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#Pgoal:115"><span class="id" title="variable">Pgoal</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#Plemma:114"><span class="id" title="variable">Plemma</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#Pgoal:115"><span class="id" title="variable">Pgoal</span></a>.<br/>
 
<br/>

<br/>
</div>

<div class="doc">
 View lemmas that don't use reflection.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a id="ApplyIff" class="idref" href="#ApplyIff"><span class="id" title="section">ApplyIff</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> <a id="ApplyIff.P" class="idref" href="#ApplyIff.P"><span class="id" title="variable">P</span></a> <a id="ApplyIff.Q" class="idref" href="#ApplyIff.Q"><span class="id" title="variable">Q</span></a> : <span class="id" title="keyword">Prop</span>.<br/>
<span class="id" title="keyword">Hypothesis</span> <a id="ApplyIff.eqPQ" class="idref" href="#ApplyIff.eqPQ"><span class="id" title="variable">eqPQ</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff.Q"><span class="id" title="variable">Q</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="iffLR" class="idref" href="#iffLR"><span class="id" title="lemma">iffLR</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff.Q"><span class="id" title="variable">Q</span></a>.  <br/>
<span class="id" title="keyword">Lemma</span> <a id="iffRL" class="idref" href="#iffRL"><span class="id" title="lemma">iffRL</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff.P"><span class="id" title="variable">P</span></a>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a id="iffLRn" class="idref" href="#iffLRn"><span class="id" title="lemma">iffLRn</span></a> : <a class="idref" href="Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff.Q"><span class="id" title="variable">Q</span></a>.  <br/>
<span class="id" title="keyword">Lemma</span> <a id="iffRLn" class="idref" href="#iffRLn"><span class="id" title="lemma">iffRLn</span></a> : <a class="idref" href="Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff.P"><span class="id" title="variable">P</span></a>.  <br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Coq.ssr.ssreflect.html#ApplyIff"><span class="id" title="section">ApplyIff</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
 To focus non-ssreflect tactics on a subterm, eg vm_compute.
 Usage:
   elim/abstract_context: (pattern) =&gt; G defG.
   vm_compute; rewrite {}defG {G}.
 Note that vm_cast are not stored in the proof term
 for reductions occurring in the context, hence
   set here := pattern; vm_compute in (value of here)
 blows up at Qed time.                                        
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="abstract_context" class="idref" href="#abstract_context"><span class="id" title="lemma">abstract_context</span></a> <a id="T:119" class="idref" href="#T:119"><span class="id" title="binder">T</span></a> (<a id="P:120" class="idref" href="#P:120"><span class="id" title="binder">P</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#T:119"><span class="id" title="variable">T</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>) <a id="x:121" class="idref" href="#x:121"><span class="id" title="binder">x</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">forall</span> <a id="Q:122" class="idref" href="#Q:122"><span class="id" title="binder">Q</span></a>, <a class="idref" href="Coq.ssr.ssreflect.html#Q:122"><span class="id" title="variable">Q</span></a> <a class="idref" href="Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#P:120"><span class="id" title="variable">P</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#Q:122"><span class="id" title="variable">Q</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:121"><span class="id" title="variable">x</span></a><a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#P:120"><span class="id" title="variable">P</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#x:121"><span class="id" title="variable">x</span></a>.<br/>
 
<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="Coq.ssr.ssrunder.html#"><span class="id" title="library">ssrunder</span></a>.<br/>

<br/>
#[<span class="id" title="var">global</span>]<br/>
<span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Extern</span> 0 (@<a class="idref" href="Coq.ssr.ssrunder.html#Under_rel.Over_rel"><span class="id" title="axiom">Under_rel.Over_rel</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">solve</span> [ <span class="id" title="tactic">apply</span>: <a class="idref" href="Coq.ssr.ssrunder.html#Under_rel.over_rel_done"><span class="id" title="axiom">Under_rel.over_rel_done</span></a> ] : <span class="id" title="var">core</span>.<br/>
#[<span class="id" title="var">global</span>]<br/>
<span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Resolve</span> <span class="id" title="var">Under_rel.over_rel_done</span> : <span class="id" title="var">core</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Closing rewrite rule 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="over" class="idref" href="#over"><span class="id" title="definition">over</span></a> := <a class="idref" href="Coq.ssr.ssrunder.html#Under_rel.over_rel"><span class="id" title="axiom">over_rel</span></a>.<br/>

<br/>
</div>

<div class="doc">
Closing tactic 
</div>
<div class="code">
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">over</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">by</span> [ <span class="id" title="tactic">apply</span>: <a class="idref" href="Coq.ssr.ssrunder.html#Under_rel.under_rel_done"><span class="id" title="axiom">Under_rel.under_rel_done</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">rewrite</span> <a class="idref" href="Coq.ssr.ssreflect.html#over"><span class="id" title="definition">over</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;].<br/>

<br/>
</div>

<div class="doc">
Convenience rewrite rule to unprotect evars, e.g., to instantiate
    them in another way than with reflexivity. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a id="UnderE" class="idref" href="#UnderE"><span class="id" title="definition">UnderE</span></a> := <a class="idref" href="Coq.ssr.ssrunder.html#Under_rel.Under_relE"><span class="id" title="axiom">Under_relE</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
An interface for non-Prop types; used to avoid improper instantiation
    of polymorphic lemmas with on-demand implicits when they are used as views.
    For example: Some_inj {T} : forall x y : T, Some x = Some y -&gt; x = y.
    Using move/Some_inj on a goal of the form Some n = Some 0 will fail:
    SSReflect will interpret the view as @Some_inj ?T <i>top_assumption</i>
    since this is the well-typed application of the view with the minimal
    number of inserted evars (taking ?T := Some n = Some 0), and then will
    later complain that it cannot erase <i>top_assumption</i> after having
    abstracted the viewed assumption. Making x and y maximal implicits
    would avoid this and force the intended @Some_inj nat x y <i>top_assumption</i>
    interpretation, but is undesirable as it makes it harder to use Some_inj
    with the many SSReflect and MathComp lemmas that have an injectivity
    premise. Specifying {T : nonPropType} solves this more elegantly, as then
    (?T : Type) no longer unifies with (Some n = Some 0), which has sort Prop.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a id="NonPropType" class="idref" href="#NonPropType"><span class="id" title="module">NonPropType</span></a>.<br/>

<br/>
</div>

<div class="doc">
Implementation notes:
 We rely on three interface Structures:
<ul class="doclist">
<li> test_of r, the middle structure, performs the actual check: it has two
    canonical instances whose 'condition' projection are maybeProj (?P : Prop)
    and tt, and which set r := true and r := false, respectively. Unifying
    condition (?t : test_of ?r) with maybeProj T will thus set ?r to true if
    T is in Prop as the test_Prop T instance will apply, and otherwise simplify
    maybeProp T to tt and use the test_negative instance and set ?r to false.

</li>
<li> call_of c r sets up a call to test_of on condition c with expected result r.
    It has a default instance for its 'callee' projection to Type, which
    sets c := maybeProj T and r := false when unifying with a type T.

</li>
<li> type is a telescope on call_of c r, which checks that unifying test_of ?r1
    with c indeed sets ?r1 := r; the type structure bundles the 'test' instance
    and its 'result' value along with its call_of c r projection. The default
    instance essentially provides eta-expansion for 'type'. This is only
    essential for the first 'result' projection to bool; using the instance
    for other projection merely avoids spurious delta expansions that would
    spoil the notProp T notation.

</li>
</ul>
 In detail, unifying T =~= ?S with ?S : nonPropType, i.e.,
  (1)  T =~= @callee (@condition (result ?S) (test ?S)) (result ?S) (frame ?S)
 first uses the default call instance with ?T := T to reduce (1) to
  (2a) @condition (result ?S) (test ?S) =~= maybeProp T
  (3)                         result ?S =~= false
  (4)                          frame ?S =~= call T
 along with some trivial universe-related checks which are irrelevant here.
   Then the unification tries to use the test_Prop instance to reduce (2a) to
  (6a)                        result ?S =~= true
  (7a)                               ?P =~= T with ?P : Prop
  (8a)                          test ?S =~= test_Prop ?P
 Now the default 'check' instance with ?result := true resolves (6a) as
  (9a)                               ?S := @check true ?test ?frame
 Then (7a) can be solved precisely if T has sort at most (hence exactly) Prop,
 and then (8a) is solved by the check instance, yielding ?test := test_Prop T,
 and completing the solution of (2a), and <i>committing</i> to it. But now (3) is
 inconsistent with (9a), and this makes the entire problem (1) fails.
   If on the other hand T does not have sort Prop then (7a) fails and the
 unification resorts to delta expanding (2a), which gives
  (2b) @condition (result ?S) (test ?S) =~= tt
 which is then reduced, using the test_negative instance, to
  (6b)                        result ?S =~= false
  (8b)                          test ?S =~= test_negative
 Both are solved using the check default instance, as in the (2a) branch, giving
  (9b)                               ?S := @check false test_negative ?frame
 Then (3) and (4) are similarly solved using check, giving the final assignment
  (9)                                ?S := notProp T
 Observe that we <i>must</i> perform the actual test unification on the arguments
 of the initial canonical instance, and not on the instance itself as we do
 in mathcomp/matrix and mathcomp/vector, because we want the unification to
 fail when T has sort Prop. If both the test_of <i>and</i> the result check
 unifications were done as part of the structure telescope then the latter
 would be a sub-problem of the former, and thus failing the check would merely
 make the test_of unification backtrack and delta-expand and we would not get
 failure.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Structure</span> <a id="NonPropType.call_of" class="idref" href="#NonPropType.call_of"><span class="id" title="record">call_of</span></a> (<a id="condition:123" class="idref" href="#condition:123"><span class="id" title="binder">condition</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>) (<a id="result:124" class="idref" href="#result:124"><span class="id" title="binder">result</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) := <a id="NonPropType.Call" class="idref" href="#NonPropType.Call"><span class="id" title="constructor">Call</span></a> {<a id="NonPropType.callee" class="idref" href="#NonPropType.callee"><span class="id" title="projection">callee</span></a> : <span class="id" title="keyword">Type</span>}.<br/>
<span class="id" title="keyword">Definition</span> <a id="NonPropType.maybeProp" class="idref" href="#NonPropType.maybeProp"><span class="id" title="definition">maybeProp</span></a> (<a id="T:127" class="idref" href="#T:127"><span class="id" title="binder">T</span></a> : <span class="id" title="keyword">Type</span>) := <a class="idref" href="Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a id="NonPropType.call" class="idref" href="#NonPropType.call"><span class="id" title="definition">call</span></a> <a id="T:128" class="idref" href="#T:128"><span class="id" title="binder">T</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.Call"><span class="id" title="constructor">Call</span></a> (<a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.maybeProp"><span class="id" title="definition">maybeProp</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#T:128"><span class="id" title="variable">T</span></a>) <a class="idref" href="Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#T:128"><span class="id" title="variable">T</span></a>.<br/>

<br/>
<span class="id" title="keyword">Structure</span> <a id="NonPropType.test_of" class="idref" href="#NonPropType.test_of"><span class="id" title="record">test_of</span></a> (<a id="result:129" class="idref" href="#result:129"><span class="id" title="binder">result</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) := <a id="NonPropType.Test" class="idref" href="#NonPropType.Test"><span class="id" title="constructor">Test</span></a> {<a id="NonPropType.condition" class="idref" href="#NonPropType.condition"><span class="id" title="projection">condition</span></a> :&gt; <a class="idref" href="Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>}.<br/>
<span class="id" title="keyword">Definition</span> <a id="NonPropType.test_Prop" class="idref" href="#NonPropType.test_Prop"><span class="id" title="definition">test_Prop</span></a> (<a id="P:132" class="idref" href="#P:132"><span class="id" title="binder">P</span></a> : <span class="id" title="keyword">Prop</span>) := <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.Test"><span class="id" title="constructor">Test</span></a> <a class="idref" href="Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> (<a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.maybeProp"><span class="id" title="definition">maybeProp</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#P:132"><span class="id" title="variable">P</span></a>).<br/>
<span class="id" title="keyword">Definition</span> <a id="NonPropType.test_negative" class="idref" href="#NonPropType.test_negative"><span class="id" title="definition">test_negative</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.Test"><span class="id" title="constructor">Test</span></a> <a class="idref" href="Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>.<br/>

<br/>
<span class="id" title="keyword">Structure</span> <a id="NonPropType.type" class="idref" href="#NonPropType.type"><span class="id" title="record">type</span></a> :=<br/>
&nbsp;&nbsp;<a id="NonPropType.Check" class="idref" href="#NonPropType.Check"><span class="id" title="constructor">Check</span></a> {<a id="NonPropType.result" class="idref" href="#NonPropType.result"><span class="id" title="projection">result</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>; <a id="NonPropType.test" class="idref" href="#NonPropType.test"><span class="id" title="projection">test</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.test_of"><span class="id" title="record">test_of</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#result:134"><span class="id" title="method">result</span></a>; <a id="NonPropType.frame" class="idref" href="#NonPropType.frame"><span class="id" title="projection">frame</span></a> : <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.call_of"><span class="id" title="record">call_of</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#test:135"><span class="id" title="method">test</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#result:134"><span class="id" title="method">result</span></a>}.<br/>
<span class="id" title="keyword">Definition</span> <a id="NonPropType.check" class="idref" href="#NonPropType.check"><span class="id" title="definition">check</span></a> <a id="result:137" class="idref" href="#result:137"><span class="id" title="binder">result</span></a> <a id="test:138" class="idref" href="#test:138"><span class="id" title="binder">test</span></a> <a id="frame:139" class="idref" href="#frame:139"><span class="id" title="binder">frame</span></a> := @<a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.Check"><span class="id" title="constructor">Check</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#result:137"><span class="id" title="variable">result</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#test:138"><span class="id" title="variable">test</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#frame:139"><span class="id" title="variable">frame</span></a>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a id="NonPropType.Exports" class="idref" href="#NonPropType.Exports"><span class="id" title="module">Exports</span></a>.<br/>
<span class="id" title="keyword">Canonical</span> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.call"><span class="id" title="definition">call</span></a>.<br/>
<span class="id" title="keyword">Canonical</span> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.test_Prop"><span class="id" title="definition">test_Prop</span></a>.<br/>
<span class="id" title="keyword">Canonical</span> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.test_negative"><span class="id" title="definition">test_negative</span></a>.<br/>
<span class="id" title="keyword">Canonical</span> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.check"><span class="id" title="definition">check</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a id="NonPropType.Exports.nonPropType" class="idref" href="#NonPropType.Exports.nonPropType"><span class="id" title="abbreviation">nonPropType</span></a> := <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.type"><span class="id" title="record">type</span></a>.<br/>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.callee"><span class="id" title="projection">callee</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.callee"><span class="id" title="projection">:</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.callee"><span class="id" title="projection">call_of</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.callee"><span class="id" title="projection">&gt;-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.callee"><span class="id" title="projection">Sortclass</span></a>.<br/>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.frame"><span class="id" title="projection">frame</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.frame"><span class="id" title="projection">:</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.frame"><span class="id" title="projection">type</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.frame"><span class="id" title="projection">&gt;-&gt;</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.frame"><span class="id" title="projection">call_of</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a id="NonPropType.Exports.notProp" class="idref" href="#NonPropType.Exports.notProp"><span class="id" title="abbreviation">notProp</span></a> <span class="id" title="var">T</span> := (@<a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.check"><span class="id" title="definition">check</span></a> <a class="idref" href="Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.test_negative"><span class="id" title="definition">test_negative</span></a> (<a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.call"><span class="id" title="definition">call</span></a> <span class="id" title="var">T</span>)).<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType.Exports"><span class="id" title="module">Exports</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Coq.ssr.ssreflect.html#NonPropType"><span class="id" title="module">NonPropType</span></a>.<br/>
<span class="id" title="keyword">Export</span> <span class="id" title="var">NonPropType.Exports</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a id="ipat" class="idref" href="#ipat"><span class="id" title="module">ipat</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="69f87318111a06c23cf3b6c947249a45" class="idref" href="#69f87318111a06c23cf3b6c947249a45"><span class="id" title="notation">&quot;</span></a>'[' 'apply' ']'" := (<span class="id" title="keyword">ltac</span>:(<span class="id" title="keyword">let</span> <span class="id" title="var">f</span> := <span class="id" title="tactic">fresh</span> "_top_" <span class="id" title="tactic">in</span> <span class="id" title="tactic">move</span>=&gt; <span class="id" title="var">f</span> {}/<span class="id" title="var">f</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">ssripat_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="d18bf1e242aa8006719f115a8f44092e" class="idref" href="#d18bf1e242aa8006719f115a8f44092e"><span class="id" title="notation">&quot;</span></a>'[' 'swap' ']'" := (<span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">move</span>;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="keyword">lazymatch</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">forall</span> (<a id="x:141" class="idref" href="#x:141"><span class="id" title="binder">x</span></a> : <span class="id" title="var">_</span>), <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">fresh</span> <span class="id" title="var">x</span> | |- <span class="id" title="keyword">let</span> <a id="x:143" class="idref" href="#x:143"><span class="id" title="binder">x</span></a> := <span class="id" title="var">_</span> <span class="id" title="tactic">in</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">fresh</span> <span class="id" title="var">x</span> | <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">fresh</span> "_top_"<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="tactic">in</span> <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">move</span>;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">y</span> := <span class="id" title="keyword">lazymatch</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">forall</span> (<a id="y:145" class="idref" href="#y:145"><span class="id" title="binder">y</span></a> : <span class="id" title="var">_</span>), <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">fresh</span> <span class="id" title="var">y</span> | |- <span class="id" title="keyword">let</span> <a id="y:147" class="idref" href="#y:147"><span class="id" title="binder">y</span></a> := <span class="id" title="var">_</span> <span class="id" title="tactic">in</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">fresh</span> <span class="id" title="var">y</span> | <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">fresh</span> "_top_"<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="tactic">in</span> <span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="var">revert</span> <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">ssripat_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="a686f16c7fee28a2e0daca8726c6780b" class="idref" href="#a686f16c7fee28a2e0daca8726c6780b"><span class="id" title="notation">&quot;</span></a>'[' 'dup' ']'" := (<span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">move</span>;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">lazymatch</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| |- <span class="id" title="keyword">forall</span> (<a id="x:149" class="idref" href="#x:149"><span class="id" title="binder">x</span></a> : <span class="id" title="var">_</span>), <span class="id" title="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="tactic">fresh</span> <span class="id" title="var">x</span> <span class="id" title="tactic">in</span> <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">copy</span> := <span class="id" title="tactic">fresh</span> <span class="id" title="var">x</span> <span class="id" title="tactic">in</span> <span class="id" title="var">have</span> <span class="id" title="var">copy</span> := <span class="id" title="var">x</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="var">revert</span> <span class="id" title="var">copy</span><br/>
&nbsp;&nbsp;| |- <span class="id" title="keyword">let</span> <a id="x:151" class="idref" href="#x:151"><span class="id" title="binder">x</span></a> := <span class="id" title="var">_</span> <span class="id" title="tactic">in</span> <span class="id" title="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="tactic">fresh</span> <span class="id" title="var">x</span> <span class="id" title="tactic">in</span> <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">copy</span> := <span class="id" title="tactic">fresh</span> <span class="id" title="var">x</span> <span class="id" title="tactic">in</span> <span class="id" title="tactic">pose</span> <span class="id" title="var">copy</span> := <span class="id" title="var">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">do</span> [<span class="id" title="tactic">unfold</span> <span class="id" title="var">x</span> <span class="id" title="tactic">in</span> (<span class="id" title="var">value</span> <span class="id" title="keyword">of</span> <span class="id" title="var">copy</span>)]; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="var">revert</span> <span class="id" title="var">copy</span><br/>
&nbsp;&nbsp;| |- <span class="id" title="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="tactic">fresh</span> "_top_" <span class="id" title="tactic">in</span> <span class="id" title="tactic">move</span>=&gt; <span class="id" title="var">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">copy</span> := <span class="id" title="tactic">fresh</span> "_top" <span class="id" title="tactic">in</span> <span class="id" title="var">have</span> <span class="id" title="var">copy</span> := <span class="id" title="var">x</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="var">revert</span> <span class="id" title="var">copy</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">ssripat_scope</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Coq.ssr.ssreflect.html#ipat"><span class="id" title="module">ipat</span></a>.<br/>
</div>
    <div id="sidebarWrapper">
      <div id="sidebar">
        <div class="block">
          <h2 class="title">Navigation</h2>
          <div class="content">
            <ul class="menu">
              <li class="leaf">Standard Library
                <ul class="menu">
                  <li><a href="index.html">Table of contents</a></li>
                  <li><a href="genindex.html">Index</a></li>
                </ul>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>

  </div>

  <div id="footer">
    <div id="nav-footer">
      <ul class="links-menu-footer">
        <li><a href="mailto:coq-www_@_inria.fr">webmaster</a></li>
        <li><a href="http://validator.w3.org/">xhtml valid</a></li>
        <li><a href="http://jigsaw.w3.org/css-validator/">CSS valid</a></li>
      </ul>
    </div>
  </div>

</div>

</body>
</html>
