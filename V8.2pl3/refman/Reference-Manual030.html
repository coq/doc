<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Reference Manual | The Coq Proof Assistant</title>

<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<style type="text/css" media="all">@import "/modules/node/node.css";</style>

<style type="text/css" media="all">@import "/modules/system/defaults.css";</style>
<style type="text/css" media="all">@import "/modules/system/system.css";</style>
<style type="text/css" media="all">@import "/modules/user/user.css";</style>

<style type="text/css" media="all">@import "/sites/all/themes/coq/style.css";</style>
<style type="text/css" media="all">@import "/sites/all/themes/coq/coqdoc.css";</style>
<style type="text/css" media="all">@import "/sites/all/themes/coq/hevea.css";</style>
<TITLE>User defined equalities and relations</TITLE>
</HEAD>
<BODY >

<div id="container">
<div id="headertop">
<div id="nav">
  <ul class="links-menu">
    <li><a href="http://coq.inria.fr/" class="active">Home</a></li>

    <li><a href="http://coq.inria.fr/about-coq" title="More about coq">About Coq</a></li>    
    <li><a href="http://coq.inria.fr/download">Get Coq</a></li>
    <li><a href="http://coq.inria.fr/documentation">Documentation</a></li>
    <li><a href="http://coq.inria.fr/community">Community</a></li>
  </ul>
</div>
</div>

<div id="header">

<div id="logoWrapper">

<div id="logo"><a href="http://coq.inria.fr/" title="Home"><img src="/files/barron_logo.png" alt="Home" /></a>
</div>
<div id="siteName"><a href="http://coq.inria.fr/" title="Home">The Coq Proof Assistant</a>
</div>

</div>
</div>

<div id="content">

<H1 CLASS="chapter"><A NAME="htoc500">Chapter 24</A>  User defined equalities and relations</H1><UL>
<LI><A HREF="Reference-Manual030.html#toc156">Relations and morphisms</A>
</LI><LI><A HREF="Reference-Manual030.html#toc157">Adding new relations and morphisms</A>
</LI><LI><A HREF="Reference-Manual030.html#toc158">Rewriting and non reflexive relations</A>
</LI><LI><A HREF="Reference-Manual030.html#toc159">Rewriting and non symmetric relations</A>
</LI><LI><A HREF="Reference-Manual030.html#toc160">Rewriting in ambiguous setoid contexts</A>
</LI><LI><A HREF="Reference-Manual030.html#toc161">First class setoids and morphisms</A>
</LI><LI><A HREF="Reference-Manual030.html#toc162">Tactics enabled on user provided relations</A>
</LI><LI><A HREF="Reference-Manual030.html#toc163">Printing relations and morphisms</A>
</LI><LI><A HREF="Reference-Manual030.html#toc164">Deprecated syntax and backward incompatibilities</A>
</LI><LI><A HREF="Reference-Manual030.html#toc165">Rewriting under binders</A>
</LI><LI><A HREF="Reference-Manual030.html#toc166">Sub-relations</A>
</LI><LI><A HREF="Reference-Manual030.html#toc167">Constant unfolding</A>
</LI></UL>
<P>
<FONT SIZE=5><B>Matthieu Sozeau</B></FONT> <BR>
<BR>

<A NAME="@default892"></A><A NAME="@tactic194"></A>
<A NAME="setoid_replace"></A></P><P>This chapter presents the extension of several equality related tactics to
work over user-defined structures (called setoids) that are equipped with
ad-hoc equivalence relations meant to behave as equalities.
Actually, the tactics have also been generalized to relations weaker then
equivalences (e.g. rewriting systems).</P><P>This documentation is adapted from the previous setoid documentation by
Claudio Sacerdoti Coen (based on previous work by Clément Renard).
The new implementation is a drop-in replacement for the old one <SUP><A NAME="text33" HREF="#note33">1</A></SUP>, hence most of the documentation still applies.</P><P>The work is a complete rewrite of the previous implementation, based on
the type class infrastructure. It also improves on and generalizes
the previous implementation in several ways:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
User-extensible algorithm. The algorithm is separated in two
parts: generations of the rewriting constraints (done in ML) and
solving of these constraints using type class resolution. As type
class resolution is extensible using tactics, this allows users to define
general ways to solve morphism constraints.
</LI><LI CLASS="li-itemize">Sub-relations. An example extension to the base algorithm is the
ability to define one relation as a subrelation of another so that
morphism declarations on one relation can be used automatically for
the other. This is done purely using tactics and type class search.
</LI><LI CLASS="li-itemize">Rewriting under binders. It is possible to rewrite under binders
in the new implementation, if one provides the proper
morphisms. Again, most of the work is handled in the tactics.
</LI><LI CLASS="li-itemize">First-class morphisms and signatures. Signatures and morphisms are
ordinary Coq terms, hence they can be manipulated inside Coq, put
inside structures and lemmas about them can be proved inside the
system. Higher-order morphisms are also allowed.
</LI><LI CLASS="li-itemize">Performance. The implementation is based on a depth-first search for the first
solution to a set of constraints which can be as fast as linear in the
size of the term, and the size of the proof term is linear
in the size of the original term. Besides, the extensibility allows the
user to customize the proof-search if necessary.
</LI></UL><H2 CLASS="section"><A NAME="toc156"></A><A NAME="htoc501">24.1</A>  Relations and morphisms</H2><P>A parametric <EM>relation</EM> <TT>R</TT> is any term of type
<TT>forall (</TT><TT><I>x</I></TT><SUB><TT>1</TT></SUB><TT>:</TT><TT><I>T</I></TT><SUB><TT>1</TT></SUB><TT>) &#X2026;(</TT><TT><I>x</I></TT><SUB><TT><I>n</I></TT></SUB><TT>:</TT><TT><I>T</I></TT><SUB><TT><I>n</I></TT></SUB><TT>), relation </TT><TT><I>A</I></TT>. The
expression <I>A</I>, which depends on <I>x</I><SUB>1</SUB> &#X2026;<I>x</I><SUB><I>n</I></SUB>, is called the
<EM>carrier</EM> of the relation and <TT>R</TT> is
said to be a relation over <TT>A</TT>; the list <I>x</I><SUB>1</SUB>,&#X2026;,<I>x</I><SUB><I>n</I></SUB>
is the (possibly empty) list of parameters of the relation.</P><DIV CLASS="theorem"><B>Example 1</B> <B>(Parametric relation)</B>  <EM>
It is possible to implement finite sets of elements of type </EM><EM><TT>A</TT></EM><EM>
as unordered list of elements of type </EM><EM><TT>A</TT></EM><EM>. The function
</EM><EM><TT>set_eq: forall (A: Type), relation (list A)</TT></EM><EM> satisfied by two lists
with the same elements is a parametric relation over </EM><EM><TT>(list A)</TT></EM><EM> with
one parameter </EM><EM><TT>A</TT></EM><EM>. The type of </EM><EM><TT>set_eq</TT></EM><EM> is convertible with
</EM><EM><TT>forall (A: Type), list A -&gt; list A -&gt; Prop</TT></EM><EM>.
</EM></DIV><P>An <EM>instance</EM> of a parametric relation <TT>R</TT> with <I>n</I> parameters
is any term <TT>(R </TT><TT><I>t</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><TT><I>t</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT>.</P><P>Let <TT>R</TT> be a relation over <TT>A</TT> with <I>n</I> parameters.
A term is a parametric proof of reflexivity for <TT>R</TT> if it has type
<TT>forall (</TT><TT><I>x</I></TT><SUB><TT>1</TT></SUB><TT>:</TT><TT><I>T</I></TT><SUB><TT>1</TT></SUB><TT>) &#X2026;(</TT><TT><I>x</I></TT><SUB><TT><I>n</I></TT></SUB><TT>:</TT><TT><I>T</I></TT><SUB><TT><I>n</I></TT></SUB><TT>),
reflexive (R </TT><TT><I>x</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><TT><I>x</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT>. Similar definitions are given for
parametric proofs of symmetry and transitivity.</P><DIV CLASS="theorem"><B>Example 2</B> <B>(Parametric relation (cont.))</B>  <EM>
The </EM><EM><TT>set_eq</TT></EM><EM> relation of the previous example can be proved to be
reflexive, symmetric and transitive.
</EM></DIV><P>A parametric unary function <I>f</I> of type
<TT>forall (</TT><TT><I>x</I></TT><SUB><TT>1</TT></SUB><TT>:</TT><TT><I>T</I></TT><SUB><TT>1</TT></SUB><TT>) &#X2026;(</TT><TT><I>x</I></TT><SUB><TT><I>n</I></TT></SUB><TT>:</TT><TT><I>T</I></TT><SUB><TT><I>n</I></TT></SUB><TT>), </TT><TT><I>A</I></TT><SUB><TT>1</TT></SUB><TT> -&gt; </TT><TT><I>A</I></TT><SUB><TT>2</TT></SUB>
covariantly respects two parametric relation instances <I>R</I><SUB>1</SUB> and <I>R</I><SUB>2</SUB> if,
whenever <I>x</I>, <I>y</I> satisfy <I>R</I><SUB>1</SUB> <I>x</I> <I>y</I>, their images (<I>f</I> <I>x</I>) and (<I>f</I> <I>y</I>) 
satisfy <I>R</I><SUB>2</SUB> (<I>f</I> <I>x</I>) (<I>f</I> <I>y</I>) . An <I>f</I> that respects its input and output relations
will be called a unary covariant <EM>morphism</EM>. We can also say that <I>f</I> is
a monotone function with respect to <I>R</I><SUB>1</SUB> and <I>R</I><SUB>2</SUB>. 
The sequence <I>x</I><SUB>1</SUB>,&#X2026; <I>x</I><SUB><I>n</I></SUB> represents the parameters of the morphism.</P><P>Let <I>R</I><SUB>1</SUB> and <I>R</I><SUB>2</SUB> be two parametric relations.
The <EM>signature</EM> of a parametric morphism of type
<TT>forall (</TT><TT><I>x</I></TT><SUB><TT>1</TT></SUB><TT>:</TT><TT><I>T</I></TT><SUB><TT>1</TT></SUB><TT>) &#X2026;(</TT><TT><I>x</I></TT><SUB><TT><I>n</I></TT></SUB><TT>:</TT><TT><I>T</I></TT><SUB><TT><I>n</I></TT></SUB><TT>), </TT><TT><I>A</I></TT><SUB><TT>1</TT></SUB><TT> -&gt; </TT><TT><I>A</I></TT><SUB><TT>2</TT></SUB> that
covariantly respects two instances <I>I</I><SUB><I>R</I><SUB>1</SUB></SUB> and <I>I</I><SUB><I>R</I><SUB>2</SUB></SUB> of <I>R</I><SUB>1</SUB> and <I>R</I><SUB>2</SUB> is written <I>I</I><SUB><I>R</I><SUB>1</SUB></SUB> <TT>++&gt;</TT> <I>I</I><SUB><I>R</I><SUB>2</SUB></SUB>.
Notice that the special arrow <TT>++&gt;</TT>, which reminds the reader
of covariance, is placed between the two relation instances, not
between the two carriers. The signature relation instances and morphism will
be typed in a context introducing variables for the parameters.</P><P>The previous definitions are extended straightforwardly to <I>n</I>-ary morphisms,
that are required to be simultaneously monotone on every argument.</P><P>Morphisms can also be contravariant in one or more of their arguments.
A morphism is contravariant on an argument associated to the relation instance
<I>R</I> if it is covariant on the same argument when the inverse relation
<I>R</I><SUP>&#X2212;1</SUP> (<TT>inverse R</TT> in Coq) is considered. 
The special arrow <TT>--&gt;</TT> is used in signatures
for contravariant morphisms.</P><P>Functions having arguments related by symmetric relations instances are both
covariant and contravariant in those arguments. The special arrow
<TT>==&gt;</TT> is used in signatures for morphisms that are both covariant
and contravariant.</P><P>An instance of a parametric morphism <I>f</I> with <I>n</I> parameters is any term
<TT>f </TT><TT><I>t</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><TT><I>t</I></TT><SUB><TT><I>n</I></TT></SUB>.</P><DIV CLASS="theorem"><B>Example 3</B> <B>(Morphisms)</B>  <EM>
Continuing the previous example, let
</EM><EM><TT>union: forall (A: Type), list A -&gt; list A -&gt; list A</TT></EM><EM> perform the union
of two sets by appending one list to the other. </EM><EM><TT>union</TT></EM><EM> is a binary
morphism parametric over </EM><EM><TT>A</TT></EM><EM> that respects the relation instance
</EM><EM><TT>(set_eq A)</TT></EM><EM>. The latter condition is proved by showing
</EM><EM><TT>forall (A: Type) (S1 S1&#X2019; S2 S2&#X2019;: list A), set_eq A S1 S1&#X2019; -&gt;
set_eq A S2 S2&#X2019; -&gt; set_eq A (union A S1 S2) (union A S1&#X2019; S2&#X2019;)</TT></EM><EM>.</EM><P><EM>The signature of the function </EM><EM><TT>union A</TT></EM><EM> is
</EM><EM><TT>set_eq A ==&gt; set_eq A ==&gt; set_eq A</TT></EM><EM> for all </EM><EM><TT>A</TT></EM><EM>.
</EM></P></DIV><DIV CLASS="theorem"><B>Example 4</B> <B>(Contravariant morphism)</B>  <EM>
The division function </EM><EM><TT>Rdiv: R -&gt; R -&gt; R</TT></EM><EM> is a morphism of
signature </EM><EM><TT>le ++&gt; le --&gt; le</TT></EM><EM> where </EM><EM><TT>le</TT></EM><EM> is
the usual order relation over real numbers. Notice that division is
covariant in its first argument and contravariant in its second
argument.
</EM></DIV><P>Leibniz equality is a relation and every function is a
morphism that respects Leibniz equality. Unfortunately, Leibniz equality
is not always the intended equality for a given structure.</P><P>In the next section we will describe the commands to register terms as
parametric relations and morphisms. Several tactics that deal with equality
in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> can also work with the registered relations.
The exact list of tactic will be given in Sect. <A HREF="#setoidtactics">24.7</A>.
For instance, the
tactic <TT>reflexivity</TT> can be used to close a goal <I>R</I> <I>n</I> <I>n</I> whenever
<I>R</I> is an instance of a registered reflexive relation. However, the tactics
that replace in a context <I>C</I>[] one term with another one related by <I>R</I>
must verify that <I>C</I>[] is a morphism that respects the intended relation.
Currently the verification consists in checking whether <I>C</I>[] is a syntactic
composition of morphism instances that respects some obvious
compatibility constraints.</P><DIV CLASS="theorem"><B>Example 5</B> <B>(Rewriting)</B>  <EM>
Continuing the previous examples, suppose that the user must prove
</EM><EM><TT>set_eq int (union int (union int S1 S2) S2) (f S1 S2)</TT></EM><EM> under the
hypothesis </EM><EM><TT>H: set_eq int S2 (nil int)</TT></EM><EM>. It is possible to
use the </EM><EM><TT>rewrite</TT></EM><EM> tactic to replace the first two occurrences of
</EM><EM><TT>S2</TT></EM><EM> with </EM><EM><TT>nil int</TT></EM><EM> in the goal since the context
</EM><EM><TT>set_eq int (union int (union int S1 nil) nil) (f S1 S2)</TT></EM><EM>, being
a composition of morphisms instances, is a morphism. However the tactic
will fail replacing the third occurrence of </EM><EM><TT>S2</TT></EM><EM> unless </EM><EM><TT>f</TT></EM><EM>
has also been declared as a morphism.
</EM></DIV><H2 CLASS="section"><A NAME="toc157"></A><A NAME="htoc502">24.2</A>  Adding new relations and morphisms</H2><P>
A parametric relation
<I>Aeq</I><TT>: forall (</TT><TT><I>y</I></TT><SUB><TT>1</TT></SUB><TT> : &#X3B2;</TT><SUB><TT>!</TT></SUB><TT> &#X2026;</TT><TT><I>y</I></TT><SUB><TT><I>m</I></TT></SUB><TT> : &#X3B2;</TT><SUB><TT><I>m</I></TT></SUB><TT>), relation (A </TT><TT><I>t</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><TT><I>t</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT> over
<I>(A : </I><I>&#X3B1;</I><SUB><I><I>i</I></I></SUB><I> -&gt; &#X2026;</I><I>&#X3B1;</I><SUB><I><I>n</I></I></SUB><I> -&gt; </I><TT>Type</TT>)
can be declared with the following command:</P><P><A NAME="@default893"></A><A NAME="@command322"></A>
</P><BLOCKQUOTE CLASS="quote">
<TT>Add Parametric Relation</TT> (<I>x</I><SUB>1</SUB> : <I>T</I><SUB>1</SUB>) &#X2026;(<I>x</I><SUB><I>n</I></SUB> : <I>T</I><SUB><I>k</I></SUB>) :
<I>(A </I><I><I>t</I></I><SUB><I>1</I></SUB><I> &#X2026;</I><I><I>t</I></I><SUB><I><I>n</I></I></SUB><I>) (Aeq </I><I><I>t</I>&#X2032;</I><SUB><I>1</I></SUB><I> &#X2026;</I><I><I>t</I>&#X2032;</I><SUB><I><I>m</I></I></SUB><I>)</I><BR>
  <I><FONT COLOR=maroon>[</FONT></I><TT>reflexivity proved by</TT> <I>refl</I><I><FONT COLOR=maroon>]</FONT></I><BR>
  <I><FONT COLOR=maroon>[</FONT></I><TT>symmetry proved by</TT> <I>sym</I><I><FONT COLOR=maroon>]</FONT></I><BR>
  <I><FONT COLOR=maroon>[</FONT></I><TT>transitivity proved by</TT> <I>trans</I><I><FONT COLOR=maroon>]</FONT></I><BR>
 <TT> as</TT> <I>id</I>.
</BLOCKQUOTE><P>
after having required the <TT>Setoid</TT> module with the
<TT>Require Setoid</TT> command.</P><P>The identifier <I>id</I> gives a unique name to the morphism and it is
used by the command to generate fresh names for automatically provided lemmas
used internally.</P><P>Notice that the carrier and relation parameters may refer to the context 
of variables introduced at the beginning of the declaration, but the
instances need not be made only of variables.
Also notice that <I>A</I> is <EM>not</EM> required to be a term
having the same parameters as <I>Aeq</I>, although that is often the
case in practice (this departs from the previous implementation).</P><P><A NAME="@default894"></A><A NAME="@command323"></A>
In case the carrier and relations are not parametric, one can use the
command <TT>Add Relation</TT> instead, whose syntax is the same except
there is no local context.</P><P>The proofs of reflexivity, symmetry and transitivity can be omitted if the
relation is not an equivalence relation. The proofs must be instances of the
corresponding relation definitions: e.g. the proof of reflexivity must
have a type convertible to <TT>reflexive (A </TT><TT><I>t</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><TT><I>t</I></TT><SUB><TT><I>n</I></TT></SUB><TT>) (Aeq </TT><TT><I>t</I>&#X2032;</TT><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><TT><I>t</I>&#X2032;</TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT>. Each proof may refer to the introduced variables as well. </P><DIV CLASS="theorem"><B>Example 6</B> <B>(Parametric relation)</B>  <EM>
For leibniz equality, we may declare:
</EM><EM><TT>Add Parametric Relation (A : Type) :</TT></EM><EM> </EM><EM><TT>A (@eq A)</TT></EM><EM><BR>
 </EM><EM><I><FONT COLOR=maroon>[</FONT></I></EM><EM><TT>reflexivity proved by</TT></EM><EM> </EM><EM><TT>@refl_equal A</TT></EM><EM><I><FONT COLOR=maroon>]</FONT></I></EM><EM><BR>
&#X2026;</EM></DIV><P>Some tactics
(<TT>reflexivity</TT>, <TT>symmetry</TT>, <TT>transitivity</TT>) work only
on relations that respect the expected properties. The remaining tactics
(<TT>replace</TT>, <TT>rewrite</TT> and derived tactics such as
<TT>autorewrite</TT>) do not require any properties over the relation.
However, they are able to replace terms with related ones only in contexts
that are syntactic compositions of parametric morphism instances declared with
the following command.</P><P><A NAME="@default895"></A><A NAME="@command324"></A>
</P><BLOCKQUOTE CLASS="quote">
<TT>Add Parametric Morphism</TT> (<I>x</I><SUB>1</SUB> : <TT>T</TT><SUB>!</SUB>) &#X2026;(<I>x</I><SUB><I>k</I></SUB> : <TT>T</TT><SUB><I>k</I></SUB>)<BR>
 (<I>f </I><I><I>t</I></I><SUB><I>1</I></SUB><I> &#X2026;</I><I><I>t</I></I><SUB><I><I>n</I></I></SUB>)<BR>
 <TT> with signature</TT> <I>sig</I><BR>
 <TT> as id</TT>.<BR>
 <TT>Proof</TT><BR>
  &#X2026;<BR>
 <TT>Qed</TT>
</BLOCKQUOTE><P>The command declares <I>f</I> as a parametric morphism of signature
<I>sig</I>. The identifier <I>id</I> gives a unique name to the morphism
and it is used as the base name of the type class instance definition 
and as the name of the lemma that proves the well-definedness of the morphism.
The parameters of the morphism as well as the signature may refer to the
context of variables.
The command asks the user to prove interactively that <I>f</I> respects
the relations identified from the signature.</P><DIV CLASS="theorem"><B>Example 7</B>  <EM>
We start the example by assuming a small theory over homogeneous sets and
we declare set equality as a parametric equivalence relation and
union of two sets as a parametric morphism.
</EM><EM>
</EM><DIV CLASS="flushleft"><EM>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Require Export Setoid.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Require Export Relation_Definitions.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Set Implicit Arguments.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Parameter set: Type -</TT></EM><EM><TT>&gt;</TT></EM><EM><TT> Type.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Parameter empty: forall A, set A.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Parameter eq_set: forall A, set A -</TT></EM><EM><TT>&gt;</TT></EM><EM><TT> set A -</TT></EM><EM><TT>&gt;</TT></EM><EM><TT> Prop.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Parameter union: forall A, set A -</TT></EM><EM><TT>&gt;</TT></EM><EM><TT> set A -</TT></EM><EM><TT>&gt;</TT></EM><EM><TT> set A.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Axiom eq_set_refl: forall A, reflexive _ (eq_set (A:=A)).</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Axiom eq_set_sym: forall A, symmetric _ (eq_set (A:=A)).</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Axiom eq_set_trans: forall A, transitive _ (eq_set (A:=A)).</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Axiom empty_neutral: forall A (S: set A), eq_set (union S (empty A)) S.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Axiom union_compat:</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>  forall (A : Type),</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>   forall x x&#X2019; : set A, eq_set x x&#X2019; -</TT></EM><EM><TT>&gt;</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>   forall y y&#X2019; : set A, eq_set y y&#X2019; -</TT></EM><EM><TT>&gt;</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>    eq_set (union x y) (union x&#X2019; y&#X2019;).</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Add Parametric Relation A : (set A) (@eq_set A)</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>  reflexivity proved by (eq_set_refl (A:=A))</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>  symmetry proved by (eq_set_sym (A:=A))</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>  transitivity proved by (eq_set_trans (A:=A))</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>  as eq_set_rel.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Add Parametric Morphism A : (@union A) with </TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> signature (@eq_set A) ==</TT></EM><EM><TT>&gt;</TT></EM><EM><TT> (@eq_set A) ==</TT></EM><EM><TT>&gt;</TT></EM><EM><TT> (@eq_set A) as union_mor.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Proof. exact (@union_compat A). Qed.</TT></EM><EM><BR>
</EM></DIV><EM>
</EM></DIV><P>Is is possible to reduce the burden of specifying parameters using
(maximally inserted) implicit arguments. If <TT>A</TT> is always set as
maximally implicit in the previous example, one can write:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Add Parametric Relation A : (set A) eq_set</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  reflexivity proved by eq_set_refl</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  symmetry proved by eq_set_sym</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  transitivity proved by eq_set_trans</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  as eq_set_rel.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Add Parametric Morphism A : (@union A) with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   signature eq_set ==</TT><TT>&gt;</TT><TT> eq_set ==</TT><TT>&gt;</TT><TT> eq_set as union_mor.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof. exact (@union_compat A). Qed.</TT><BR>
</DIV><P>We proceed now by proving a simple lemma performing a rewrite step
and then applying reflexivity, as we would do working with Leibniz
equality. Both tactic applications are accepted
since the required properties over <TT>eq_set</TT> and
<TT>union</TT> can be established from the two declarations above.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall (S: set nat),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  eq_set (union (union S empty) S) (union S S).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof. intros. rewrite empty_neutral. reflexivity. Qed.</TT><BR>
</DIV><P>The tables of relations and morphisms are managed by the type class
instance mechanism. The behavior on section close is to generalize
the instances by the variables of the section (and possibly hypotheses
used in the proofs of instance declarations) but not to export them in
the rest of the development for proof search. One can use the
<TT>Existing Instance</TT> command to do so outside the section,
using the name of the declared morphism suffixed by <TT>_Morphism</TT>, 
or use the <TT>Global</TT> modifier for the corresponding class instance
declaration (see §<A HREF="#setoid:first-class">24.6</A>) at definition time.
When loading a compiled file or importing a module,
all the declarations of this module will be loaded.</P><H2 CLASS="section"><A NAME="toc158"></A><A NAME="htoc503">24.3</A>  Rewriting and non reflexive relations</H2><P>
To replace only one argument of an n-ary morphism it is necessary to prove
that all the other arguments are related to themselves by the respective
relation instances.</P><DIV CLASS="theorem"><B>Example 8</B>  <EM>
To replace </EM><EM><TT>(union S empty)</TT></EM><EM> with </EM><EM><TT>S</TT></EM><EM> in
</EM><EM><TT>(union (union S empty) S) (union S S)</TT></EM><EM> the rewrite tactic must
exploit the monotony of </EM><EM><TT>union</TT></EM><EM> (axiom </EM><EM><TT>union_compat</TT></EM><EM> in
the previous example). Applying </EM><EM><TT>union_compat</TT></EM><EM> by hand we are left
with the goal </EM><EM><TT>eq_set (union S S) (union S S)</TT></EM><EM>.
</EM></DIV><P>When the relations associated to some arguments are not reflexive, the tactic
cannot automatically prove the reflexivity goals, that are left to the user.</P><P>Setoids whose relation are partial equivalence relations (PER)
are useful to deal with partial functions. Let <TT>R</TT> be a PER. We say
that an element <TT>x</TT> is defined if <TT>R x x</TT>. A partial function
whose domain comprises all the defined elements only is declared as a
morphism that respects <TT>R</TT>. Every time a rewriting step is performed
the user must prove that the argument of the morphism is defined.</P><DIV CLASS="theorem"><B>Example 9</B>  <EM>
Let </EM><EM><TT>eqO</TT></EM><EM> be </EM><EM><TT>fun x y =&gt; x = y </TT></EM><EM><TT>&#X2227;</TT></EM><EM><TT>  x</TT></EM><EM><TT>&#X2260;</TT></EM><EM><TT> 0</TT></EM><EM> (the smaller PER over
non zero elements). Division can be declared as a morphism of signature
</EM><EM><TT>eq ==&gt; eq0 ==&gt; eq</TT></EM><EM>. Replace </EM><EM><TT>x</TT></EM><EM> with </EM><EM><TT>y</TT></EM><EM> in
</EM><EM><TT>div x n = div y n</TT></EM><EM> opens the additional goal </EM><EM><TT>eq0 n n</TT></EM><EM> that
is equivalent to </EM><EM><TT>n=n </TT></EM><EM><TT>&#X2227;</TT></EM><EM><TT> n</TT></EM><EM><TT>&#X2260;</TT></EM><EM><TT>0</TT></EM><EM>.
</EM></DIV><H2 CLASS="section"><A NAME="toc159"></A><A NAME="htoc504">24.4</A>  Rewriting and non symmetric relations</H2><P>
When the user works up to relations that are not symmetric, it is no longer
the case that any covariant morphism argument is also contravariant. As a
result it is no longer possible to replace a term with a related one in
every context, since the obtained goal implies the previous one if and
only if the replacement has been performed in a contravariant position.
In a similar way, replacement in an hypothesis can be performed only if
the replaced term occurs in a covariant position.</P><DIV CLASS="theorem"><B>Example 10</B> <B>(Covariance and contravariance)</B>  <EM>
Suppose that division over real numbers has been defined as a
morphism of signature </EM><EM><TT>Zdiv: Zlt ++&gt; Zlt --&gt; Zlt</TT></EM><EM> (i.e.
</EM><EM><TT>Zdiv</TT></EM><EM> is increasing in its first argument, but decreasing on the
second one). Let </EM><EM><TT>&lt;</TT></EM><EM> denotes </EM><EM><TT>Zlt</TT></EM><EM>. 
Under the hypothesis </EM><EM><TT>H: x &lt; y</TT></EM><EM> we have
</EM><EM><TT>k &lt; x / y -&gt; k &lt; x / x</TT></EM><EM>, but not
</EM><EM><TT>k &lt; y / x -&gt; k &lt; x / x</TT></EM><EM>.
Dually, under the same hypothesis </EM><EM><TT>k &lt; x / y -&gt; k &lt; y / y</TT></EM><EM> holds,
but </EM><EM><TT>k &lt; y / x -&gt; k &lt; y / y</TT></EM><EM> does not.
Thus, if the current goal is </EM><EM><TT>k &lt; x / x</TT></EM><EM>, it is possible to replace
only the second occurrence of </EM><EM><TT>x</TT></EM><EM> (in contravariant position)
with </EM><EM><TT>y</TT></EM><EM> since the obtained goal must imply the current one.
On the contrary, if </EM><EM><TT>k &lt; x / x</TT></EM><EM> is
an hypothesis, it is possible to replace only the first occurrence of
</EM><EM><TT>x</TT></EM><EM> (in covariant position) with </EM><EM><TT>y</TT></EM><EM> since
the current hypothesis must imply the obtained one.
</EM></DIV><P>Contrary to the previous implementation, no specific error message will
be raised when trying to replace a term that occurs in the wrong
position. It will only fail because the rewriting constraints are not
satisfiable. However it is possible to use the <TT>at</TT> modifier to
specify which occurences should be rewritten.</P><P>As expected, composing morphisms together propagates the variance annotations by
switching the variance every time a contravariant position is traversed.
</P><DIV CLASS="theorem"><B>Example 11</B>  <EM>
Let us continue the previous example and let us consider the goal
</EM><EM><TT>x / (x / x) &lt; k</TT></EM><EM>. The first and third occurrences of </EM><EM><TT>x</TT></EM><EM> are
in a contravariant position, while the second one is in covariant position.
More in detail, the second occurrence of </EM><EM><TT>x</TT></EM><EM> occurs
covariantly in </EM><EM><TT>(x / x)</TT></EM><EM> (since division is covariant in its first
argument), and thus contravariantly in </EM><EM><TT>x / (x / x)</TT></EM><EM> (since division
is contravariant in its second argument), and finally covariantly in
</EM><EM><TT>x / (x / x) &lt; k</TT></EM><EM> (since </EM><EM><TT>&lt;</TT></EM><EM>, as every transitive relation,
is contravariant in its first argument with respect to the relation itself).
</EM></DIV><H2 CLASS="section"><A NAME="toc160"></A><A NAME="htoc505">24.5</A>  Rewriting in ambiguous setoid contexts</H2><P>
One function can respect several different relations and thus it can be
declared as a morphism having multiple signatures.</P><DIV CLASS="theorem"><B>Example 12</B>  <EM>
Union over homogeneous lists can be given all the following signatures:
</EM><EM><TT>eq ==&gt; eq ==&gt; eq</TT></EM><EM> (</EM><EM><TT>eq</TT></EM><EM> being the equality over ordered lists)
</EM><EM><TT>set_eq ==&gt; set_eq ==&gt; set_eq</TT></EM><EM> (</EM><EM><TT>set_eq</TT></EM><EM> being the equality
over unordered lists up to duplicates),
</EM><EM><TT>multiset_eq ==&gt; multiset_eq ==&gt; multiset_eq</TT></EM><EM> (</EM><EM><TT>multiset_eq</TT></EM><EM>
being the equality over unordered lists).
</EM></DIV><P>To declare multiple signatures for a morphism, repeat the <TT>Add Morphism</TT>
command.</P><P>When morphisms have multiple signatures it can be the case that a rewrite
request is ambiguous, since it is unclear what relations should be used to
perform the rewriting. Contrary to the previous implementation, the
tactic will always choose the first possible solution to the set of
constraints generated by a rewrite and will not try to find <EM>all</EM>
possible solutions to warn the user about.</P><H2 CLASS="section"><A NAME="toc161"></A><A NAME="htoc506">24.6</A>  First class setoids and morphisms</H2><P>
<A NAME="setoid:first-class"></A></P><P>The implementation is based on a first-class representation of
properties of relations and morphisms as type classes. That is, 
the various combinations of properties on relations and morphisms 
are represented as records and instances of theses classes are put
in a hint database.
For example, the declaration:</P><BLOCKQUOTE CLASS="quote">
<TT>Add Parametric Relation</TT> (<I>x</I><SUB>1</SUB> : <I>T</I><SUB>1</SUB>) &#X2026;(<I>x</I><SUB><I>n</I></SUB> : <I>T</I><SUB><I>k</I></SUB>) :
<I>(A </I><I><I>t</I></I><SUB><I>1</I></SUB><I> &#X2026;</I><I><I>t</I></I><SUB><I><I>n</I></I></SUB><I>) (Aeq </I><I><I>t</I>&#X2032;</I><SUB><I>1</I></SUB><I> &#X2026;</I><I><I>t</I>&#X2032;</I><SUB><I><I>m</I></I></SUB><I>)</I><BR>
  <I><FONT COLOR=maroon>[</FONT></I><TT>reflexivity proved by</TT> <I>refl</I><I><FONT COLOR=maroon>]</FONT></I><BR>
  <I><FONT COLOR=maroon>[</FONT></I><TT>symmetry proved by</TT> <I>sym</I><I><FONT COLOR=maroon>]</FONT></I><BR>
  <I><FONT COLOR=maroon>[</FONT></I><TT>transitivity proved by</TT> <I>trans</I><I><FONT COLOR=maroon>]</FONT></I><BR>
 <TT> as</TT> <I>id</I>.
</BLOCKQUOTE><P>is equivalent to an instance declaration:</P><BLOCKQUOTE CLASS="quote">
<TT>Instance</TT> (<I>x</I><SUB>1</SUB> : <I>T</I><SUB>1</SUB>) &#X2026;(<I>x</I><SUB><I>n</I></SUB> : <I>T</I><SUB><I>k</I></SUB>) <TT>=&gt;</TT>
<I>id</I> : <TT>@Equivalence</TT> <I>(A </I><I><I>t</I></I><SUB><I>1</I></SUB><I> &#X2026;</I><I><I>t</I></I><SUB><I><I>n</I></I></SUB><I>) (Aeq
</I><I><I>t</I>&#X2032;</I><SUB><I>1</I></SUB><I> &#X2026;</I><I><I>t</I>&#X2032;</I><SUB><I><I>m</I></I></SUB><I>)</I> :=<BR>
  <I><FONT COLOR=maroon>[</FONT></I><TT>Equivalence_Reflexive :=</TT> <I>refl</I><I><FONT COLOR=maroon>]</FONT></I><BR>
  <I><FONT COLOR=maroon>[</FONT></I><TT>Equivalence_Symmetric :=</TT> <I>sym</I><I><FONT COLOR=maroon>]</FONT></I><BR>
  <I><FONT COLOR=maroon>[</FONT></I><TT>Equivalence_Transitive :=</TT> <I>trans</I><I><FONT COLOR=maroon>]</FONT></I>.
</BLOCKQUOTE><P>The declaration itself amounts to the definition of an object of the
record type <TT>Coq.Classes.RelationClasses.Equivalence</TT> and a
hint added to the <TT>typeclass_instances</TT> hint database. 
Morphism declarations are also instances of a type class defined in
<TT>Classes.Morphisms</TT>.
See the documentation on type classes <A HREF="Reference-Manual024.html#typeclasses">18</A> and 
the theories files in <TT>Classes</TT> for further explanations. </P><P>One can inform the rewrite tactic about morphisms and relations just by
using the typeclass metchanism to declare them using <TT>Instance</TT>
and <TT>Context</TT> vernacular commands.
Any object of type <TT>Morphism</TT> in the local context will also be
automatically used by the rewriting tactic to solve constraints.</P><P>Other representations of first class setoids and morphisms can also
be handled by encoding them as records. In the following example,
the projections of the setoid relation and of the morphism function 
can be registered as parametric relations and morphisms.
</P><DIV CLASS="theorem"><B>Example 13</B> <B>(First class setoids)</B>  <DIV CLASS="flushleft"><EM>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Require Import Relation_Definitions Setoid.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Record Setoid: Type :=</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> { car:Type;</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>   eq:car-</TT></EM><EM><TT>&gt;</TT></EM><EM><TT>car-</TT></EM><EM><TT>&gt;</TT></EM><EM><TT>Prop;</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>   refl: reflexive _ eq;</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>   sym: symmetric _ eq;</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>   trans: transitive _ eq</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> }.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Add Parametric Relation (s : Setoid) : (@car s) (@eq s)</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>  reflexivity proved by (refl s)</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>  symmetry proved by (sym s)</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>  transitivity proved by (trans s) as eq_rel.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Record Morphism (S1 S2:Setoid): Type :=</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> { f:car S1 -</TT></EM><EM><TT>&gt;</TT></EM><EM><TT>car S2;</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>   compat: forall (x1 x2: car S1), eq S1 x1 x2 -</TT></EM><EM><TT>&gt;</TT></EM><EM><TT> eq S2 (f x1) (f x2) }.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Add Parametric Morphism (S1 S2 : Setoid) (M : Morphism S1 S2) :</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>  (@f S1 S2 M) with signature (@eq S1 ==</TT></EM><EM><TT>&gt;</TT></EM><EM><TT> @eq S2) as apply_mor.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Proof. apply (compat S1 S2 M). Qed.</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Lemma test: forall (S1 S2:Setoid) (m: Morphism S1 S2)</TT></EM><EM><BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT>  (x y: car S1), eq S1 x y -</TT></EM><EM><TT>&gt;</TT></EM><EM><TT> eq S2 (f _ _ m x) (f _ _ m y).</TT></EM><EM><BR>
<BR>
</EM><EM><TT>Coq </TT></EM><EM><TT>&lt;</TT></EM><EM><TT> Proof. intros. rewrite H. reflexivity. Qed.</TT></EM><EM><BR>
</EM></DIV></DIV><H2 CLASS="section"><A NAME="toc162"></A><A NAME="htoc507">24.7</A>  Tactics enabled on user provided relations</H2><P>
<A NAME="setoidtactics"></A>
The following tactics, all prefixed by <TT>setoid_</TT>, 
deal with arbitrary
registered relations and morphisms. Moreover, all the corresponding unprefixed
tactics (i.e. <TT>reflexivity, symmetry, transitivity, replace, rewrite</TT>)
have been extended to fall back to their prefixed counterparts when
the relation involved is not Leibniz equality. Notice, however, that using
the prefixed tactics it is possible to pass additional arguments such as
<TT>using relation</TT>.
<BR>
</P><P><A NAME="@default896"></A><A NAME="@command325"></A>
<TT>setoid_reflexivity</TT></P><P><A NAME="@default897"></A><A NAME="@command326"></A>
<TT>setoid_symmetry</TT> <I><FONT COLOR=maroon>[</FONT></I><TT>in</TT> <I>ident</I><I><FONT COLOR=maroon>]</FONT></I></P><P><A NAME="@default898"></A><A NAME="@command327"></A>
<TT>setoid_transitivity</TT></P><P><A NAME="@default899"></A><A NAME="@command328"></A>
<TT>setoid_rewrite</TT> <I><FONT COLOR=maroon>[</FONT></I><I>orientation</I><I><FONT COLOR=maroon>]</FONT></I> <I>term</I>
 <I><FONT COLOR=maroon>[</FONT></I><TT>at</TT> <I>occs</I><I><FONT COLOR=maroon>]</FONT></I>  <I><FONT COLOR=maroon>[</FONT></I><TT>in</TT> <I>ident</I><I><FONT COLOR=maroon>]</FONT></I></P><P><A NAME="@default900"></A><A NAME="@command329"></A>
<TT>setoid_replace</TT> <I>term</I> <TT>with</TT> <I>term</I>
 <I><FONT COLOR=maroon>[</FONT></I><TT>in</TT> <I>ident</I><I><FONT COLOR=maroon>]</FONT></I>
 <I><FONT COLOR=maroon>[</FONT></I><TT>using relation</TT> <I>term</I><I><FONT COLOR=maroon>]</FONT></I>
 <I><FONT COLOR=maroon>[</FONT></I><TT>by</TT> <I>tactic</I><I><FONT COLOR=maroon>]</FONT></I>
<BR>
</P><P>The <TT>using relation</TT>
arguments cannot be passed to the unprefixed form. The latter argument
tells the tactic what parametric relation should be used to replace
the first tactic argument with the second one. If omitted, it defaults
to the <TT>DefaultRelation</TT> instance on the type of the objects.
By default, it means the most recent <TT>Equivalence</TT> instance in
the environment, but it can be customized by declaring new
<TT>DefaultRelation</TT> instances. As leiniz equality is a declared
equivalence, it will fall back to it if no other relation is declared on
a type.</P><P>Every derived tactic that is based on the unprefixed forms of the tactics
considered above will also work up to user defined relations. For instance,
it is possible to register hints for <TT>autorewrite</TT> that are
not proof of Leibniz equalities. In particular it is possible to exploit
<TT>autorewrite</TT> to simulate normalization in a term rewriting system
up to user defined equalities.</P><H2 CLASS="section"><A NAME="toc163"></A><A NAME="htoc508">24.8</A>  Printing relations and morphisms</H2><P>
The <TT>Print Instances</TT> command can be used to show the list of
currently registered <TT>Reflexive</TT> (using <TT>Print Instances Reflexive</TT>),
<TT>Symmetric</TT> or <TT>Transitive</TT> relations,
<TT>Equivalence</TT>s, <TT>PreOrder</TT>s, <TT>PER</TT>s, and
<TT>Morphism</TT>s. When the rewriting tactics refuse to replace a term in a context
because the latter is not a composition of morphisms, the <TT>Print Instances</TT>
commands can be useful to understand what additional morphisms should be
registered.</P><H2 CLASS="section"><A NAME="toc164"></A><A NAME="htoc509">24.9</A>  Deprecated syntax and backward incompatibilities</H2><P>
Due to backward compatibility reasons, the following syntax for the
declaration of setoids and morphisms is also accepted.</P><P><A NAME="@default901"></A><A NAME="@command330"></A>
</P><BLOCKQUOTE CLASS="quote">
<TT>Add Setoid</TT> <I>A Aeq ST</I> <TT>as</TT> <I>ident</I>
</BLOCKQUOTE><P>
where <I>Aeq</I> is a congruence relation without parameters,
<I>A</I> is its carrier and <I>ST</I> is an object of type
<TT>(Setoid_Theory A Aeq)</TT> (i.e. a record packing together the reflexivity,
symmetry and transitivity lemmas). Notice that the syntax is not completely
backward compatible since the identifier was not required.</P><P><A NAME="@default902"></A><A NAME="@command331"></A>
</P><BLOCKQUOTE CLASS="quote">
<TT>Add Morphism</TT> <I>f</I>:<I>ident</I>.<BR>
 Proof.<BR>
 &#X2026;<BR>
 Qed.
</BLOCKQUOTE><P>The latter command also is restricted to the declaration of morphisms without
parameters. It is not fully backward compatible since the property the user
is asked to prove is slightly different: for <I>n</I>-ary morphisms the hypotheses
of the property are permuted; moreover, when the morphism returns a
proposition, the property is now stated using a bi-implication in place of
a simple implication. In practice, porting an old development to the new
semantics is usually quite simple.</P><P>Notice that several limitations of the old implementation have been lifted.
In particular, it is now possible to declare several relations with the
same carrier and several signatures for the same morphism. Moreover, it is
now also possible to declare several morphisms having the same signature.
Finally, the replace and rewrite tactics can be used to replace terms in
contexts that were refused by the old implementation. As discussed in
the next section, the semantics of the new <TT>setoid_rewrite</TT>
command differs slightly from the old one and <TT>rewrite</TT>.</P><H2 CLASS="section"><A NAME="toc165"></A><A NAME="htoc510">24.10</A>  Rewriting under binders</H2><P><B>Warning</B>: Due to compatibility issues, this feature is enabled only when calling 
the <TT>setoid_rewrite</TT> tactics directly and not <TT>rewrite</TT>.</P><P>To be able to rewrite under binding constructs, one must declare
morphisms with respect to pointwise (setoid) equivalence of functions. 
Example of such morphisms are the standard <TT>all</TT> and <TT>ex</TT>
combinators for universal and existential quantification respectively. 
They are declared as morphisms in the <TT>Classes.Morphisms_Prop</TT>
module. For example, to declare that universal quantification is a
morphism for logical equivalence:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Instance all_iff_morphism (A : Type) :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Morphism (pointwise_relation A iff ==</TT><TT>&gt;</TT><TT> iff) (@all A).</TT><BR>
<TT><I>Toplevel input, characters 51-83:</I></TT><BR>
<TT><I>&gt;</I></TT><TT><I>   Morphism (pointwise_relation A iff ==</I></TT><TT><I>&gt;</I></TT><TT><I> iff) (@all A).</I></TT><BR>
<TT><I>&gt;</I></TT><TT><I>             </I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><BR>
<TT><I>Error: Unknown interpretation for notation "_ ==</I></TT><TT><I>&gt;</I></TT><TT><I> _".</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof. simpl_relation. </TT><BR>
<TT><I>Error: Unknown command of the non proof-editing mode.</I></TT><BR>
<TT><I>Error: Unknown command of the non proof-editing mode.</I></TT><BR>
</DIV><P>One then has to show that if two predicates are equivalent at every
point, their universal quantifications are equivalent. Once we have
declared such a morphism, it will be used by the setoid rewriting tactic
each time we try to rewrite under an <TT>all</TT> application (products
in <FONT COLOR=purple>Prop</FONT> are implicitely translated to such applications).</P><P>Indeed, when rewriting under a lambda, binding variable <I>x</I>, say from
<I>P</I> <I>x</I> to <I>Q</I> <I>x</I> using the relation <TT>iff</TT>, the tactic will generate
a proof of <TT>pointwise_relation A iff (fun x =&gt; P x) (fun x =&gt; Q
x)</TT> from the proof of <TT>iff (P x) (Q x)</TT> and a constraint of the
form <TT>Morphism (pointwise_relation A iff ==&gt; ?) m</TT> will be
generated for the surrounding morphism <TT>m</TT>.</P><P>Hence, one can add higher-order combinators as morphisms by providing
signatures using pointwise extension for the relations on the functional
arguments (or whatever subrelation of the pointwise extension).
For example, one could declare the <TT>map</TT> combinator on lists as 
a morphism:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Instance map_morphism &#X2018;{Equivalence A eqA, Equivalence B eqB} :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Morphism ((eqA ==</TT><TT>&gt;</TT><TT> eqB) ==</TT><TT>&gt;</TT><TT> list_equiv eqA ==</TT><TT>&gt;</TT><TT> list_equiv eqB) </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>      (@map A B).</TT><BR>
</DIV><P>where <TT>list_equiv</TT> implements an equivalence on lists
parameterized by an equivalence on the elements.</P><P>Note that when one does rewriting with a lemma under a binder
using <TT>setoid_rewrite</TT>, the application of the lemma may capture
the bound variable, as the semantics are different from rewrite where
the lemma is first matched on the whole term. With the new
<TT>setoid_rewrite</TT>, matching is done on each subterm separately
and in its local environment, and all matches are rewritten
<EM>simultaneously</EM> by default. The semantics of the previous
<TT>setoid_rewrite</TT> implementation can almost be recovered using
the <TT>at 1</TT> modifier.</P><H2 CLASS="section"><A NAME="toc166"></A><A NAME="htoc511">24.11</A>  Sub-relations</H2><P>Sub-relations can be used to specify that one relation is included in
another, so that morphisms signatures for one can be used for the other.
If a signature mentions a relation <I>R</I> on the left of an arrow
<TT>==&gt;</TT>, then the signature also applies for any relation <I>S</I> that
is smaller than <I>R</I>, and the inverse applies on the right of an arrow. 
One can then declare only a few morphisms instances that generate the complete set
of signatures for a particular constant. By default, the only declared
subrelation is <TT>iff</TT>, which is a subrelation of <TT>impl</TT>
and <TT>inverse impl</TT> (the dual of implication). That&#X2019;s why we can
declare only two morphisms for conjunction:
<TT>Morphism (impl ==&gt; impl ==&gt; impl) and</TT> and 
<TT>Morphism (iff ==&gt; iff ==&gt; iff) and</TT>. This is sufficient to satisfy
any rewriting constraints arising from a rewrite using <TT>iff</TT>,
<TT>impl</TT> or <TT>inverse impl</TT> through <TT>and</TT>.</P><P>Sub-relations are implemented in <TT>Classes.Morphisms</TT> and are a 
prime example of a mostly user-space extension of the algorithm.</P><H2 CLASS="section"><A NAME="toc167"></A><A NAME="htoc512">24.12</A>  Constant unfolding</H2><P>The resolution tactic is based on type classes and hence regards user-defined 
constants as transparent by default. This may slow down the resolution
due to a lot of unifications (all the declared <TT>Morphism</TT>
instances are tried at each node of the search tree).
To speed it up, declare your constant as rigid for proof search
using the command <TT>Typeclasses Opaque</TT> (see §<A HREF="Reference-Manual024.html#TypeclassesTransparency">18.5.4</A>).</P><HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note33" HREF="#text33">1</A></DT><DD CLASS="dd-thefootnotes">Nicolas
Tabareau helped with the glueing
</DD></DL>

<div id="sidebarWrapper">
<div id="sidebar">

<div class="block">
<h2 class="title">Navigation</h2>
<div class="content">

<ul class="menu">

<li class="leaf"><a href="index.html">Cover</a></li>
<li class="leaf"><a href="toc.html">Table of contents</a></li>
<li class="leaf">Index
  <ul class="menu">
  <li><a href="general-index.html">General</a></li>
  <li><a href="command-index.html">Commands</a></li>
  <li><a href="tactic-index.html">Tactics</a></li>
  <li><a href="error-index.html">Errors</a></li>
  </ul>
</li>

</ul>

</div>
</div>

</div>
</div>


</div>

</div>

<div id="footer">
<div id="nav-footer">
  <ul class="links-menu-footer">
    <li><a href="mailto:www-coq at lix.polytechnique.fr">webmaster</a></li>
    <li><a href="http://validator.w3.org/check?uri=referer">xhtml valid</a></li>
    <li><a href="http://jigsaw.w3.org/css-validator/check/referer">CSS valid</a></li>
  </ul>

</div>
</div>

</div>
</BODY>
</HTML>
