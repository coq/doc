<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ssrmatching (coq.Ssrmatching_plugin.Ssrmatching)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">coq</a> &#x00BB; <a href="../index.html">Ssrmatching_plugin</a> &#x00BB; Ssrmatching</nav><h1>Module <code>Ssrmatching_plugin.Ssrmatching</code></h1></header><aside><p>******** Small Scale Reflection pattern matching facilities *************</p></aside><aside><p>Pattern parsing</p></aside><dl><dt class="spec type" id="type-cpattern"><a href="#type-cpattern" class="anchor"></a><code><span class="keyword">type</span> cpattern</code></dt><dd><p>The type of context patterns, the patterns of the <code>set</code> tactic and <code>:</code> tactical. These are patterns that identify a precise subterm.</p></dd></dl><dl><dt class="spec value" id="val-pr_cpattern"><a href="#val-pr_cpattern" class="anchor"></a><code><span class="keyword">val</span> pr_cpattern : <a href="index.html#type-cpattern">cpattern</a> <span>&#45;&gt;</span> <a href="../../Pp/index.html#type-t">Pp.t</a></code></dt></dl><dl><dt class="spec type" id="type-rpattern"><a href="#type-rpattern" class="anchor"></a><code><span class="keyword">type</span> rpattern</code></dt><dd><p>The type of rewrite patterns, the patterns of the <code>rewrite</code> tactic. These patterns also include patterns that identify all the subterms of a context (i.e. &quot;in&quot; prefix)</p></dd></dl><dl><dt class="spec value" id="val-pr_rpattern"><a href="#val-pr_rpattern" class="anchor"></a><code><span class="keyword">val</span> pr_rpattern : <a href="index.html#type-rpattern">rpattern</a> <span>&#45;&gt;</span> <a href="../../Pp/index.html#type-t">Pp.t</a></code></dt></dl><aside><p>Pattern interpretation and matching</p></aside><dl><dt class="spec exception" id="exception-NoMatch"><a href="#exception-NoMatch" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">NoMatch</span></code></dt><dt class="spec exception" id="exception-NoProgress"><a href="#exception-NoProgress" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">NoProgress</span></code></dt></dl><dl><dt class="spec type" id="type-ssrpattern"><a href="#type-ssrpattern" class="anchor"></a><code><span class="keyword">type</span> <span>('ident, 'term) ssrpattern</span></code><code> = </code><table class="variant"><tr id="type-ssrpattern.T" class="anchored"><td class="def constructor"><a href="#type-ssrpattern.T" class="anchor"></a><code>| </code><code><span class="constructor">T</span> <span class="keyword">of</span> <span class="type-var">'term</span></code></td></tr><tr id="type-ssrpattern.In_T" class="anchored"><td class="def constructor"><a href="#type-ssrpattern.In_T" class="anchor"></a><code>| </code><code><span class="constructor">In_T</span> <span class="keyword">of</span> <span class="type-var">'term</span></code></td></tr><tr id="type-ssrpattern.X_In_T" class="anchored"><td class="def constructor"><a href="#type-ssrpattern.X_In_T" class="anchor"></a><code>| </code><code><span class="constructor">X_In_T</span> <span class="keyword">of</span> <span class="type-var">'ident</span> * <span class="type-var">'term</span></code></td></tr><tr id="type-ssrpattern.In_X_In_T" class="anchored"><td class="def constructor"><a href="#type-ssrpattern.In_X_In_T" class="anchor"></a><code>| </code><code><span class="constructor">In_X_In_T</span> <span class="keyword">of</span> <span class="type-var">'ident</span> * <span class="type-var">'term</span></code></td></tr><tr id="type-ssrpattern.E_In_X_In_T" class="anchored"><td class="def constructor"><a href="#type-ssrpattern.E_In_X_In_T" class="anchor"></a><code>| </code><code><span class="constructor">E_In_X_In_T</span> <span class="keyword">of</span> <span class="type-var">'term</span> * <span class="type-var">'ident</span> * <span class="type-var">'term</span></code></td></tr><tr id="type-ssrpattern.E_As_X_In_T" class="anchored"><td class="def constructor"><a href="#type-ssrpattern.E_As_X_In_T" class="anchor"></a><code>| </code><code><span class="constructor">E_As_X_In_T</span> <span class="keyword">of</span> <span class="type-var">'term</span> * <span class="type-var">'ident</span> * <span class="type-var">'term</span></code></td></tr></table></dt><dd><p>AST for <code>rpattern</code> (and consequently <code>cpattern</code>)</p></dd></dl><dl><dt class="spec type" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span class="keyword">type</span> pattern</code><code> = <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <span><span>(<a href="../../Constr/index.html#type-constr">Constr.constr</a>, <a href="../../Constr/index.html#type-constr">Constr.constr</a>)</span> <a href="index.html#type-ssrpattern">ssrpattern</a></span></code></dt></dl><dl><dt class="spec value" id="val-pp_pattern"><a href="#val-pp_pattern" class="anchor"></a><code><span class="keyword">val</span> pp_pattern : <a href="../../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a> <span>&#45;&gt;</span> <a href="../../Pp/index.html#type-t">Pp.t</a></code></dt><dt class="spec value" id="val-redex_of_pattern"><a href="#val-redex_of_pattern" class="anchor"></a><code><span class="keyword">val</span> redex_of_pattern : <span>?&#8288;resolve_typeclasses:bool</span> <span>&#45;&gt;</span> <a href="../../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a> <span>&#45;&gt;</span> <span><a href="../../Constr/index.html#type-constr">Constr.constr</a> <a href="../../Evd/index.html#type-in_evar_universe_context">Evd.in_evar_universe_context</a></span></code></dt><dd><p>Extracts the redex and applies to it the substitution part of the pattern.</p><dl><dt>raises Anomaly</dt><dd><p>if called on <code>In_T</code> or <code>In_X_In_T</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-interp_rpattern"><a href="#val-interp_rpattern" class="anchor"></a><code><span class="keyword">val</span> interp_rpattern : <span><a href="../../Goal/index.html#type-goal">Goal.goal</a> <a href="../../Evd/index.html#type-sigma">Evd.sigma</a></span> <span>&#45;&gt;</span> <a href="index.html#type-rpattern">rpattern</a> <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a></code></dt><dd><p><code>interp_rpattern ise gl rpat</code> &quot;internalizes&quot; and &quot;interprets&quot; <code>rpat</code> in the current <code>Ltac</code> interpretation signature <code>ise</code> and tactic input <code>gl</code></p></dd></dl><dl><dt class="spec value" id="val-interp_cpattern"><a href="#val-interp_cpattern" class="anchor"></a><code><span class="keyword">val</span> interp_cpattern : <span><a href="../../Goal/index.html#type-goal">Goal.goal</a> <a href="../../Evd/index.html#type-sigma">Evd.sigma</a></span> <span>&#45;&gt;</span> <a href="index.html#type-cpattern">cpattern</a> <span>&#45;&gt;</span> <span><span>(<a href="../../Genintern/index.html#type-glob_constr_and_expr">Genintern.glob_constr_and_expr</a> * <a href="../../Geninterp/index.html#type-interp_sign">Geninterp.interp_sign</a>)</span> option</span> <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a></code></dt><dd><p><code>interp_cpattern ise gl cpat ty</code> &quot;internalizes&quot; and &quot;interprets&quot; <code>cpat</code> in the current <code>Ltac</code> interpretation signature <code>ise</code> and tactic input <code>gl</code>. <code>ty</code> is an optional type for the redex of <code>cpat</code></p></dd></dl><dl><dt class="spec type" id="type-occ"><a href="#type-occ" class="anchor"></a><code><span class="keyword">type</span> occ</code><code> = <span><span>(bool * <span>int list</span>)</span> option</span></code></dt><dd><p>The set of occurrences to be matched. The boolean is set to true * to signal the complement of this set (i.e. {-1 3})</p></dd></dl><dl><dt class="spec type" id="type-subst"><a href="#type-subst" class="anchor"></a><code><span class="keyword">type</span> subst</code><code> = <a href="../../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>subst e p t i</code>. <code>i</code> is the number of binders traversed so far, <code>p</code> the term from the pattern, <code>t</code> the matched one</p></dd></dl><dl><dt class="spec value" id="val-eval_pattern"><a href="#val-eval_pattern" class="anchor"></a><code><span class="keyword">val</span> eval_pattern : <span>?&#8288;raise_NoMatch:bool</span> <span>&#45;&gt;</span> <a href="../../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <span><a href="index.html#type-pattern">pattern</a> option</span> <span>&#45;&gt;</span> <a href="index.html#type-occ">occ</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>eval_pattern b env sigma t pat occ subst</code> maps <code>t</code> calling <code>subst</code> on every <code>occ</code> occurrence of <code>pat</code>. The <code>int</code> argument is the number of binders traversed. If <code>pat</code> is <code>None</code> then then subst is called on <code>t</code>. <code>t</code> must live in <code>env</code> and <code>sigma</code>, <code>pat</code> must have been interpreted in (an extension of) <code>sigma</code>.</p><dl><dt>raises NoMatch</dt><dd><p>if <code>pat</code> has no occurrence and <code>b</code> is <code>true</code> (default <code>false</code>)</p></dd></dl><dl><dt>returns</dt><dd><p><code>t</code> where all <code>occ</code> occurrences of <code>pat</code> have been mapped using <code>subst</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fill_occ_pattern"><a href="#val-fill_occ_pattern" class="anchor"></a><code><span class="keyword">val</span> fill_occ_pattern : <span>?&#8288;raise_NoMatch:bool</span> <span>&#45;&gt;</span> <a href="../../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="index.html#type-pattern">pattern</a> <span>&#45;&gt;</span> <a href="index.html#type-occ">occ</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="../../Constr/index.html#type-constr">Constr.constr</a> <a href="../../Evd/index.html#type-in_evar_universe_context">Evd.in_evar_universe_context</a></span> * <a href="../../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>fill_occ_pattern b env sigma t pat occ h</code> is a simplified version of <code>eval_pattern</code>. It replaces all <code>occ</code> occurrences of <code>pat</code> in <code>t</code> with Rel <code>h</code>. <code>t</code> must live in <code>env</code> and <code>sigma</code>, <code>pat</code> must have been interpreted in (an extension of) <code>sigma</code>.</p><dl><dt>raises NoMatch</dt><dd><p>if <code>pat</code> has no occurrence and <code>b</code> is <code>true</code> (default <code>false</code>)</p></dd></dl><dl><dt>returns</dt><dd><p>the instance of the redex of <code>pat</code> that was matched and <code>t</code> transformed as described above.</p></dd></dl></dd></dl><aside><p>*************************** Low level APIs ******************************</p></aside><dl><dt class="spec type" id="type-ssrdir"><a href="#type-ssrdir" class="anchor"></a><code><span class="keyword">type</span> ssrdir</code><code> = </code><table class="variant"><tr id="type-ssrdir.L2R" class="anchored"><td class="def constructor"><a href="#type-ssrdir.L2R" class="anchor"></a><code>| </code><code><span class="constructor">L2R</span></code></td></tr><tr id="type-ssrdir.R2L" class="anchored"><td class="def constructor"><a href="#type-ssrdir.R2L" class="anchor"></a><code>| </code><code><span class="constructor">R2L</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-pr_dir_side"><a href="#val-pr_dir_side" class="anchor"></a><code><span class="keyword">val</span> pr_dir_side : <a href="index.html#type-ssrdir">ssrdir</a> <span>&#45;&gt;</span> <a href="../../Pp/index.html#type-t">Pp.t</a></code></dt></dl><dl><dt class="spec type" id="type-tpattern"><a href="#type-tpattern" class="anchor"></a><code><span class="keyword">type</span> tpattern</code></dt><dd><p>a pattern for a term with wildcards</p></dd></dl><dl><dt class="spec value" id="val-mk_tpattern"><a href="#val-mk_tpattern" class="anchor"></a><code><span class="keyword">val</span> mk_tpattern : <span>?&#8288;p_origin:<span>(<a href="index.html#type-ssrdir">ssrdir</a> * <a href="../../Constr/index.html#type-constr">Constr.constr</a>)</span></span> <span>&#45;&gt;</span> <a href="../../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <span>(<a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../../Constr/index.html#type-constr">Constr.constr</a>)</span> <span>&#45;&gt;</span> <span>(<a href="../../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-ssrdir">ssrdir</a> <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="index.html#type-tpattern">tpattern</a></code></dt><dd><p><code>mk_tpattern env sigma0 sigma_p ok p_origin dir t</code> compiles a term <code>t</code> living in <code>env</code> <code>sigma</code> (an extension of <code>sigma0</code>) intro a <code>tpattern</code>. The <code>tpattern</code> can hold a (proof) term <code>p</code> and a diction <code>dir</code>. The <code>ok</code> callback is used to filter occurrences.</p><dl><dt>returns</dt><dd><p>the compiled <code>tpattern</code> and its <code>evar_map</code></p></dd></dl><dl><dt>raises UserEerror</dt><dd><p>is the pattern is a wildcard</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-find_P"><a href="#type-find_P" class="anchor"></a><code><span class="keyword">type</span> find_P</code><code> = <a href="../../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>k:<a href="index.html#type-subst">subst</a></span> <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a></code></dt><dd><p><code>findP env t i k</code> is a stateful function that finds the next occurrence of a tpattern and calls the callback <code>k</code> to map the subterm matched. The <code>int</code> argument passed to <code>k</code> is the number of binders traversed so far plus the initial value <code>i</code>.</p><dl><dt>returns</dt><dd><p><code>t</code> where the subterms identified by the selected occurrences of the patter have been mapped using <code>k</code></p></dd></dl><dl><dt>raises NoMatch</dt><dd><p>if the raise_NoMatch flag given to <code>mk_tpattern_matcher</code> is <code>true</code> and if the pattern did not match</p></dd></dl><dl><dt>raises UserEerror</dt><dd><p>if the raise_NoMatch flag given to <code>mk_tpattern_matcher</code> is <code>false</code> and if the pattern did not match</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-conclude"><a href="#type-conclude" class="anchor"></a><code><span class="keyword">type</span> conclude</code><code> = unit <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a> * <a href="index.html#type-ssrdir">ssrdir</a> * <span>(<a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../../UState/index.html#type-t">UState.t</a> * <a href="../../Constr/index.html#type-constr">Constr.constr</a>)</span></code></dt><dd><p><code>conclude ()</code> asserts that all mentioned occurrences have been visited.</p><dl><dt>returns</dt><dd><p>the instance of the pattern, the evarmap after the pattern instantiation, the proof term and the ssrdit stored in the tpattern</p></dd></dl><dl><dt>raises UserEerror</dt><dd><p>if too many occurrences were specified</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mk_tpattern_matcher"><a href="#val-mk_tpattern_matcher" class="anchor"></a><code><span class="keyword">val</span> mk_tpattern_matcher : <span>?&#8288;all_instances:bool</span> <span>&#45;&gt;</span> <span>?&#8288;raise_NoMatch:bool</span> <span>&#45;&gt;</span> <span>?&#8288;upats_origin:<span>(<a href="index.html#type-ssrdir">ssrdir</a> * <a href="../../Constr/index.html#type-constr">Constr.constr</a>)</span></span> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="index.html#type-occ">occ</a> <span>&#45;&gt;</span> <span>(<a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <span><a href="index.html#type-tpattern">tpattern</a> list</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-find_P">find_P</a> * <a href="index.html#type-conclude">conclude</a></code></dt><dd><p><code>mk_tpattern_matcher b o sigma0 occ sigma_tplist</code> creates a pair a function <code>find_P</code> and <code>conclude</code> with the behaviour explained above. The flag <code>b</code> (default <code>false</code>) changes the error reporting behaviour of <code>find_P</code> if none of the <code>tpattern</code> matches. The argument <code>o</code> can be passed to tune the <code>UserError</code> eventually raised (useful if the pattern is coming from the LHS/RHS of an equation)</p></dd></dl><aside><p>Example of <code>mk_tpattern_matcher</code> to implement <code>rewrite \{occ\}[in t]rules</code>. It first matches &quot;in t&quot; (called <code>pat</code>), then in all matched subterms it matches the LHS of the rules using <code>find_R</code>. <code>concl0</code> is the initial goal, <code>concl</code> will be the goal where some terms are replaced by a De Bruijn index. The <code>rw_progress</code> extra check selects only occurrences that are not rewritten to themselves (e.g. an occurrence &quot;x + x&quot; rewritten with the commutativity law of addition is skipped) </p><pre><code class="ml">let find_R, conclude = match pat with
| Some (_, In_T _) -&gt;
    let aux (sigma, pats) (d, r, lhs, rhs) =
      let sigma, pat = 
        mk_tpattern env0 sigma0 (sigma, r) (rw_progress rhs) d lhs in
      sigma, pats @ [pat] in
    let rpats = List.fold_left aux (r_sigma, []) rules in
    let find_R, end_R = mk_tpattern_matcher sigma0 occ rpats in
    find_R ~k:(fun _ _ h -&gt; mkRel h), 
    fun cl -&gt; let rdx, d, r = end_R () in (d,r),rdx
| _ -&gt; ... in
let concl = eval_pattern env0 sigma0 concl0 pat occ find_R in
let (d, r), rdx = conclude concl in </code></pre></aside><dl><dt class="spec value" id="val-pf_fill_occ_term"><a href="#val-pf_fill_occ_term" class="anchor"></a><code><span class="keyword">val</span> pf_fill_occ_term : <span><a href="../../Goal/index.html#type-goal">Goal.goal</a> <a href="../../Evd/index.html#type-sigma">Evd.sigma</a></span> <span>&#45;&gt;</span> <a href="index.html#type-occ">occ</a> <span>&#45;&gt;</span> <span>(<a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a>)</span> <span>&#45;&gt;</span> <a href="../../EConstr/index.html#type-t">EConstr.t</a> * <a href="../../EConstr/index.html#type-t">EConstr.t</a></code></dt><dt class="spec value" id="val-cpattern_of_term"><a href="#val-cpattern_of_term" class="anchor"></a><code><span class="keyword">val</span> cpattern_of_term : <span>(char * <a href="../../Genintern/index.html#type-glob_constr_and_expr">Genintern.glob_constr_and_expr</a>)</span> <span>&#45;&gt;</span> <a href="../../Geninterp/index.html#type-interp_sign">Geninterp.interp_sign</a> <span>&#45;&gt;</span> <a href="index.html#type-cpattern">cpattern</a></code></dt></dl><aside><p>Helpers to make stateful closures. Example: a <code>find_P</code> function may be called many times, but the pattern instantiation phase is performed only the first time. The corresponding <code>conclude</code> has to return the instantiated pattern redex. Since it is up to <code>find_P</code> to raise <code>NoMatch</code> if the pattern has no instance, <code>conclude</code> considers it an anomaly if the pattern did not match</p></aside><dl><dt class="spec value" id="val-do_once"><a href="#val-do_once" class="anchor"></a><code><span class="keyword">val</span> do_once : <span><span><span class="type-var">'a</span> option</span> Stdlib.ref</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>do_once r f</code> calls <code>f</code> and updates the ref only once</p></dd></dl><dl><dt class="spec value" id="val-assert_done"><a href="#val-assert_done" class="anchor"></a><code><span class="keyword">val</span> assert_done : <span><span><span class="type-var">'a</span> option</span> Stdlib.ref</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>assert_done r</code> return the content of r. </p><dl><dt>raises Anomaly</dt><dd><p>is r is <code>None</code></p></dd></dl></dd></dl><aside><p>Very low level APIs. these are calls to evarconv's <code>the_conv_x</code> followed by <code>solve_unif_constraints_with_heuristics</code>. In case of failure they raise <code>NoMatch</code></p></aside><dl><dt class="spec value" id="val-unify_HO"><a href="#val-unify_HO" class="anchor"></a><code><span class="keyword">val</span> unify_HO : <a href="../../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../../EConstr/index.html#type-constr">EConstr.constr</a> <span>&#45;&gt;</span> <a href="../../EConstr/index.html#type-constr">EConstr.constr</a> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a></code></dt><dt class="spec value" id="val-pf_unify_HO"><a href="#val-pf_unify_HO" class="anchor"></a><code><span class="keyword">val</span> pf_unify_HO : <span><a href="../../Goal/index.html#type-goal">Goal.goal</a> <a href="../../Evd/index.html#type-sigma">Evd.sigma</a></span> <span>&#45;&gt;</span> <a href="../../EConstr/index.html#type-constr">EConstr.constr</a> <span>&#45;&gt;</span> <a href="../../EConstr/index.html#type-constr">EConstr.constr</a> <span>&#45;&gt;</span> <span><a href="../../Goal/index.html#type-goal">Goal.goal</a> <a href="../../Evd/index.html#type-sigma">Evd.sigma</a></span></code></dt><dt class="spec value" id="val-tag_of_cpattern"><a href="#val-tag_of_cpattern" class="anchor"></a><code><span class="keyword">val</span> tag_of_cpattern : <a href="index.html#type-cpattern">cpattern</a> <span>&#45;&gt;</span> char</code></dt><dd><p>Some more low level functions needed to implement the full SSR language on top of the former APIs</p></dd></dl><dl><dt class="spec value" id="val-loc_of_cpattern"><a href="#val-loc_of_cpattern" class="anchor"></a><code><span class="keyword">val</span> loc_of_cpattern : <a href="index.html#type-cpattern">cpattern</a> <span>&#45;&gt;</span> <span><a href="../../Loc/index.html#type-t">Loc.t</a> option</span></code></dt><dt class="spec value" id="val-id_of_pattern"><a href="#val-id_of_pattern" class="anchor"></a><code><span class="keyword">val</span> id_of_pattern : <a href="index.html#type-pattern">pattern</a> <span>&#45;&gt;</span> <span><a href="../../Names/Id/index.html#type-t">Names.Id.t</a> option</span></code></dt><dt class="spec value" id="val-is_wildcard"><a href="#val-is_wildcard" class="anchor"></a><code><span class="keyword">val</span> is_wildcard : <a href="index.html#type-cpattern">cpattern</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-cpattern_of_id"><a href="#val-cpattern_of_id" class="anchor"></a><code><span class="keyword">val</span> cpattern_of_id : <a href="../../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> <a href="index.html#type-cpattern">cpattern</a></code></dt><dt class="spec value" id="val-pr_constr_pat"><a href="#val-pr_constr_pat" class="anchor"></a><code><span class="keyword">val</span> pr_constr_pat : <a href="../../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../../Constr/index.html#type-constr">Constr.constr</a> <span>&#45;&gt;</span> <a href="../../Pp/index.html#type-t">Pp.t</a></code></dt><dt class="spec value" id="val-pr_econstr_pat"><a href="#val-pr_econstr_pat" class="anchor"></a><code><span class="keyword">val</span> pr_econstr_pat : <a href="../../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../../Evd/index.html#type-econstr">Evd.econstr</a> <span>&#45;&gt;</span> <a href="../../Pp/index.html#type-t">Pp.t</a></code></dt><dt class="spec value" id="val-pf_merge_uc"><a href="#val-pf_merge_uc" class="anchor"></a><code><span class="keyword">val</span> pf_merge_uc : <a href="../../UState/index.html#type-t">UState.t</a> <span>&#45;&gt;</span> <span><a href="../../Goal/index.html#type-goal">Goal.goal</a> <a href="../../Evd/index.html#type-sigma">Evd.sigma</a></span> <span>&#45;&gt;</span> <span><a href="../../Goal/index.html#type-goal">Goal.goal</a> <a href="../../Evd/index.html#type-sigma">Evd.sigma</a></span></code></dt><dt class="spec value" id="val-pf_unsafe_merge_uc"><a href="#val-pf_unsafe_merge_uc" class="anchor"></a><code><span class="keyword">val</span> pf_unsafe_merge_uc : <a href="../../UState/index.html#type-t">UState.t</a> <span>&#45;&gt;</span> <span><a href="../../Goal/index.html#type-goal">Goal.goal</a> <a href="../../Evd/index.html#type-sigma">Evd.sigma</a></span> <span>&#45;&gt;</span> <span><a href="../../Goal/index.html#type-goal">Goal.goal</a> <a href="../../Evd/index.html#type-sigma">Evd.sigma</a></span></code></dt><dt class="spec value" id="val-debug"><a href="#val-debug" class="anchor"></a><code><span class="keyword">val</span> debug : bool <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-ssrinstancesof"><a href="#val-ssrinstancesof" class="anchor"></a><code><span class="keyword">val</span> ssrinstancesof : <a href="index.html#type-cpattern">cpattern</a> <span>&#45;&gt;</span> <a href="../../Tacmach/index.html#type-tactic">Tacmach.tactic</a></code></dt></dl><aside><p>Functions used for grammar extensions. Do not use.</p></aside><div class="spec module" id="module-Internal"><a href="#module-Internal" class="anchor"></a><code><span class="keyword">module</span> <a href="Internal/index.html">Internal</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>