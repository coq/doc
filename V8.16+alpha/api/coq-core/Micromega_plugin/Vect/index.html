<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vect (coq-core.Micromega_plugin.Vect)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">coq-core</a> &#x00BB; <a href="../index.html">Micromega_plugin</a> &#x00BB; Vect</nav><h1>Module <code>Micromega_plugin.Vect</code></h1><nav class="toc"><ul><li><a href="#generic-functions">Generic functions</a></li><li><a href="#basic-accessors-and-utility-functions">Basic accessors and utility functions</a></li><li><a href="#linear-arithmetics">Linear arithmetics</a></li><li><a href="#iterators">Iterators</a></li></ul></nav></header><dl><dt class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><code><span class="keyword">type</span> var</code><code> = int</code></dt><dd><p>Variables are simply (positive) integers.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of vectors or equivalently linear expressions. The current implementation is using association lists. A list <code>(0,c),(x1,ai),...,(xn,an)</code> represents the linear expression c + a1.xn + ... an.xn where ai are rational constants and xi are variables.</p><p>Note that the variable 0 has a special meaning and represent a constant. Moreover, the representation is spare and variables with a zero coefficient are not represented.</p></dd></dl><dl><dt class="spec type" id="type-vector"><a href="#type-vector" class="anchor"></a><code><span class="keyword">type</span> vector</code><code> = <a href="index.html#type-t">t</a></code></dt></dl><section><header><h2 id="generic-functions"><a href="#generic-functions" class="anchor"></a>Generic functions</h2></header><aside><p><code>hash</code> <code>equal</code> and <code>compare</code> so that Vect.t can be used as keys for Set Map and Hashtbl</p></aside><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></section><section><header><h2 id="basic-accessors-and-utility-functions"><a href="#basic-accessors-and-utility-functions" class="anchor"></a>Basic accessors and utility functions</h2></header><dl><dt class="spec value" id="val-pp_gen"><a href="#val-pp_gen" class="anchor"></a><code><span class="keyword">val</span> pp_gen : <span>(Stdlib.out_channel <span>&#45;&gt;</span> <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.out_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_gen pp_var o v</code> prints the representation of the vector <code>v</code> over the channel <code>o</code></p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Stdlib.out_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp o v</code> prints the representation of the vector <code>v</code> over the channel <code>o</code></p></dd></dl><dl><dt class="spec value" id="val-pp_smt"><a href="#val-pp_smt" class="anchor"></a><code><span class="keyword">val</span> pp_smt : Stdlib.out_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_smt o v</code> prints the representation of the vector <code>v</code> over the channel <code>o</code> using SMTLIB conventions</p></dd></dl><dl><dt class="spec value" id="val-variables"><a href="#val-variables" class="anchor"></a><code><span class="keyword">val</span> variables : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Micromega_plugin__Mutils/index.html#module-ISet">Micromega_plugin.Mutils.ISet</a>.t</code></dt><dd><p><code>variables v</code> returns the set of variables with non-zero coefficients</p></dd></dl><dl><dt class="spec value" id="val-get_cst"><a href="#val-get_cst" class="anchor"></a><code><span class="keyword">val</span> get_cst : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a></code></dt><dd><p><code>get_cst v</code> returns c i.e. the coefficient of the variable zero</p></dd></dl><dl><dt class="spec value" id="val-decomp_cst"><a href="#val-decomp_cst" class="anchor"></a><code><span class="keyword">val</span> decomp_cst : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>decomp_cst v</code> returns the pair (c,a1.x1+...+an.xn)</p></dd></dl><dl><dt class="spec value" id="val-decomp_at"><a href="#val-decomp_at" class="anchor"></a><code><span class="keyword">val</span> decomp_at : <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>decomp_at xi v</code> returns the pair (ai, ai+1.xi+...+an.xn)</p></dd></dl><dl><dt class="spec value" id="val-decomp_fst"><a href="#val-decomp_fst" class="anchor"></a><code><span class="keyword">val</span> decomp_fst : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>(<a href="index.html#type-var">var</a> * <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a>)</span> * <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-cst"><a href="#val-cst" class="anchor"></a><code><span class="keyword">val</span> cst : <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>cst c</code> returns the vector v=c+0.x1+...+0.xn</p></dd></dl><dl><dt class="spec value" id="val-is_constant"><a href="#val-is_constant" class="anchor"></a><code><span class="keyword">val</span> is_constant : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_constant v</code> holds if <code>v</code> is a constant vector i.e. v=c+0.x1+...+0.xn</p></dd></dl><dl><dt class="spec value" id="val-null"><a href="#val-null" class="anchor"></a><code><span class="keyword">val</span> null : <a href="index.html#type-t">t</a></code></dt><dd><p><code>null</code> is the empty vector i.e. 0+0.x1+...+0.xn</p></dd></dl><dl><dt class="spec value" id="val-is_null"><a href="#val-is_null" class="anchor"></a><code><span class="keyword">val</span> is_null : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_null v</code> returns whether <code>v</code> is the <code>null</code> vector i.e <code>equal v  null</code></p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a></code></dt><dd><p><code>get xi v</code> returns the coefficient ai of the variable <code>xi</code>. <code>get</code> is also defined for the variable 0</p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>set xi ai' v</code> returns the vector c+a1.x1+...ai'.xi+...+an.xn i.e. the coefficient of the variable xi is set to ai'</p></dd></dl><dl><dt class="spec value" id="val-mkvar"><a href="#val-mkvar" class="anchor"></a><code><span class="keyword">val</span> mkvar : <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>mkvar xi</code> returns 1.xi</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">val</span> update : <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <span>(<a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>update xi f v</code> returns c+a1.x1+...+f(ai).xi+...+an.xn</p></dd></dl><dl><dt class="spec value" id="val-fresh"><a href="#val-fresh" class="anchor"></a><code><span class="keyword">val</span> fresh : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>fresh v</code> return the fresh variable with index 1+ max (variables v)</p></dd></dl><dl><dt class="spec value" id="val-choose"><a href="#val-choose" class="anchor"></a><code><span class="keyword">val</span> choose : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-var">var</a> * <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> * <a href="index.html#type-t">t</a>)</span> option</span></code></dt><dd><p><code>choose v</code> decomposes a vector <code>v</code> depending on whether it is <code>null</code> or not.</p><dl><dt>returns</dt><dd><p>None if v is <code>null</code></p></dd></dl><dl><dt>returns</dt><dd><p>Some(x,n,r) where v = r + n.x x is the smallest variable with non-zero coefficient n &lt;&gt; 0.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_list"><a href="#val-from_list" class="anchor"></a><code><span class="keyword">val</span> from_list : <span><a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>from_list l</code> returns the vector c+a1.x1...an.xn from the list of coefficient <code>l=c;a1;...;an</code></p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> list</span></code></dt><dd><p><code>to_list v</code> returns the list of all coefficient of the vector v i.e. <code>c;a1;...;an</code> The list representation is (obviously) not sparsed and therefore certain ai may be 0</p></dd></dl><dl><dt class="spec value" id="val-decr_var"><a href="#val-decr_var" class="anchor"></a><code><span class="keyword">val</span> decr_var : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>decr_var i v</code> decrements the variables of the vector <code>v</code> by the amount <code>i</code>. Beware, it is only defined if all the variables of v are greater than i</p></dd></dl><dl><dt class="spec value" id="val-incr_var"><a href="#val-incr_var" class="anchor"></a><code><span class="keyword">val</span> incr_var : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>incr_var i v</code> increments the variables of the vector <code>v</code> by the amount <code>i</code>.</p></dd></dl><dl><dt class="spec value" id="val-gcd"><a href="#val-gcd" class="anchor"></a><code><span class="keyword">val</span> gcd : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../NumCompat/Z/index.html#type-t">NumCompat.Z.t</a></code></dt><dd><p><code>gcd v</code> returns gcd(num(c),num(a1),...,num(an)) where num extracts the numerator of a rational value.</p></dd></dl><dl><dt class="spec value" id="val-normalise"><a href="#val-normalise" class="anchor"></a><code><span class="keyword">val</span> normalise : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>normalise v</code> returns a vector with only integer coefficients</p></dd></dl></section><section><header><h2 id="linear-arithmetics"><a href="#linear-arithmetics" class="anchor"></a>Linear arithmetics</h2></header><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add v1 v2</code> is vector addition.</p><dl><dt>parameter v1</dt><dd><p>is of the form c +a1.x1 +...+an.xn</p></dd></dl><dl><dt>parameter v2</dt><dd><p>is of the form c'+a1'.x1 +...+an'.xn</p></dd></dl><dl><dt>returns</dt><dd><p>c1+c1'+ (a1+a1').x1 + ... + (an+an').xn</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span class="keyword">val</span> mul : <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>mul a v</code> is vector multiplication of vector <code>v</code> by a scalar <code>a</code>.</p><dl><dt>returns</dt><dd><p>a.v = a.c+a.a1.x1+...+a.an.xn</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mul_add"><a href="#val-mul_add" class="anchor"></a><code><span class="keyword">val</span> mul_add : <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>mul_add c1 v1 c2 v2</code> returns the linear combination c1.v1+c2.v2</p></dd></dl><dl><dt class="spec value" id="val-subst"><a href="#val-subst" class="anchor"></a><code><span class="keyword">val</span> subst : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>subst x v v'</code> replaces x by v in vector v'</p></dd></dl><dl><dt class="spec value" id="val-div"><a href="#val-div" class="anchor"></a><code><span class="keyword">val</span> div : <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>div c1 v1</code> returns the mutiplication by the inverse of c1 i.e (1/c1).v1</p></dd></dl><dl><dt class="spec value" id="val-uminus"><a href="#val-uminus" class="anchor"></a><code><span class="keyword">val</span> uminus : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>uminus v</code> </p><dl><dt>returns</dt><dd><p>-v the opposite vector of v i.e. (-1).v</p></dd></dl></dd></dl></section><section><header><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2></header><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <span class="type-var">'acc</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'acc</span></code></dt><dd><p><code>fold f acc v</code> returns f (f (f acc 0 c ) x1 a1 ) ... xn an</p></dd></dl><dl><dt class="spec value" id="val-fold_error"><a href="#val-fold_error" class="anchor"></a><code><span class="keyword">val</span> fold_error : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'acc</span> option</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span class="type-var">'acc</span> option</span></code></dt><dd><p><code>fold_error f acc v</code> is the same as <code>fold (fun acc x i -&gt; match acc with None -&gt; None | Some acc' -&gt; f acc' x i) (Some acc) v</code> but with early exit...</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span>(<a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> option</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> option</span></code></dt><dd><p><code>find f v</code> returns the first <code>f xi ai</code> such that <code>f xi ai &lt;&gt; None</code>. If no such xi ai exists, it returns None</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span>(<a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p v</code> returns /\_<i>&gt;=0</i> (f xi ai)</p></dd></dl><dl><dt class="spec value" id="val-exists2"><a href="#val-exists2" class="anchor"></a><code><span class="keyword">val</span> exists2 : <span>(<a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-var">var</a> * <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> * <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a>)</span> option</span></code></dt><dd><p><code>exists2 p v v'</code> returns Some(xi,ai,ai') if p(xi,ai,ai') holds and ai,ai' &lt;&gt; 0. It returns None if no such pair of coefficient exists.</p></dd></dl><dl><dt class="spec value" id="val-dotproduct"><a href="#val-dotproduct" class="anchor"></a><code><span class="keyword">val</span> dotproduct : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a></code></dt><dd><p><code>dotproduct v1 v2</code> is the dot product of v1 and v2.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-abs_min_elt"><a href="#val-abs_min_elt" class="anchor"></a><code><span class="keyword">val</span> abs_min_elt : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-var">var</a> * <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a>)</span> option</span></code></dt><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : <span>(<a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="../NumCompat/Q/index.html#type-t">NumCompat.Q.t</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Bound"><a href="#module-Bound" class="anchor"></a><code><span class="keyword">module</span> <a href="Bound/index.html">Bound</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>