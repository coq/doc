<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dnet (coq.Dnet)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Dnet</nav><h1>Module <code>Dnet</code></h1><p>Generic discrimination net implementation over recursive types. This module implements a association data structure similar to tries but working on any types (not just lists). It is a term indexing datastructure, a generalization of the discrimination nets described for example in W.W.McCune, 1992, related also to generalized tries <code>Hinze, 2000</code>.</p><p>You can add pairs of (term,identifier) into a dnet, where the identifier is *unique*, and search terms in a dnet filtering a given pattern (retrievial of instances). It returns all identifiers associated with terms matching the pattern. It also works the other way around : You provide a set of patterns and a term, and it returns all patterns which the term matches (retrievial of generalizations). That's why you provide *patterns* everywhere.</p><p>Warning 1: Full unification doesn't work as for now. Make sure the set of metavariables in the structure and in the queries are distincts, or you'll get unexpected behaviours.</p><p>Warning 2: This structure is perfect, i.e. the set of candidates returned is equal to the set of solutions. Beware of de Bruijn shifts and sorts subtyping though (which makes the comparison not symmetric, see term_dnet.ml).</p><p>The complexity of the search is (almost) the depth of the term.</p><p>To use it, you have to provide a module (Datatype) with the datatype parametrized on the recursive argument. example:</p><p>type btree = type 'a btree0 = | Leaf ===&gt; | Leaf | Node of btree * btree | Node of 'a * 'a</p></header><dl><dt class="spec module-type" id="module-type-Datatype"><a href="#module-type-Datatype" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Datatype/index.html">Datatype</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>datatype you want to build a dnet on</p></dd></dl><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-T/index.html">T</a> : <a href="index.html#module-type-Datatype">Datatype</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make/index.html#argument-2-Ident">Ident</a> : Stdlib.Set.OrderedType) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make/index.html#argument-3-Meta">Meta</a> : Stdlib.Set.OrderedType) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-ident">ident</a> = <a href="Make/index.html#argument-2-Ident">Ident</a>.t <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make/index.html#type-meta">meta</a> = <a href="Make/index.html#argument-3-Meta">Meta</a>.t <span class="keyword">and</span> <span class="keyword">type</span> <span>'a <a href="Make/index.html#type-structure">structure</a></span> = <span><span class="type-var">'a</span> <a href="Make/argument-1-T/index.html#type-t">T.t</a></span></code></div></div></body></html>