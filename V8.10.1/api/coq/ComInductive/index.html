<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ComInductive (coq.ComInductive)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; ComInductive</nav><h1>Module <code>ComInductive</code></h1><h6 id="inductive-and-coinductive-types"><a href="#inductive-and-coinductive-types" class="anchor"></a>Inductive and coinductive types</h6></header><aside><p>Entry points for the vernacular commands Inductive and CoInductive</p></aside><dl><dt class="spec type" id="type-uniform_inductive_flag"><a href="#type-uniform_inductive_flag" class="anchor"></a><code><span class="keyword">type</span> uniform_inductive_flag</code><code> = </code><table class="variant"><tr id="type-uniform_inductive_flag.UniformParameters" class="anchored"><td class="def constructor"><a href="#type-uniform_inductive_flag.UniformParameters" class="anchor"></a><code>| </code><code><span class="constructor">UniformParameters</span></code></td></tr><tr id="type-uniform_inductive_flag.NonUniformParameters" class="anchored"><td class="def constructor"><a href="#type-uniform_inductive_flag.NonUniformParameters" class="anchor"></a><code>| </code><code><span class="constructor">NonUniformParameters</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-do_mutual_inductive"><a href="#val-do_mutual_inductive" class="anchor"></a><code><span class="keyword">val</span> do_mutual_inductive : template:bool option <span>&#45;&gt;</span> <a href="../Constrexpr/index.html#type-universe_decl_expr">Constrexpr.universe_decl_expr</a> option <span>&#45;&gt;</span> (<a href="../Vernacexpr/index.html#type-one_inductive_expr">Vernacexpr.one_inductive_expr</a> * <a href="../Vernacexpr/index.html#type-decl_notation">Vernacexpr.decl_notation</a> list) list <span>&#45;&gt;</span> <a href="../Decl_kinds/index.html#type-cumulative_inductive_flag">Decl_kinds.cumulative_inductive_flag</a> <span>&#45;&gt;</span> <a href="../Decl_kinds/index.html#type-polymorphic">Decl_kinds.polymorphic</a> <span>&#45;&gt;</span> <a href="../Decl_kinds/index.html#type-private_flag">Decl_kinds.private_flag</a> <span>&#45;&gt;</span> uniform:<a href="index.html#type-uniform_inductive_flag">uniform_inductive_flag</a> <span>&#45;&gt;</span> <a href="../Declarations/index.html#type-recursivity_kind">Declarations.recursivity_kind</a> <span>&#45;&gt;</span> unit</code></dt></dl><aside><p>Internal API</p></aside><aside><p>Exported for Record and Funind</p></aside><aside><p>Registering a mutual inductive definition together with its associated schemes</p></aside><dl><dt class="spec type" id="type-one_inductive_impls"><a href="#type-one_inductive_impls" class="anchor"></a><code><span class="keyword">type</span> one_inductive_impls</code><code> = <a href="../Impargs/index.html#type-manual_implicits">Impargs.manual_implicits</a> * <a href="../Impargs/index.html#type-manual_implicits">Impargs.manual_implicits</a> list</code></dt></dl><dl><dt class="spec value" id="val-declare_mutual_inductive_with_eliminations"><a href="#val-declare_mutual_inductive_with_eliminations" class="anchor"></a><code><span class="keyword">val</span> declare_mutual_inductive_with_eliminations : ?&#8288;primitive_expected:bool <span>&#45;&gt;</span> <a href="../Entries/index.html#type-mutual_inductive_entry">Entries.mutual_inductive_entry</a> <span>&#45;&gt;</span> <a href="../UnivNames/index.html#type-universe_binders">UnivNames.universe_binders</a> <span>&#45;&gt;</span> <a href="index.html#type-one_inductive_impls">one_inductive_impls</a> list <span>&#45;&gt;</span> <a href="../Names/MutInd/index.html#type-t">Names.MutInd.t</a></code></dt><dt class="spec value" id="val-should_auto_template"><a href="#val-should_auto_template" class="anchor"></a><code><span class="keyword">val</span> should_auto_template : <a href="../Names/Id/index.html#type-t">Names.Id.t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> bool</code></dt><dd><p><code>should_auto_template x b</code> is <code>true</code> when <code>b</code> is <code>true</code> and we automatically use template polymorphism. <code>x</code> is the name of the inductive under consideration.</p></dd></dl><dl><dt class="spec value" id="val-template_polymorphism_candidate"><a href="#val-template_polymorphism_candidate" class="anchor"></a><code><span class="keyword">val</span> template_polymorphism_candidate : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Entries/index.html#type-universes_entry">Entries.universes_entry</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_context">Constr.rel_context</a> <span>&#45;&gt;</span> <a href="../Sorts/index.html#type-t">Sorts.t</a> option <span>&#45;&gt;</span> bool</code></dt><dd><p><code>template_polymorphism_candidate env uctx params conclsort</code> is <code>true</code> iff an inductive with params <code>params</code> and conclusion <code>conclsort</code> would be definable as template polymorphic. It should have at least one universe in its monomorphic universe context that can be made parametric in its conclusion sort, if one is given. If the <code>Template Check</code> flag is false we just check that the conclusion sort is not small.</p></dd></dl><dl><dt class="spec value" id="val-sign_level"><a href="#val-sign_level" class="anchor"></a><code><span class="keyword">val</span> sign_level : <a href="../Environ/index.html#type-env">Environ.env</a> <span>&#45;&gt;</span> <a href="../Evd/index.html#type-evar_map">Evd.evar_map</a> <span>&#45;&gt;</span> <a href="../Constr/index.html#type-rel_declaration">Constr.rel_declaration</a> list <span>&#45;&gt;</span> <a href="../Univ/Universe/index.html#type-t">Univ.Universe.t</a></code></dt><dd><p><code>sign_level env sigma ctx</code> computes the universe level of the context <code>ctx</code> as the <code>sup</code> of its individual assumptions, which should be well-typed in <code>env</code> and <code>sigma</code></p></dd></dl><aside><p>Exported for Funind</p></aside><aside><p>Extracting the semantical components out of the raw syntax of mutual inductive declarations</p></aside><dl><dt class="spec type" id="type-structured_one_inductive_expr"><a href="#type-structured_one_inductive_expr" class="anchor"></a><code><span class="keyword">type</span> structured_one_inductive_expr</code><code> = </code><code>{</code><table class="record"><tr id="type-structured_one_inductive_expr.ind_name" class="anchored"><td class="def field"><a href="#type-structured_one_inductive_expr.ind_name" class="anchor"></a><code>ind_name : <a href="../Names/Id/index.html#type-t">Names.Id.t</a>;</code></td></tr><tr id="type-structured_one_inductive_expr.ind_arity" class="anchored"><td class="def field"><a href="#type-structured_one_inductive_expr.ind_arity" class="anchor"></a><code>ind_arity : <a href="../Constrexpr/index.html#type-constr_expr">Constrexpr.constr_expr</a>;</code></td></tr><tr id="type-structured_one_inductive_expr.ind_lc" class="anchored"><td class="def field"><a href="#type-structured_one_inductive_expr.ind_lc" class="anchor"></a><code>ind_lc : (<a href="../Names/Id/index.html#type-t">Names.Id.t</a> * <a href="../Constrexpr/index.html#type-constr_expr">Constrexpr.constr_expr</a>) list;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-structured_inductive_expr"><a href="#type-structured_inductive_expr" class="anchor"></a><code><span class="keyword">type</span> structured_inductive_expr</code><code> = <a href="../Constrexpr/index.html#type-local_binder_expr">Constrexpr.local_binder_expr</a> list * <a href="index.html#type-structured_one_inductive_expr">structured_one_inductive_expr</a> list</code></dt></dl><dl><dt class="spec value" id="val-extract_mutual_inductive_declaration_components"><a href="#val-extract_mutual_inductive_declaration_components" class="anchor"></a><code><span class="keyword">val</span> extract_mutual_inductive_declaration_components : (<a href="../Vernacexpr/index.html#type-one_inductive_expr">Vernacexpr.one_inductive_expr</a> * <a href="../Vernacexpr/index.html#type-decl_notation">Vernacexpr.decl_notation</a> list) list <span>&#45;&gt;</span> <a href="index.html#type-structured_inductive_expr">structured_inductive_expr</a> * <a href="../Libnames/index.html#type-qualid">Libnames.qualid</a> list * <a href="../Vernacexpr/index.html#type-decl_notation">Vernacexpr.decl_notation</a> list</code></dt></dl><aside><p>Typing mutual inductive definitions</p></aside><dl><dt class="spec value" id="val-interp_mutual_inductive"><a href="#val-interp_mutual_inductive" class="anchor"></a><code><span class="keyword">val</span> interp_mutual_inductive : template:bool option <span>&#45;&gt;</span> <a href="../Constrexpr/index.html#type-universe_decl_expr">Constrexpr.universe_decl_expr</a> option <span>&#45;&gt;</span> <a href="index.html#type-structured_inductive_expr">structured_inductive_expr</a> <span>&#45;&gt;</span> <a href="../Vernacexpr/index.html#type-decl_notation">Vernacexpr.decl_notation</a> list <span>&#45;&gt;</span> <a href="../Decl_kinds/index.html#type-cumulative_inductive_flag">Decl_kinds.cumulative_inductive_flag</a> <span>&#45;&gt;</span> <a href="../Decl_kinds/index.html#type-polymorphic">Decl_kinds.polymorphic</a> <span>&#45;&gt;</span> <a href="../Decl_kinds/index.html#type-private_flag">Decl_kinds.private_flag</a> <span>&#45;&gt;</span> <a href="../Declarations/index.html#type-recursivity_kind">Declarations.recursivity_kind</a> <span>&#45;&gt;</span> <a href="../Entries/index.html#type-mutual_inductive_entry">Entries.mutual_inductive_entry</a> * <a href="../UnivNames/index.html#type-universe_binders">UnivNames.universe_binders</a> * <a href="index.html#type-one_inductive_impls">one_inductive_impls</a> list</code></dt></dl></div></body></html>